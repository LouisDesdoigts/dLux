import dLux
import jax 
import jax.numpy as numpy
import equinox
import typing

# Type annotations
Array = numpy.array
Wavefront = dLux.PhysicalWavefront
FresnelWavefront = typing.NewType("FresnelWavefront", Wavefront)

class FresnelWavefront(dLux.PhysicalWavefront):
    """
    Expresses the behaviour and state of a wavefront propagating in 
    an optical system under the fresnel assumptions. This 
    implementation is based on the same class from the `poppy` 
    library [poppy](https://github.com/spacetelescope/poppy/fresnel.py)
    and Chapter 3 from _Applied Optics and Optical Engineering_
    by Lawrence G. N.


    Approximates the wavefront as a Gaussian Beam parametrised by the 
    radius of the beam, the phase radius, the phase factor and the 
    Rayleigh distance. 
     - Rayleigh Distance: $ z_{R} = \\pi\\omega_{0}^{2}/\\lambda $
     - Phase Factor: $ \\theta = \\arctan(z / z_{R}) $
     - Phase Radius: $ R = z + z_{R}^{2} / z $
     - Beam Radius: $ \\omega = \\omega_{0}\\sqrt{1 + (z / z_{R})^{2}}$
    $\\omega_{0}$ is the the radius at the waste of the beam.


    Propagation is based on two different regimes for a total of 
    four different opertations. 
    """
    rayleigh_distance: float
    phase_radius: float
    beam_radius: Array


    def __init__(self, beam_radius: Array, wavelength: float,
            offset: Array, amplitude: Array, phase: Array) -> FresnelWavefront:
        """
        Creates a wavefront with an empty amplitude and phase 
        arrays but of a given wavelength and phase offset. 

        Parameters
        ----------
        beam_radius : float 
            Radius of the beam at the initial optical plane.
        wavelength : float
            Wavelength of the monochromatic light.
        offset : ndarray
            Phase shift of the initial optical plane.         
        """
        super(wavelength, offset)
        self.beam_radius = beam_radius
        self.rayleigh_distance = rayleigh_distance(beam_radius, wavelength)
        self.amplitude = global_phase(beam_radius, wavelength)
        self.phase_radius = phase_radius(beam_radius, wavelength) 


    def rayleigh_distance(self, beam_radius: float,
            wavelength: float) -> float:
        """
        Calculates the rayleigh distance $z_{R}$ of the Gaussian beam 
        using the formula:
        $$
        z_{R} = \\pi\\omega_{0}^{2} / \\lambda,
        $$
        where, $\\omega_{0}$ is the beam waist radius and $\\lambda$
        is the wavelength (m).

        Parameters
        ----------
        beam_radius : float 
            The radius of the beam in metres at its waist. 
        wavelength : float 
            The wavelength of the monochromatic light in meters.
        
        Returns
        -------
        : float :
            The rayleigh distance
        """
        return numpy.pi * beam_radius ** 2 / wavelength


    def global_phase(self, beam_radius: float, 
            wavelength: float) -> float: 
        """
        Calculates the global phase of the wavefront generated by 
        the propagation of the Gaussian beam. Calculated using the 
        following formula.
        $$
        q(\\Delta z) = e^{(i\\pi r^{2} / \\lambda)\\Delta z}
        $$
        where, $\\Delta z$ is the distance propagated, $i$ is the 
        imaginary unit, $r$ is the distance from the center of the 
        wavefront and $\\lambda$ is the wavelength. 
        """
        # So some problems are popping up already in that we may 
        # have none for the ampliotude and phase arrays. I also 
        # need to way out how to get xs and ys in that CircularAperture 
        # function for the calculation of r. This is actually more 
        # involved than it seems. 
        
  



    
