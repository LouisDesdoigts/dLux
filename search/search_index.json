{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\\(\\partial\\) Lux Docs \u2202Lux \u2202Lux: Taking derivatives through Light - 'Optical systems as a Neural Network' Contributors Louis Desdoigts , Benjamin Pope , Jordan Dennis Installation The easiest way to install is from PyPI: just use pip install dLux To install from source: clone this git repo, enter the directory, and run pip install . Use We are currently building examples and documentation! We currently have two tutrial notebooks, showing the basics of how to optimise simple and more complex models here . Please note that this software is still under development and so is subject to change! History \u2202Lux is a full from-scratch rewrite of the ideas morphine , which is a fork of the popular optical simulation package ' poppy ' using the autodiff library Google Jax to do derivatives . We have built it from the ground up in equinox , a powerful object-oriented library in Jax, to best take advantage of new features and permit easy development and integration with neural networks. The Basics The goal of \\(\\partial\\) Lux is to revolutionalise the way in which optical modelling is approached. We believe that the mathematical symmetry betweeen neural networks and optical systems means that the current state of optical modelling is stuck in the old ways, and that differentiable optical models that harness the power of automatic differention is imperative to pushing the bounds of what is possible. For the uninitiated, automatic differentaion (auto-diff) is the mathematical tool that underpins the revolution in machine learning. The power of auto-diff ultimately lies in its ability to divorce the time it takes to optimise a model from the number of parameters being optimised in that model. This represents a fundamental paradigm shift in the way in which problems can be approached. Much time and effort has been focused in the past on making problems in optical modelling computationally tracatable, forcing compromises on what is learnt. This is no longer the case, directly optimising physics-based forwards models with millions of parameters is not only possible, but practical without requiring vast computation power. We have built \\(\\partial\\) Lux using Jax - googles numpy-like auto-diff library and Equinox. Together these two packages allow us to build an optical simulator that takes full advantage of the bleeding edge of computer science. For example each individual PSF calcualtion is natively performed in parallel across however many computational resources are available without any work from the end-user. Similarly these models can be compiled at run time into XLA without. TBC... Package Overview \\(\\partial\\) Lux has been built to be as simple and easy as possible for end-users, without abstracting them away from the underlying computations. There are two main types of classes that form the foundation of \\(\\partial\\) Lux, the OpticalSystem() and the layers. In order to construct a model of an optical system one simply defines the series of operations/transforms that is performed on the input wavefront in a list, which is passed as an argument to the OpticalSystem() class. Each transformation or operation is a single 'layer' in that list. For a very simple optical a typical list of layers would look something like this: layers = [ CreateWavefront(wf_npix, wf_size), TiltWavefront(), CircualrAperture(wf_npix), NormaliseWavefront(), MFT(det_npix, fl, det_pixsize) ] This list of layers can then be turned into an optical system -> OpticalSystem(layers) . We now have a fully differentiable optical model! The OpticalSystem() is the main class that we will interact with and does most of the heavy lifting, so lets a take a detailed look at what this class does. The OpticalSystem() object! The OpticalSystem object is the primary object of dLux, so here is a quick overview. dLux curently does not check that inputs are correctly shaped/formatted in order to making things work appropriately (under development) Inputs: layers: list, required A list of layers that defines the tranformaitons and operations of the system (typically optical) wavels: ndarray, optional An array of wavelengths in meters to simulate The shape must be 1d - stellar spectrums are controlled through the weights parameter No default value is set if not provided and this will throw an error if you try to call functions that depend on this parameter It is left as optional so that functions that allow wavelength input can be called on objects without having to pre-input wavelengths positions: ndarray, optional An array of (x,y) stellar positions in units of radians, measured as deivation of the optical axis. Its input shape should be (Nstars, 2), defining an x, y position for each star. If not provided, the value defaults to (0, 0) - on axis fluxes: ndarray, optional An array of stellar fluxes, its length must match the positions inputs size to work properly Theoretically this has arbitrary units, but we think of it as photons Defaults to 1 (ie, returning a unitary flux psf if not specified) weights: ndarray, optional An array of stellar spectral weights (arb units) This can take multiple shapes Default is to weight all wavelengths equally (top-hat) If a 1d array is provided this is applied to all stars, shape (Nwavels) if a 2d array is provided each is applied to each individual star, shape (Nstars, Nwavels) Note the inputs values are always normalised and will not directly change total output flux (inderectly it can change it by weighting more flux to wavelengths with more aperture losses, for example) dithers: ndarray, optional An arary of (x, y) positional dithers in units of radians Its input shape should be (Nims, 2), defining the (x,y) dither for each image if not provided, defualts to no-dither detector_layers: list, optional A second list of layer objects designed to allow processing of psfs, rather than wavefronts It is applied to each image after psfs have been approraitely weighted and summed Functions: call () Primary call function applying all parameters of the scene object through the systems - Takes no inputs, returning a image, or array of images - The primary function designed to apply all of the inputs of the class in order to generate the appropriate output images - Automatically maps the psf calcualtion over both wavelength and input position for highly efficient calculations - It takes no inputs as to allow for easier coherent optimsation of the whole system propagate_mono(wavel): Propagates a single monochromatic wavelength through only the layers list - Inputs: - wavel (float): The wavelength in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - Returns: A sigle monochromatic PSF propagate_single(wavels) Propagataes a single broadband stellar source through the layers list - Inputs: - wavels (ndarray): The wavelengths in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - weights (ndarray, optional): the realative weights of each wavelength, - No normalisation is applied to the weights to allow user flexibility - Unitary weights will output a total sum of 1 - Returns: A single broadband PSF debug_prop(wavels) Propagataes a single wavelength through while storing the intermediary value of the wavefront and pixelscale between each operation. This is designed to help build and debug unexpected behaviour. It is functionally a mirror of propagate_mono() that stored intermediary values/arrays - Inputs: - wavels (ndarray): The wavelengths in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - Returns: [A single monochromatic PSF, intermediate wavefront, intermediate pixelscales]","title":"Home"},{"location":"#lux","text":"\u2202Lux: Taking derivatives through Light - 'Optical systems as a Neural Network'","title":"\u2202Lux"},{"location":"#contributors","text":"Louis Desdoigts , Benjamin Pope , Jordan Dennis","title":"Contributors"},{"location":"#installation","text":"The easiest way to install is from PyPI: just use pip install dLux To install from source: clone this git repo, enter the directory, and run pip install .","title":"Installation"},{"location":"#use","text":"We are currently building examples and documentation! We currently have two tutrial notebooks, showing the basics of how to optimise simple and more complex models here . Please note that this software is still under development and so is subject to change!","title":"Use"},{"location":"#history","text":"\u2202Lux is a full from-scratch rewrite of the ideas morphine , which is a fork of the popular optical simulation package ' poppy ' using the autodiff library Google Jax to do derivatives . We have built it from the ground up in equinox , a powerful object-oriented library in Jax, to best take advantage of new features and permit easy development and integration with neural networks.","title":"History"},{"location":"#the-basics","text":"The goal of \\(\\partial\\) Lux is to revolutionalise the way in which optical modelling is approached. We believe that the mathematical symmetry betweeen neural networks and optical systems means that the current state of optical modelling is stuck in the old ways, and that differentiable optical models that harness the power of automatic differention is imperative to pushing the bounds of what is possible. For the uninitiated, automatic differentaion (auto-diff) is the mathematical tool that underpins the revolution in machine learning. The power of auto-diff ultimately lies in its ability to divorce the time it takes to optimise a model from the number of parameters being optimised in that model. This represents a fundamental paradigm shift in the way in which problems can be approached. Much time and effort has been focused in the past on making problems in optical modelling computationally tracatable, forcing compromises on what is learnt. This is no longer the case, directly optimising physics-based forwards models with millions of parameters is not only possible, but practical without requiring vast computation power. We have built \\(\\partial\\) Lux using Jax - googles numpy-like auto-diff library and Equinox. Together these two packages allow us to build an optical simulator that takes full advantage of the bleeding edge of computer science. For example each individual PSF calcualtion is natively performed in parallel across however many computational resources are available without any work from the end-user. Similarly these models can be compiled at run time into XLA without. TBC...","title":"The Basics"},{"location":"#package-overview","text":"\\(\\partial\\) Lux has been built to be as simple and easy as possible for end-users, without abstracting them away from the underlying computations. There are two main types of classes that form the foundation of \\(\\partial\\) Lux, the OpticalSystem() and the layers. In order to construct a model of an optical system one simply defines the series of operations/transforms that is performed on the input wavefront in a list, which is passed as an argument to the OpticalSystem() class. Each transformation or operation is a single 'layer' in that list. For a very simple optical a typical list of layers would look something like this: layers = [ CreateWavefront(wf_npix, wf_size), TiltWavefront(), CircualrAperture(wf_npix), NormaliseWavefront(), MFT(det_npix, fl, det_pixsize) ] This list of layers can then be turned into an optical system -> OpticalSystem(layers) . We now have a fully differentiable optical model! The OpticalSystem() is the main class that we will interact with and does most of the heavy lifting, so lets a take a detailed look at what this class does.","title":"Package Overview"},{"location":"#the-opticalsystem-object","text":"The OpticalSystem object is the primary object of dLux, so here is a quick overview. dLux curently does not check that inputs are correctly shaped/formatted in order to making things work appropriately (under development)","title":"The OpticalSystem() object!"},{"location":"#inputs","text":"","title":"Inputs:"},{"location":"#layers-list-required","text":"A list of layers that defines the tranformaitons and operations of the system (typically optical)","title":"layers: list, required"},{"location":"#wavels-ndarray-optional","text":"An array of wavelengths in meters to simulate The shape must be 1d - stellar spectrums are controlled through the weights parameter No default value is set if not provided and this will throw an error if you try to call functions that depend on this parameter It is left as optional so that functions that allow wavelength input can be called on objects without having to pre-input wavelengths","title":"wavels: ndarray, optional"},{"location":"#positions-ndarray-optional","text":"An array of (x,y) stellar positions in units of radians, measured as deivation of the optical axis. Its input shape should be (Nstars, 2), defining an x, y position for each star. If not provided, the value defaults to (0, 0) - on axis","title":"positions: ndarray, optional"},{"location":"#fluxes-ndarray-optional","text":"An array of stellar fluxes, its length must match the positions inputs size to work properly Theoretically this has arbitrary units, but we think of it as photons Defaults to 1 (ie, returning a unitary flux psf if not specified)","title":"fluxes: ndarray, optional"},{"location":"#weights-ndarray-optional","text":"An array of stellar spectral weights (arb units) This can take multiple shapes Default is to weight all wavelengths equally (top-hat) If a 1d array is provided this is applied to all stars, shape (Nwavels) if a 2d array is provided each is applied to each individual star, shape (Nstars, Nwavels) Note the inputs values are always normalised and will not directly change total output flux (inderectly it can change it by weighting more flux to wavelengths with more aperture losses, for example)","title":"weights: ndarray, optional"},{"location":"#dithers-ndarray-optional","text":"An arary of (x, y) positional dithers in units of radians Its input shape should be (Nims, 2), defining the (x,y) dither for each image if not provided, defualts to no-dither","title":"dithers: ndarray, optional"},{"location":"#detector_layers-list-optional","text":"A second list of layer objects designed to allow processing of psfs, rather than wavefronts It is applied to each image after psfs have been approraitely weighted and summed","title":"detector_layers: list, optional"},{"location":"#functions","text":"","title":"Functions:"},{"location":"#call","text":"Primary call function applying all parameters of the scene object through the systems - Takes no inputs, returning a image, or array of images - The primary function designed to apply all of the inputs of the class in order to generate the appropriate output images - Automatically maps the psf calcualtion over both wavelength and input position for highly efficient calculations - It takes no inputs as to allow for easier coherent optimsation of the whole system","title":"call()"},{"location":"#propagate_monowavel","text":"Propagates a single monochromatic wavelength through only the layers list - Inputs: - wavel (float): The wavelength in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - Returns: A sigle monochromatic PSF","title":"propagate_mono(wavel):"},{"location":"#propagate_singlewavels","text":"Propagataes a single broadband stellar source through the layers list - Inputs: - wavels (ndarray): The wavelengths in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - weights (ndarray, optional): the realative weights of each wavelength, - No normalisation is applied to the weights to allow user flexibility - Unitary weights will output a total sum of 1 - Returns: A single broadband PSF","title":"propagate_single(wavels)"},{"location":"#debug_propwavels","text":"Propagataes a single wavelength through while storing the intermediary value of the wavefront and pixelscale between each operation. This is designed to help build and debug unexpected behaviour. It is functionally a mirror of propagate_mono() that stored intermediary values/arrays - Inputs: - wavels (ndarray): The wavelengths in meters to be modelled through the system - offset (ndarray, optional): the (x,y) offest from the optical axis in radians - Returns: [A single monochromatic PSF, intermediate wavefront, intermediate pixelscales]","title":"debug_prop(wavels)"}]}