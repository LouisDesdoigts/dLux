{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#lux","title":"\u2202Lux","text":"<p>Differentiable Optical Models as Parameterised Neural Networks in Jax using Zodiax</p> <p>Contributors: Louis Desdoigts, Jordan Dennis, Adam Taras, Max Charles, Benjamin Pope, Peter Tuthill</p> <p>\u2202Lux is an open-source differentiable optical modelling framework harnessing the structural isomorphism between optical systems and neural networks, giving forwards models of optical systems as parametric neural networks.</p> <p>\u2202Lux is built in Zodiax, which is an open-source object-oriented Jax framework built as an extension of Equinox for scientific programming. This framework allows for the creation of complex optical systems involving many planes, phase and amplitude screens in each, and propagates between them in the Fraunhofer or Fresnel regimes. This enables fast phase retrieval, image deconvolution, and hardware design in high dimensions. Because \u2202Lux models are fully differentiable, you can optimize them by gradient descent over millions of parameters; or use Hamiltonian Monte Carlo to accelerate MCMC sampling. Our code is fully open-source under a 3-clause BSD license, and we encourage you to use it and build on it to solve problems in astronomy and beyond.</p> <p>The \u2202Lux framework is built in Zodiax, which gives it a deep range of capabilities from both Jax and Equinox:</p> <ul> <li> <p>Accelerated Numpy: a Numpy-like API that can run on GPU and TPU</p> </li> <li> <p>Automatic Differentiation: Allows for optimisation and inference in extremely high-dimensional spaces</p> </li> <li> <p>Just-In-Time Compilation: Compiles code into XLA at runtime and optimising execution across hardware</p> </li> <li> <p>Automatic Vectorisation: Allows for simple parallelism across hardware and asynchronous execution</p> </li> <li> <p>Object-Oriented Jax: Allows for differentiable classes that are recognised as a valid Jax type</p> </li> <li> <p>Inbuilt Neural Networks: Has pre-built neural network layer classes</p> </li> <li> <p>Path-Based Pytree Interface: Path based indexing allows for easy interfacing with large and highly nested physical models</p> </li> <li> <p>Leaf Manipulation Methods: Inbuilt methods allow for easy manipulation of Pytrees mirroring the Jax Array API</p> </li> </ul> <p>For an overview of these capabilities and different optimisation methods in Zodiax, please go through this Zodiax Tutorial.</p> <p>Documentation: https://louisdesdoigts.github.io/dLux/</p> <p>Requires: Python 3.8+, Jax 0.4.3+, Zodiax 0.4+</p> <p>Installation: <code>pip install dLux</code></p> <p>Docs installation: <code>pip install \"dLux[docs]\"</code></p> <p>Test installation: <code>pip install \"dLux[tests]\"</code></p>"},{"location":"#collaboration-development","title":"Collaboration &amp; Development","text":"<p>We are always looking to collaborate and further develop this software! We have focused on flexibility and ease of development, so if you have a project you want to use \u2202Lux for, but it currently does not have the required capabilities, don't hesitate to email me and we can discuss how to implement and merge it! Similarly, you can take a look at the <code>CONTRIBUTING.md</code> file.</p>"},{"location":"#publications","title":"Publications","text":"<p>We have a multitude of publications in the pipeline using dLux, some built from our tutorials. To start we would recommend looking at this invited talk on \u2202Lux which gives a good overview and has an attached recording of it being presented! We also have this poster!</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guide!","text":"<p>Note: This document is out of date and in the process of being updated!</p>"},{"location":"CONTRIBUTING/#units","title":"Units:","text":"<p>All units within \u2202Lux are SI!</p>"},{"location":"CONTRIBUTING/#adding-to-documentation","title":"Adding to documentation","text":"<p>When adding to the documentation, there are a few steps that need to be done: 1. Create the class or function and add the docstring 2. Create a <code>.md</code> file in the docs/ directory 3. Point to the class/function as so <code>::: dLux.module.new_class</code> 4. Edit the <code>mkdocs.yml</code> file to add the new class 5. Run <code>mkdocs serve</code> to deploy the docs locally at <code>localhost:8000</code> (put this into a browser)</p>"},{"location":"CONTRIBUTING/#building-and-running-unit-tests","title":"Building and running unit-tests","text":"<p>Any added functionality should be unit-tested! This is done with <code>pytest</code> in the <code>tests/</code> directory. Please have a look at the testing module and try to create tests to match the style!</p> <p>There are three main things we want to test: 1. Constructor assert statements and input types. Ensure that the correct error is thrown and that classes cant be constructed with incompatible inputs. 2. Test that the different run time logic branches evaluate. 3. Test that the different run time logic branches do not return nan or infinite values.</p>"},{"location":"CONTRIBUTING/#typing-conventions","title":"Typing conventions","text":"<p>So we have worked out a general typing convention for the software. There are two main data-types we care about: Jax data types, and others. We denote any jax-types with the <code>Array</code> typing hint. This is simply defined as a<code>jax.numpy.ndarray</code>, so at the start of any files one should have <code>Array = np.ndarray</code>. Any jax arrays should use this type-hint, regardless of data-type. All other type-hints for \u2202Lux type objects should refer to the base object type assuming it is not defined inside that script, i.e.:</p> <p>dLux.wavefronts.Wavefront dLux.propagators.Propagator dLux.optics.OpticalLayer dLux.base.Instrument</p> <p>For classes defined in the script, add <code>from __future__ import annotations</code> to the first line of the script in order to be able to reference these types within the script.</p>"},{"location":"CONTRIBUTING/#class-inheritance","title":"Class Inheritance","text":"<p>\u2202Lux classes are built from <code>Equinox</code> and <code>Zodiax</code>. Any new class types should inherit from either the <code>zodiax.Base</code> or <code>zodiax.ExtendedBase</code> classes, which inherit from <code>equinox.Module</code>, giving the full functionality from both of these packages.</p>"},{"location":"CONTRIBUTING/#code-style-formatting","title":"Code Style &amp; Formatting","text":"<p>All imported functionality should import the specific method used, as opposed to a full package.</p> <p>For example rather than importing whole package: <pre><code>import abc\n\nclass Foo(abc.ABC):\n    pass\n</code></pre></p> <p>We want to specifically import the function used: <pre><code>from abc import ABC\n\nclass Foo(ABC):\n    pass\n</code></pre></p> <p>Functions and methods with more than two inputs should spread those inputs over multiple lines, using spaces to format alignment of type hints and default values to help with code readability.</p> <p>For example rather than this: <pre><code>def Foo(self: Foo, a: Array = None, b: Array=np.ones(2), c: int=2) -&gt; float:\n    pass\n</code></pre></p> <p>Format like this: <pre><code>def Foo(self : Foo,\n        a    : Array = None,\n        b    : Array = np.ones(2),\n        c    : int   = 2) -&gt; float:\n    pass\n</code></pre></p>"},{"location":"CONTRIBUTING/#constructors","title":"Constructors","text":"<p>Data type enforcing for jax-type arrays: Constructors should be able to take in lists, numpy arrays and python floats, but ensure that they are correctly formatted into jax-type arrays like follows:</p> <pre><code>self.parameter = np.asarray(input_parameter, dtype=float)\n</code></pre> <p>This ensures flexibility in the input types and that all data types will match the default jax-32 or -64 bit types.</p> <p>All constructor methods should use assert statements to ensure that inputs are correctly formatted at init time. The goal should be if no errors are thrown at init time then all the class methods should work as intended and have correct dimensionality. For \u2202Lux this would typically be testing jax-type and array dimensionality. Do be sure that these enforce correct dimensionality, not just that errors are not thrown.</p> <p>For example if an attribute is a scalar, most methods will work identically if it is zero- or one-dimensional. For example, enforcing zero-dimensionality for scalars: <pre><code>input_parameter = [1e3]\n\nself.parameter = np.asarray(input_parameter, dtype=float)\nassert self.parameter.ndim == 0, \\\n(\"input_parameter must a scalar array, i.e. zero dimensional\")\n</code></pre></p>"},{"location":"CONTRIBUTING/#non-differentiable-parameters","title":"Non-differentiable parameters","text":"<p>By default, all parameters should be jax-types. However, parameters that define array shapes or logical flow can be python types (ie int, bool). This prevents issues with jax tracing through arrays of integers which can cause jax errors at runtime.</p>"},{"location":"CONTRIBUTING/#internal-logic-flow","title":"Internal logic flow","text":"<p>Most internal logic within \u2202Lux should be achieved using regular python logic. In some rare cases, <code>jax.lax.cond</code> should be used, but only if the internal logical flow can change during run time. Ie any logic that uses a boolean class attribute can not change during run time, and so should use regular python logic. This helps jax trace through the code and reduces compile time.</p>"},{"location":"CONTRIBUTING/#setter-and-getters","title":"Setter and Getters","text":"<p>By default, getters and setter should be avoided. Most getting and setting can be achieved with nice syntax using the <code>Zodiax</code> methods. There are however some exceptions.</p> <p>Setter: Some class types such as <code>Wavefronts</code> track a lot of parameters that change a lot throughout runtime and so the setter methods are used in conjunction with assert statements to ensure that parameters are not set incorrectly and that the errors are raised at the point where the issue arises, as opposed to some other method receiving an incorrectly shaped array.</p> <p>Getters: For some classes we want to have parameterised values, i.e. binary stars using separation and field angle. However, optical modelling methods use Cartesian position inputs, so the base <code>Source</code> class implements an abstract <code>.get_position()</code> method to be overwritten by all child classes. In the case of the <code>BinarySource</code> class this method uses the separation and field angle to generate these Cartesian values at run time. This means that all other classes in \u2202Lux can assume Cartesian positional values and use a single method when working with any <code>Source</code> class. Furthermore, getters can be used to generate useful values. For example wavefronts are store pixel scale and npixels, but implement a class property method for the diameter, which is much more useful for the <code>Propagator</code> classes.</p>"},{"location":"CONTRIBUTING/#hidden-methods","title":"Hidden methods","text":"<p>In general hidden class methods should be avoided and classes should try to implement methods that allow for them to used stand-alone. For example the <code>CompoundAperture</code> class implements the <code>construct_combined_aperture</code> and <code>get_aperture</code> methods that allow for users to directly construct and output the internally stored apertures, or use the <code>make_aperture</code> method to construct individual apertures.</p>"},{"location":"CONTRIBUTING/#non-circular-imports","title":"Non-Circular imports","text":"<p>To prevent circular imports, you can not import any specific classes or methods within the package, you instead need to import the whole pacakge (ie <code>import dLux</code>) and then in the code, refer to specific function (ie <code>dLux.sources.Source</code>). This is inconvenient, but just the way python works.</p> <p>exception: The utils package The utils package is the collection of functions that operate independently of the package, and so can be imported as normal, i.e. <code>from dLux.utils.coordinates import radians_to_arcseconds</code> etc.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2010-2018, Space Telescope Science Institute, AURA All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"setup/","title":"Setup","text":"In\u00a0[\u00a0]: Copied! <pre>import setuptools\nimport os\nimport codecs\nimport re\n</pre> import setuptools import os import codecs import re In\u00a0[\u00a0]: Copied! <pre>long_description = \"Taking derivatives through Light\"\n</pre> long_description = \"Taking derivatives through Light\" In\u00a0[\u00a0]: Copied! <pre>here = os.path.abspath(os.path.dirname(__file__))\ndef read(*parts):\n    with codecs.open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n</pre> here = os.path.abspath(os.path.dirname(__file__)) def read(*parts):     with codecs.open(os.path.join(here, *parts), 'r') as fp:         return fp.read() In\u00a0[\u00a0]: Copied! <pre>def find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n</pre> def find_version(*file_paths):     version_file = read(*file_paths)     version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)     if version_match:         return version_match.group(1)     raise RuntimeError(\"Unable to find version string.\") In\u00a0[\u00a0]: Copied! <pre># DEPENDENCIES\nwith open('requirements.txt') as f:\n    install_requires = f.read().splitlines()\ntests_require = ['pytest']\ndocs_require = ['matplotlib', 'jupyter', 'jupyterlab', 'tqdm', \n    'chainconsumer', 'numpyro', 'dLuxToliman', \"scikit-learn\", \"mkdocs\", \n    \"mkdocs-jupyter\", \"mkdocs-same-dir\", \"mkdocs-autorefs\",\n    \"mkdocs-simple-plugin\", \"mkdocstrings-python\",\n    \"jupyter_contrib_nbextensions\"]\n</pre> # DEPENDENCIES with open('requirements.txt') as f:     install_requires = f.read().splitlines() tests_require = ['pytest'] docs_require = ['matplotlib', 'jupyter', 'jupyterlab', 'tqdm',      'chainconsumer', 'numpyro', 'dLuxToliman', \"scikit-learn\", \"mkdocs\",      \"mkdocs-jupyter\", \"mkdocs-same-dir\", \"mkdocs-autorefs\",     \"mkdocs-simple-plugin\", \"mkdocstrings-python\",     \"jupyter_contrib_nbextensions\"] In\u00a0[\u00a0]: Copied! <pre>setuptools.setup(\n    python_requires='&gt;=3.7,&lt;4.0',\n    name=\"dLux\",\n    version=find_version(\"dLux\", \"__init__.py\"),\n    description=\"A fully differentiable optical simulator build in Jax\",\n    long_description=long_description,\n\n    author=\"Louis Desdoigts\",\n    author_email=\"Louis.Desdoigts@sydney.edu.au\",\n    url=\"https://github.com/LouisDesdoigts/dLux\",\n\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/LouisDesdoigts/dLux/issues\",\n    },\n\n    install_requires=install_requires,\n    extras_require={\n        'docs': docs_require, \n        'tests' : tests_require\n        },\n\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",\n    ],\n\n    packages = [\"dLux\", \"dLux/utils\"]\n)\n</pre> setuptools.setup(     python_requires='&gt;=3.7,&lt;4.0',     name=\"dLux\",     version=find_version(\"dLux\", \"__init__.py\"),     description=\"A fully differentiable optical simulator build in Jax\",     long_description=long_description,      author=\"Louis Desdoigts\",     author_email=\"Louis.Desdoigts@sydney.edu.au\",     url=\"https://github.com/LouisDesdoigts/dLux\",      project_urls={         \"Bug Tracker\": \"https://github.com/LouisDesdoigts/dLux/issues\",     },      install_requires=install_requires,     extras_require={         'docs': docs_require,          'tests' : tests_require         },      classifiers=[         \"Programming Language :: Python :: 3\",         \"Operating System :: OS Independent\",     ],      packages = [\"dLux\", \"dLux/utils\"] )"},{"location":"dLux/__init__/","title":"init","text":"In\u00a0[\u00a0]: Copied! <pre>name = \"dLux\"\n__version__ = \"0.13.1\"\n</pre> name = \"dLux\" __version__ = \"0.13.1\" In\u00a0[\u00a0]: Copied! <pre># Import as modules\n# Wavefronts and Optics\nfrom . import wavefronts\nfrom . import optics\nfrom . import optical_layers\nfrom . import propagators\nfrom . import apertures\nfrom . import aberrations\n</pre> # Import as modules # Wavefronts and Optics from . import wavefronts from . import optics from . import optical_layers from . import propagators from . import apertures from . import aberrations In\u00a0[\u00a0]: Copied! <pre># Images and Detectors\nfrom . import images\nfrom . import detectors\nfrom . import detector_layers\n</pre> # Images and Detectors from . import images from . import detectors from . import detector_layers In\u00a0[\u00a0]: Copied! <pre># All other classes\nfrom . import instruments\nfrom . import observations\nfrom . import sources\nfrom . import spectra\n</pre> # All other classes from . import instruments from . import observations from . import sources from . import spectra In\u00a0[\u00a0]: Copied! <pre># Sub Modules\nfrom . import utils\n</pre> # Sub Modules from . import utils In\u00a0[\u00a0]: Copied! <pre># Import core functions from modules\n# Wavefronts and Optics\nfrom .wavefronts     import *\nfrom .optics         import *\nfrom .optical_layers import *\nfrom .propagators    import *\nfrom .apertures      import *\nfrom .aberrations    import *\n</pre> # Import core functions from modules # Wavefronts and Optics from .wavefronts     import * from .optics         import * from .optical_layers import * from .propagators    import * from .apertures      import * from .aberrations    import * In\u00a0[\u00a0]: Copied! <pre># Images and Detectors\nfrom .images          import *\nfrom .detectors       import *\nfrom .detector_layers import *\n</pre> # Images and Detectors from .images          import * from .detectors       import * from .detector_layers import * In\u00a0[\u00a0]: Copied! <pre># All other classes\nfrom .sources      import *\nfrom .spectra    import *\nfrom .instruments  import *\nfrom .observations import *\n</pre> # All other classes from .sources      import * from .spectra    import * from .instruments  import * from .observations import * <p>Sub Modules from .utils      import *</p> In\u00a0[\u00a0]: Copied! <pre># Add to __all__\nmodules = [\n    wavefronts,\n    optics,\n    optical_layers,\n    propagators,\n    apertures,\n    aberrations,\n\n    images,\n    detectors,\n    detector_layers,\n\n    sources,\n    spectra,\n\n    instruments,\n    observations,\n]\n</pre> # Add to __all__ modules = [     wavefronts,     optics,     optical_layers,     propagators,     apertures,     aberrations,      images,     detectors,     detector_layers,      sources,     spectra,      instruments,     observations, ] In\u00a0[\u00a0]: Copied! <pre>__all__ = [module.__all__ for module in modules]\n</pre> __all__ = [module.__all__ for module in modules]"},{"location":"dLux/aberrations/","title":"Aberrations","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom zodiax import Base\nimport jax.numpy as np\nfrom jax import lax, Array\nimport jax.tree_util as jtu\nimport dLux.utils as dlu\n</pre> from __future__ import annotations from zodiax import Base import jax.numpy as np from jax import lax, Array import jax.tree_util as jtu import dLux.utils as dlu In\u00a0[\u00a0]: Copied! <pre>__all__ = ['Zernike', 'ZernikeBasis']\n</pre> __all__ = ['Zernike', 'ZernikeBasis'] In\u00a0[\u00a0]: Copied! <pre>zernike_names = {\n    # 0th Radial\n    1: 'Piston',\n\n    # 1st Radial\n    2: 'Tilt X',\n    3: 'Tilt Y',\n\n    # Second Radial\n    4: 'Defocus',\n    5: 'Astig X',\n    6: 'Astig Y',\n\n    # Third Radial\n    7: 'Coma X',\n    8: 'Coma Y',\n    9: 'Trefoil X',\n    10: 'Trefoil Y',\n\n    # Fourth Radial\n    11: 'Spherical',\n    12: '2nd Astig X',\n    13: '2nd Astig Y',\n    14: 'Quadrafoil X',\n    15: 'Quadrafoil Y',\n\n    # Fifth Radial\n    16: '2nd Coma X',\n    17: '2nd Coma Y',\n    18: '2nd Trefoil X',\n    19: '2nd Trefoil Y',\n    20: 'Pentafoil X',\n    21: 'Pentafoil Y',\n\n    # Sixth Radial\n    22: '2nd Spherical',\n    23: '3rd Coma X',\n    24: '3rd Coma Y',\n    25: '3rd Astig X',\n    26: '3rd Astig Y',\n    27: 'Hexafoil X',\n    28: 'Hexafoil Y',\n\n    # Seventh Radial\n    29: '4th Coma X',\n    30: '4th Coma Y',\n    31: '4th Astig X',\n    32: '4th Astig Y',\n    33: '3rd Trefoil X',\n    34: '3rd Trefoil Y',\n    35: 'Heptafoil X',\n    36: 'Heptafoil Y',\n}\n</pre> zernike_names = {     # 0th Radial     1: 'Piston',      # 1st Radial     2: 'Tilt X',     3: 'Tilt Y',      # Second Radial     4: 'Defocus',     5: 'Astig X',     6: 'Astig Y',      # Third Radial     7: 'Coma X',     8: 'Coma Y',     9: 'Trefoil X',     10: 'Trefoil Y',      # Fourth Radial     11: 'Spherical',     12: '2nd Astig X',     13: '2nd Astig Y',     14: 'Quadrafoil X',     15: 'Quadrafoil Y',      # Fifth Radial     16: '2nd Coma X',     17: '2nd Coma Y',     18: '2nd Trefoil X',     19: '2nd Trefoil Y',     20: 'Pentafoil X',     21: 'Pentafoil Y',      # Sixth Radial     22: '2nd Spherical',     23: '3rd Coma X',     24: '3rd Coma Y',     25: '3rd Astig X',     26: '3rd Astig Y',     27: 'Hexafoil X',     28: 'Hexafoil Y',      # Seventh Radial     29: '4th Coma X',     30: '4th Coma Y',     31: '4th Astig X',     32: '4th Astig Y',     33: '3rd Trefoil X',     34: '3rd Trefoil Y',     35: 'Heptafoil X',     36: 'Heptafoil Y', } In\u00a0[\u00a0]: Copied! <pre>class Zernike(Base):\n\"\"\"\n    A class to generate Zernike polynomials dynamically.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    j : int\n        The Zernike (noll) index.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    name : str\n        The name of the Zernike polynomial.\n    _k : Array\n        The array of powers using the radial calculation. This is a \n        pre-calculated parameter and should not be changed.\n    _c : Array\n        The array of normalisation coefficients used in the radial calculation.\n        This is a pre-calculated parameter and should not be changed.\n    \"\"\"\n    j: int\n    n: int\n    m: int\n    name: str\n    _k: Array\n    _c: Array\n\n    def __init__(self: Zernike, j: int):\n\"\"\"\n        Construct for the Zernike class.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n        \"\"\"\n        if int(j) &lt; 1:\n            raise ValueError('The Zernike index must be greater than 0.')\n        self.j = int(j)\n        self.n, self.m = self._noll_indices(self.j)\n        self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n            else f'Zernike {int(self.j)}'\n\n        # Calculate values\n        self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n        sign = lax.pow(-1., self._k)\n        _fact_1 = dlu.factorial(np.abs(self.n - self._k))\n        _fact_2 = dlu.factorial(self._k)\n        _fact_3 = dlu.factorial(((self.n + self.m) // 2) - self._k)\n        _fact_4 = dlu.factorial(((self.n - self.m) // 2) - self._k)\n        self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4\n\n    def _noll_indices(self: Zernike, j: int) -&gt; tuple[int]:\n\"\"\"\n        Calculate the radial and azimuthal orders of the Zernike polynomial.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n\n        Returns\n        -------\n        n, m : tuple[int]\n            The radial and azimuthal orders of the Zernike polynomial.\n        \"\"\"\n        n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)\n        smallest_j_in_row = n * (n + 1) / 2 + 1\n        number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2\n        sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2\n        base_case = (n &amp; 1)\n        m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)\n        return int(n), int(m)\n\n    def _calculate_radial(self: Zernike, rho: Array) -&gt; Array:\n\"\"\"\n        Calculates the radial component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        rho : Array\n            The radial coordinate of the Zernike polynomial.\n        Returns\n        -------\n        radial : Array\n            The radial component of the Zernike polynomial.\n        \"\"\"\n        rads = lax.pow(rho[:, :, None],\n                       (np.abs(self.n) - 2 * self._k)[None, None, :])\n        return (self._c * rads).sum(axis=2)\n\n    def _calculate_azimuthal(self: Zernike, theta: Array) -&gt; Array:\n\"\"\"\n        Calculates the azimuthal component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        theta : Array\n            The azimuthal coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        azimuthal : Array\n            The azimuthal component of the Zernike polynomial.\n        \"\"\"\n        norm_coeff = np.sqrt(self.n + 1)\n        if self.m != 0:\n            norm_coeff *= 1 + (np.sqrt(2) - 1)\n\n        if self.m &gt;= 0:\n            return norm_coeff * np.cos(np.abs(self.m) * theta)\n        else:\n            return norm_coeff * np.sin(np.abs(self.m) * theta)\n\n    def calculate_zernike(self: Zernike, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        polar_coordinates = dlu.cart_to_polar(coordinates)\n        rho = polar_coordinates[0]\n        theta = polar_coordinates[1]\n        aperture = rho &lt;= 1.\n        return aperture * self._calculate_radial(rho) * \\\n            self._calculate_azimuthal(theta)\n\n    def calculate_polike(self: Zernike,\n                         coordinates: Array,\n                         nsides: int) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial on an n-sided aperture.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture.\n\n        Returns\n        -------\n        polike : Array\n            The Zernike polynomial on an n-sided aperture.\n        \"\"\"\n        if nsides &lt; 3:\n            raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n        theta = dlu.cart_to_polar(coordinates)[1]\n        alpha = np.pi / nsides\n        phi = theta + alpha\n        wedge = np.floor((phi + alpha) / (2. * alpha))\n        u_alpha = phi - wedge * (2 * alpha)\n        r_alpha = np.cos(alpha) / np.cos(u_alpha)\n        return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n\n    def calculate(self: Zernike,\n                  coordinates: Array,\n                  nsides: int = 0) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike polynomial\n            is calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        if nsides == 0:\n            return self.calculate_zernike(coordinates)\n        else:\n            return self.calculate_polike(coordinates, nsides)\n</pre> class Zernike(Base):     \"\"\"     A class to generate Zernike polynomials dynamically.      The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).     The basic translation between the noll index and the pair of numbers is     shown below:      1 -&gt; (0, 0)      2, 3 -&gt; (1, -1), (1, 1)      4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)      7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)           Attributes     ----------     j : int         The Zernike (noll) index.     n : int         The radial order of the Zernike polynomial.     m : int         The azimuthal order of the Zernike polynomial.     name : str         The name of the Zernike polynomial.     _k : Array         The array of powers using the radial calculation. This is a          pre-calculated parameter and should not be changed.     _c : Array         The array of normalisation coefficients used in the radial calculation.         This is a pre-calculated parameter and should not be changed.     \"\"\"     j: int     n: int     m: int     name: str     _k: Array     _c: Array      def __init__(self: Zernike, j: int):         \"\"\"         Construct for the Zernike class.          Parameters         ----------         j : int             The Zernike (noll) index.         \"\"\"         if int(j) &lt; 1:             raise ValueError('The Zernike index must be greater than 0.')         self.j = int(j)         self.n, self.m = self._noll_indices(self.j)         self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\             else f'Zernike {int(self.j)}'          # Calculate values         self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)         sign = lax.pow(-1., self._k)         _fact_1 = dlu.factorial(np.abs(self.n - self._k))         _fact_2 = dlu.factorial(self._k)         _fact_3 = dlu.factorial(((self.n + self.m) // 2) - self._k)         _fact_4 = dlu.factorial(((self.n - self.m) // 2) - self._k)         self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4      def _noll_indices(self: Zernike, j: int) -&gt; tuple[int]:         \"\"\"         Calculate the radial and azimuthal orders of the Zernike polynomial.          Parameters         ----------         j : int             The Zernike (noll) index.          Returns         -------         n, m : tuple[int]             The radial and azimuthal orders of the Zernike polynomial.         \"\"\"         n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)         smallest_j_in_row = n * (n + 1) / 2 + 1         number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2         sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2         base_case = (n &amp; 1)         m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)         return int(n), int(m)      def _calculate_radial(self: Zernike, rho: Array) -&gt; Array:         \"\"\"         Calculates the radial component of the Zernike polynomial.          Parameters         ----------         rho : Array             The radial coordinate of the Zernike polynomial.                  Returns         -------         radial : Array             The radial component of the Zernike polynomial.         \"\"\"         rads = lax.pow(rho[:, :, None],                        (np.abs(self.n) - 2 * self._k)[None, None, :])         return (self._c * rads).sum(axis=2)      def _calculate_azimuthal(self: Zernike, theta: Array) -&gt; Array:         \"\"\"         Calculates the azimuthal component of the Zernike polynomial.          Parameters         ----------         theta : Array             The azimuthal coordinate of the Zernike polynomial.          Returns         -------         azimuthal : Array             The azimuthal component of the Zernike polynomial.         \"\"\"         norm_coeff = np.sqrt(self.n + 1)         if self.m != 0:             norm_coeff *= 1 + (np.sqrt(2) - 1)          if self.m &gt;= 0:             return norm_coeff * np.cos(np.abs(self.m) * theta)         else:             return norm_coeff * np.sin(np.abs(self.m) * theta)      def calculate_zernike(self: Zernike, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The Cartesian coordinates to calculate the Zernike polynomial upon.                  Returns         -------         zernike : Array             The Zernike polynomial.         \"\"\"         polar_coordinates = dlu.cart_to_polar(coordinates)         rho = polar_coordinates[0]         theta = polar_coordinates[1]         aperture = rho &lt;= 1.         return aperture * self._calculate_radial(rho) * \\             self._calculate_azimuthal(theta)      def calculate_polike(self: Zernike,                          coordinates: Array,                          nsides: int) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial on an n-sided aperture.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The Cartesian coordinates to calculate the Zernike polynomial upon.         nsides : int             The number of sides of the aperture.          Returns         -------         polike : Array             The Zernike polynomial on an n-sided aperture.         \"\"\"         if nsides &lt; 3:             raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')         theta = dlu.cart_to_polar(coordinates)[1]         alpha = np.pi / nsides         phi = theta + alpha         wedge = np.floor((phi + alpha) / (2. * alpha))         u_alpha = phi - wedge * (2 * alpha)         r_alpha = np.cos(alpha) / np.cos(u_alpha)         return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)      def calculate(self: Zernike,                   coordinates: Array,                   nsides: int = 0) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The Cartesian coordinates to calculate the Zernike polynomial upon.         nsides : int             The number of sides of the aperture. If 0, the Zernike polynomial             is calculated on a circular aperture.          Returns         -------         zernike : Array             The Zernike polynomial.         \"\"\"         if nsides == 0:             return self.calculate_zernike(coordinates)         else:             return self.calculate_polike(coordinates, nsides) In\u00a0[\u00a0]: Copied! <pre>class ZernikeBasis(Base):\n\"\"\"\n    A class to calculate a set of Zernike polynomials on a dynamic set of\n    coordinates.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n    1 -&gt; (0, 0)\n    2, 3 -&gt; (1, -1), (1, 1)\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    noll_indices : list[Zernike]\n        The list of Zernike polynomial classes to calculate.\n    \"\"\"\n    noll_indices: list[Zernike]\n\n    def __init__(self: ZernikeBasis, js: list[int]):\n\"\"\"\n        Constructor for the DynamicZernike class.\n\n        Parameters\n        ----------\n        js : list[int]\n            The list of Zernike (noll) indices to calculate.\n        \"\"\"\n        self.noll_indices = [Zernike(j) for j in js]\n\n    def calculate_basis(self: ZernikeBasis,\n                        coordinates: Array,\n                        nsides: int = 0) -&gt; Array:\n\"\"\"\n        Calculates the full Zernike polynomial basis.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike basis upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike basis is\n            calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike_basis : Array\n            The Zernike polynomial basis.\n        \"\"\"\n        leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n        calculate_fn = lambda z: z.calculate(coordinates, nsides)\n        return np.array(jtu.tree_map(calculate_fn, self.noll_indices,\n                                     is_leaf=leaf_fn))\n</pre> class ZernikeBasis(Base):     \"\"\"     A class to calculate a set of Zernike polynomials on a dynamic set of     coordinates.      The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).     The basic translation between the noll index and the pair of numbers is     shown below:          1 -&gt; (0, 0)          2, 3 -&gt; (1, -1), (1, 1)          4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)          7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)      Attributes     ----------     noll_indices : list[Zernike]         The list of Zernike polynomial classes to calculate.     \"\"\"     noll_indices: list[Zernike]      def __init__(self: ZernikeBasis, js: list[int]):         \"\"\"         Constructor for the DynamicZernike class.          Parameters         ----------         js : list[int]             The list of Zernike (noll) indices to calculate.         \"\"\"         self.noll_indices = [Zernike(j) for j in js]      def calculate_basis(self: ZernikeBasis,                         coordinates: Array,                         nsides: int = 0) -&gt; Array:         \"\"\"         Calculates the full Zernike polynomial basis.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The Cartesian coordinates to calculate the Zernike basis upon.         nsides : int             The number of sides of the aperture. If 0, the Zernike basis is             calculated on a circular aperture.          Returns         -------         zernike_basis : Array             The Zernike polynomial basis.         \"\"\"         leaf_fn = lambda leaf: isinstance(leaf, Zernike)         calculate_fn = lambda z: z.calculate(coordinates, nsides)         return np.array(jtu.tree_map(calculate_fn, self.noll_indices,                                      is_leaf=leaf_fn))"},{"location":"dLux/apertures/","title":"Apertures","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom jax import numpy as np, lax, vmap, Array\nfrom jax.tree_util import tree_map, tree_flatten\nfrom typing import Any\nfrom abc import abstractmethod\nfrom equinox import filter\nimport dLux.utils as dlu\nimport dLux\n\nWavefront = lambda: dLux.wavefronts.Wavefront\nOptic = lambda: dLux.optical_layers.Optic\nBasisOptic = lambda: dLux.optical_layers.BasisOptic\nTransmissiveLayer = lambda: dLux.optical_layers.TransmissiveLayer\nBasisLayer = lambda: dLux.optical_layers.BasisLayer\nZernikeBasis = lambda: dLux.aberrations.ZernikeBasis\n\n__all__ = [\n    \"CircularAperture\",\n    \"RectangularAperture\",\n    \"RegPolyAperture\",\n    \"IrregPolyAperture\",\n    \"AberratedAperture\",\n    \"UniformSpider\",\n    \"CompoundAperture\",\n    \"MultiAperture\",\n    \"ApertureFactory\",\n]\n\n\nclass ApertureLayer(TransmissiveLayer()):\n\"\"\"\n    The abstract base class that all aperture layers inherit from. This\n    instantiates the TransmissiveLayer class, initialising the normalisation\n    attribute.\n\n    Attributes\n    ----------\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    @abstractmethod\n    def make_static(\n        self: ApertureLayer, npixels: int, diameter: float\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Returns the static version of the input aperture calculated on the\n        coordinates defined by npixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the aperture in metres.\n\n        Returns\n        -------\n        aperture: ApertureLayer\n            The static OpticLayer version of this aperture.\n        \"\"\"\n\n    @abstractmethod\n    def _transmission(\n        self: ApertureLayer, coordinates: Array\n    ) -&gt; Array:  # pragma: no cover\n\"\"\"\n        Compute the array representing the aperture transmission on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n\n    def transmission(self: ApertureLayer, npixels: int, diameter: float) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on a set of coordinates\n        with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the array to calculate the transmission on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._transmission(dlu.pixel_coords(npixels, diameter / npixels))\n\n\nclass BaseDynamicAperture(ApertureLayer):\n\"\"\"\n    Base class instantiating a series of methods designed to generate\n    apertures differentiably at run-time. This class primarily implements the\n    coordinate transformations that can be applied to each aperture in order to\n    have fully control over the aperture shape, and apply global transformations\n    to the apertures.\n\n    Attributes\n    ----------\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    centre: Array\n    shear: Array\n    compression: Array\n    rotation: Array\n\n    def __init__(\n        self: ApertureLayer,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the BaseDynamicAperture class.\n\n        Parameters\n        ----------\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(normalise=normalise)\n\n        self.centre = np.asarray(centre, dtype=float)\n        self.shear = np.asarray(shear, dtype=float)\n        self.compression = np.asarray(compression, dtype=float)\n        self.rotation = np.asarray(rotation, dtype=float)\n\n        if self.centre.shape != (2,):\n            raise ValueError(\"center must be have shape (2,).\")\n        if self.shear.shape != (2,):\n            raise ValueError(\"shear must be have shape (2,).\")\n        if self.compression.shape != (2,):\n            raise ValueError(\"compression must have shape (2,).\")\n        if self.rotation.shape != ():\n            raise ValueError(\"rotation must have shaoe ().\")\n\n    def _coordinates(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Transform the input coordinates into the coordinate system of the\n        aperture.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to transform.\n\n        Returns\n        -------\n        coordinates: Array, metres\n            The coordinates of the `Aperture`.\n        \"\"\"\n\n        # Define and Apply Transformation Functions\n        def translate(coords, centre):\n            return coords - centre[:, None, None]\n\n        is_trans = (self.centre != np.zeros((2,), float)).any()\n        coordinates = lax.cond(\n            is_trans, lambda: translate(coordinates, self.centre), lambda: coordinates\n        )\n\n        def compress(coords, compress):\n            return coords * compress[:, None, None]\n\n        is_compr = (self.compression != np.ones((2,), float)).any()\n        coordinates = lax.cond(\n            is_compr,\n            lambda: compress(coordinates, self.compression),\n            lambda: coordinates,\n        )\n\n        def shear(coords, shear):\n            trans_coords = np.transpose(coords, (0, 2, 1))\n            return coords + trans_coords * shear[:, None, None]\n\n        is_shear = (self.shear != np.zeros((2,), float)).any()\n        coordinates = lax.cond(\n            is_shear, lambda: shear(coordinates, self.shear), lambda: coordinates\n        )\n\n        def rotate(coordinates: Array, rotation: Array) -&gt; Array:\n            x, y = coordinates[0], coordinates[1]\n            new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n            new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n            return np.array([new_x, new_y])\n\n        is_rot = self.rotation != 0.0\n        coordinates = lax.cond(\n            is_rot, lambda: rotate(coordinates, self.rotation), lambda: coordinates\n        )\n\n        return coordinates\n\n    def make_static(\n        self: ApertureLayer, npixels: int, diameter: float\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Returns the static version of the input aperture calculated on the\n        coordinates defined by npixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the aperture in metres.\n\n        Returns\n        -------\n        aperture: ApertureLayer\n            The TransmissiveOptic version of this aperture.\n        \"\"\"\n        coordinates = dlu.pixel_coords(npixels, diameter / npixels)\n        transmission = self._transmission(coordinates)\n        return Optic()(transmission, None, self.normalise)\n\n    def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        coordinates = self._coordinates(wavefront.coordinates)\n        wavefront *= self._transmission(coordinates)\n        if self.normalise:\n            return wavefront.normalise()\n        return wavefront\n\n\nclass DynamicAperture(BaseDynamicAperture):\n\"\"\"\n    An abstract base class that implements the methods required to provide soft\n    edges to the apertures and generate either transmissive or occulting\n    apertures.\n\n    Attributes\n    ----------\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    occulting: bool\n    softening: Array\n\n    def __init__(\n        self: ApertureLayer,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the DynamicAperture class.\n\n        Parameters\n        ----------\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            normalise=normalise,\n        )\n        self.occulting = bool(occulting)\n        self.softening = np.asarray(softening).astype(float)\n        if self.softening.shape != ():\n            raise ValueError(\"softening must have shape ().\")\n\n    @abstractmethod\n    def _extent(self: ApertureLayer) -&gt; Array:  # pragma: no cover\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n\n    @abstractmethod\n    def _soft_edged(\n        self: ApertureLayer, coordinates: Array\n    ) -&gt; Array:  # pragma: no cover\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n\n    @abstractmethod\n    def _hard_edged(\n        self: ApertureLayer, coordinates: Array\n    ) -&gt; Array:  # pragma: no cover\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n\n    def _soften(self: ApertureLayer, distances: Array) -&gt; Array:\n\"\"\"\n        Converts the distances from an edge into a soft-edged transmission array\n        using a tanh function.\n\n        Parameters\n        ----------\n        distances: Array\n            The distances from an edge to the aperture.\n\n        Returns\n        -------\n        transmission: Array\n            The softened transmission of the aperture edge based on the input\n            distances.\n        \"\"\"\n        steepness = 3.0 / self.softening * distances.shape[-1]\n        return (np.tanh(steepness * distances) + 1.0) / 2.0\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture transmission on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n\n        aperture = lax.cond(\n            (self.softening != 0.0).any(),\n            lambda coords: self._soft_edged(coords),\n            lambda coords: self._hard_edged(coords).astype(float),\n            coordinates,\n        )\n\n        if self.occulting:\n            aperture = 1.0 - aperture\n        return aperture\n\n    def _normalised_coordinates(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Shift a set of coordinates to be centered on the aperture and scaled such\n        that the radial distance is 1 to the edge of the aperture.\n\n        ### Here\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        coordinates : Array, metres\n            The coordinate system centered on the aperture with radius\n            normalised the maximum distance of an edge from the center.\n        \"\"\"\n        return self._coordinates(coordinates) / self._extent()\n</pre> from __future__ import annotations from jax import numpy as np, lax, vmap, Array from jax.tree_util import tree_map, tree_flatten from typing import Any from abc import abstractmethod from equinox import filter import dLux.utils as dlu import dLux  Wavefront = lambda: dLux.wavefronts.Wavefront Optic = lambda: dLux.optical_layers.Optic BasisOptic = lambda: dLux.optical_layers.BasisOptic TransmissiveLayer = lambda: dLux.optical_layers.TransmissiveLayer BasisLayer = lambda: dLux.optical_layers.BasisLayer ZernikeBasis = lambda: dLux.aberrations.ZernikeBasis  __all__ = [     \"CircularAperture\",     \"RectangularAperture\",     \"RegPolyAperture\",     \"IrregPolyAperture\",     \"AberratedAperture\",     \"UniformSpider\",     \"CompoundAperture\",     \"MultiAperture\",     \"ApertureFactory\", ]   class ApertureLayer(TransmissiveLayer()):     \"\"\"     The abstract base class that all aperture layers inherit from. This     instantiates the TransmissiveLayer class, initialising the normalisation     attribute.      Attributes     ----------     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      @abstractmethod     def make_static(         self: ApertureLayer, npixels: int, diameter: float     ) -&gt; ApertureLayer:         \"\"\"         Returns the static version of the input aperture calculated on the         coordinates defined by npixels and diameter.          Parameters         ----------         npixels : int             The number of pixels across one edge of the aperture.         diameter : float, metres             The diameter of the aperture in metres.          Returns         -------         aperture: ApertureLayer             The static OpticLayer version of this aperture.         \"\"\"      @abstractmethod     def _transmission(         self: ApertureLayer, coordinates: Array     ) -&gt; Array:  # pragma: no cover         \"\"\"         Compute the array representing the aperture transmission on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the aperture on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"      def transmission(self: ApertureLayer, npixels: int, diameter: float) -&gt; Array:         \"\"\"         Compute the array representing the aperture on a set of coordinates         with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels across one edge of the aperture.         diameter : float, metres             The diameter of the array to calculate the transmission on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"         return self._transmission(dlu.pixel_coords(npixels, diameter / npixels))   class BaseDynamicAperture(ApertureLayer):     \"\"\"     Base class instantiating a series of methods designed to generate     apertures differentiably at run-time. This class primarily implements the     coordinate transformations that can be applied to each aperture in order to     have fully control over the aperture shape, and apply global transformations     to the apertures.      Attributes     ----------     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      centre: Array     shear: Array     compression: Array     rotation: Array      def __init__(         self: ApertureLayer,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the BaseDynamicAperture class.          Parameters         ----------         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(normalise=normalise)          self.centre = np.asarray(centre, dtype=float)         self.shear = np.asarray(shear, dtype=float)         self.compression = np.asarray(compression, dtype=float)         self.rotation = np.asarray(rotation, dtype=float)          if self.centre.shape != (2,):             raise ValueError(\"center must be have shape (2,).\")         if self.shear.shape != (2,):             raise ValueError(\"shear must be have shape (2,).\")         if self.compression.shape != (2,):             raise ValueError(\"compression must have shape (2,).\")         if self.rotation.shape != ():             raise ValueError(\"rotation must have shaoe ().\")      def _coordinates(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Transform the input coordinates into the coordinate system of the         aperture.          Parameters         ----------         coordinates: Array, metres             The coordinates to transform.          Returns         -------         coordinates: Array, metres             The coordinates of the `Aperture`.         \"\"\"          # Define and Apply Transformation Functions         def translate(coords, centre):             return coords - centre[:, None, None]          is_trans = (self.centre != np.zeros((2,), float)).any()         coordinates = lax.cond(             is_trans, lambda: translate(coordinates, self.centre), lambda: coordinates         )          def compress(coords, compress):             return coords * compress[:, None, None]          is_compr = (self.compression != np.ones((2,), float)).any()         coordinates = lax.cond(             is_compr,             lambda: compress(coordinates, self.compression),             lambda: coordinates,         )          def shear(coords, shear):             trans_coords = np.transpose(coords, (0, 2, 1))             return coords + trans_coords * shear[:, None, None]          is_shear = (self.shear != np.zeros((2,), float)).any()         coordinates = lax.cond(             is_shear, lambda: shear(coordinates, self.shear), lambda: coordinates         )          def rotate(coordinates: Array, rotation: Array) -&gt; Array:             x, y = coordinates[0], coordinates[1]             new_x = np.cos(-rotation) * x + np.sin(-rotation) * y             new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y             return np.array([new_x, new_y])          is_rot = self.rotation != 0.0         coordinates = lax.cond(             is_rot, lambda: rotate(coordinates, self.rotation), lambda: coordinates         )          return coordinates      def make_static(         self: ApertureLayer, npixels: int, diameter: float     ) -&gt; ApertureLayer:         \"\"\"         Returns the static version of the input aperture calculated on the         coordinates defined by npixels and diameter.          Parameters         ----------         npixels : int             The number of pixels across one edge of the aperture.         diameter : float, metres             The diameter of the aperture in metres.          Returns         -------         aperture: ApertureLayer             The TransmissiveOptic version of this aperture.         \"\"\"         coordinates = dlu.pixel_coords(npixels, diameter / npixels)         transmission = self._transmission(coordinates)         return Optic()(transmission, None, self.normalise)      def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         coordinates = self._coordinates(wavefront.coordinates)         wavefront *= self._transmission(coordinates)         if self.normalise:             return wavefront.normalise()         return wavefront   class DynamicAperture(BaseDynamicAperture):     \"\"\"     An abstract base class that implements the methods required to provide soft     edges to the apertures and generate either transmissive or occulting     apertures.      Attributes     ----------     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      occulting: bool     softening: Array      def __init__(         self: ApertureLayer,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the DynamicAperture class.          Parameters         ----------         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             normalise=normalise,         )         self.occulting = bool(occulting)         self.softening = np.asarray(softening).astype(float)         if self.softening.shape != ():             raise ValueError(\"softening must have shape ().\")      @abstractmethod     def _extent(self: ApertureLayer) -&gt; Array:  # pragma: no cover         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"      @abstractmethod     def _soft_edged(         self: ApertureLayer, coordinates: Array     ) -&gt; Array:  # pragma: no cover         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"      @abstractmethod     def _hard_edged(         self: ApertureLayer, coordinates: Array     ) -&gt; Array:  # pragma: no cover         \"\"\"         Calculates the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"      def _soften(self: ApertureLayer, distances: Array) -&gt; Array:         \"\"\"         Converts the distances from an edge into a soft-edged transmission array         using a tanh function.          Parameters         ----------         distances: Array             The distances from an edge to the aperture.          Returns         -------         transmission: Array             The softened transmission of the aperture edge based on the input             distances.         \"\"\"         steepness = 3.0 / self.softening * distances.shape[-1]         return (np.tanh(steepness * distances) + 1.0) / 2.0      def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture transmission on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the aperture on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"         coordinates = self._coordinates(coordinates)          aperture = lax.cond(             (self.softening != 0.0).any(),             lambda coords: self._soft_edged(coords),             lambda coords: self._hard_edged(coords).astype(float),             coordinates,         )          if self.occulting:             aperture = 1.0 - aperture         return aperture      def _normalised_coordinates(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Shift a set of coordinates to be centered on the aperture and scaled such         that the radial distance is 1 to the edge of the aperture.          ### Here          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the aperture on.          Returns         -------         coordinates : Array, metres             The coordinate system centered on the aperture with radius             normalised the maximum distance of an edge from the center.         \"\"\"         return self._coordinates(coordinates) / self._extent()  In\u00a0[\u00a0]: Copied! <pre>class CircularAperture(DynamicAperture):\n\"\"\"\n    A circular aperture parameterised by its radius.\n\n    Attributes\n    ----------\n    radius: Array, metres\n        The radius of the aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    radius: Array\n\n    def __init__(\n        self: ApertureLayer,\n        radius: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Constructor for the CircularAperture class.\n\n        Parameters\n        ----------\n        radius: Array, metres\n            The radius of the aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.radius = np.asarray(radius).astype(float)\n        if self.radius.shape != ():\n            raise ValueError(\"radius must have shape ().\")\n\n    def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        scale = coordinates[0, 1] - coordinates[0, 0]\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(-coordinates + self.radius)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return (coordinates &lt; self.radius).astype(float)\n\n    def _extent(self: ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.radius\n\n\nclass RectangularAperture(DynamicAperture):\n\"\"\"\n    A rectangular aperture parameterised by it height and width.\n\n    Attributes\n    ----------\n    height: Array, metres\n        The length of the aperture in the y-direction.\n    width: Array, metres\n        The length of the aperture in the x-direction.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    height: Array\n    width: Array\n\n    def __init__(\n        self: ApertureLayer,\n        height: Array,\n        width: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RectangularAperture class.\n\n        Parameters\n        ----------\n        height: Array, metres\n            The length of the aperture in the y-direction.\n        width: Array, metres\n            The length of the aperture in the x-direction.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.height = np.asarray(height).astype(float)\n        self.width = np.asarray(width).astype(float)\n\n        if self.height.shape != ():\n            raise ValueError(\"height must have shape ().\")\n        if self.width.shape != ():\n            raise ValueError(\"width must have shape ().\")\n\n    def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        y_mask = self._soften(-np.abs(coordinates[1]) + self.height / 2.0)\n        x_mask = self._soften(-np.abs(coordinates[0]) + self.width / 2.0)\n        return x_mask * y_mask\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        y_mask = np.abs(coordinates[1]) &lt; self.height / 2.0\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.0\n        return (x_mask * y_mask).astype(float)\n\n    def _extent(self: ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.hypot(self.height / 2.0, self.width / 2.0)\n\n\nclass PolyAperture(DynamicAperture):\n\"\"\"\n    Base  class for all polygonal apertures, from which both regular\n    and irregular polygonal apertures inherit from, implementing some shared\n    methods.\n\n    Implementation Notes: A lot of the code that is provided was carefully hand\n    vectorised. In general, where a shape change is applied to an array the new\n    array is given the prefix `bc` standing for \"broadcastable\".\n\n    Attributes\n    ----------\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def __init__(\n        self: ApertureLayer,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the PolygonalAperture class.\n\n        Parameters\n        ----------\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n    def _perp_dists_from_lines(\n        self: ApertureLayer, m: float, x1: float, y1: float, xs: Array, ys: Array\n    ) -&gt; Array:\n\"\"\"\n        Calculates the perpendicular distance of the Cartesian (x, y)\n        coordinates from a line. The line is parameterised by its gradient m and\n        a point (x1, y1) that lies on the line.\n\n        Parameters\n        ----------\n        m: float\n            The gradient of the line.\n        x1: float, metres\n            The x coordinate the point that lies on the line.\n        y1: float, metres\n            The y coordinate the point that lies on the line.\n        xs: Array, metres\n            The x coordinates to calculate the distance on.\n        ys: Array, metres\n            The y coordinates to calculate the distance on.\n\n        Returns\n        -------\n        distances: Array, metres\n            The distance of the points (xs, ys) from the line.\n        \"\"\"\n        inf_case = xs - x1\n        gen_case = (m * inf_case - (ys - y1)) / np.sqrt(1 + m**2)\n        return np.where(np.isinf(m), inf_case, gen_case)\n\n    def _offset(self: ApertureLayer, theta: float, threshold: float) -&gt; float:\n\"\"\"\n        Transform the angular range of polar coordinates so that the new lowest\n        angle is offset. The final range should be $[\\\\phi, \\\\phi + 2 \\\\pi]$\n        where $\\\\phi$ represents the `threshold`.\n\n        Parameters\n        ----------\n        theta: float, radians\n            The angular coordinates.\n        threshold: float\n            The amount to offset the coordinates by.\n\n        Returns\n        -------\n        theta: float, radians\n            The offset coordinate system.\n        \"\"\"\n        comps = (theta &lt; threshold).astype(float)\n        return theta + comps * 2.0 * np.pi\n\n    def _is_orig_left_of_edge(\n        self: ApertureLayer, ms: float, xs: float, ys: float\n    ) -&gt; int:\n\"\"\"\n        Determines whether the origin is to the left or the right of the edge.\n        The edge(s) are defined by a set of gradients, ms and points (xs, ys).\n\n        Parameters\n        ----------\n        ms: float\n            The gradient of the edge(s).\n        xs: float, metres\n            The set of x coordinates that lie along the edges.\n        ys: float, metres\n            The set of y coordinates that lie along the edges.\n\n        Returns\n        -------\n        is_left: int\n            1 if the origin is to the left else -1.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_orig = np.array([[0.0]])\n        dist_from_orig = self._perp_dists_from_lines(ms, xs, ys, bc_orig, bc_orig)\n        return np.sign(dist_from_orig)\n\n\nclass IrregPolyAperture(PolyAperture):\n\"\"\"\n    An arbitrary aperture parameterised by a set of vertices.\n\n    TODO: Check if the vertices need to be defined in a specific way, based on\n    the methods this looks like the case (ie, ordered).\n\n    Attributes\n    ----------\n    vertices: Array, metres\n        The location of the vertices of the aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    vertices: Array\n\n    def __init__(\n        self: ApertureLayer,\n        vertices: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the IrregularPolygonalAperture class.\n\n        Parameters\n        ----------\n        vertices: Array, metres\n            The location of the vertices of the aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.vertices = np.array(vertices).astype(float)\n        if self.vertices.ndim != 2 or self.vertices.shape[1] != 2:\n            raise ValueError(\"vertices must have shape (n, 2).\")\n\n    def _grads_from_many_points(self: ApertureLayer, xs: float, ys: float) -&gt; float:\n\"\"\"\n        Given a set of points, calculate the gradient of the line that connects\n        those points. This function assumes that the points are provided in the\n        order they are to be connected together. Notice that we also assume\n        there are more than two points, but more can be provided in which case\n        the shape is assumed to be closed. The output has the same shape as the\n        input and does not check for infinite (vertical) gradients.\n\n        Note: Due to the intensely vectorised nature of this code it is often\n        necessary to provide the parameters with expanded dimensions. This may\n        be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or\n        `np.expand_dims(x1, (1, 2))`.\n\n        Parameters\n        ----------\n        xs: float, metres\n            The x coordinates of the points that are to be connected.\n        ys: float, metres\n            The y coordinates of the points that are to be connected.\n            Must have the same shape as x.\n\n        Returns\n        -------\n        ms: float\n            The gradients of the lines that connect the vertices. The vertices\n            wrap around to form a closed shape whatever it may look like.\n        \"\"\"\n        x_diffs = xs - np.roll(xs, -1)\n        y_diffs = ys - np.roll(ys, -1)\n        return y_diffs / x_diffs\n\n    def _extent(self: ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        verts = self.vertices\n        dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])\n        return np.max(dist_to_verts)\n\n    def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.0)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(\n            sorted_m, sorted_x1, sorted_y1, bc_x, bc_y\n        )\n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        soft_edges = self._soften(dist_sgn * dist_from_edges)\n\n        return (soft_edges).prod(axis=0)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.0)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(\n            sorted_m, sorted_x1, sorted_y1, bc_x, bc_y\n        )\n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        edges = (dist_from_edges * dist_sgn) &gt; 0.0\n\n        return (edges).prod(axis=0)\n\n\nclass RegPolyAperture(PolyAperture):\n\"\"\"\n    A regular polygonal aperture defined by its number of sides and the maximum\n    radius to the vertices from its center.\n\n    Attributes\n    ----------\n    nsides: int\n        The number of sides of the aperture.\n    rmax: Array, metres\n        The maximum radius to the vertices from its center.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    nsides: int\n    rmax: Array\n\n    def __init__(\n        self: ApertureLayer,\n        nsides: int,\n        rmax: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RegPolyAperture class.\n\n        Parameters\n        ----------\n        nsides: int\n            The number of sides of the aperture.\n        rmax: Array, metres\n            The maximum radius to the vertices from its center.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.nsides = int(nsides)\n        self.rmax = np.array(rmax).astype(float)\n        if self.rmax.shape != ():\n            raise ValueError(\"rmax must have shape ().\")\n\n    def _extent(self: ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n\n    def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x)\n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None]  # Dummy index\n        bounds = 2.0 * i * alpha\n\n        ms = -1 / np.tan(2.0 * i * alpha + alpha)\n        xs = self.rmax * np.cos(2.0 * i * alpha)\n        ys = self.rmax * np.sin(2.0 * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = self._soften(inside * dists)\n        return dist.prod(axis=0)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x)\n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None]  # Dummy index\n        bounds = 2.0 * i * alpha\n\n        ms = -1 / np.tan(2.0 * i * alpha + alpha)\n        xs = self.rmax * np.cos(2.0 * i * alpha)\n        ys = self.rmax * np.sin(2.0 * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = (inside * dists) &gt; 0.0\n        return dist.prod(axis=0)\n\n\n###################\n### Aberrations ###\n###################\nclass AberratedAperture(ApertureLayer, BasisLayer()):\n\"\"\"\n    A class for generating apertures with aberrations. This class generates the\n    basis vectors of the aberrations at run time, allowing for the aperture and\n    aberrations to be recovered simultaneously.\n\n    Attributes\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    basis: list[Zernike]\n        A list of basis functions that represent the basis. The exact\n        polynomials that are represented will depend on the aperture shape.\n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    normalise: bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    aperture: ApertureLayer\n\n    def __init__(\n        self: ApertureLayer,\n        aperture: ApertureLayer,\n        noll_inds: Array,\n        coefficients: Array = None,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture on which the aberration basis is defined.\n        noll_inds: List[int]\n            The noll indices are a scheme for indexing the Zernike\n            polynomials. Normally these polynomials have two\n            indices but the noll indices prevent an order to\n            these pairs. All basis can be indexed using the noll\n            indices based on `n` and `m`.\n        coefficients: Array = None\n            The amplitude of each basis vector of the aberrations. If nothing\n            is provided, then the coefficients are set to zero.\n        \"\"\"\n        # Ensure aperture is dynamic\n        if not isinstance(aperture, DynamicAperture):\n            raise TypeError(\n                \"AberratedApertures can not contain Static, \"\n                \"Compound or Multi Apertures. AberratedApertures can be \"\n                \"placed in Compound or Multi Apertures, which can then be \"\n                \"promoted to Static.\"\n            )\n\n        # Ensure transmissive\n        if aperture.occulting:\n            raise ValueError(\"AberratedApertures can not be occulting.\")\n\n        super().__init__(normalise=aperture.normalise)\n\n        # Set Aperture\n        self.aperture = aperture\n        self.basis = ZernikeBasis()(noll_inds)\n\n        if coefficients is None:\n            coefficients = np.zeros(len(noll_inds))\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the transmission of the aperture on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the transmission on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self.aperture._transmission(coordinates)\n\n    def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        coordinates = wavefront.coordinates\n        transmission = self.aperture._transmission(coordinates)\n        phase = wavefront.phase + self._opd(coordinates) * wavefront.wavenumber\n        amplitude = transmission * wavefront.amplitude\n        wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])\n        if self.aperture.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n    def _basis(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aberration basis vectors on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the basis on.\n\n        Returns\n        -------\n        basis : Array\n            The array representing the basis vectors of the aperture.\n        \"\"\"\n        coordinates = self.aperture._normalised_coordinates(coordinates)\n\n        if isinstance(self.aperture, RegPolyAperture):\n            ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)\n        else:\n            ikes = self.basis.calculate_basis(coordinates)\n\n        is_reg_pol = isinstance(self.aperture, RegPolyAperture)\n        is_circ = isinstance(self.aperture, CircularAperture)\n\n        if is_circ or is_reg_pol:\n            return ikes\n        aperture = self.aperture._transmission(coordinates)\n        return self._orthonormalise(aperture, ikes)\n\n    def _opd(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the opd of the optical aberrations on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        opd : Array\n            The array representing the opd of the aberrations.\n        \"\"\"\n        return self.calculate(self._basis(coordinates), self.coefficients)\n\n    def _orthonormalise(self: ApertureLayer, aperture: Array, zernikes: Array) -&gt; Array:\n\"\"\"\n        Orthonomalises the zernike polynomials on the aperture.\n\n        Parameters\n        ----------\n        aperture : Array\n            An array representing the aperture.\n        zernikes : Array\n            The zernike polynomials to orthonormalise on the aperture.\n\n        Returns\n        -------\n        basis : Array\n            The orthonormalised zernike polynomials evaluated on the aperture.\n        \"\"\"\n        pixel_area = aperture.sum()\n        shape = zernikes.shape\n        basis = np.zeros(shape).at[0].set(aperture)\n\n        nterms = len(zernikes)\n        for j in range(nterms):\n            intermediate = zernikes[j] * aperture\n            coefficient = np.zeros((nterms, 1, 1), dtype=float)\n            mask = (np.arange(1, nterms) &gt; j + 1).reshape((-1, 1, 1))\n\n            coefficient = (\n                -1\n                / pixel_area\n                * (zernikes[j] * basis[1:] * aperture * mask)\n                .sum(axis=(1, 2))\n                .reshape(-1, 1, 1)\n            )\n\n            intermediate += (coefficient * basis[1:] * mask).sum(axis=0)\n            basis = basis.at[j].set(\n                intermediate / np.sqrt((intermediate**2).sum() / pixel_area)\n            )\n        return basis\n\n    def make_static(\n        self: ApertureLayer, npixels: int, diameter: float\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Returns the static version of the input aperture calculated on the\n        coordinates defined by npixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the aperture in metres.\n\n        Returns\n        -------\n        aperture: ApertureLayer\n            The BasisOptic version of this aperture.\n        \"\"\"\n        coordinates = dlu.pixel_coords(npixels, diameter / npixels)\n        transmission = self.aperture._transmission(coordinates)\n\n        basis = self._basis(coordinates)\n        return BasisOptic()(\n            basis=basis,\n            transmission=transmission,\n            coefficients=self.coefficients,\n            normalise=self.normalise,\n        )\n\n\n###############\n### Spiders ###\n###############\nclass Spider(DynamicAperture):\n\"\"\"\n    An abstract class for generating aperture spiders struts.\n\n    Attributes\n    ----------\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def __init__(\n        self: ApertureLayer,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the Spider class.\n\n        Parameters\n        ----------\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=False,\n            softening=softening,\n            normalise=normalise,\n        )\n\n    def _strut(self: ApertureLayer, angle: float, coordinates: Array) -&gt; Array:\n\"\"\"\n        Generates a representation of a single strut in the spider.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle that this strut points from the positive x-axis.\n\n        Returns\n        -------\n        distance: float\n            The distance from the center of the strut.\n        \"\"\"\n        x, y = coordinates[0], coordinates[1]\n        gradient = np.tan(angle)\n        dist = np.abs(y - gradient * x) / np.sqrt(1 + gradient**2)\n        theta = np.arctan2(y, x) + np.pi\n        theta = np.where(theta &gt; angle, theta - angle, theta + 2 * np.pi - angle)\n        theta = np.where(theta &gt; 2 * np.pi, theta - 2 * np.pi, theta)\n        strut = np.where((theta &gt; np.pi / 2.0) &amp; (theta &lt; 3.0 * np.pi / 2.0), 1.0, dist)\n        return strut\n\n    def _extent(self: ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n\n\nclass UniformSpider(Spider):\n\"\"\"\n    A set of spider struts with equally-spaced, equal-width struts.\n\n    Attributes\n    ----------\n    nstruts: int\n        The number of spider struts.\n    strut_width: Array, metres\n        The width of each strut.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    nstruts: int\n    strut_width: Array\n\n    def __init__(\n        self: ApertureLayer,\n        nstruts: int,\n        strut_width: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the UniformSpider class.\n\n        Parameters\n        ----------\n        nstruts: int\n            The number of struts to equally space around the circle. This is not\n            a differentiable parameter.\n        strut_width: Array, metres\n            The width of each strut.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.nstruts = int(nstruts)\n        self.strut_width = np.asarray(strut_width).astype(float)\n        if self.strut_width.shape != ():\n            raise ValueError(\"strut_width must have shape ().\")\n\n    def _stacked_struts(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates an array of individual struts comprising the full spider\n        aperture on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinate system to calculate the struts on.\n\n        Returns\n        -------\n        struts: Array\n            The array of all the individual struts.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n        angles = np.linspace(0, 2 * np.pi, self.nstruts, endpoint=False)\n        angles += self.rotation\n        return vmap(self._strut, in_axes=(0, None))(angles, coordinates)\n\n    def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) - self.strut_width / 2.0\n        softened = self._soften(struts)\n        return softened.prod(axis=0)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) &gt; self.strut_width / 2.0\n        return struts.prod(axis=0)\n</pre> class CircularAperture(DynamicAperture):     \"\"\"     A circular aperture parameterised by its radius.      Attributes     ----------     radius: Array, metres         The radius of the aperture.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      radius: Array      def __init__(         self: ApertureLayer,         radius: Array,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; Array:         \"\"\"         Constructor for the CircularAperture class.          Parameters         ----------         radius: Array, metres             The radius of the aperture.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             occulting=occulting,             softening=softening,             normalise=normalise,         )          self.radius = np.asarray(radius).astype(float)         if self.radius.shape != ():             raise ValueError(\"radius must have shape ().\")      def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"         scale = coordinates[0, 1] - coordinates[0, 0]         coordinates = np.hypot(coordinates[0], coordinates[1])         return self._soften(-coordinates + self.radius)      def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         coordinates = np.hypot(coordinates[0], coordinates[1])         return (coordinates &lt; self.radius).astype(float)      def _extent(self: ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return self.radius   class RectangularAperture(DynamicAperture):     \"\"\"     A rectangular aperture parameterised by it height and width.      Attributes     ----------     height: Array, metres         The length of the aperture in the y-direction.     width: Array, metres         The length of the aperture in the x-direction.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      height: Array     width: Array      def __init__(         self: ApertureLayer,         height: Array,         width: Array,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the RectangularAperture class.          Parameters         ----------         height: Array, metres             The length of the aperture in the y-direction.         width: Array, metres             The length of the aperture in the x-direction.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise,         )          self.height = np.asarray(height).astype(float)         self.width = np.asarray(width).astype(float)          if self.height.shape != ():             raise ValueError(\"height must have shape ().\")         if self.width.shape != ():             raise ValueError(\"width must have shape ().\")      def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"         y_mask = self._soften(-np.abs(coordinates[1]) + self.height / 2.0)         x_mask = self._soften(-np.abs(coordinates[0]) + self.width / 2.0)         return x_mask * y_mask      def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         y_mask = np.abs(coordinates[1]) &lt; self.height / 2.0         x_mask = np.abs(coordinates[0]) &lt; self.width / 2.0         return (x_mask * y_mask).astype(float)      def _extent(self: ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return np.hypot(self.height / 2.0, self.width / 2.0)   class PolyAperture(DynamicAperture):     \"\"\"     Base  class for all polygonal apertures, from which both regular     and irregular polygonal apertures inherit from, implementing some shared     methods.      Implementation Notes: A lot of the code that is provided was carefully hand     vectorised. In general, where a shape change is applied to an array the new     array is given the prefix `bc` standing for \"broadcastable\".      Attributes     ----------     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      def __init__(         self: ApertureLayer,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the PolygonalAperture class.          Parameters         ----------         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise,         )      def _perp_dists_from_lines(         self: ApertureLayer, m: float, x1: float, y1: float, xs: Array, ys: Array     ) -&gt; Array:         \"\"\"         Calculates the perpendicular distance of the Cartesian (x, y)         coordinates from a line. The line is parameterised by its gradient m and         a point (x1, y1) that lies on the line.          Parameters         ----------         m: float             The gradient of the line.         x1: float, metres             The x coordinate the point that lies on the line.         y1: float, metres             The y coordinate the point that lies on the line.         xs: Array, metres             The x coordinates to calculate the distance on.         ys: Array, metres             The y coordinates to calculate the distance on.          Returns         -------         distances: Array, metres             The distance of the points (xs, ys) from the line.         \"\"\"         inf_case = xs - x1         gen_case = (m * inf_case - (ys - y1)) / np.sqrt(1 + m**2)         return np.where(np.isinf(m), inf_case, gen_case)      def _offset(self: ApertureLayer, theta: float, threshold: float) -&gt; float:         \"\"\"         Transform the angular range of polar coordinates so that the new lowest         angle is offset. The final range should be $[\\\\phi, \\\\phi + 2 \\\\pi]$         where $\\\\phi$ represents the `threshold`.          Parameters         ----------         theta: float, radians             The angular coordinates.         threshold: float             The amount to offset the coordinates by.          Returns         -------         theta: float, radians             The offset coordinate system.         \"\"\"         comps = (theta &lt; threshold).astype(float)         return theta + comps * 2.0 * np.pi      def _is_orig_left_of_edge(         self: ApertureLayer, ms: float, xs: float, ys: float     ) -&gt; int:         \"\"\"         Determines whether the origin is to the left or the right of the edge.         The edge(s) are defined by a set of gradients, ms and points (xs, ys).          Parameters         ----------         ms: float             The gradient of the edge(s).         xs: float, metres             The set of x coordinates that lie along the edges.         ys: float, metres             The set of y coordinates that lie along the edges.          Returns         -------         is_left: int             1 if the origin is to the left else -1.         \"\"\"         # NOTE: see class docs.         bc_orig = np.array([[0.0]])         dist_from_orig = self._perp_dists_from_lines(ms, xs, ys, bc_orig, bc_orig)         return np.sign(dist_from_orig)   class IrregPolyAperture(PolyAperture):     \"\"\"     An arbitrary aperture parameterised by a set of vertices.      TODO: Check if the vertices need to be defined in a specific way, based on     the methods this looks like the case (ie, ordered).      Attributes     ----------     vertices: Array, metres         The location of the vertices of the aperture.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      vertices: Array      def __init__(         self: ApertureLayer,         vertices: Array,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the IrregularPolygonalAperture class.          Parameters         ----------         vertices: Array, metres             The location of the vertices of the aperture.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise,         )          self.vertices = np.array(vertices).astype(float)         if self.vertices.ndim != 2 or self.vertices.shape[1] != 2:             raise ValueError(\"vertices must have shape (n, 2).\")      def _grads_from_many_points(self: ApertureLayer, xs: float, ys: float) -&gt; float:         \"\"\"         Given a set of points, calculate the gradient of the line that connects         those points. This function assumes that the points are provided in the         order they are to be connected together. Notice that we also assume         there are more than two points, but more can be provided in which case         the shape is assumed to be closed. The output has the same shape as the         input and does not check for infinite (vertical) gradients.          Note: Due to the intensely vectorised nature of this code it is often         necessary to provide the parameters with expanded dimensions. This may         be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or         `np.expand_dims(x1, (1, 2))`.          Parameters         ----------         xs: float, metres             The x coordinates of the points that are to be connected.         ys: float, metres             The y coordinates of the points that are to be connected.             Must have the same shape as x.          Returns         -------         ms: float             The gradients of the lines that connect the vertices. The vertices             wrap around to form a closed shape whatever it may look like.         \"\"\"         x_diffs = xs - np.roll(xs, -1)         y_diffs = ys - np.roll(ys, -1)         return y_diffs / x_diffs      def _extent(self: ApertureLayer) -&gt; float:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         verts = self.vertices         dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])         return np.max(dist_to_verts)      def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"         # NOTE: see class docs.         bc_x1 = self.vertices[:, 0][:, None, None]         bc_y1 = self.vertices[:, 1][:, None, None]          bc_x = coordinates[0][None, :, :]         bc_y = coordinates[1][None, :, :]          theta = np.arctan2(bc_y1, bc_x1)         offset_theta = self._offset(theta, 0.0)          sorted_inds = np.argsort(offset_theta.flatten())          sorted_x1 = bc_x1[sorted_inds]         sorted_y1 = bc_y1[sorted_inds]         sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)          dist_from_edges = self._perp_dists_from_lines(             sorted_m, sorted_x1, sorted_y1, bc_x, bc_y         )         dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)         soft_edges = self._soften(dist_sgn * dist_from_edges)          return (soft_edges).prod(axis=0)      def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         # NOTE: see class docs.         bc_x1 = self.vertices[:, 0][:, None, None]         bc_y1 = self.vertices[:, 1][:, None, None]          bc_x = coordinates[0][None, :, :]         bc_y = coordinates[1][None, :, :]          theta = np.arctan2(bc_y1, bc_x1)         offset_theta = self._offset(theta, 0.0)          sorted_inds = np.argsort(offset_theta.flatten())          sorted_x1 = bc_x1[sorted_inds]         sorted_y1 = bc_y1[sorted_inds]         sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)          dist_from_edges = self._perp_dists_from_lines(             sorted_m, sorted_x1, sorted_y1, bc_x, bc_y         )         dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)         edges = (dist_from_edges * dist_sgn) &gt; 0.0          return (edges).prod(axis=0)   class RegPolyAperture(PolyAperture):     \"\"\"     A regular polygonal aperture defined by its number of sides and the maximum     radius to the vertices from its center.      Attributes     ----------     nsides: int         The number of sides of the aperture.     rmax: Array, metres         The maximum radius to the vertices from its center.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or transmissive. False results in a transmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      nsides: int     rmax: Array      def __init__(         self: ApertureLayer,         nsides: int,         rmax: Array,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         occulting: bool = False,         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the RegPolyAperture class.          Parameters         ----------         nsides: int             The number of sides of the aperture.         rmax: Array, metres             The maximum radius to the vertices from its center.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or transmissive. False results in a             transmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise,         )          self.nsides = int(nsides)         self.rmax = np.array(rmax).astype(float)         if self.rmax.shape != ():             raise ValueError(\"rmax must have shape ().\")      def _extent(self: ApertureLayer) -&gt; float:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return self.rmax      def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"         x = coordinates[0]         y = coordinates[1]          neg_pi_to_pi_phi = np.arctan2(y, x)         alpha = np.pi / self.nsides          i = np.arange(self.nsides)[:, None, None]  # Dummy index         bounds = 2.0 * i * alpha          ms = -1 / np.tan(2.0 * i * alpha + alpha)         xs = self.rmax * np.cos(2.0 * i * alpha)         ys = self.rmax * np.sin(2.0 * i * alpha)         dists = self._perp_dists_from_lines(ms, xs, ys, x, y)         inside = self._is_orig_left_of_edge(ms, xs, ys)          dist = self._soften(inside * dists)         return dist.prod(axis=0)      def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         x = coordinates[0]         y = coordinates[1]          neg_pi_to_pi_phi = np.arctan2(y, x)         alpha = np.pi / self.nsides          i = np.arange(self.nsides)[:, None, None]  # Dummy index         bounds = 2.0 * i * alpha          ms = -1 / np.tan(2.0 * i * alpha + alpha)         xs = self.rmax * np.cos(2.0 * i * alpha)         ys = self.rmax * np.sin(2.0 * i * alpha)         dists = self._perp_dists_from_lines(ms, xs, ys, x, y)         inside = self._is_orig_left_of_edge(ms, xs, ys)          dist = (inside * dists) &gt; 0.0         return dist.prod(axis=0)   ################### ### Aberrations ### ################### class AberratedAperture(ApertureLayer, BasisLayer()):     \"\"\"     A class for generating apertures with aberrations. This class generates the     basis vectors of the aberrations at run time, allowing for the aperture and     aberrations to be recovered simultaneously.      Attributes     ----------     aperture: ApertureLayer         The aperture on which the aberration basis is defined.     basis: list[Zernike]         A list of basis functions that represent the basis. The exact         polynomials that are represented will depend on the aperture shape.     coefficients: Array         The amplitude of each basis vector of the aberrations.     normalise: bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      aperture: ApertureLayer      def __init__(         self: ApertureLayer,         aperture: ApertureLayer,         noll_inds: Array,         coefficients: Array = None,     ) -&gt; ApertureLayer:         \"\"\"         Parameters         ----------         aperture: ApertureLayer             The aperture on which the aberration basis is defined.         noll_inds: List[int]             The noll indices are a scheme for indexing the Zernike             polynomials. Normally these polynomials have two             indices but the noll indices prevent an order to             these pairs. All basis can be indexed using the noll             indices based on `n` and `m`.         coefficients: Array = None             The amplitude of each basis vector of the aberrations. If nothing             is provided, then the coefficients are set to zero.         \"\"\"         # Ensure aperture is dynamic         if not isinstance(aperture, DynamicAperture):             raise TypeError(                 \"AberratedApertures can not contain Static, \"                 \"Compound or Multi Apertures. AberratedApertures can be \"                 \"placed in Compound or Multi Apertures, which can then be \"                 \"promoted to Static.\"             )          # Ensure transmissive         if aperture.occulting:             raise ValueError(\"AberratedApertures can not be occulting.\")          super().__init__(normalise=aperture.normalise)          # Set Aperture         self.aperture = aperture         self.basis = ZernikeBasis()(noll_inds)          if coefficients is None:             coefficients = np.zeros(len(noll_inds))         self.coefficients = np.asarray(coefficients, dtype=float)      def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the transmission of the aperture on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the transmission on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"         return self.aperture._transmission(coordinates)      def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         coordinates = wavefront.coordinates         transmission = self.aperture._transmission(coordinates)         phase = wavefront.phase + self._opd(coordinates) * wavefront.wavenumber         amplitude = transmission * wavefront.amplitude         wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])         if self.aperture.normalise:             wavefront = wavefront.normalise()         return wavefront      def _basis(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the aberration basis vectors on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the basis on.          Returns         -------         basis : Array             The array representing the basis vectors of the aperture.         \"\"\"         coordinates = self.aperture._normalised_coordinates(coordinates)          if isinstance(self.aperture, RegPolyAperture):             ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)         else:             ikes = self.basis.calculate_basis(coordinates)          is_reg_pol = isinstance(self.aperture, RegPolyAperture)         is_circ = isinstance(self.aperture, CircularAperture)          if is_circ or is_reg_pol:             return ikes         aperture = self.aperture._transmission(coordinates)         return self._orthonormalise(aperture, ikes)      def _opd(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the opd of the optical aberrations on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the opd on.          Returns         -------         opd : Array             The array representing the opd of the aberrations.         \"\"\"         return self.calculate(self._basis(coordinates), self.coefficients)      def _orthonormalise(self: ApertureLayer, aperture: Array, zernikes: Array) -&gt; Array:         \"\"\"         Orthonomalises the zernike polynomials on the aperture.          Parameters         ----------         aperture : Array             An array representing the aperture.         zernikes : Array             The zernike polynomials to orthonormalise on the aperture.          Returns         -------         basis : Array             The orthonormalised zernike polynomials evaluated on the aperture.         \"\"\"         pixel_area = aperture.sum()         shape = zernikes.shape         basis = np.zeros(shape).at[0].set(aperture)          nterms = len(zernikes)         for j in range(nterms):             intermediate = zernikes[j] * aperture             coefficient = np.zeros((nterms, 1, 1), dtype=float)             mask = (np.arange(1, nterms) &gt; j + 1).reshape((-1, 1, 1))              coefficient = (                 -1                 / pixel_area                 * (zernikes[j] * basis[1:] * aperture * mask)                 .sum(axis=(1, 2))                 .reshape(-1, 1, 1)             )              intermediate += (coefficient * basis[1:] * mask).sum(axis=0)             basis = basis.at[j].set(                 intermediate / np.sqrt((intermediate**2).sum() / pixel_area)             )         return basis      def make_static(         self: ApertureLayer, npixels: int, diameter: float     ) -&gt; ApertureLayer:         \"\"\"         Returns the static version of the input aperture calculated on the         coordinates defined by npixels and diameter.          Parameters         ----------         npixels : int             The number of pixels across one edge of the aperture.         diameter : float, metres             The diameter of the aperture in metres.          Returns         -------         aperture: ApertureLayer             The BasisOptic version of this aperture.         \"\"\"         coordinates = dlu.pixel_coords(npixels, diameter / npixels)         transmission = self.aperture._transmission(coordinates)          basis = self._basis(coordinates)         return BasisOptic()(             basis=basis,             transmission=transmission,             coefficients=self.coefficients,             normalise=self.normalise,         )   ############### ### Spiders ### ############### class Spider(DynamicAperture):     \"\"\"     An abstract class for generating aperture spiders struts.      Attributes     ----------     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      def __init__(         self: ApertureLayer,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the Spider class.          Parameters         ----------         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=False,             softening=softening,             normalise=normalise,         )      def _strut(self: ApertureLayer, angle: float, coordinates: Array) -&gt; Array:         \"\"\"         Generates a representation of a single strut in the spider.          Parameters         ----------         angle: float, radians             The angle that this strut points from the positive x-axis.          Returns         -------         distance: float             The distance from the center of the strut.         \"\"\"         x, y = coordinates[0], coordinates[1]         gradient = np.tan(angle)         dist = np.abs(y - gradient * x) / np.sqrt(1 + gradient**2)         theta = np.arctan2(y, x) + np.pi         theta = np.where(theta &gt; angle, theta - angle, theta + 2 * np.pi - angle)         theta = np.where(theta &gt; 2 * np.pi, theta - 2 * np.pi, theta)         strut = np.where((theta &gt; np.pi / 2.0) &amp; (theta &lt; 3.0 * np.pi / 2.0), 1.0, dist)         return strut      def _extent(self: ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for         speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"   class UniformSpider(Spider):     \"\"\"     A set of spider struts with equally-spaced, equal-width struts.      Attributes     ----------     nstruts: int         The number of spider struts.     strut_width: Array, metres         The width of each strut.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the         aperture. Hard edges can be achieved by setting the softening to 0.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      nstruts: int     strut_width: Array      def __init__(         self: ApertureLayer,         nstruts: int,         strut_width: Array,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         softening: Array = np.array(1.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the UniformSpider class.          Parameters         ----------         nstruts: int             The number of struts to equally space around the circle. This is not             a differentiable parameter.         strut_width: Array, metres             The width of each strut.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the             aperture. Hard edges can be achieved by setting the softening to 0.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             softening=softening,             normalise=normalise,         )          self.nstruts = int(nstruts)         self.strut_width = np.asarray(strut_width).astype(float)         if self.strut_width.shape != ():             raise ValueError(\"strut_width must have shape ().\")      def _stacked_struts(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates an array of individual struts comprising the full spider         aperture on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinate system to calculate the struts on.          Returns         -------         struts: Array             The array of all the individual struts.         \"\"\"         coordinates = self._coordinates(coordinates)         angles = np.linspace(0, 2 * np.pi, self.nstruts, endpoint=False)         angles += self.rotation         return vmap(self._strut, in_axes=(0, None))(angles, coordinates)      def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the soft-edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The soft-edged aperture shape.         \"\"\"         struts = self._stacked_struts(coordinates) - self.strut_width / 2.0         softened = self._soften(struts)         return softened.prod(axis=0)      def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, metres             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         struts = self._stacked_struts(coordinates) &gt; self.strut_width / 2.0         return struts.prod(axis=0)  In\u00a0[\u00a0]: Copied! <pre>class CompositeAperture(BaseDynamicAperture):\n\"\"\"\n    An abstract class used to combine multiple apertures so that more complex\n    apertures can have global transformations applied to them. Two examples\n    would be a pupil with spiders holding the secondary mirror or an aperture\n    mask.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n       The sub-apertures that make up the full aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    apertures: dict\n\n    def __init__(\n        self: ApertureLayer,\n        apertures: list,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompositeAperture class.\n\n        Parameters\n        ----------\n        apertures: dict(str, Aperture)\n            The sub-apertures that make up the full aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        self.apertures = dlu.list_to_dictionary(apertures, False, ApertureLayer)\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            normalise=normalise,\n        )\n\n    def _stacked_apertures(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates an array of individual apertures comprising the compound\n        aperture on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the apertures on.\n\n        Returns\n        -------\n        apertures: Array\n            The array of all the individual apertures.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n        get_transmission = lambda ap: ap._transmission(coordinates)\n        transmissions = [get_transmission(ap) for ap in self.apertures.values()]\n        return np.array(transmissions)\n\n    def _aberrated_apertures(self: ApertureLayer) -&gt; list:\n\"\"\"\n        Returns the individual apertures with aberrations.\n        Note: This method returns CompoundApertures if it contains apertures\n        with aberrations in them.\n\n        Returns\n        -------\n        apertures: list[Union[AberratedAperture, CompoundAperture]]\n            The list of apertures with aberrations.\n        \"\"\"\n\n        # Define leaf fn\n        def is_aberrated(leaf):\n            if isinstance(leaf, AberratedAperture):\n                return True\n            elif isinstance(leaf, CompoundAperture):\n                if len(leaf._aberrated_apertures()) &gt; 0:\n                    return True\n            return False\n\n        # Get aberrated apertures\n        # TODO: use partition\n        filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)\n        aberrated = filter(self.apertures, filter_map)\n        return tree_flatten(aberrated, is_leaf=is_aberrated)[0]\n\n    @property\n    def coefficients(self):\n        coefficients = [ap.coefficients for ap in self._aberrated_apertures()]\n        return np.squeeze(np.array(coefficients))\n\n    def _basis(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aberration basis vectors on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the basis on.\n\n        Returns\n        -------\n        basis : Array\n            The array representing the basis vectors of the aperture.\n        \"\"\"\n        aberrated_apertures = self._aberrated_apertures()\n        basis = [ap._basis(coordinates) for ap in aberrated_apertures]\n        return np.squeeze(np.array(basis))\n\n    # This is actually a duplicate from BasisLayer - class structure could be\n    # optimised\n    def calculate(self, basis, coefficients):\n        ndim = coefficients.ndim\n        axes = (tuple(range(ndim)), tuple(range(ndim)))\n        return np.tensordot(basis, coefficients, axes=axes)\n\n    def _opd(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the opd of the optical aberrations on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        opd : Array\n            The array representing the opd of the aberrations.\n        \"\"\"\n        return self.calculate(self._basis(coordinates), self.coefficients)\n\n    def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        coordinates = wavefront.coordinates\n        amplitude = wavefront.amplitude * self._transmission(coordinates)\n\n        if len(self._aberrated_apertures()) == 0:\n            wavefront = wavefront.set(\"amplitude\", amplitude)\n        else:\n            opd = self._opd(coordinates)\n            phase = wavefront.phase + opd * wavefront.wavenumber\n            wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])\n\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n    def make_static(\n        self: ApertureLayer, npixels: int, diameter: float\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Returns the static version of the input aperture calculated on the\n        coordinates defined by npixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the aperture in metres.\n\n        Returns\n        -------\n        aperture: ApertureLayer\n            The BasisOptic version of this aperture.\n        \"\"\"\n        coordinates = self._coordinates(dlu.pixel_coords(npixels, diameter / npixels))\n        transmission = self._transmission(coordinates)\n\n        if len(self._aberrated_apertures()) == 0:\n            return Optic()(transmission=transmission, normalise=self.normalise)\n        else:\n            basis = self._basis(coordinates)\n        return BasisOptic()(\n            basis=basis,\n            transmission=transmission,\n            coefficients=self.coefficients,\n            normalise=self.normalise,\n        )\n\n    def __getattr__(self: ApertureLayer, key: str) -&gt; Any:\n\"\"\"\n        Get the attribute of the aberrated apertures.\n\n        Parameters\n        ----------\n        key: str\n            The attribute to get.\n\n        Returns\n        -------\n        attribute: Any\n            The attribute of the aberrated apertures.\n        \"\"\"\n        if key in self.apertures:\n            return self.apertures[key]\n        else:\n            raise AttributeError(f\"{key} not in {self.apertures.keys()}\")\n\n\nclass CompoundAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture with spiders holding a secondary mirror.\n\n    This class is distinct from the MultiAperture class in that the\n    sub-apertures are combined by multiplying their respective transmissions\n    together, i.e. the sub-apertures are overlapping.\n\n    This class should not contain a MultiAperture, but MultiApertures can\n    contain CompoundApertures.\n\n    A single aberrated aperture can be placed into the set of apertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def __init__(\n        self: ApertureLayer,\n        apertures: list,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompoundAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            apertures=apertures,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            normalise=normalise,\n        )\n\n        # Check for more than one aberrated aperture\n        naberrated = 0\n        for aperture in self.apertures.values():\n            if isinstance(aperture, AberratedAperture):\n                naberrated += 1\n            if naberrated &gt; 1:\n                raise TypeError(\n                    \"CompoundAperture can only have a single \" \"AberratedAperture.\"\n                )\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture transmission on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._stacked_apertures(coordinates).prod(axis=0)\n\n\nclass MultiAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture mask.\n\n    This class is distinct from the CompoundAperture class in that the\n    sub-apertures are combined by adding their respective transmissions\n    together, i.e. the sub-apertures are not overlapping.\n\n    This class can contain multiple CompoundApertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the transmission of the aperture on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the transmission on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._stacked_apertures(coordinates).sum(axis=0)\n\n\n###############\n### Factory ###\n###############\ndef ApertureFactory(\n    npixels: int,\n    radial_orders: Array = None,\n    coefficients: Array = None,\n    noll_indices: Array = None,\n    aperture_ratio: float = 1.0,\n    secondary_ratio: float = 0.0,\n    nsides: int = 0,\n    secondary_nsides: int = 0,\n    rotation: float = 0.0,\n    nstruts: int = 0,\n    strut_ratio: float = 0.0,\n    strut_rotation: float = 0.0,\n    normalise: bool = True,\n    static: bool = True,\n):\n\"\"\"\n    This method is used to\n    give a simple constructor interface that is used to construct the most\n    commonly used apertures. It is able to construct hard-edged circular or\n    regular polygonal apertures. Secondary mirrors obscurations with the same\n    aperture shape can be constructed, along with uniformly spaced struts. The\n    ratio of the primary aperture opening to the array size is determined by\n    the `aperture_ratio` parameter, with secondary mirror obscurations and\n    struts being scaled relative to the aperture diameter.\n\n    Let's look at an example of how to construct a simple circular aperture with\n    a secondary mirror obscuration held by 4 struts. For this example lets take\n    a 2m diameter aperture, with a 20cm secondary mirror held by 3 struts with\n    a width of 2cm. In this example the secondary mirror is 10% of the primary\n    aperture diameter and the struts are 1% of the primary aperture diameter,\n    giving us values of 0.1 and 0.01 for the `secondary_ratio` and\n    `strut_ratio` parameters. Let calculate this for a 512x512 array with the\n    aperture spanning the full array.\n\n    ```python\n    from dLux import ApertureFactory\n    import jax.numpy as np\n    import jax.random as jr\n\n    # Construct aperture\n    aperture = ApertureFactory(512, secondary_ratio=0.1, nstruts=4,\n        strut_ratio=0.01)\n    ```\n\n    The resulting aperture class has onc parameters, `.transmission` which\n    represents the transmission of the aperture.\n    ```\n\n    We can also easily change this to a hexagonal aperture with 3 struts:\n\n    ```python\n    # Make aperture\n    hexagonal_aperture = ApertureFactory(512, nsides=6, secondary_ratio=0.1,\n        nstruts=3, strut_ratio=0.01)\n\n    # Examine\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.transmission)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(hexagonal_aperture.transmission)\n    plt.colorbar()\n    plt.show()\n    ```\n\n    Parameters\n    ----------\n    npixels : int\n        Number of pixels used to represent the aperture.\n    radial_orders : Array = None\n        The radial orders of the zernike polynomials to be used for the\n        aberrations. Input of [0, 1] would give [Piston, Tilt X, Tilt Y],\n        [1, 2] would be [Tilt X, Tilt Y, Defocus, Astig X, Astig Y], etc.\n        The order must be increasing but does not have to be consecutive.\n        If you want to specify specific zernikes across radial orders the\n        noll_indices argument should be used instead.\n    coefficients : Array = None\n        The zernike coefficients to be applied to the aberrations. Defaults\n        to an array of zeros.\n    noll_indices : Array = None\n        The zernike noll indices to be used for the aberrations. [1, 2, 3]\n        would give [Piston, Tilt X, Tilt Y], [2, 3, 4] would be [Tilt X,\n        Tilt Y, Defocus.\n    aperture_ratio : float = 1.\n        The ratio of the aperture size to the array size. A value of 1.\n        results in an aperture that fully spans the array, a value of 0.5\n        results in an aperture that is half the size of the array, which is\n        equivalent to a padding factor of 2.\n    secondary_ratio : float = 0.\n        The ratio of the secondary mirror obscuration diameter to the\n        aperture diameter. A value of 0. results in no secondary mirror\n        obscuration.\n    nsides : int = 0\n        Number of sides of the aperture. A zero input results in a circular\n        aperture. All other values of three and above are supported.\n    secondary_nsides : int = 0\n        The number of sides of the secondary mirror obscuration. A zero input\n        results in a circular aperture. All other other values of three and\n        above are supported.\n    rotation : float, radians = 0\n        The global rotation of the aperture in radians.\n    nstruts : int = 0\n        The number of uniformly spaced struts holding the secondary mirror.\n    strut_ratio : float = 0.\n        The ratio of the width of the strut to the aperture diameter.\n    strut_rotation : float = 0\n        The rotation of the struts in radians.\n    normalise : bool = True\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    static : bool = True\n        Whether to return a static aperture or a dynamic aperture.\n\n    Returns\n    -------\n    aperture : StaticAperture\n        Returns an appropriately constructed StaticAperture.\n    \"\"\"\n    # Check valid inputs\n    if nsides &lt; 3 and nsides != 0:\n        raise ValueError(\"nsides must be either 0 or &gt;=3\")\n\n    if secondary_nsides &lt; 3 and secondary_nsides != 0:\n        raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")\n\n    if aperture_ratio &lt;= 0:\n        raise ValueError(\"aperture_ratio must be &gt; 0\")\n\n    if secondary_ratio &lt; 0:\n        raise ValueError(\"secondary_ratio must be &gt;= 0\")\n\n    if strut_ratio &lt; 0:\n        raise ValueError(\"strut_ratio must be &gt;= 0\")\n\n    # Construct components\n    apertures = []\n\n    # Primary\n    if nsides == 0:\n        ap = CircularAperture(aperture_ratio / 2, softening=0)\n    else:\n        ap = RegPolyAperture(nsides, aperture_ratio / 2, softening=0, rotation=rotation)\n\n    # Aberrations\n    if radial_orders is not None:\n        radial_orders = np.array(radial_orders)\n\n        if (radial_orders &lt; 0).any():\n            raise ValueError(\"Radial orders must be &gt;= 0\")\n\n        noll_indices = []\n        for order in radial_orders:\n            start = dlu.triangular_number(order)\n            stop = dlu.triangular_number(order + 1)\n            noll_indices.append(np.arange(start, stop) + 1)\n        noll_indices = np.concatenate(noll_indices)\n\n    if noll_indices is None:\n        apertures.append(ap)\n    else:\n        ab_ap = AberratedAperture(ap, noll_indices, coefficients=coefficients)\n        apertures.append(ab_ap)\n\n    # Secondary\n    if secondary_ratio != 0:\n        secondary_rel = aperture_ratio * secondary_ratio\n\n        # Circular\n        if secondary_nsides == 0:\n            apertures.append(\n                CircularAperture(secondary_rel / 2, softening=0, occulting=True)\n            )\n        # Polygonal\n        else:\n            apertures.append(\n                RegPolyAperture(\n                    secondary_nsides,\n                    secondary_rel / 2,\n                    softening=0,\n                    rotation=rotation,\n                    occulting=True,\n                )\n            )\n\n    # Spiders\n    if nstruts &gt; 0:\n        if strut_ratio == 0:\n            raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")\n        strut_rel = aperture_ratio * strut_ratio\n        full_rotation = strut_rotation + rotation\n        apertures.append(\n            UniformSpider(nstruts, strut_rel, rotation=full_rotation, softening=0)\n        )\n\n    # Construct CompoundAperture\n    full_aperture = CompoundAperture(apertures, normalise=normalise)\n    if static:\n        return full_aperture.make_static(npixels, 1)\n    return full_aperture\n</pre> class CompositeAperture(BaseDynamicAperture):     \"\"\"     An abstract class used to combine multiple apertures so that more complex     apertures can have global transformations applied to them. Two examples     would be a pupil with spiders holding the secondary mirror or an aperture     mask.      Attributes     ----------     apertures: dict(str, Aperture)        The sub-apertures that make up the full aperture.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      apertures: dict      def __init__(         self: ApertureLayer,         apertures: list,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the CompositeAperture class.          Parameters         ----------         apertures: dict(str, Aperture)             The sub-apertures that make up the full aperture.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         self.apertures = dlu.list_to_dictionary(apertures, False, ApertureLayer)         super().__init__(             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             normalise=normalise,         )      def _stacked_apertures(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Calculates an array of individual apertures comprising the compound         aperture on the input coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the apertures on.          Returns         -------         apertures: Array             The array of all the individual apertures.         \"\"\"         coordinates = self._coordinates(coordinates)         get_transmission = lambda ap: ap._transmission(coordinates)         transmissions = [get_transmission(ap) for ap in self.apertures.values()]         return np.array(transmissions)      def _aberrated_apertures(self: ApertureLayer) -&gt; list:         \"\"\"         Returns the individual apertures with aberrations.         Note: This method returns CompoundApertures if it contains apertures         with aberrations in them.          Returns         -------         apertures: list[Union[AberratedAperture, CompoundAperture]]             The list of apertures with aberrations.         \"\"\"          # Define leaf fn         def is_aberrated(leaf):             if isinstance(leaf, AberratedAperture):                 return True             elif isinstance(leaf, CompoundAperture):                 if len(leaf._aberrated_apertures()) &gt; 0:                     return True             return False          # Get aberrated apertures         # TODO: use partition         filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)         aberrated = filter(self.apertures, filter_map)         return tree_flatten(aberrated, is_leaf=is_aberrated)[0]      @property     def coefficients(self):         coefficients = [ap.coefficients for ap in self._aberrated_apertures()]         return np.squeeze(np.array(coefficients))      def _basis(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the aberration basis vectors on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the basis on.          Returns         -------         basis : Array             The array representing the basis vectors of the aperture.         \"\"\"         aberrated_apertures = self._aberrated_apertures()         basis = [ap._basis(coordinates) for ap in aberrated_apertures]         return np.squeeze(np.array(basis))      # This is actually a duplicate from BasisLayer - class structure could be     # optimised     def calculate(self, basis, coefficients):         ndim = coefficients.ndim         axes = (tuple(range(ndim)), tuple(range(ndim)))         return np.tensordot(basis, coefficients, axes=axes)      def _opd(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the opd of the optical aberrations on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the opd on.          Returns         -------         opd : Array             The array representing the opd of the aberrations.         \"\"\"         return self.calculate(self._basis(coordinates), self.coefficients)      def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         coordinates = wavefront.coordinates         amplitude = wavefront.amplitude * self._transmission(coordinates)          if len(self._aberrated_apertures()) == 0:             wavefront = wavefront.set(\"amplitude\", amplitude)         else:             opd = self._opd(coordinates)             phase = wavefront.phase + opd * wavefront.wavenumber             wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])          if self.normalise:             wavefront = wavefront.normalise()         return wavefront      def make_static(         self: ApertureLayer, npixels: int, diameter: float     ) -&gt; ApertureLayer:         \"\"\"         Returns the static version of the input aperture calculated on the         coordinates defined by npixels and diameter.          Parameters         ----------         npixels : int             The number of pixels across one edge of the aperture.         diameter : float, metres             The diameter of the aperture in metres.          Returns         -------         aperture: ApertureLayer             The BasisOptic version of this aperture.         \"\"\"         coordinates = self._coordinates(dlu.pixel_coords(npixels, diameter / npixels))         transmission = self._transmission(coordinates)          if len(self._aberrated_apertures()) == 0:             return Optic()(transmission=transmission, normalise=self.normalise)         else:             basis = self._basis(coordinates)         return BasisOptic()(             basis=basis,             transmission=transmission,             coefficients=self.coefficients,             normalise=self.normalise,         )      def __getattr__(self: ApertureLayer, key: str) -&gt; Any:         \"\"\"         Get the attribute of the aberrated apertures.          Parameters         ----------         key: str             The attribute to get.          Returns         -------         attribute: Any             The attribute of the aberrated apertures.         \"\"\"         if key in self.apertures:             return self.apertures[key]         else:             raise AttributeError(f\"{key} not in {self.apertures.keys()}\")   class CompoundAperture(CompositeAperture):     \"\"\"     A  class used to combine multiple apertures into a single coherent aperture.     An example would be an aperture with spiders holding a secondary mirror.      This class is distinct from the MultiAperture class in that the     sub-apertures are combined by multiplying their respective transmissions     together, i.e. the sub-apertures are overlapping.      This class should not contain a MultiAperture, but MultiApertures can     contain CompoundApertures.      A single aberrated aperture can be placed into the set of apertures.      Attributes     ----------     apertures: dict(str, Aperture)         The sub-apertures that make up the full aperture.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      def __init__(         self: ApertureLayer,         apertures: list,         centre: Array = np.array([0.0, 0.0]),         shear: Array = np.array([0.0, 0.0]),         compression: Array = np.array([1.0, 1.0]),         rotation: Array = np.array(0.0),         normalise: bool = False,     ) -&gt; ApertureLayer:         \"\"\"         Constructor for the CompoundAperture class.          Parameters         ----------         apertures: list[Aperture]             The sub-apertures that make up the full aperture.         centre: Array, metres = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperture.         compression: Array  = np.array([1., 1.])             The (x, y) compression of the aperture.         rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         super().__init__(             apertures=apertures,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             normalise=normalise,         )          # Check for more than one aberrated aperture         naberrated = 0         for aperture in self.apertures.values():             if isinstance(aperture, AberratedAperture):                 naberrated += 1             if naberrated &gt; 1:                 raise TypeError(                     \"CompoundAperture can only have a single \" \"AberratedAperture.\"                 )      def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture transmission on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the aperture on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"         return self._stacked_apertures(coordinates).prod(axis=0)   class MultiAperture(CompositeAperture):     \"\"\"     A  class used to combine multiple apertures into a single coherent aperture.     An example would be an aperture mask.      This class is distinct from the CompoundAperture class in that the     sub-apertures are combined by adding their respective transmissions     together, i.e. the sub-apertures are not overlapping.      This class can contain multiple CompoundApertures.      Attributes     ----------     apertures: dict(str, Aperture)         The sub-apertures that make up the full aperture.     centre: Array, metres         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperture.     compression: Array         The (x, y) compression of the aperture.     rotation: Array, radians         The clockwise rotation of the aperture.     normalise : bool = False         Whether to normalise the wavefront after passing through the aperture.     \"\"\"      def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:         \"\"\"         Compute the array representing the transmission of the aperture on the         provided coordinates.          Parameters         ----------         coordinates : Array, metres             The coordinate system to calculate the transmission on.          Returns         -------         transmission : Array             The array representing the transmission of the aperture.         \"\"\"         return self._stacked_apertures(coordinates).sum(axis=0)   ############### ### Factory ### ############### def ApertureFactory(     npixels: int,     radial_orders: Array = None,     coefficients: Array = None,     noll_indices: Array = None,     aperture_ratio: float = 1.0,     secondary_ratio: float = 0.0,     nsides: int = 0,     secondary_nsides: int = 0,     rotation: float = 0.0,     nstruts: int = 0,     strut_ratio: float = 0.0,     strut_rotation: float = 0.0,     normalise: bool = True,     static: bool = True, ):     \"\"\"     This method is used to     give a simple constructor interface that is used to construct the most     commonly used apertures. It is able to construct hard-edged circular or     regular polygonal apertures. Secondary mirrors obscurations with the same     aperture shape can be constructed, along with uniformly spaced struts. The     ratio of the primary aperture opening to the array size is determined by     the `aperture_ratio` parameter, with secondary mirror obscurations and     struts being scaled relative to the aperture diameter.      Let's look at an example of how to construct a simple circular aperture with     a secondary mirror obscuration held by 4 struts. For this example lets take     a 2m diameter aperture, with a 20cm secondary mirror held by 3 struts with     a width of 2cm. In this example the secondary mirror is 10% of the primary     aperture diameter and the struts are 1% of the primary aperture diameter,     giving us values of 0.1 and 0.01 for the `secondary_ratio` and     `strut_ratio` parameters. Let calculate this for a 512x512 array with the     aperture spanning the full array.      ```python     from dLux import ApertureFactory     import jax.numpy as np     import jax.random as jr      # Construct aperture     aperture = ApertureFactory(512, secondary_ratio=0.1, nstruts=4,         strut_ratio=0.01)     ```      The resulting aperture class has onc parameters, `.transmission` which     represents the transmission of the aperture.     ```      We can also easily change this to a hexagonal aperture with 3 struts:      ```python     # Make aperture     hexagonal_aperture = ApertureFactory(512, nsides=6, secondary_ratio=0.1,         nstruts=3, strut_ratio=0.01)      # Examine     plt.figure(figsize=(10, 5))     plt.subplot(1, 2, 1)     plt.imshow(aperture.transmission)     plt.colorbar()      plt.subplot(1, 2, 2)     plt.imshow(hexagonal_aperture.transmission)     plt.colorbar()     plt.show()     ```      Parameters     ----------     npixels : int         Number of pixels used to represent the aperture.     radial_orders : Array = None         The radial orders of the zernike polynomials to be used for the         aberrations. Input of [0, 1] would give [Piston, Tilt X, Tilt Y],         [1, 2] would be [Tilt X, Tilt Y, Defocus, Astig X, Astig Y], etc.         The order must be increasing but does not have to be consecutive.         If you want to specify specific zernikes across radial orders the         noll_indices argument should be used instead.     coefficients : Array = None         The zernike coefficients to be applied to the aberrations. Defaults         to an array of zeros.     noll_indices : Array = None         The zernike noll indices to be used for the aberrations. [1, 2, 3]         would give [Piston, Tilt X, Tilt Y], [2, 3, 4] would be [Tilt X,         Tilt Y, Defocus.     aperture_ratio : float = 1.         The ratio of the aperture size to the array size. A value of 1.         results in an aperture that fully spans the array, a value of 0.5         results in an aperture that is half the size of the array, which is         equivalent to a padding factor of 2.     secondary_ratio : float = 0.         The ratio of the secondary mirror obscuration diameter to the         aperture diameter. A value of 0. results in no secondary mirror         obscuration.     nsides : int = 0         Number of sides of the aperture. A zero input results in a circular         aperture. All other values of three and above are supported.     secondary_nsides : int = 0         The number of sides of the secondary mirror obscuration. A zero input         results in a circular aperture. All other other values of three and         above are supported.     rotation : float, radians = 0         The global rotation of the aperture in radians.     nstruts : int = 0         The number of uniformly spaced struts holding the secondary mirror.     strut_ratio : float = 0.         The ratio of the width of the strut to the aperture diameter.     strut_rotation : float = 0         The rotation of the struts in radians.     normalise : bool = True         Whether to normalise the wavefront after passing through the         aperture.     static : bool = True         Whether to return a static aperture or a dynamic aperture.      Returns     -------     aperture : StaticAperture         Returns an appropriately constructed StaticAperture.     \"\"\"     # Check valid inputs     if nsides &lt; 3 and nsides != 0:         raise ValueError(\"nsides must be either 0 or &gt;=3\")      if secondary_nsides &lt; 3 and secondary_nsides != 0:         raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")      if aperture_ratio &lt;= 0:         raise ValueError(\"aperture_ratio must be &gt; 0\")      if secondary_ratio &lt; 0:         raise ValueError(\"secondary_ratio must be &gt;= 0\")      if strut_ratio &lt; 0:         raise ValueError(\"strut_ratio must be &gt;= 0\")      # Construct components     apertures = []      # Primary     if nsides == 0:         ap = CircularAperture(aperture_ratio / 2, softening=0)     else:         ap = RegPolyAperture(nsides, aperture_ratio / 2, softening=0, rotation=rotation)      # Aberrations     if radial_orders is not None:         radial_orders = np.array(radial_orders)          if (radial_orders &lt; 0).any():             raise ValueError(\"Radial orders must be &gt;= 0\")          noll_indices = []         for order in radial_orders:             start = dlu.triangular_number(order)             stop = dlu.triangular_number(order + 1)             noll_indices.append(np.arange(start, stop) + 1)         noll_indices = np.concatenate(noll_indices)      if noll_indices is None:         apertures.append(ap)     else:         ab_ap = AberratedAperture(ap, noll_indices, coefficients=coefficients)         apertures.append(ab_ap)      # Secondary     if secondary_ratio != 0:         secondary_rel = aperture_ratio * secondary_ratio          # Circular         if secondary_nsides == 0:             apertures.append(                 CircularAperture(secondary_rel / 2, softening=0, occulting=True)             )         # Polygonal         else:             apertures.append(                 RegPolyAperture(                     secondary_nsides,                     secondary_rel / 2,                     softening=0,                     rotation=rotation,                     occulting=True,                 )             )      # Spiders     if nstruts &gt; 0:         if strut_ratio == 0:             raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")         strut_rel = aperture_ratio * strut_ratio         full_rotation = strut_rotation + rotation         apertures.append(             UniformSpider(nstruts, strut_rel, rotation=full_rotation, softening=0)         )      # Construct CompoundAperture     full_aperture = CompoundAperture(apertures, normalise=normalise)     if static:         return full_aperture.make_static(npixels, 1)     return full_aperture"},{"location":"dLux/apertures/#concrete-aperture-classes","title":"Concrete Aperture Classes\u00b6","text":"<p>################################</p>"},{"location":"dLux/apertures/#composite-apertures","title":"Composite Apertures\u00b6","text":"<p>##########################</p>"},{"location":"dLux/detector_layers/","title":"Detector layers","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nimport jax.numpy as np\nfrom jax import Array\nfrom jax.scipy.stats import norm\nfrom zodiax import Base\nimport dLux\n</pre> from __future__ import annotations from abc import abstractmethod import jax.numpy as np from jax import Array from jax.scipy.stats import norm from zodiax import Base import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"ApplyPixelResponse\", \"ApplyJitter\", \"ApplySaturation\",\n           \"AddConstant\", \"IntegerDownsample\", \"Rotate\"]\n</pre> __all__ = [\"ApplyPixelResponse\", \"ApplyJitter\", \"ApplySaturation\",            \"AddConstant\", \"IntegerDownsample\", \"Rotate\"] In\u00a0[\u00a0]: Copied! <pre>Image = lambda: dLux.images.Image\n</pre> Image = lambda: dLux.images.Image In\u00a0[\u00a0]: Copied! <pre>class DetectorLayer(Base):\n\"\"\"\n    A base Detector layer class to help with type checking throughout the rest\n    of the software.\n    \"\"\"\n\n    def __init__(self: DetectorLayer):\n\"\"\"\n        Constructor for the DetectorLayer class.\n        \"\"\"\n        super().__init__()\n\n    @abstractmethod\n    def __call__(self: DetectorLayer,\n                 image: Image()) -&gt; Image:  # pragma: no cover\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n</pre> class DetectorLayer(Base):     \"\"\"     A base Detector layer class to help with type checking throughout the rest     of the software.     \"\"\"      def __init__(self: DetectorLayer):         \"\"\"         Constructor for the DetectorLayer class.         \"\"\"         super().__init__()      @abstractmethod     def __call__(self: DetectorLayer,                  image: Image()) -&gt; Image:  # pragma: no cover         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\" In\u00a0[\u00a0]: Copied! <pre>class ApplyPixelResponse(DetectorLayer):\n\"\"\"\n    Applies a pixel response array to the input image, via a multiplication.\n\n    Attributes\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image.\n    \"\"\"\n    pixel_response: Array\n\n    def __init__(self: DetectorLayer,\n                 pixel_response: Array):\n\"\"\"\n        Constructor for the ApplyPixelResponse class.\n\n        Parameters\n        ----------\n        pixel_response : Array\n            The pixel_response to apply to the input image. Must be a 2-dimensional\n            array equal to size of the image at time of application.\n        \"\"\"\n        super().__init__()\n        self.pixel_response = np.asarray(pixel_response, dtype=float)\n        if self.pixel_response.ndim != 2:\n            raise ValueError(\"pixel_response must be a 2 dimensional array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image:\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image * self.pixel_response\n</pre> class ApplyPixelResponse(DetectorLayer):     \"\"\"     Applies a pixel response array to the input image, via a multiplication.      Attributes     ----------     pixel_response : Array         The pixel_response to apply to the input image.     \"\"\"     pixel_response: Array      def __init__(self: DetectorLayer,                  pixel_response: Array):         \"\"\"         Constructor for the ApplyPixelResponse class.          Parameters         ----------         pixel_response : Array             The pixel_response to apply to the input image. Must be a 2-dimensional             array equal to size of the image at time of application.         \"\"\"         super().__init__()         self.pixel_response = np.asarray(pixel_response, dtype=float)         if self.pixel_response.ndim != 2:             raise ValueError(\"pixel_response must be a 2 dimensional array.\")      def __call__(self: DetectorLayer, image: Image()) -&gt; Image:         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         return image * self.pixel_response In\u00a0[\u00a0]: Copied! <pre>class ApplyJitter(DetectorLayer):\n\"\"\"\n    Convolves the image with a Gaussian kernel parameterised by the standard\n    deviation (sigma).\n\n    Attributes\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the Gaussian kernel, in units of pixels.\n    kernel_size : int\n        The size of the convolution kernel to use.\n    \"\"\"\n    kernel_size: int\n    sigma: Array\n\n    def __init__(self: DetectorLayer,\n                 sigma: Array,\n                 kernel_size: int = 10):\n\"\"\"\n        Constructor for the ApplyJitter class.\n\n        Parameters\n        ----------\n        sigma : Array, pixels\n            The standard deviation of the Gaussian kernel, in units of pixels.\n        kernel_size : int = 10\n            The size of the convolution kernel to use.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n        self.sigma = np.asarray(sigma, dtype=float)\n        if self.sigma.ndim != 0:\n            raise ValueError(\"sigma must be a scalar array.\")\n\n    def generate_kernel(self: DetectorLayer, pixel_scale: Array) -&gt; Array:\n\"\"\"\n        Generates the normalised Gaussian kernel.\n\n        Returns\n        -------\n        kernel : Array\n            The Gaussian kernel.\n        \"\"\"\n        # Generate distribution\n        sigma = self.sigma * pixel_scale\n        x = np.linspace(-10, 10, self.kernel_size) * pixel_scale\n        kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)\n        return kernel / np.sum(kernel)\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        kernel = self.generate_kernel(image.pixel_scale)\n        return image.convolve(kernel)\n</pre> class ApplyJitter(DetectorLayer):     \"\"\"     Convolves the image with a Gaussian kernel parameterised by the standard     deviation (sigma).      Attributes     ----------     sigma : Array, pixels         The standard deviation of the Gaussian kernel, in units of pixels.     kernel_size : int         The size of the convolution kernel to use.     \"\"\"     kernel_size: int     sigma: Array      def __init__(self: DetectorLayer,                  sigma: Array,                  kernel_size: int = 10):         \"\"\"         Constructor for the ApplyJitter class.          Parameters         ----------         sigma : Array, pixels             The standard deviation of the Gaussian kernel, in units of pixels.         kernel_size : int = 10             The size of the convolution kernel to use.         \"\"\"         super().__init__()         self.kernel_size = int(kernel_size)         self.sigma = np.asarray(sigma, dtype=float)         if self.sigma.ndim != 0:             raise ValueError(\"sigma must be a scalar array.\")      def generate_kernel(self: DetectorLayer, pixel_scale: Array) -&gt; Array:         \"\"\"         Generates the normalised Gaussian kernel.          Returns         -------         kernel : Array             The Gaussian kernel.         \"\"\"         # Generate distribution         sigma = self.sigma * pixel_scale         x = np.linspace(-10, 10, self.kernel_size) * pixel_scale         kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)         return kernel / np.sum(kernel)      def __call__(self: DetectorLayer, image: Image()) -&gt; Image():         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         kernel = self.generate_kernel(image.pixel_scale)         return image.convolve(kernel) In\u00a0[\u00a0]: Copied! <pre>class ApplySaturation(DetectorLayer):\n\"\"\"\n    Applies a simple saturation model to the input image, by clipping any\n    values above saturation, to saturation.\n\n    Attributes\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    \"\"\"\n    saturation: Array\n\n    def __init__(self: DetectorLayer, saturation: Array) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplySaturation class.\n\n        Parameters\n        ----------\n        saturation : Array\n            The value at which the saturation is applied.\n        \"\"\"\n        super().__init__()\n        self.saturation = np.asarray(saturation, dtype=float)\n        if self.saturation.ndim != 0:\n            raise ValueError(\"saturation must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.min('image', self.saturation)\n</pre> class ApplySaturation(DetectorLayer):     \"\"\"     Applies a simple saturation model to the input image, by clipping any     values above saturation, to saturation.      Attributes     ----------     saturation : Array         The value at which the saturation is applied.     \"\"\"     saturation: Array      def __init__(self: DetectorLayer, saturation: Array) -&gt; DetectorLayer:         \"\"\"         Constructor for the ApplySaturation class.          Parameters         ----------         saturation : Array             The value at which the saturation is applied.         \"\"\"         super().__init__()         self.saturation = np.asarray(saturation, dtype=float)         if self.saturation.ndim != 0:             raise ValueError(\"saturation must be a scalar array.\")      def __call__(self: DetectorLayer, image: Image()) -&gt; Image():         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         return image.min('image', self.saturation) In\u00a0[\u00a0]: Copied! <pre>class AddConstant(DetectorLayer):\n\"\"\"\n    Add a constant to the output image. This is typically used to model the\n    mean value of the detector noise.\n\n    Attributes\n    ----------\n    value : Array\n        The value to add to the image.\n    \"\"\"\n    value: Array\n\n    def __init__(self: DetectorLayer, value: Array) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the AddConstant class.\n\n        Parameters\n        ----------\n        value : Array\n            The value to add to the image.\n        \"\"\"\n        super().__init__()\n        self.value = np.asarray(value, dtype=float)\n        if self.value.ndim != 0:\n            raise ValueError(\"value must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image + self.value\n</pre> class AddConstant(DetectorLayer):     \"\"\"     Add a constant to the output image. This is typically used to model the     mean value of the detector noise.      Attributes     ----------     value : Array         The value to add to the image.     \"\"\"     value: Array      def __init__(self: DetectorLayer, value: Array) -&gt; DetectorLayer:         \"\"\"         Constructor for the AddConstant class.          Parameters         ----------         value : Array             The value to add to the image.         \"\"\"         super().__init__()         self.value = np.asarray(value, dtype=float)         if self.value.ndim != 0:             raise ValueError(\"value must be a scalar array.\")      def __call__(self: DetectorLayer, image: Image()) -&gt; Image():         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         return image + self.value In\u00a0[\u00a0]: Copied! <pre>class IntegerDownsample(DetectorLayer):\n\"\"\"\n    Downsamples an input image by an integer number of pixels via a sum.\n    The number of pixels in the input image must be integer divisible by the\n    kernel_size.\n\n    Attributes\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    \"\"\"\n    kernel_size: int\n\n    def __init__(self: DetectorLayer, kernel_size: int) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the IntegerDownsample class.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the downsampling kernel.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n\n    def __call__(self, image):\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.downsample(self.kernel_size)\n</pre> class IntegerDownsample(DetectorLayer):     \"\"\"     Downsamples an input image by an integer number of pixels via a sum.     The number of pixels in the input image must be integer divisible by the     kernel_size.      Attributes     ----------     kernel_size : int         The size of the downsampling kernel.     \"\"\"     kernel_size: int      def __init__(self: DetectorLayer, kernel_size: int) -&gt; DetectorLayer:         \"\"\"         Constructor for the IntegerDownsample class.          Parameters         ----------         kernel_size : int             The size of the downsampling kernel.         \"\"\"         super().__init__()         self.kernel_size = int(kernel_size)      def __call__(self, image):         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         return image.downsample(self.kernel_size) In\u00a0[\u00a0]: Copied! <pre>class Rotate(DetectorLayer):\n\"\"\"\n    Applies a rotation to the image using interpolation methods.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the image in the clockwise direction.\n    order : int\n        The order of the interpolation.\n    \"\"\"\n    angle: Array\n    order: int\n\n    def __init__(self: DetectorLayer,\n                 angle: Array,\n                 order: int = 1):\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the image in the clockwise direction.\n        \"\"\"\n        super().__init__()\n        self.angle = np.asarray(angle, dtype=float)\n        self.order = int(order)\n        if self.angle.ndim != 0:\n            raise ValueError(\"angle must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.rotate(self.angle, self.order)\n</pre> class Rotate(DetectorLayer):     \"\"\"     Applies a rotation to the image using interpolation methods.      Parameters     ----------     angle : Array, radians         The angle by which to rotate the image in the clockwise direction.     order : int         The order of the interpolation.     \"\"\"     angle: Array     order: int      def __init__(self: DetectorLayer,                  angle: Array,                  order: int = 1):         \"\"\"         Constructor for the Rotate class.          Parameters         ----------         angle: float, radians             The angle by which to rotate the image in the clockwise direction.         \"\"\"         super().__init__()         self.angle = np.asarray(angle, dtype=float)         self.order = int(order)         if self.angle.ndim != 0:             raise ValueError(\"angle must be a scalar array.\")      def __call__(self: DetectorLayer, image: Image()) -&gt; Image():         \"\"\"         Applies the layer to the Image.          Parameters         ----------         image : Image             The image to operate on.          Returns         -------         image : Image             The transformed image.         \"\"\"         return image.rotate(self.angle, self.order)"},{"location":"dLux/detectors/","title":"Detectors","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nimport jax.numpy as np\nfrom jax import Array\nfrom zodiax import Base\nimport dLux.utils as dlu\nimport dLux\n</pre> from __future__ import annotations from abc import abstractmethod from collections import OrderedDict import jax.numpy as np from jax import Array from zodiax import Base import dLux.utils as dlu import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"LayeredDetector\"]\n</pre> __all__ = [\"LayeredDetector\"] In\u00a0[\u00a0]: Copied! <pre>DetectorLayer = lambda: dLux.detector_layers.DetectorLayer\n</pre> DetectorLayer = lambda: dLux.detector_layers.DetectorLayer In\u00a0[\u00a0]: Copied! <pre>class BaseDetector(Base):\n\n    @abstractmethod\n    def model(self, image):  # pragma: no cover\n        pass\n</pre> class BaseDetector(Base):      @abstractmethod     def model(self, image):  # pragma: no cover         pass In\u00a0[\u00a0]: Copied! <pre>class LayeredDetector(BaseDetector):\n\"\"\"\n    A high level class designed to model the behaviour of some detectors\n    response to some psf.\n\n    Attributes\n    ----------\n    layers: dict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input psf as it interacts with the detector.\n    \"\"\"\n    layers: OrderedDict\n\n    def __init__(self: Detector, layers: list):\n\"\"\"\n        Constructor for the Detector class.\n\n        Parameters\n        ----------\n        layers : list\n            An list of dLux detector layer classes that define the instrumental\n            effects for some detector.\n\n            A list of \u2202Lux 'layers' that define the transformations and\n            operations upon some input wavefront through an optical system.\n            The entries can either be dLux DetectorLayers, or tuples of the\n            form (DetectorLayer, key), with the key being used as the dictionary\n            key for the layer.\n        \"\"\"\n        self.layers = dlu.list_to_dictionary(layers, True, DetectorLayer())\n        super().__init__()\n\n    def __getattr__(self: Detector, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        else:\n            raise AttributeError(\"'{}' object has no attribute '{}'\"\n                                 .format(type(self), key))\n\n    def model(self: Detector, image: Array) -&gt; Array:\n\"\"\"\n        Applied the stored detector layers to the input image.\n\n        Parameters\n        ----------\n        image : Array\n            The input psf to be transformed.\n\n        Returns\n        -------\n        image : Array\n            The output 'image' after being transformed by the detector layers.\n        \"\"\"\n        for key, layer in self.layers.items():\n            image = layer(image)\n        return image.image\n</pre> class LayeredDetector(BaseDetector):     \"\"\"     A high level class designed to model the behaviour of some detectors     response to some psf.      Attributes     ----------     layers: dict         A collections.OrderedDict of 'layers' that define the transformations         and operations upon some input psf as it interacts with the detector.     \"\"\"     layers: OrderedDict      def __init__(self: Detector, layers: list):         \"\"\"         Constructor for the Detector class.          Parameters         ----------         layers : list             An list of dLux detector layer classes that define the instrumental             effects for some detector.              A list of \u2202Lux 'layers' that define the transformations and             operations upon some input wavefront through an optical system.             The entries can either be dLux DetectorLayers, or tuples of the             form (DetectorLayer, key), with the key being used as the dictionary             key for the layer.         \"\"\"         self.layers = dlu.list_to_dictionary(layers, True, DetectorLayer())         super().__init__()      def __getattr__(self: Detector, key: str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the layers dictionary of this class via the 'class.attribute' method.          Parameters         ----------         key : str             The key of the item to be searched for in the layers dictionary.          Returns         -------         item : object             The item corresponding to the supplied key in the layers dictionary.         \"\"\"         if key in self.layers.keys():             return self.layers[key]         else:             raise AttributeError(\"'{}' object has no attribute '{}'\"                                  .format(type(self), key))      def model(self: Detector, image: Array) -&gt; Array:         \"\"\"         Applied the stored detector layers to the input image.          Parameters         ----------         image : Array             The input psf to be transformed.          Returns         -------         image : Array             The output 'image' after being transformed by the detector layers.         \"\"\"         for key, layer in self.layers.items():             image = layer(image)         return image.image"},{"location":"dLux/images/","title":"Images","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax.scipy.signal import convolve\nfrom jax import Array\nfrom zodiax import Base\nimport dLux.utils as dlu\n</pre> from __future__ import annotations import jax.numpy as np from jax.scipy.signal import convolve from jax import Array from zodiax import Base import dLux.utils as dlu In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"Image\"]\n</pre> __all__ = [\"Image\"] In\u00a0[\u00a0]: Copied! <pre>class Image(Base):\n\"\"\"\n    A class representing some image as it is transformed by the detector. It\n    tracks the image via the `image` attribute, and the pixel scale via the\n    `pixel_scale` attribute.\n\n    Attributes\n    ----------\n    image : Array\n        The image as it is transformed by the detector.\n    pixel_scale : Array\n        The pixel scale of the image.\n    \"\"\"\n    image: Array\n    pixel_scale: Array\n\n    def __init__(self: Image, image: Array, pixel_scale: Array):\n\"\"\"\n        Parameters\n        ----------\n        image : Array\n            The image as it is transformed by the detector.\n        pixel_scale : Array\n            The pixel scale of the image.\n        \"\"\"\n        self.image = np.asarray(image, dtype=float)\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n\n    @property\n    def npixels(self: Image) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        image.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Image`.\n        \"\"\"\n        return self.image.shape[-1]\n\n    def downsample(self: Image, n: int) -&gt; Image:\n\"\"\"\n        Downsamples the image by a factor of n. This is done by summing the\n        image pixels in n x n blocks.\n\n        Parameters\n        ----------\n        n : int\n            The factor by which to downsample the image.\n        Returns\n        -------\n        image : Image\n            The downsampled image.\n        \"\"\"\n        downsampled = dlu.downsample(self.image, n, 'sum')\n        return self.set('image', downsampled)\n\n    def convolve(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Convolves the image with another image. This is done using the\n        `jax.scipy.signal.convolve` function.\n\n        Parameters\n        ----------\n        other : Array\n            The image to convolve with.\n        Returns\n        -------\n        image : Image\n            The convolved image.\n        \"\"\"\n        return self.set('image', convolve(self.image, other, mode='same'))\n\n    def rotate(self: Image, angle: float, order: int = 1) -&gt; Image:\n\"\"\"\n        Rotates the image by a given angle. This is done using interpolation\n        methods.\n\n        Parameters\n        ----------\n        angle : float\n            The angle by which to rotate the image.\n        order : int\n            The order of the interpolation method to use.\n        Returns\n        -------\n        image : Image\n            The rotated image.\n        \"\"\"\n        return self.set('image', dlu.rotate(self.image, angle, order=order))\n\n    def __mul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the multiplication operator. This allows for the\n        multiplication of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to multiply the image by.\n        Returns\n        -------\n        image : Image\n            The multiplied image.\n        \"\"\"\n        return self.multiply('image', other)\n\n    def __imul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace multiplication operator. This allows for\n        the inplace multiplication of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to multiply the image by.\n        Returns\n        -------\n        image : Image\n            The multiplied image.\n        \"\"\"\n        return self.__mul__(other)\n\n    def __add__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the addition operator. This allows for the addition of\n        the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to add to the image.\n        Returns\n        -------\n        image : Image\n            The added image.\n        \"\"\"\n        return self.add('image', other)\n\n    def __iadd__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace addition operator. This allows for the\n        inplace addition of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to add to the image.\n        Returns\n        -------\n        image : Image\n            The added image.\n        \"\"\"\n        return self.__add__(other)\n\n    def __sub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the subtraction operator. This allows for the\n        subtraction of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to subtract from the image.\n        Returns\n        -------\n        image : Image\n            The subtracted image.\n        \"\"\"\n        return self.add('image', -other)\n\n    def __isub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace subtraction operator. This allows for the\n        inplace subtraction of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to subtract from the image.\n        Returns\n        -------\n        image : Image\n            The subtracted image.\n        \"\"\"\n        return self.__sub__(other)\n\n    def __truediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the division operator. This allows for the division of\n        the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to divide the image by.\n        Returns\n        -------\n        image : Image\n            The divided image.\n        \"\"\"\n        return self.divide('image', other)\n\n    def __itruediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace division operator. This allows for the\n        inplace division of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to divide the image by.\n        Returns\n        -------\n        image : Image\n            The divided image.\n        \"\"\"\n        return self.__truediv__(other)\n</pre> class Image(Base):     \"\"\"     A class representing some image as it is transformed by the detector. It     tracks the image via the `image` attribute, and the pixel scale via the     `pixel_scale` attribute.      Attributes     ----------     image : Array         The image as it is transformed by the detector.     pixel_scale : Array         The pixel scale of the image.     \"\"\"     image: Array     pixel_scale: Array      def __init__(self: Image, image: Array, pixel_scale: Array):         \"\"\"         Parameters         ----------         image : Array             The image as it is transformed by the detector.         pixel_scale : Array             The pixel scale of the image.         \"\"\"         self.image = np.asarray(image, dtype=float)         self.pixel_scale = np.asarray(pixel_scale, dtype=float)      @property     def npixels(self: Image) -&gt; int:         \"\"\"         Returns the side length of the arrays currently representing the         image.          Returns         -------         pixels : int             The number of pixels that represent the `Image`.         \"\"\"         return self.image.shape[-1]      def downsample(self: Image, n: int) -&gt; Image:         \"\"\"         Downsamples the image by a factor of n. This is done by summing the         image pixels in n x n blocks.          Parameters         ----------         n : int             The factor by which to downsample the image.                  Returns         -------         image : Image             The downsampled image.         \"\"\"         downsampled = dlu.downsample(self.image, n, 'sum')         return self.set('image', downsampled)      def convolve(self: Image, other: Array) -&gt; Image:         \"\"\"         Convolves the image with another image. This is done using the         `jax.scipy.signal.convolve` function.          Parameters         ----------         other : Array             The image to convolve with.                  Returns         -------         image : Image             The convolved image.         \"\"\"         return self.set('image', convolve(self.image, other, mode='same'))      def rotate(self: Image, angle: float, order: int = 1) -&gt; Image:         \"\"\"         Rotates the image by a given angle. This is done using interpolation         methods.          Parameters         ----------         angle : float             The angle by which to rotate the image.         order : int             The order of the interpolation method to use.                  Returns         -------         image : Image             The rotated image.         \"\"\"         return self.set('image', dlu.rotate(self.image, angle, order=order))      def __mul__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the multiplication operator. This allows for the         multiplication of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to multiply the image by.                  Returns         -------         image : Image             The multiplied image.         \"\"\"         return self.multiply('image', other)      def __imul__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the inplace multiplication operator. This allows for         the inplace multiplication of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to multiply the image by.                  Returns         -------         image : Image             The multiplied image.         \"\"\"         return self.__mul__(other)      def __add__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the addition operator. This allows for the addition of         the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to add to the image.                  Returns         -------         image : Image             The added image.         \"\"\"         return self.add('image', other)      def __iadd__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the inplace addition operator. This allows for the         inplace addition of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to add to the image.                  Returns         -------         image : Image             The added image.         \"\"\"         return self.__add__(other)      def __sub__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the subtraction operator. This allows for the         subtraction of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to subtract from the image.                  Returns         -------         image : Image             The subtracted image.         \"\"\"         return self.add('image', -other)      def __isub__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the inplace subtraction operator. This allows for the         inplace subtraction of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to subtract from the image.                  Returns         -------         image : Image             The subtracted image.         \"\"\"         return self.__sub__(other)      def __truediv__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the division operator. This allows for the division of         the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to divide the image by.                  Returns         -------         image : Image             The divided image.         \"\"\"         return self.divide('image', other)      def __itruediv__(self: Image, other: Array) -&gt; Image:         \"\"\"         Magic method for the inplace division operator. This allows for the         inplace division of the image by a scalar or another image.          Parameters         ----------         other : Array             The scalar or image to divide the image by.                  Returns         -------         image : Image             The divided image.         \"\"\"         return self.__truediv__(other)"},{"location":"dLux/instruments/","title":"Instruments","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nimport jax.numpy as np\nfrom jax import Array\nfrom jax.tree_util import tree_map, tree_flatten\nfrom zodiax import Base\nfrom typing import Union\nimport dLux.utils as dlu\nimport dLux\n</pre> from __future__ import annotations from abc import abstractmethod import jax.numpy as np from jax import Array from jax.tree_util import tree_map, tree_flatten from zodiax import Base from typing import Union import dLux.utils as dlu import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"Instrument\"]\n</pre> __all__ = [\"Instrument\"] In\u00a0[\u00a0]: Copied! <pre># Alias classes for simplified type-checking\nOptics = lambda: dLux.optics.BaseOptics\nDetector = lambda: dLux.detectors.BaseDetector\nSource = lambda: dLux.sources.BaseSource\nObservation = lambda: dLux.observations.BaseObservation\nImage = lambda: dLux.images.Image\n</pre> # Alias classes for simplified type-checking Optics = lambda: dLux.optics.BaseOptics Detector = lambda: dLux.detectors.BaseDetector Source = lambda: dLux.sources.BaseSource Observation = lambda: dLux.observations.BaseObservation Image = lambda: dLux.images.Image In\u00a0[\u00a0]: Copied! <pre>class BaseInstrument(Base):\n\"\"\"\n    The Base Instrument class that all instrument classes inherit from. Can be\n    used to create your own instrument classes that will integrate seamlessly\n    with the rest of dLux.\n    \"\"\"\n\n    @abstractmethod\n    def model(self):  # pragma: no cover\n        pass\n</pre> class BaseInstrument(Base):     \"\"\"     The Base Instrument class that all instrument classes inherit from. Can be     used to create your own instrument classes that will integrate seamlessly     with the rest of dLux.     \"\"\"      @abstractmethod     def model(self):  # pragma: no cover         pass In\u00a0[\u00a0]: Copied! <pre>class Instrument(Base):\n\"\"\"\n    A high level class designed to model the behaviour of a telescope. It\n    stores a series different \u2202Lux objects, and primarily passes the relevant\n    information between these objects in order to coherently model some\n    telescope observation.\n\n    Attributes\n    ----------\n    optics : Optics\n        A Optics object that defines some optical configuration.\n    sources : dict\n        A dictionary of the various source objects that the instrument is\n        observing.\n    detector : Detector\n        A Detector object that is used to model the various\n        instrumental effects on a psf.\n    observation : Observation\n        An class that inherits from Observation. This is to allow flexibility\n        in the different kind of observations, i.e. applying dithers, switching\n        filters, etc.\n    \"\"\"\n    optics: Optics()\n    sources: dict\n    detector: Detector()\n    observation: Observation()\n\n    def __init__(self: Instrument,\n                 optics: Optics(),\n                 sources: Union[list, Source()],\n                 detector: Detector() = None,\n                 observation: Observation = None,\n                 ):\n\"\"\"\n        Constructor for the Instrument class.\n\n        Parameters\n        ----------\n        optics : Optics\n            A pre-configured Optics object.\n        sources : Union[list, Source]\n            Either a list of sources or an individual Source object.\n        detector : Detector = None\n            A pre-configured Detector object.\n        observation : Observation = None\n            An class that inherits from Observation. This is to allow\n            flexibility in the different kind of observations, i.e. applying\n            dithers, switching filters, etc.\n        \"\"\"\n        # Optics\n        if not isinstance(optics, Optics()):\n            raise TypeError(\"optics must be an Optics object.\")\n        self.optics = optics\n\n        # Sources\n        if isinstance(sources, (Source(), tuple)):\n            sources = [sources]\n        self.sources = dlu.list_to_dictionary(sources, False, Source())\n\n        # Detector\n        if not isinstance(detector, Detector()) and detector is not None:\n            raise TypeError(\"detector must be an Detector object. \"\n                            f\"Got type {type(detector)}\")\n        self.detector = detector\n\n        # Observation\n        if (not isinstance(observation, Observation()) and\n                observation is not None):\n            raise TypeError(\"observation must be an Observation object.\")\n        self.observation = observation\n\n    def observe(self: Instrument) -&gt; Any:\n\"\"\"\n        Calls the `observe` method of the stored observation class, passing in\n        any extra keyword arguments.\n\n        Returns\n        -------\n         : Any\n            The output of the stored observation class.\n        \"\"\"\n        return self.observation.model(self)\n\n    def __getattr__(self: Instrument, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the sub-dictionaries of this class via the 'class.attribute' method.\n        It is recommended that each dictionary key in the optical layers,\n        detector layers, and scene sources are unique to prevent unexpected\n        behaviour. In the case they there are identical keys across the\n        dictionaries This method prioritises searching for keys in the optical\n        layers, then detector layers, and then the scene sources.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the sub-dictionaries.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the sub-dictionaries.\n        \"\"\"\n        for attribute in self.__dict__.values():\n            if hasattr(attribute, key):\n                return getattr(attribute, key)\n        if key in self.sources.keys():\n            return self.sources[key]\n        for source in self.sources.values():\n            if hasattr(source, key):\n                return getattr(source, key)\n        raise AttributeError(f\"{self.__class__.__name__} has no attribute \"\n                             f\"{key}.\")\n\n    def normalise(self: Instrument) -&gt; Instrument:\n\"\"\"\n        Method for returning a new instrument with normalised source objects.\n\n        Returns\n        -------\n        instrument : Instrument\n            The normalised instrument object.\n        \"\"\"\n        is_source = lambda leaf: isinstance(leaf, Source())\n        norm_fn = lambda source: source.normalise()\n        sources = tree_map(norm_fn, self.sources, is_leaf=is_source)\n        return self.set('sources', sources)\n\n    def model(self: Instrument) -&gt; Union[Array, dict]:\n\"\"\"\n        A base level modelling function designed to robustly handle the\n        different combinations of inputs. Models the sources through the\n        instrument optics and detector.\n\n        Returns\n        -------\n        image : Array, dict\n            The image of the scene modelled through the optics with detector and\n            filter effects applied if they are supplied. Returns either as a\n            single array (if return_tree is false), or a dict of the output for\n            each source.\n        \"\"\"\n        psf = self.optics.model(list(self.sources.values()))\n        image = Image()(psf, self.optics.true_pixel_scale)\n        image = self.detector.model(image) if self.detector is not None else psf\n        return np.array(tree_flatten(image)[0]).sum(0)\n</pre> class Instrument(Base):     \"\"\"     A high level class designed to model the behaviour of a telescope. It     stores a series different \u2202Lux objects, and primarily passes the relevant     information between these objects in order to coherently model some     telescope observation.      Attributes     ----------     optics : Optics         A Optics object that defines some optical configuration.     sources : dict         A dictionary of the various source objects that the instrument is         observing.     detector : Detector         A Detector object that is used to model the various         instrumental effects on a psf.     observation : Observation         An class that inherits from Observation. This is to allow flexibility         in the different kind of observations, i.e. applying dithers, switching         filters, etc.     \"\"\"     optics: Optics()     sources: dict     detector: Detector()     observation: Observation()      def __init__(self: Instrument,                  optics: Optics(),                  sources: Union[list, Source()],                  detector: Detector() = None,                  observation: Observation = None,                  ):         \"\"\"         Constructor for the Instrument class.          Parameters         ----------         optics : Optics             A pre-configured Optics object.         sources : Union[list, Source]             Either a list of sources or an individual Source object.         detector : Detector = None             A pre-configured Detector object.         observation : Observation = None             An class that inherits from Observation. This is to allow             flexibility in the different kind of observations, i.e. applying             dithers, switching filters, etc.         \"\"\"         # Optics         if not isinstance(optics, Optics()):             raise TypeError(\"optics must be an Optics object.\")         self.optics = optics          # Sources         if isinstance(sources, (Source(), tuple)):             sources = [sources]         self.sources = dlu.list_to_dictionary(sources, False, Source())          # Detector         if not isinstance(detector, Detector()) and detector is not None:             raise TypeError(\"detector must be an Detector object. \"                             f\"Got type {type(detector)}\")         self.detector = detector          # Observation         if (not isinstance(observation, Observation()) and                 observation is not None):             raise TypeError(\"observation must be an Observation object.\")         self.observation = observation      def observe(self: Instrument) -&gt; Any:         \"\"\"         Calls the `observe` method of the stored observation class, passing in         any extra keyword arguments.          Returns         -------          : Any             The output of the stored observation class.         \"\"\"         return self.observation.model(self)      def __getattr__(self: Instrument, key: str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the sub-dictionaries of this class via the 'class.attribute' method.         It is recommended that each dictionary key in the optical layers,         detector layers, and scene sources are unique to prevent unexpected         behaviour. In the case they there are identical keys across the         dictionaries This method prioritises searching for keys in the optical         layers, then detector layers, and then the scene sources.          Parameters         ----------         key : str             The key of the item to be searched for in the sub-dictionaries.          Returns         -------         item : object             The item corresponding to the supplied key in the sub-dictionaries.         \"\"\"         for attribute in self.__dict__.values():             if hasattr(attribute, key):                 return getattr(attribute, key)         if key in self.sources.keys():             return self.sources[key]         for source in self.sources.values():             if hasattr(source, key):                 return getattr(source, key)         raise AttributeError(f\"{self.__class__.__name__} has no attribute \"                              f\"{key}.\")      def normalise(self: Instrument) -&gt; Instrument:         \"\"\"         Method for returning a new instrument with normalised source objects.          Returns         -------         instrument : Instrument             The normalised instrument object.         \"\"\"         is_source = lambda leaf: isinstance(leaf, Source())         norm_fn = lambda source: source.normalise()         sources = tree_map(norm_fn, self.sources, is_leaf=is_source)         return self.set('sources', sources)      def model(self: Instrument) -&gt; Union[Array, dict]:         \"\"\"         A base level modelling function designed to robustly handle the         different combinations of inputs. Models the sources through the         instrument optics and detector.          Returns         -------         image : Array, dict             The image of the scene modelled through the optics with detector and             filter effects applied if they are supplied. Returns either as a             single array (if return_tree is false), or a dict of the output for             each source.         \"\"\"         psf = self.optics.model(list(self.sources.values()))         image = Image()(psf, self.optics.true_pixel_scale)         image = self.detector.model(image) if self.detector is not None else psf         return np.array(tree_flatten(image)[0]).sum(0)"},{"location":"dLux/observations/","title":"Observations","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nfrom zodiax import Base\nfrom jax.tree_util import tree_map\nimport jax.numpy as np\nfrom jax import vmap, Array\nfrom equinox import tree_at\nimport dLux\n</pre> from __future__ import annotations from abc import abstractmethod from zodiax import Base from jax.tree_util import tree_map import jax.numpy as np from jax import vmap, Array from equinox import tree_at import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"Dither\"]\n</pre> __all__ = [\"Dither\"] In\u00a0[\u00a0]: Copied! <pre>Instrument = lambda: dLux.core.BaseInstrument\n</pre> Instrument = lambda: dLux.core.BaseInstrument In\u00a0[\u00a0]: Copied! <pre>class BaseObservation(Base):\n\"\"\"\n    Abstract base class for observations. All observations should inherit from\n    this class and must implement an `.model()` method that only takes in a\n    single instance of `dLux.Instrument`.\n    \"\"\"\n\n    @abstractmethod\n    def model(self: BaseObservation,\n              instrument: Instrument()):  # pragma: no cover\n\"\"\"\n        Abstract method for the observation function.\n        \"\"\"\n</pre> class BaseObservation(Base):     \"\"\"     Abstract base class for observations. All observations should inherit from     this class and must implement an `.model()` method that only takes in a     single instance of `dLux.Instrument`.     \"\"\"      @abstractmethod     def model(self: BaseObservation,               instrument: Instrument()):  # pragma: no cover         \"\"\"         Abstract method for the observation function.         \"\"\" In\u00a0[\u00a0]: Copied! <pre>class Dither(BaseObservation):\n\"\"\"\n    Observation class designed to apply a series of dithers to the instrument\n    and return the corresponding PSFs.\n\n    Attributes\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2) where ndithers is the number of dithers\n        and the second dimension is the (x, y) dither in radians.\n    \"\"\"\n    dithers: Array\n\n    def __init__(self: Dither, dithers: Array):\n\"\"\"\n        Constructor for the Dither class.\n\n        Parameters\n        ----------\n        dithers : Array, (radians)\n            The array of dithers to apply to the source positions. The shape of\n            the array should be (ndithers, 2) where ndithers is the number of\n            dithers and the second dimension is the (x, y) dither in radians.\n        \"\"\"\n        super().__init__()\n        self.dithers = np.asarray(dithers, float)\n        if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:\n            raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")\n\n    def dither_position(self: Dither,\n                        instrument: Instrument,\n                        dither: Array) -&gt; Instrument:\n\"\"\"\n        Dithers the position of the source objects by dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The instrument to dither.\n        dither : Array, radians\n            The (x, y) dither to apply to the source positions.\n\n        Returns\n        -------\n        instrument : Instrument\n            The instrument with the sources dithered.\n        \"\"\"\n        # Define the dither function\n        dither_fn = lambda source: source.add('position', dither)\n\n        # Map the dithers across the sources\n        dithered_sources = tree_map(dither_fn, instrument.sources, \\\n                                    is_leaf=lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n        # Apply updates\n        return tree_at(lambda instrument: instrument.sources, instrument,\n                       dithered_sources)\n\n    def model(self: Dither,\n              instrument: Instrument,\n              *args, **kwargs) -&gt; Array:\n\"\"\"\n        Applies a series of dithers to the instrument sources and calls the\n        .model() method after applying each dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The array of dithers to apply to the source positions.\n\n        Returns\n        -------\n        psfs : Array\n            The psfs generated after applying the dithers to the source\n            positions.\n        \"\"\"\n        dith_fn = lambda dither: self.dither_position(instrument,\n                                                      dither).model(*args, **kwargs)\n        return vmap(dith_fn, 0)(self.dithers)\n</pre> class Dither(BaseObservation):     \"\"\"     Observation class designed to apply a series of dithers to the instrument     and return the corresponding PSFs.      Attributes     ----------     dithers : Array, (radians)         The array of dithers to apply to the source positions. The shape of the         array should be (ndithers, 2) where ndithers is the number of dithers         and the second dimension is the (x, y) dither in radians.     \"\"\"     dithers: Array      def __init__(self: Dither, dithers: Array):         \"\"\"         Constructor for the Dither class.          Parameters         ----------         dithers : Array, (radians)             The array of dithers to apply to the source positions. The shape of             the array should be (ndithers, 2) where ndithers is the number of             dithers and the second dimension is the (x, y) dither in radians.         \"\"\"         super().__init__()         self.dithers = np.asarray(dithers, float)         if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:             raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")      def dither_position(self: Dither,                         instrument: Instrument,                         dither: Array) -&gt; Instrument:         \"\"\"         Dithers the position of the source objects by dither.          Parameters         ----------         instrument : Instrument             The instrument to dither.         dither : Array, radians             The (x, y) dither to apply to the source positions.          Returns         -------         instrument : Instrument             The instrument with the sources dithered.         \"\"\"         # Define the dither function         dither_fn = lambda source: source.add('position', dither)          # Map the dithers across the sources         dithered_sources = tree_map(dither_fn, instrument.sources, \\                                     is_leaf=lambda leaf: isinstance(leaf, dLux.sources.Source))          # Apply updates         return tree_at(lambda instrument: instrument.sources, instrument,                        dithered_sources)      def model(self: Dither,               instrument: Instrument,               *args, **kwargs) -&gt; Array:         \"\"\"         Applies a series of dithers to the instrument sources and calls the         .model() method after applying each dither.          Parameters         ----------         instrument : Instrument             The array of dithers to apply to the source positions.          Returns         -------         psfs : Array             The psfs generated after applying the dithers to the source             positions.         \"\"\"         dith_fn = lambda dither: self.dither_position(instrument,                                                       dither).model(*args, **kwargs)         return vmap(dith_fn, 0)(self.dithers)"},{"location":"dLux/optical_layers/","title":"Optical layers","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nimport jax.numpy as np\nfrom jax import Array\nfrom zodiax import Base\n\n__all__ = [\n\n    # OpticalLayer\n    # TransmissiveLayer\n    # AberratedLayer\n    # ShapedLayer\n\n    # BaseTransmissiveOptic\n    # BaseOPDOptic\n    # BasePhaseOptic\n    # BaseBasisOptic\n\n    \"Optic\",\n    \"PhaseOptic\",\n    \"BasisOptic\",\n    \"PhaseBasisOptic\",\n    \"Tilt\",\n    \"Normalise\",\n    \"Rotate\"]\n\n\nclass OpticalLayer(Base):\n\"\"\"\n    Base class for optical layers. Primarily used for input type checking.\n\n    Child classes must implement the __call__ method that takes in the wavefront\n    as the first parameter\n\n    Note: I have chosen __call__ over apply as the method name for the layer \n    to be applied to the wavefront. This is because even though it prevents\n    the simple interface with optax (not having to wrap in a list), because\n    wavefront should in general not be able to be an object you take a gradient\n    with respect to, it is just a latent class to store information throughout\n    the calculation, plus its use of strings as a way to track parameters can\n    make interactions with jax difficult.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self: OpticalLayer,\n                 wavefront: Wavefront) -&gt; Wavefront:  # pragma: no cover\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n\n\nclass TransmissiveLayer(OpticalLayer):\n\"\"\"\n    Base class to hold transmissive layers imbuing them with a normalise \n    parameter.\n    \"\"\"\n    normalise: bool\n\n    def __init__(self: OpticalLayer,\n                 normalise: bool = False,\n                 **kwargs):\n\"\"\"\n        Parameters\n        ----------\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        self.normalise = bool(normalise)\n        super().__init__(**kwargs)\n\n\nclass AberratedLayer(OpticalLayer):\n\"\"\"\n    Base class for aberration layers. Primarily used for input type checking.\n    \"\"\"\n\n\nclass ShapedLayer(OpticalLayer):\n\"\"\"\n    Base class used for layers that have a specified output shape.\n    \"\"\"\n\n    @abstractmethod\n    def applied_shape(self: OpticalLayer) -&gt; int:\n\"\"\"\n        Returns the 'shape' of the layer, more specifically the required \n        matching shape of the wavefront to be applied to.\n\n        Returns\n        -------\n        shape : int\n            The linear shape of the wavefront to be applied to.\n        \"\"\"\n\n\nclass BasisLayer(OpticalLayer):\n\"\"\"\n    This class primarily exists to allow for the use of the class based basis\n    used for dynamic aberrated apertures.\n\n    Attributes\n    ----------\n    basis: Union[Array, list]\n        The basis to use. Can be an array of a list of aberrations classes.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n    basis: Union[Array, list]\n    coefficients: Array\n\n    def __init__(self: OpticalLayer,\n                 basis: Array = None,\n                 coefficients: Array = None,\n                 **kwargs) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        basis: Union[Array, list]\n            The basis to use. Can be an array of a list of aberrations classes.\n        coefficients: Array\n            The Array of coefficients to be applied to each basis vector.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        self.basis = np.asarray(basis, dtype=float)\n        if coefficients is None:\n            self.coefficients = np.zeros(self.basis.shape[:-2])\n        else:\n            self.coefficients = np.asarray(coefficients, dtype=float)\n            if self.basis.shape[:-2] != self.coefficients.shape:\n                raise ValueError(\"The number of basis vectors must be equal to \"\n                                 \"the number of coefficients.\")\n\n    def calculate(self: OpticalLayer,\n                  basis: Array,\n                  coefficients: Array) -&gt; Array:\n\"\"\"\n        Performs an n-dimensional dot-product between the basis and coefficients\n        arrays.\n\n        Parameters\n        ----------\n        basis: Array\n            The basis to use.\n        coefficients: Array\n            The Array of coefficients to be applied to each basis vector.\n        \"\"\"\n        ndim = coefficients.ndim\n        axes = (tuple(range(ndim)), tuple(range(ndim)))\n        return np.tensordot(basis, coefficients, axes=axes)\n\n\n######### Optics #########\nclass BaseTransmissiveOptic(TransmissiveLayer, ShapedLayer):\n\"\"\"\n    Base class for transmissive optics. Implements the transmission attribute\n    and the `applied_shape` method.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    \"\"\"\n    transmission: Array\n\n    def __init__(self: OpticalLayer,\n                 transmission: Array,\n                 **kwargs) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        transmission: Array\n            The Array of transmission values to be applied to the input\n            wavefront.\n        \"\"\"\n        if transmission is not None:\n            transmission = np.asarray(transmission, dtype=float)\n        self.transmission = transmission\n        super().__init__(**kwargs)\n\n    @property\n    def applied_shape(self: OpticalLayer) -&gt; int:\n\"\"\"\n        Returns the 'shape' of the layer, more specifically the required \n        matching shape of the wavefront to be applied to.\n\n        Returns\n        -------\n        shape : int\n            The linear shape of the wavefront to be applied to.\n        \"\"\"\n        return self.transmission.shape\n\n\nclass BaseOPDOptic(AberratedLayer, ShapedLayer):\n\"\"\"\n    Base class for OPD optics. Implements the opd attribute.\n\n    Attributes\n    ----------\n    opd : Array, metres\n        The Array of OPD values to be applied to the input wavefront.\n    \"\"\"\n    opd: Array\n\n    def __init__(self: OpticalLayer, opd: Array, **kwargs) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        opd : Array, metres\n            The Array of OPD values to be applied to the input wavefront.\n        \"\"\"\n        if opd is not None:\n            opd = np.asarray(opd, dtype=float)\n        self.opd = opd\n        super().__init__(**kwargs)\n\n\nclass BasePhaseOptic(AberratedLayer, ShapedLayer):\n\"\"\"\n    Base class for phase optics. Implements the phase attribute.\n\n    Attributes\n    ----------\n    phase : Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    \"\"\"\n    phase: Array\n\n    def __init__(self: OpticalLayer, phase: Array, **kwargs) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        phase : Array, radians\n            The Array of phase values to be applied to the input wavefront.\n        \"\"\"\n        if phase is not None:\n            phase = np.asarray(phase, dtype=float)\n        self.phase = phase\n        super().__init__(**kwargs)\n\n\nclass BaseBasisOptic(BaseTransmissiveOptic, BasisLayer, ShapedLayer):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n\n    def __init__(self: OpticalLayer,\n                 basis: Array,\n                 transmission: Array = None,\n                 coefficients: Array = None,\n                 normalise: bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        basis: Array, metres\n            Arrays holding the pre-calculated basis vectors.\n        transmission: Array = None\n            The Array of transmission values to be applied to the input\n            wavefront.\n        coefficients: Array = None\n            The Array of coefficients to be applied to each basis vector.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the\n        \"\"\"\n        super().__init__(transmission=transmission, basis=basis,\n                         coefficients=coefficients, normalise=normalise)\n\n    @property\n    def applied_shape(self: OpticalLayer) -&gt; int:\n\"\"\"\n        Returns the 'shape' of the layer, more specifically the required\n        matching shape of the wavefront to be applied to.\n\n        Returns\n        -------\n        shape : int\n            The linear shape of the wavefront to be applied to.\n        \"\"\"\n        return self.basis.shape[-2:]\n</pre> from __future__ import annotations from abc import abstractmethod import jax.numpy as np from jax import Array from zodiax import Base  __all__ = [      # OpticalLayer     # TransmissiveLayer     # AberratedLayer     # ShapedLayer      # BaseTransmissiveOptic     # BaseOPDOptic     # BasePhaseOptic     # BaseBasisOptic      \"Optic\",     \"PhaseOptic\",     \"BasisOptic\",     \"PhaseBasisOptic\",     \"Tilt\",     \"Normalise\",     \"Rotate\"]   class OpticalLayer(Base):     \"\"\"     Base class for optical layers. Primarily used for input type checking.      Child classes must implement the __call__ method that takes in the wavefront     as the first parameter      Note: I have chosen __call__ over apply as the method name for the layer      to be applied to the wavefront. This is because even though it prevents     the simple interface with optax (not having to wrap in a list), because     wavefront should in general not be able to be an object you take a gradient     with respect to, it is just a latent class to store information throughout     the calculation, plus its use of strings as a way to track parameters can     make interactions with jax difficult.     \"\"\"      @abstractmethod     def __call__(self: OpticalLayer,                  wavefront: Wavefront) -&gt; Wavefront:  # pragma: no cover         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"   class TransmissiveLayer(OpticalLayer):     \"\"\"     Base class to hold transmissive layers imbuing them with a normalise      parameter.     \"\"\"     normalise: bool      def __init__(self: OpticalLayer,                  normalise: bool = False,                  **kwargs):         \"\"\"         Parameters         ----------         normalise : bool = False             Whether to normalise the wavefront after passing through the             aperture.         \"\"\"         self.normalise = bool(normalise)         super().__init__(**kwargs)   class AberratedLayer(OpticalLayer):     \"\"\"     Base class for aberration layers. Primarily used for input type checking.     \"\"\"   class ShapedLayer(OpticalLayer):     \"\"\"     Base class used for layers that have a specified output shape.     \"\"\"      @abstractmethod     def applied_shape(self: OpticalLayer) -&gt; int:         \"\"\"         Returns the 'shape' of the layer, more specifically the required          matching shape of the wavefront to be applied to.          Returns         -------         shape : int             The linear shape of the wavefront to be applied to.         \"\"\"   class BasisLayer(OpticalLayer):     \"\"\"     This class primarily exists to allow for the use of the class based basis     used for dynamic aberrated apertures.      Attributes     ----------     basis: Union[Array, list]         The basis to use. Can be an array of a list of aberrations classes.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     \"\"\"     basis: Union[Array, list]     coefficients: Array      def __init__(self: OpticalLayer,                  basis: Array = None,                  coefficients: Array = None,                  **kwargs) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         basis: Union[Array, list]             The basis to use. Can be an array of a list of aberrations classes.         coefficients: Array             The Array of coefficients to be applied to each basis vector.         \"\"\"         super().__init__(**kwargs)          self.basis = np.asarray(basis, dtype=float)         if coefficients is None:             self.coefficients = np.zeros(self.basis.shape[:-2])         else:             self.coefficients = np.asarray(coefficients, dtype=float)             if self.basis.shape[:-2] != self.coefficients.shape:                 raise ValueError(\"The number of basis vectors must be equal to \"                                  \"the number of coefficients.\")      def calculate(self: OpticalLayer,                   basis: Array,                   coefficients: Array) -&gt; Array:         \"\"\"         Performs an n-dimensional dot-product between the basis and coefficients         arrays.          Parameters         ----------         basis: Array             The basis to use.         coefficients: Array             The Array of coefficients to be applied to each basis vector.         \"\"\"         ndim = coefficients.ndim         axes = (tuple(range(ndim)), tuple(range(ndim)))         return np.tensordot(basis, coefficients, axes=axes)   ######### Optics ######### class BaseTransmissiveOptic(TransmissiveLayer, ShapedLayer):     \"\"\"     Base class for transmissive optics. Implements the transmission attribute     and the `applied_shape` method.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     \"\"\"     transmission: Array      def __init__(self: OpticalLayer,                  transmission: Array,                  **kwargs) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         transmission: Array             The Array of transmission values to be applied to the input             wavefront.         \"\"\"         if transmission is not None:             transmission = np.asarray(transmission, dtype=float)         self.transmission = transmission         super().__init__(**kwargs)      @property     def applied_shape(self: OpticalLayer) -&gt; int:         \"\"\"         Returns the 'shape' of the layer, more specifically the required          matching shape of the wavefront to be applied to.          Returns         -------         shape : int             The linear shape of the wavefront to be applied to.         \"\"\"         return self.transmission.shape   class BaseOPDOptic(AberratedLayer, ShapedLayer):     \"\"\"     Base class for OPD optics. Implements the opd attribute.      Attributes     ----------     opd : Array, metres         The Array of OPD values to be applied to the input wavefront.     \"\"\"     opd: Array      def __init__(self: OpticalLayer, opd: Array, **kwargs) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         opd : Array, metres             The Array of OPD values to be applied to the input wavefront.         \"\"\"         if opd is not None:             opd = np.asarray(opd, dtype=float)         self.opd = opd         super().__init__(**kwargs)   class BasePhaseOptic(AberratedLayer, ShapedLayer):     \"\"\"     Base class for phase optics. Implements the phase attribute.      Attributes     ----------     phase : Array, radians         The Array of phase values to be applied to the input wavefront.     \"\"\"     phase: Array      def __init__(self: OpticalLayer, phase: Array, **kwargs) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         phase : Array, radians             The Array of phase values to be applied to the input wavefront.         \"\"\"         if phase is not None:             phase = np.asarray(phase, dtype=float)         self.phase = phase         super().__init__(**kwargs)   class BaseBasisOptic(BaseTransmissiveOptic, BasisLayer, ShapedLayer):     \"\"\"     Adds an array of phase values to the input wavefront calculated from the     Optical Path Difference (OPD). The OPDs are calculated from the basis     arrays, and weighted by the coefficients, and converted to phases by the     wavefront methods.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     basis: Array, metres         Arrays holding the pre-calculated basis vectors.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     normalise: bool         Whether to normalise the wavefront after passing through the         optic.     \"\"\"      def __init__(self: OpticalLayer,                  basis: Array,                  transmission: Array = None,                  coefficients: Array = None,                  normalise: bool = False) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         basis: Array, metres             Arrays holding the pre-calculated basis vectors.         transmission: Array = None             The Array of transmission values to be applied to the input             wavefront.         coefficients: Array = None             The Array of coefficients to be applied to each basis vector.         normalise: bool = False             Whether to normalise the wavefront after passing through the         \"\"\"         super().__init__(transmission=transmission, basis=basis,                          coefficients=coefficients, normalise=normalise)      @property     def applied_shape(self: OpticalLayer) -&gt; int:         \"\"\"         Returns the 'shape' of the layer, more specifically the required         matching shape of the wavefront to be applied to.          Returns         -------         shape : int             The linear shape of the wavefront to be applied to.         \"\"\"         return self.basis.shape[-2:]  In\u00a0[\u00a0]: Copied! <pre>class Optic(BaseTransmissiveOptic, BaseOPDOptic):\n\"\"\"\n    Optics class that holds both a transmission and OPD array.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    opd : Array, metres\n        The Array of OPD values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n\n    def __init__(self: OpticalLayer,\n                 transmission: Array = None,\n                 opd: Array = None,\n                 normalise: bool = False):\n\"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The Array of transmission values to be applied to the input\n            wavefront.\n        opd : Array, metres = None\n            The Array of OPD values to be applied to the input wavefront.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the\n            optic.\n        \"\"\"\n        super().__init__(transmission=transmission, opd=opd,\n                         normalise=normalise)\n\n        if self.opd is not None and self.transmission is not None:\n            if opd.shape != self.transmission.shape:\n                raise ValueError(\"opd and transmission must have the same \"\n                                 \"shape.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront += self.opd\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n\nclass BasisOptic(BaseBasisOptic):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n\n    @property\n    def opd(self: OpticalLayer) -&gt; Array:\n\"\"\"\n        Calculates the total opd from the basis vectors and coefficients.\n\n        Returns\n        -------\n        opd : Array, metres\n            The total opd.\n        \"\"\"\n        return self.calculate(self.basis, self.coefficients)\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront += self.opd\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n\nclass PhaseOptic(BaseTransmissiveOptic, BasePhaseOptic):\n\"\"\"\n    Optics class that holds both a transmission and phase array.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    phase : Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n\n    def __init__(self: OpticalLayer,\n                 transmission: Array = None,\n                 phase: Array = None,\n                 normalise: bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The Array of transmission values to be applied to the input\n            wavefront.\n        phase : Array, radians = None\n            The Array of phase values to be applied to the input wavefront.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the\n            optic.\n        \"\"\"\n        super().__init__(transmission=transmission, phase=phase,\n                         normalise=normalise)\n\n        if self.phase is not None and self.transmission is not None:\n            if phase.shape != self.transmission.shape:\n                raise ValueError(\"phase and transmission must have the same \"\n                                 \"shape.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront = wavefront.add_phase(self.phase)\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n\nclass PhaseBasisOptic(BaseBasisOptic):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n\n    @property\n    def phase(self: OpticalLayer) -&gt; Array:\n\"\"\"\n        Calculates the total phase from the basis vectors and coefficients.\n\n        Returns\n        -------\n        phase : Array, radians\n            The total phase.\n        \"\"\"\n        return self.calculate(self.basis, self.coefficients)\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront = wavefront.add_phase(self.phase)\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n\nclass Tilt(OpticalLayer):\n\"\"\"\n    Tilts the wavefront by the input angles.\n\n    Attributes\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    \"\"\"\n    angles: Array\n\n    def __init__(self: OpticalLayer, angles: Array) -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TiltWavefront class.\n\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n        \"\"\"\n        super().__init__()\n        self.angles = np.asarray(angles, dtype=float)\n\n        if self.angles.shape != (2,):\n            raise ValueError(\"angles must have have (2,)\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.tilt(self.angles)\n\n\nclass Normalise(OpticalLayer):\n\"\"\"Normalises the wavefront.\"\"\"\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.normalise()\n\n\nclass Rotate(OpticalLayer):\n\"\"\"\n    Applies a rotation to the wavefront using interpolation methods.\n\n    Attributes\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in the clockwise direction.\n    order : int = 1\n        The order of the interpolation to use. Only applies if fourier is\n        False. Must be 0, 1, or 3.\n    complex : bool = False\n        Should the rotation be performed on the 'complex' (real, imaginary),\n        as opposed to the default 'phasor' (amplitude, phase) arrays.\n    \"\"\"\n    angle: Array\n    order: int\n    complex: bool\n\n    def __init__(self: OpticalLayer,\n                 angle: Array,\n                 order: int = 1,\n                 complex: bool = False):\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the wavefront in the clockwise \n            direction.\n        order : int = 1\n            The order of the interpolation to use. Must be 0, or 1.\n        complex : bool = False\n            Should the rotation be performed on the 'complex' (real, imaginary),\n            as opposed to the default 'phasor' (amplitude, phase) arrays.\n        \"\"\"\n        super().__init__()\n        self.angle = np.asarray(angle, dtype=float)\n        self.order = int(order)\n        self.complex = bool(complex)\n\n        if self.order not in (0, 1):\n            raise ValueError(\"Order must be 0, 1\")\n        if self.angle.ndim != 0:\n            raise ValueError(f\"angle must be a zero-dimensional, has \"\n                             f\"{self.angle.ndim} dimensions.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.rotate(self.angle, self.order, self.complex)\n</pre> class Optic(BaseTransmissiveOptic, BaseOPDOptic):     \"\"\"     Optics class that holds both a transmission and OPD array.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     opd : Array, metres         The Array of OPD values to be applied to the input wavefront.     normalise: bool         Whether to normalise the wavefront after passing through the         optic.     \"\"\"      def __init__(self: OpticalLayer,                  transmission: Array = None,                  opd: Array = None,                  normalise: bool = False):         \"\"\"         Parameters         ----------         transmission: Array = None             The Array of transmission values to be applied to the input             wavefront.         opd : Array, metres = None             The Array of OPD values to be applied to the input wavefront.         normalise: bool = False             Whether to normalise the wavefront after passing through the             optic.         \"\"\"         super().__init__(transmission=transmission, opd=opd,                          normalise=normalise)          if self.opd is not None and self.transmission is not None:             if opd.shape != self.transmission.shape:                 raise ValueError(\"opd and transmission must have the same \"                                  \"shape.\")      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         wavefront *= self.transmission         wavefront += self.opd         if self.normalise:             wavefront = wavefront.normalise()         return wavefront   class BasisOptic(BaseBasisOptic):     \"\"\"     Adds an array of phase values to the input wavefront calculated from the     Optical Path Difference (OPD). The OPDs are calculated from the basis     arrays, and weighted by the coefficients, and converted to phases by the     wavefront methods.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     basis: Array, metres         Arrays holding the pre-calculated basis vectors.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     \"\"\"      @property     def opd(self: OpticalLayer) -&gt; Array:         \"\"\"         Calculates the total opd from the basis vectors and coefficients.          Returns         -------         opd : Array, metres             The total opd.         \"\"\"         return self.calculate(self.basis, self.coefficients)      def __call__(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         wavefront *= self.transmission         wavefront += self.opd         if self.normalise:             wavefront = wavefront.normalise()         return wavefront   class PhaseOptic(BaseTransmissiveOptic, BasePhaseOptic):     \"\"\"     Optics class that holds both a transmission and phase array.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     phase : Array, radians         The Array of phase values to be applied to the input wavefront.     normalise: bool         Whether to normalise the wavefront after passing through the         optic.     \"\"\"      def __init__(self: OpticalLayer,                  transmission: Array = None,                  phase: Array = None,                  normalise: bool = False) -&gt; OpticalLayer:         \"\"\"         Parameters         ----------         transmission: Array = None             The Array of transmission values to be applied to the input             wavefront.         phase : Array, radians = None             The Array of phase values to be applied to the input wavefront.         normalise: bool = False             Whether to normalise the wavefront after passing through the             optic.         \"\"\"         super().__init__(transmission=transmission, phase=phase,                          normalise=normalise)          if self.phase is not None and self.transmission is not None:             if phase.shape != self.transmission.shape:                 raise ValueError(\"phase and transmission must have the same \"                                  \"shape.\")      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         wavefront *= self.transmission         wavefront = wavefront.add_phase(self.phase)         if self.normalise:             wavefront = wavefront.normalise()         return wavefront   class PhaseBasisOptic(BaseBasisOptic):     \"\"\"     Adds an array of phase values to the input wavefront calculated from the     Optical Path Difference (OPD). The OPDs are calculated from the basis     arrays, and weighted by the coefficients, and converted to phases by the     wavefront methods.      Attributes     ----------     transmission: Array         The Array of transmission values to be applied to the input wavefront.     basis: Array, metres         Arrays holding the pre-calculated basis vectors.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     \"\"\"      @property     def phase(self: OpticalLayer) -&gt; Array:         \"\"\"         Calculates the total phase from the basis vectors and coefficients.          Returns         -------         phase : Array, radians             The total phase.         \"\"\"         return self.calculate(self.basis, self.coefficients)      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         wavefront *= self.transmission         wavefront = wavefront.add_phase(self.phase)         if self.normalise:             wavefront = wavefront.normalise()         return wavefront   class Tilt(OpticalLayer):     \"\"\"     Tilts the wavefront by the input angles.      Attributes     ----------     angles : Array, radians         The (x, y) angles by which to tilt the wavefront.     \"\"\"     angles: Array      def __init__(self: OpticalLayer, angles: Array) -&gt; OpticalLayer:         \"\"\"         Constructor for the TiltWavefront class.          Parameters         ----------         angles : Array, radians             The (x, y) angles by which to tilt the wavefront.         \"\"\"         super().__init__()         self.angles = np.asarray(angles, dtype=float)          if self.angles.shape != (2,):             raise ValueError(\"angles must have have (2,)\")      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         return wavefront.tilt(self.angles)   class Normalise(OpticalLayer):     \"\"\"Normalises the wavefront.\"\"\"      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         return wavefront.normalise()   class Rotate(OpticalLayer):     \"\"\"     Applies a rotation to the wavefront using interpolation methods.      Attributes     ----------     angle : Array, radians         The angle by which to rotate the wavefront in the clockwise direction.     order : int = 1         The order of the interpolation to use. Only applies if fourier is         False. Must be 0, 1, or 3.     complex : bool = False         Should the rotation be performed on the 'complex' (real, imaginary),         as opposed to the default 'phasor' (amplitude, phase) arrays.     \"\"\"     angle: Array     order: int     complex: bool      def __init__(self: OpticalLayer,                  angle: Array,                  order: int = 1,                  complex: bool = False):         \"\"\"         Constructor for the Rotate class.          Parameters         ----------         angle: float, radians             The angle by which to rotate the wavefront in the clockwise              direction.         order : int = 1             The order of the interpolation to use. Must be 0, or 1.         complex : bool = False             Should the rotation be performed on the 'complex' (real, imaginary),             as opposed to the default 'phasor' (amplitude, phase) arrays.         \"\"\"         super().__init__()         self.angle = np.asarray(angle, dtype=float)         self.order = int(order)         self.complex = bool(complex)          if self.order not in (0, 1):             raise ValueError(\"Order must be 0, 1\")         if self.angle.ndim != 0:             raise ValueError(f\"angle must be a zero-dimensional, has \"                              f\"{self.angle.ndim} dimensions.\")      def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         return wavefront.rotate(self.angle, self.order, self.complex)"},{"location":"dLux/optical_layers/#public-classes","title":"Public Classes\u00b6","text":"<p>#####################</p>"},{"location":"dLux/optics/","title":"Optics","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nimport jax.numpy as np\nfrom jax import vmap, Array\nfrom zodiax import Base\nfrom typing import Union\nimport dLux.utils as dlu\nimport dLux\n\n__all__ = [\"AngularOptics\", \"CartesianOptics\", \"FlexibleOptics\", \"LayeredOptics\"]\n\n# Alias classes for simplified type-checking\nOpticalLayer = lambda: dLux.optical_layers.OpticalLayer\nPropagator = lambda: dLux.propagators.Propagator\nSource = lambda: dLux.sources.BaseSource\n</pre> from __future__ import annotations from abc import abstractmethod import jax.numpy as np from jax import vmap, Array from zodiax import Base from typing import Union import dLux.utils as dlu import dLux  __all__ = [\"AngularOptics\", \"CartesianOptics\", \"FlexibleOptics\", \"LayeredOptics\"]  # Alias classes for simplified type-checking OpticalLayer = lambda: dLux.optical_layers.OpticalLayer Propagator = lambda: dLux.propagators.Propagator Source = lambda: dLux.sources.BaseSource  In\u00a0[\u00a0]: Copied! <pre>class BaseOptics(Base):\n\"\"\"\n    The Base Optics class that all optics classes inherit from. Can be used to\n    create your own optics classes that will integrate seamlessly with the rest\n    of dLux.\n\n    This class implements three concrete methods and on abstract one. The\n    concrete methods are `model(sources)`, which models dLux sources through\n    the optics, `propagate(wavelengths, offset, weights)`, which propagates a\n    polychromatic point source through the optics, and `__getattr__`, which\n    allows for easy access to the attributes of the class.\n\n    The abstract method is `propagate_mono(wavelength, offset, return_wf)`,\n    which propagates a monochromatic point source through the optics. This\n    is where the actual operations on the wavefront are performed. This\n    method must be implemented by any class that inherits from `BaseOptics`.\n    \"\"\"\n\n    def __getattr__(self: BaseOptics, key: str) -&gt; Any:\n\"\"\"\n        Accessor for attributes of the class to simplify zodiax paths by\n        searching for parameters in the attributes of the class.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the class.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key.\n        \"\"\"\n        for attribute in self.__dict__.values():\n            if hasattr(attribute, key):\n                return getattr(attribute, key)\n        else:\n            raise AttributeError(\n                f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n            )\n\n    @abstractmethod\n    def propagate_mono(\n        self: BaseOptics,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:  # pragma: no cover\n\"\"\"\n        Propagates a monochromatic point source through the optics.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n\n    def propagate(\n        self: BaseOptics,\n        wavelengths: Array,\n        offset: Array = np.zeros(2),\n        weights: Array = None,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a Polychromatic point source through the optics.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The wavelengths of the wavefronts to propagate through the optics.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        weights : Array, = None\n            The weights of each wavelength. If None, all wavelengths are\n            weighted equally.\n\n        Returns\n        -------\n        psf : Array\n            The chromatic point spread function after being propagated\n            though the optical layers.\n        \"\"\"\n        wavelengths = np.atleast_1d(wavelengths)\n        if weights is None:\n            weights = np.ones_like(wavelengths) / len(wavelengths)\n        else:\n            weights = np.atleast_1d(weights)\n\n        # Check wavelengths and weights\n        if weights.shape != wavelengths.shape:\n            raise ValueError(\n                \"wavelengths and weights must have the \"\n                f\"same shape, got {wavelengths.shape} and {weights.shape} \"\n                \"respectively.\"\n            )\n\n        # Check offset\n        offset = np.array(offset) if not isinstance(offset, Array) else offset\n        if offset.shape != (2,):\n            raise ValueError(\n                \"offset must be a 2-element array, got \" f\"shape {offset.shape}.\"\n            )\n\n        # Calculate\n        propagator = vmap(self.propagate_mono, in_axes=(0, None))\n        psfs = propagator(wavelengths, offset)\n        if weights is not None:\n            psfs *= weights[:, None, None]\n        return psfs.sum(0)\n\n    def model(self: BaseOptics, sources: Union[list, Source]) -&gt; Array:\n\"\"\"\n        Models the input sources through the optics. The sources input can be\n        a single Source object, or a list of Source objects.\n\n        Parameters\n        ----------\n        sources : Union[list, Source]\n            The sources to model.\n\n        Returns\n        -------\n        psf : Array\n            The sum of the individual sources modelled through the optics.\n        \"\"\"\n        if not isinstance(sources, list):\n            sources = [sources]\n\n        for source in sources:\n            if not isinstance(source, Source()):\n                raise TypeError(\n                    \"All input sources must be a Source \"\n                    f\"object. Got type: {type(sources)})\"\n                )\n\n        return np.array([source.model(self) for source in sources]).sum(0)\n\n\nclass SimpleOptics(BaseOptics):\n\"\"\"\n    A Simple Optical system that initialises a wavefront based on the wavefront\n    diameter and npixels. It adds two attributes, `wf_npixels` and `diameter`,\n    as well as the `_construct_wavefront` method that constructs and tilts the\n    initial wavefront.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The nuber of pixels of the initial wavefront to propagate.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    \"\"\"\n\n    wf_npixels: int\n    diameter: Array\n\n    def __init__(self: BaseOptics, wf_npixels: int, diameter: float, **kwargs):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        \"\"\"\n        self.wf_npixels = int(wf_npixels)\n        self.diameter = float(diameter)\n\n        super().__init__(**kwargs)\n\n    def _construct_wavefront(\n        self: BaseOptics, wavelength: Array, offset: Array = np.zeros(2)\n    ) -&gt; Array:\n\"\"\"\n        Constructs the appropriate tilted wavefront object for the optical\n        system.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optics.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront object to propagate through the optics.\n        \"\"\"\n        wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n        return wf.tilt(offset)\n\n\nclass NonPropagatorOptics(BaseOptics):\n\"\"\"\n    Implements the basics required for an optical system with a parametric PSF\n    output sampling. Adds the `psf_npixels`, `psf_pixel_scale`, and\n    `psf_oversample` attributes.\n\n    Attributes\n    ----------\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float\n        The pixel scale of the final PSF.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    \"\"\"\n\n    psf_npixels: int\n    psf_oversample: float\n    psf_pixel_scale: float\n\n    def __init__(\n        self: BaseOptics,\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        psf_oversample: float = 1.0,\n        **kwargs,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float\n            The pixel scale of the final PSF.\n        psf_oversample : float = 1.\n            The oversampling factor of the final PSF.\n        \"\"\"\n        self.psf_npixels = int(psf_npixels)\n        self.psf_oversample = float(psf_oversample)\n        self.psf_pixel_scale = float(psf_pixel_scale)\n        super().__init__(**kwargs)\n\n    @property\n    def true_pixel_scale(self):\n\"\"\"\n        Returns the true pixel scale of the PSF.\n        \"\"\"\n        return dlu.arcsec_to_rad(self.psf_pixel_scale / self.psf_oversample)\n\n\nclass AperturedOptics(BaseOptics):\n\"\"\"\n    Constructs a simple optical system  with an aperture and an optional\n    'mask'.\n\n    Attributes\n    ----------\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    \"\"\"\n\n    aperture: Union[Array, OpticalLayer()]\n    mask: Union[Array, OpticalLayer()]\n\n    def __init__(\n        self: BaseOptics,\n        aperture: Union[Array, OpticalLayer()],\n        mask: Union[Array, OpticalLayer()] = None,\n        **kwargs,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        mask : Union[Array, OpticalLayer], = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n            Default is None.\n        \"\"\"\n        if not isinstance(aperture, (Array, OpticalLayer())):\n            raise TypeError(\n                \"aperture must be an Array or \" f\"OpticalLayer, got {type(aperture)}.\"\n            )\n        self.aperture = aperture\n\n        if mask is not None:\n            if not isinstance(mask, (Array, OpticalLayer())):\n                raise TypeError(\n                    \"mask must be an Array or \" f\"OpticalLayer, got {type(aperture)}.\"\n                )\n        self.mask = mask\n\n        super().__init__(**kwargs)\n\n    def _apply_aperture(\n        self: BaseOptics, wavelength: float, offset: Array\n    ) -&gt; Wavefront():\n\"\"\"\n        Constructs the wavefront, applies the aperture and mask, and returns\n        the wavefront.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optics.\n        offset : Array, radians\n            The (x, y) offset from the optical axis of the source.\n        \"\"\"\n        wf = self._construct_wavefront(wavelength, offset)\n        wf *= self.aperture\n        wf = wf.normalise()\n        wf *= self.mask\n        return wf\n</pre> class BaseOptics(Base):     \"\"\"     The Base Optics class that all optics classes inherit from. Can be used to     create your own optics classes that will integrate seamlessly with the rest     of dLux.      This class implements three concrete methods and on abstract one. The     concrete methods are `model(sources)`, which models dLux sources through     the optics, `propagate(wavelengths, offset, weights)`, which propagates a     polychromatic point source through the optics, and `__getattr__`, which     allows for easy access to the attributes of the class.      The abstract method is `propagate_mono(wavelength, offset, return_wf)`,     which propagates a monochromatic point source through the optics. This     is where the actual operations on the wavefront are performed. This     method must be implemented by any class that inherits from `BaseOptics`.     \"\"\"      def __getattr__(self: BaseOptics, key: str) -&gt; Any:         \"\"\"         Accessor for attributes of the class to simplify zodiax paths by         searching for parameters in the attributes of the class.          Parameters         ----------         key : str             The key of the item to be searched for in the class.          Returns         -------         item : object             The item corresponding to the supplied key.         \"\"\"         for attribute in self.__dict__.values():             if hasattr(attribute, key):                 return getattr(attribute, key)         else:             raise AttributeError(                 f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"             )      @abstractmethod     def propagate_mono(         self: BaseOptics,         wavelength: Array,         offset: Array = np.zeros(2),         return_wf: bool = False,     ) -&gt; Array:  # pragma: no cover         \"\"\"         Propagates a monochromatic point source through the optics.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         return_wf : bool, = False             If True, the wavefront object after propagation is returned.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         wavefront : Wavefront             The wavefront object after propagation. Only returned if             return_wf is True.         \"\"\"      def propagate(         self: BaseOptics,         wavelengths: Array,         offset: Array = np.zeros(2),         weights: Array = None,     ) -&gt; Array:         \"\"\"         Propagates a Polychromatic point source through the optics.          Parameters         ----------         wavelengths : Array, metres             The wavelengths of the wavefronts to propagate through the optics.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         weights : Array, = None             The weights of each wavelength. If None, all wavelengths are             weighted equally.          Returns         -------         psf : Array             The chromatic point spread function after being propagated             though the optical layers.         \"\"\"         wavelengths = np.atleast_1d(wavelengths)         if weights is None:             weights = np.ones_like(wavelengths) / len(wavelengths)         else:             weights = np.atleast_1d(weights)          # Check wavelengths and weights         if weights.shape != wavelengths.shape:             raise ValueError(                 \"wavelengths and weights must have the \"                 f\"same shape, got {wavelengths.shape} and {weights.shape} \"                 \"respectively.\"             )          # Check offset         offset = np.array(offset) if not isinstance(offset, Array) else offset         if offset.shape != (2,):             raise ValueError(                 \"offset must be a 2-element array, got \" f\"shape {offset.shape}.\"             )          # Calculate         propagator = vmap(self.propagate_mono, in_axes=(0, None))         psfs = propagator(wavelengths, offset)         if weights is not None:             psfs *= weights[:, None, None]         return psfs.sum(0)      def model(self: BaseOptics, sources: Union[list, Source]) -&gt; Array:         \"\"\"         Models the input sources through the optics. The sources input can be         a single Source object, or a list of Source objects.          Parameters         ----------         sources : Union[list, Source]             The sources to model.          Returns         -------         psf : Array             The sum of the individual sources modelled through the optics.         \"\"\"         if not isinstance(sources, list):             sources = [sources]          for source in sources:             if not isinstance(source, Source()):                 raise TypeError(                     \"All input sources must be a Source \"                     f\"object. Got type: {type(sources)})\"                 )          return np.array([source.model(self) for source in sources]).sum(0)   class SimpleOptics(BaseOptics):     \"\"\"     A Simple Optical system that initialises a wavefront based on the wavefront     diameter and npixels. It adds two attributes, `wf_npixels` and `diameter`,     as well as the `_construct_wavefront` method that constructs and tilts the     initial wavefront.      Attributes     ----------     wf_npixels : int         The nuber of pixels of the initial wavefront to propagate.     diameter : Array, metres         The diameter of the initial wavefront to propagate.     \"\"\"      wf_npixels: int     diameter: Array      def __init__(self: BaseOptics, wf_npixels: int, diameter: float, **kwargs):         \"\"\"         Parameters         ----------         wf_npixels : int             The number of pixels representing the wavefront.         diameter : Array, metres             The diameter of the initial wavefront to propagate.         \"\"\"         self.wf_npixels = int(wf_npixels)         self.diameter = float(diameter)          super().__init__(**kwargs)      def _construct_wavefront(         self: BaseOptics, wavelength: Array, offset: Array = np.zeros(2)     ) -&gt; Array:         \"\"\"         Constructs the appropriate tilted wavefront object for the optical         system.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optics.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.          Returns         -------         wavefront : Wavefront             The wavefront object to propagate through the optics.         \"\"\"         wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)         return wf.tilt(offset)   class NonPropagatorOptics(BaseOptics):     \"\"\"     Implements the basics required for an optical system with a parametric PSF     output sampling. Adds the `psf_npixels`, `psf_pixel_scale`, and     `psf_oversample` attributes.      Attributes     ----------     psf_npixels : int         The number of pixels of the final PSF.     psf_pixel_scale : float         The pixel scale of the final PSF.     psf_oversample : float         The oversampling factor of the final PSF.     \"\"\"      psf_npixels: int     psf_oversample: float     psf_pixel_scale: float      def __init__(         self: BaseOptics,         psf_npixels: int,         psf_pixel_scale: float,         psf_oversample: float = 1.0,         **kwargs,     ):         \"\"\"         Parameters         ----------         psf_npixels : int             The number of pixels of the final PSF.         psf_pixel_scale : float             The pixel scale of the final PSF.         psf_oversample : float = 1.             The oversampling factor of the final PSF.         \"\"\"         self.psf_npixels = int(psf_npixels)         self.psf_oversample = float(psf_oversample)         self.psf_pixel_scale = float(psf_pixel_scale)         super().__init__(**kwargs)      @property     def true_pixel_scale(self):         \"\"\"         Returns the true pixel scale of the PSF.         \"\"\"         return dlu.arcsec_to_rad(self.psf_pixel_scale / self.psf_oversample)   class AperturedOptics(BaseOptics):     \"\"\"     Constructs a simple optical system  with an aperture and an optional     'mask'.      Attributes     ----------     aperture : Union[Array, OpticalLayer]         The aperture of the system. Can be an Array or a OpticalLayer.     mask : Union[Array, OpticalLayer]         The mask to apply to the wavefront. Can be an Array or an OpticalLayer.         If an Array it is treated as a transmissive mask.     \"\"\"      aperture: Union[Array, OpticalLayer()]     mask: Union[Array, OpticalLayer()]      def __init__(         self: BaseOptics,         aperture: Union[Array, OpticalLayer()],         mask: Union[Array, OpticalLayer()] = None,         **kwargs,     ):         \"\"\"         Parameters         ----------         aperture : Union[Array, OpticalLayer]             The aperture of the system. Can be an Array or a OpticalLayer.         mask : Union[Array, OpticalLayer], = None             The mask to apply to the wavefront. Can be an Array or an             OpticalLayer. If an Array it is treated as a transmissive mask.             Default is None.         \"\"\"         if not isinstance(aperture, (Array, OpticalLayer())):             raise TypeError(                 \"aperture must be an Array or \" f\"OpticalLayer, got {type(aperture)}.\"             )         self.aperture = aperture          if mask is not None:             if not isinstance(mask, (Array, OpticalLayer())):                 raise TypeError(                     \"mask must be an Array or \" f\"OpticalLayer, got {type(aperture)}.\"                 )         self.mask = mask          super().__init__(**kwargs)      def _apply_aperture(         self: BaseOptics, wavelength: float, offset: Array     ) -&gt; Wavefront():         \"\"\"         Constructs the wavefront, applies the aperture and mask, and returns         the wavefront.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optics.         offset : Array, radians             The (x, y) offset from the optical axis of the source.         \"\"\"         wf = self._construct_wavefront(wavelength, offset)         wf *= self.aperture         wf = wf.normalise()         wf *= self.mask         return wf  In\u00a0[\u00a0]: Copied! <pre>class AngularOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    with `psf_pixel_scale` in units of arcseconds.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    psf_pixel_scale : float\n        The pixel scale of the final PSF.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    \"\"\"\n\n    def __init__(\n        self: AngularOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        psf_oversample: float = 1,\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, arcseconds\n            The pixel scale of the final PSF in units of arcseconds.\n        psf_oversample : float\n            The oversampling factor of the final PSF.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            psf_npixels=psf_npixels,\n            mask=mask,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n        )\n\n    def propagate_mono(\n        self: AngularOptics,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n\n        # Propagate\n        pixel_scale = self.psf_pixel_scale / self.psf_oversample\n        pixel_scale_radians = dlu.arcsec_to_rad(pixel_scale)\n        wf = wf.MFT(self.psf_npixels, pixel_scale_radians)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n\n\nclass CartesianOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    with `psf_pixel_scale` in units of microns.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    focal_length : float, metres\n        The focal length of the optical system.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    psf_pixel_scale : float, microns\n        The pixel scale of the final PSF.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    \"\"\"\n\n    focal_length: None\n\n    def __init__(\n        self: CartesianOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        focal_length: float,\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        psf_oversample: int = 1,\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        focal_length : float, metres\n            The focal length of the optical system.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, microns\n            The pixel scale of the final PSF in units of microns.\n        psf_oversample : float\n            The oversampling factor of the final PSF.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        self.focal_length = float(focal_length)\n\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n            mask=mask,\n        )\n\n    def propagate_mono(\n        self: SimpleToliman,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n\n        # Propagate\n        pixel_scale = 1e-6 * self.psf_pixel_scale / self.psf_oversample\n        wf = wf.MFT(self.psf_npixels, pixel_scale, focal_length=self.focal_length)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n\n\nclass FlexibleOptics(AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    using the user-supplied propagator. This allows for propagation of fresnel\n    wavefronts.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    propagator : Propagator\n        The propagator to use to propagate the wavefront through the optics.\n    \"\"\"\n\n    propagator: None\n\n    def __init__(\n        self: BaseOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        propagator: Propagator(),\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        propagator : Propagator\n            The propagator to use to propagate the wavefront through the optics.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        if not isinstance(propagator, Propagator()):\n            raise TypeError(\n                \"propagator must be a Propagator object, \" f\"got {type(propagator)}.\"\n            )\n        self.propagator = propagator\n        super().__init__(\n            wf_npixels=wf_npixels, diameter=diameter, aperture=aperture, mask=mask\n        )\n\n    @property\n    def true_pixel_scale(self):\n\"\"\"\n        Returns the true pixel scale of the PSF.\n        \"\"\"\n        return self.propagator.pixel_scale\n\n    def _construct_wavefront(\n        self: BaseOptics, wavelength: Array, offset: Array = np.zeros(2)\n    ) -&gt; Array:\n\"\"\"\n        Constructs the appropriate tilted wavefront object for the optical\n        system.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optics.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront object to propagate through the optics.\n        \"\"\"\n        if isinstance(self.propagator, dLux.propagators.FarFieldFresnel):\n            wf = dLux.FresnelWavefront(self.wf_npixels, self.diameter, wavelength)\n        else:\n            wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n        return wf.tilt(offset)\n\n    def propagate_mono(\n        self: SimpleToliman,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n        wf = self.propagator(wf)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n\n\nclass LayeredOptics(SimpleOptics):\n\"\"\"\n    A fully flexible optical system that allows for the arbitrary chaining of\n    dLux OpticalLayers.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The size of the initial wavefront to propagate.\n    diameter : Array\n        The diameter of the wavefront to model through the system in metres.\n    layers : OrderedDict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input wavefront through an optical system.\n    \"\"\"\n\n    layers: OrderedDict\n\n    def __init__(\n        self: Optics, wf_npixels: int, diameter: float, layers: list\n    ) -&gt; Optics:\n\"\"\"\n        Constructor for the Optics class.\n\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels to use when propagating the wavefront through\n            the optical system.\n        diameter : float\n            The diameter of the wavefront to model through the system in metres.\n        layers : list\n            A list of dLux 'layers' that define the transformations and\n            operations upon some input wavefront through an optical system.\n            The entries can either be dLux OpticalLayers, or tuples of the\n            form (OpticalLayer, key), with the key being used as the dictionary\n            key for the layer.\n        \"\"\"\n        super().__init__(wf_npixels=wf_npixels, diameter=diameter)\n        self.layers = dlu.list_to_dictionary(layers, True, OpticalLayer())\n\n    def __getattr__(self: Optics, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        super().__getattr__(key)\n\n    @property\n    def true_pixel_scale(self):\n\"\"\"\n        Returns the true pixel scale of the PSF.\n        \"\"\"\n        # Note: This is a bit inefficient, but should work\n        for layer in self.layers.values():\n            if isinstance(layer, Propagator()):\n                propagator = layer\n        return propagator.pixel_scale\n\n    def propagate_mono(\n        self: BaseOptics,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wavefront = self._construct_wavefront(wavelength, offset)\n        for layer in list(self.layers.values()):\n            wavefront *= layer\n\n        if return_wf:\n            return wavefront\n        return wavefront.psf\n</pre> class AngularOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):     \"\"\"     A simple optical system that propagates a wavefront to an image plane     with `psf_pixel_scale` in units of arcseconds.      Attributes     ----------     wf_npixels : int         The number of pixels representing the wavefront.     diameter : Array, metres         The diameter of the initial wavefront to propagate.     aperture : Union[Array, OpticalLayer]         The aperture of the system. Can be an Array or a OpticalLayer.     mask : Union[Array, OpticalLayer]         The mask to apply to the wavefront. Can be an Array or an OpticalLayer.         If an Array it is treated as a transmissive mask.     psf_pixel_scale : float         The pixel scale of the final PSF.     psf_oversample : float         The oversampling factor of the final PSF.     psf_npixels : int         The number of pixels of the final PSF.     \"\"\"      def __init__(         self: AngularOptics,         wf_npixels: int,         diameter: float,         aperture: Union[Array, OpticalLayer()],         psf_npixels: int,         psf_pixel_scale: float,         psf_oversample: float = 1,         mask: Union[Array, OpticalLayer()] = None,     ):         \"\"\"         Parameters         ----------         wf_npixels : int             The number of pixels representing the wavefront.         diameter : Array, metres             The diameter of the initial wavefront to propagate.         aperture : Union[Array, OpticalLayer]             The aperture of the system. Can be an Array or a OpticalLayer.         psf_npixels : int             The number of pixels of the final PSF.         psf_pixel_scale : float, arcseconds             The pixel scale of the final PSF in units of arcseconds.         psf_oversample : float             The oversampling factor of the final PSF.         mask : Union[Array, OpticalLayer] = None             The mask to apply to the wavefront. Can be an Array or an             OpticalLayer. If an Array it is treated as a transmissive mask.         \"\"\"         super().__init__(             wf_npixels=wf_npixels,             diameter=diameter,             aperture=aperture,             psf_npixels=psf_npixels,             mask=mask,             psf_pixel_scale=psf_pixel_scale,             psf_oversample=psf_oversample,         )      def propagate_mono(         self: AngularOptics,         wavelength: Array,         offset: Array = np.zeros(2),         return_wf: bool = False,     ) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         return_wf : bool, = False             If True, the wavefront object after propagation is returned.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         wavefront : Wavefront             The wavefront object after propagation. Only returned if             return_wf is True.         \"\"\"         wf = self._apply_aperture(wavelength, offset)          # Propagate         pixel_scale = self.psf_pixel_scale / self.psf_oversample         pixel_scale_radians = dlu.arcsec_to_rad(pixel_scale)         wf = wf.MFT(self.psf_npixels, pixel_scale_radians)          # Return PSF or Wavefront         if return_wf:             return wf         return wf.psf   class CartesianOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):     \"\"\"     A simple optical system that propagates a wavefront to an image plane     with `psf_pixel_scale` in units of microns.      Attributes     ----------     wf_npixels : int         The number of pixels representing the wavefront.     diameter : Array, metres         The diameter of the initial wavefront to propagate.     focal_length : float, metres         The focal length of the optical system.     aperture : Union[Array, OpticalLayer]         The aperture of the system. Can be an Array or a OpticalLayer.     mask : Union[Array, OpticalLayer]         The mask to apply to the wavefront. Can be an Array or an OpticalLayer.         If an Array it is treated as a transmissive mask.     psf_pixel_scale : float, microns         The pixel scale of the final PSF.     psf_oversample : float         The oversampling factor of the final PSF.     psf_npixels : int         The number of pixels of the final PSF.     \"\"\"      focal_length: None      def __init__(         self: CartesianOptics,         wf_npixels: int,         diameter: float,         aperture: Union[Array, OpticalLayer()],         focal_length: float,         psf_npixels: int,         psf_pixel_scale: float,         psf_oversample: int = 1,         mask: Union[Array, OpticalLayer()] = None,     ):         \"\"\"         Parameters         ----------         wf_npixels : int             The number of pixels representing the wavefront.         diameter : Array, metres             The diameter of the initial wavefront to propagate.         aperture : Union[Array, OpticalLayer]             The aperture of the system. Can be an Array or a OpticalLayer.         focal_length : float, metres             The focal length of the optical system.         psf_npixels : int             The number of pixels of the final PSF.         psf_pixel_scale : float, microns             The pixel scale of the final PSF in units of microns.         psf_oversample : float             The oversampling factor of the final PSF.         mask : Union[Array, OpticalLayer] = None             The mask to apply to the wavefront. Can be an Array or an             OpticalLayer. If an Array it is treated as a transmissive mask.         \"\"\"         self.focal_length = float(focal_length)          super().__init__(             wf_npixels=wf_npixels,             diameter=diameter,             aperture=aperture,             psf_npixels=psf_npixels,             psf_pixel_scale=psf_pixel_scale,             psf_oversample=psf_oversample,             mask=mask,         )      def propagate_mono(         self: SimpleToliman,         wavelength: Array,         offset: Array = np.zeros(2),         return_wf: bool = False,     ) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         return_wf : bool, = False             If True, the wavefront object after propagation is returned.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         wavefront : Wavefront             The wavefront object after propagation. Only returned if             return_wf is True.         \"\"\"         wf = self._apply_aperture(wavelength, offset)          # Propagate         pixel_scale = 1e-6 * self.psf_pixel_scale / self.psf_oversample         wf = wf.MFT(self.psf_npixels, pixel_scale, focal_length=self.focal_length)          # Return PSF or Wavefront         if return_wf:             return wf         return wf.psf   class FlexibleOptics(AperturedOptics, SimpleOptics):     \"\"\"     A simple optical system that propagates a wavefront to an image plane     using the user-supplied propagator. This allows for propagation of fresnel     wavefronts.      Attributes     ----------     wf_npixels : int         The number of pixels representing the wavefront.     diameter : Array, metres         The diameter of the initial wavefront to propagate.     aperture : Union[Array, OpticalLayer]         The aperture of the system. Can be an Array or a OpticalLayer.     mask : Union[Array, OpticalLayer]         The mask to apply to the wavefront. Can be an Array or an OpticalLayer.         If an Array it is treated as a transmissive mask.     propagator : Propagator         The propagator to use to propagate the wavefront through the optics.     \"\"\"      propagator: None      def __init__(         self: BaseOptics,         wf_npixels: int,         diameter: float,         aperture: Union[Array, OpticalLayer()],         propagator: Propagator(),         mask: Union[Array, OpticalLayer()] = None,     ):         \"\"\"         Parameters         ----------         wf_npixels : int             The number of pixels representing the wavefront.         diameter : Array, metres             The diameter of the initial wavefront to propagate.         aperture : Union[Array, OpticalLayer]             The aperture of the system. Can be an Array or a OpticalLayer.         propagator : Propagator             The propagator to use to propagate the wavefront through the optics.         mask : Union[Array, OpticalLayer] = None             The mask to apply to the wavefront. Can be an Array or an             OpticalLayer. If an Array it is treated as a transmissive mask.         \"\"\"         if not isinstance(propagator, Propagator()):             raise TypeError(                 \"propagator must be a Propagator object, \" f\"got {type(propagator)}.\"             )         self.propagator = propagator         super().__init__(             wf_npixels=wf_npixels, diameter=diameter, aperture=aperture, mask=mask         )      @property     def true_pixel_scale(self):         \"\"\"         Returns the true pixel scale of the PSF.         \"\"\"         return self.propagator.pixel_scale      def _construct_wavefront(         self: BaseOptics, wavelength: Array, offset: Array = np.zeros(2)     ) -&gt; Array:         \"\"\"         Constructs the appropriate tilted wavefront object for the optical         system.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optics.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.          Returns         -------         wavefront : Wavefront             The wavefront object to propagate through the optics.         \"\"\"         if isinstance(self.propagator, dLux.propagators.FarFieldFresnel):             wf = dLux.FresnelWavefront(self.wf_npixels, self.diameter, wavelength)         else:             wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)         return wf.tilt(offset)      def propagate_mono(         self: SimpleToliman,         wavelength: Array,         offset: Array = np.zeros(2),         return_wf: bool = False,     ) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         return_wf : bool, = False             If True, the wavefront object after propagation is returned.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         wavefront : Wavefront             The wavefront object after propagation. Only returned if             return_wf is True.         \"\"\"         wf = self._apply_aperture(wavelength, offset)         wf = self.propagator(wf)          # Return PSF or Wavefront         if return_wf:             return wf         return wf.psf   class LayeredOptics(SimpleOptics):     \"\"\"     A fully flexible optical system that allows for the arbitrary chaining of     dLux OpticalLayers.      Attributes     ----------     wf_npixels : int         The size of the initial wavefront to propagate.     diameter : Array         The diameter of the wavefront to model through the system in metres.     layers : OrderedDict         A collections.OrderedDict of 'layers' that define the transformations         and operations upon some input wavefront through an optical system.     \"\"\"      layers: OrderedDict      def __init__(         self: Optics, wf_npixels: int, diameter: float, layers: list     ) -&gt; Optics:         \"\"\"         Constructor for the Optics class.          Parameters         ----------         wf_npixels : int             The number of pixels to use when propagating the wavefront through             the optical system.         diameter : float             The diameter of the wavefront to model through the system in metres.         layers : list             A list of dLux 'layers' that define the transformations and             operations upon some input wavefront through an optical system.             The entries can either be dLux OpticalLayers, or tuples of the             form (OpticalLayer, key), with the key being used as the dictionary             key for the layer.         \"\"\"         super().__init__(wf_npixels=wf_npixels, diameter=diameter)         self.layers = dlu.list_to_dictionary(layers, True, OpticalLayer())      def __getattr__(self: Optics, key: str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the layers dictionary of this class via the 'class.attribute' method.          Parameters         ----------         key : str             The key of the item to be searched for in the layers dictionary.          Returns         -------         item : object             The item corresponding to the supplied key in the layers dictionary.         \"\"\"         if key in self.layers.keys():             return self.layers[key]         super().__getattr__(key)      @property     def true_pixel_scale(self):         \"\"\"         Returns the true pixel scale of the PSF.         \"\"\"         # Note: This is a bit inefficient, but should work         for layer in self.layers.values():             if isinstance(layer, Propagator()):                 propagator = layer         return propagator.pixel_scale      def propagate_mono(         self: BaseOptics,         wavelength: Array,         offset: Array = np.zeros(2),         return_wf: bool = False,     ) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers.          Parameters         ----------         wavelength : Array, metres             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         return_wf : bool, = False             If True, the wavefront object after propagation is returned.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         wavefront : Wavefront             The wavefront object after propagation. Only returned if             return_wf is True.         \"\"\"         wavefront = self._construct_wavefront(wavelength, offset)         for layer in list(self.layers.values()):             wavefront *= layer          if return_wf:             return wavefront         return wavefront.psf"},{"location":"dLux/optics/#private-classes","title":"Private Classes\u00b6","text":"<p>######################</p>"},{"location":"dLux/optics/#public-classes","title":"Public Classes\u00b6","text":"<p>#####################</p>"},{"location":"dLux/propagators/","title":"Propagators","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax import Array\nimport dLux\n</pre> from __future__ import annotations import jax.numpy as np from jax import Array import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"MFT\", \"FFT\", \"ShiftedMFT\", \"FarFieldFresnel\"]\n</pre> __all__ = [\"MFT\", \"FFT\", \"ShiftedMFT\", \"FarFieldFresnel\"] In\u00a0[\u00a0]: Copied! <pre>class Propagator(dLux.optical_layers.OpticalLayer):\n\"\"\"\n    An abstract class to store the various properties of the propagation of\n    some wavefront.\n\n    Attributes\n    ----------\n    focal_length : Array, metres\n        The effective focal length of the lens/mirror this propagator\n        represents. If None, the output pixel_scales are taken to be \n        radians/pixel, else they are taken to be in metres/pixel.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    focal_length: Array\n    inverse: bool\n\n    def __init__(\n            self: Propagator,\n            focal_length: Array = None,\n            inverse: bool = False):\n\"\"\"\n        Constructor for the Propagator.\n\n        Parameters\n        ----------\n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        super().__init__()\n\n        if focal_length is not None:\n            focal_length = np.asarray(focal_length, dtype=float)\n            if focal_length.ndim != 0:\n                raise TypeError('focal_length must be a scalar.')\n\n        self.focal_length = focal_length\n        self.inverse = bool(inverse)\n</pre> class Propagator(dLux.optical_layers.OpticalLayer):     \"\"\"     An abstract class to store the various properties of the propagation of     some wavefront.      Attributes     ----------     focal_length : Array, metres         The effective focal length of the lens/mirror this propagator         represents. If None, the output pixel_scales are taken to be          radians/pixel, else they are taken to be in metres/pixel.     inverse : bool         Should the propagation be performed in the inverse direction.     \"\"\"     focal_length: Array     inverse: bool      def __init__(             self: Propagator,             focal_length: Array = None,             inverse: bool = False):         \"\"\"         Constructor for the Propagator.          Parameters         ----------         inverse : bool = False             Should the propagation be performed in the inverse direction.         \"\"\"         super().__init__()          if focal_length is not None:             focal_length = np.asarray(focal_length, dtype=float)             if focal_length.ndim != 0:                 raise TypeError('focal_length must be a scalar.')          self.focal_length = focal_length         self.inverse = bool(inverse) In\u00a0[\u00a0]: Copied! <pre>class FFT(Propagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transform.\n\n    # TODO: Update padding to take in units of npixels, rather than factor.\n\n    Attributes\n    ----------\n    focal_length : Array, metres\n        The focal_length of the lens/mirror this propagator represents.\n    pad : int\n        The amount of padding to apply to the wavefront before propagating.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    pad: int\n\n    def __init__(\n        self         : Propagator, \n        focal_length : Array = None,\n        pad          : int = 2,\n        inverse      : bool = False) -&gt; Propagator:\n        super().__init__(focal_length=focal_length, inverse=inverse)\n        self.pad = int(pad)\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.IFFT(self.pad, self.focal_length)\n        else:\n            return wavefront.FFT(self.pad, self.focal_length)\n</pre> class FFT(Propagator):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane using a     Fast Fourier Transform.      # TODO: Update padding to take in units of npixels, rather than factor.      Attributes     ----------     focal_length : Array, metres         The focal_length of the lens/mirror this propagator represents.     pad : int         The amount of padding to apply to the wavefront before propagating.     inverse : bool         Should the propagation be performed in the inverse direction.     \"\"\"     pad: int      def __init__(         self         : Propagator,          focal_length : Array = None,         pad          : int = 2,         inverse      : bool = False) -&gt; Propagator:         super().__init__(focal_length=focal_length, inverse=inverse)         self.pad = int(pad)      def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         if self.inverse:             return wavefront.IFFT(self.pad, self.focal_length)         else:             return wavefront.FFT(self.pad, self.focal_length) In\u00a0[\u00a0]: Copied! <pre>class MFT(Propagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in Cartesian units (ie metres/pixel).\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The effective focal length of the lens/mirror this propagator\n        represents. If None, the pixel_scale is taken to be in radians/pixel,\n        else it is taken to be in metres/pixel.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    npixels: int\n    pixel_scale: Array\n\n    def __init__(self: Propagator,\n                 npixels: int,\n                 pixel_scale: Array,\n                 focal_length: Array = None,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for VariableSampling propagators.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel or radians/pixel\n            The pixel scale in the output plane, measured in radians per pixel\n            if focal_length is None, else metres per pixel\n        focal_length : Array = None, metres\n            The focal_length of the lens/mirror this propagator represents.\n            If None, the pixel_scale is taken to be in radians/pixel, else it\n            is taken to be in metres/pixel.\n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        super().__init__(focal_length=focal_length, inverse=inverse)\n\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n        self.npixels = int(npixels)\n\n        if self.pixel_scale.ndim != 0:\n            raise TypeError('pixel_scale must be a scalar.')\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.IMFT(self.npixels, self.pixel_scale,\n                                  focal_length=self.focal_length)\n        else:\n            return wavefront.MFT(self.npixels, self.pixel_scale,\n                                 focal_length=self.focal_length)\n</pre> class MFT(Propagator):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane that is     defined in Cartesian units (ie metres/pixel).      Attributes     ----------     npixels : int         The number of pixels in the output plane.     pixel_scale : Array, metres/pixel or radians/pixel         The pixel scale in the output plane, measured in metres per pixel.     focal_length : Array, metres         The effective focal length of the lens/mirror this propagator         represents. If None, the pixel_scale is taken to be in radians/pixel,         else it is taken to be in metres/pixel.     inverse : bool         Should the propagation be performed in the inverse direction.     \"\"\"     npixels: int     pixel_scale: Array      def __init__(self: Propagator,                  npixels: int,                  pixel_scale: Array,                  focal_length: Array = None,                  inverse: bool = False):         \"\"\"         Constructor for VariableSampling propagators.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array, metres/pixel or radians/pixel             The pixel scale in the output plane, measured in radians per pixel             if focal_length is None, else metres per pixel         focal_length : Array = None, metres             The focal_length of the lens/mirror this propagator represents.             If None, the pixel_scale is taken to be in radians/pixel, else it             is taken to be in metres/pixel.         inverse : bool = False             Should the propagation be performed in the inverse direction.         \"\"\"         super().__init__(focal_length=focal_length, inverse=inverse)          self.pixel_scale = np.asarray(pixel_scale, dtype=float)         self.npixels = int(npixels)          if self.pixel_scale.ndim != 0:             raise TypeError('pixel_scale must be a scalar.')      def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         if self.inverse:             return wavefront.IMFT(self.npixels, self.pixel_scale,                                   focal_length=self.focal_length)         else:             return wavefront.MFT(self.npixels, self.pixel_scale,                                  focal_length=self.focal_length) In\u00a0[\u00a0]: Copied! <pre>class ShiftedMFT(MFT):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in Cartesian units (ie metres/pixel), with a variable output\n    sampling in that plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The effective focal length of the lens/mirror this propagator\n        represents. If None, the pixel_scale is taken to be in radians/pixel,\n        else it is taken to be in metres/pixel.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        If True the shift value is assumed to be in units of pixels, else the\n        physical units of the output plane (ie radians if focal_length is None,\n        else metres). \n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    shift: Array\n    pixel: bool\n\n    def __init__(self: Propagator,\n                 npixels: int,\n                 pixel_scale: Array,\n                 shift: Array,\n                 focal_length: Array = None,\n                 pixel: bool = False,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for VariableSampling propagators.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel or radians/pixel\n            The pixel scale in the output plane, measured in metres or radians\n            per pixel for Cartesian or Angular Wavefront respectively.\n        shift : Array\n            The (x, y) shift to apply to the wavefront in the output plane.\n        focal_length : Array = None, metres\n            The effective focal_length of the lens/mirror this propagator\n            represents. If None, the pixel_scale is taken to be in \n            radians/pixel, else it is taken to be in metres/pixel.\n        pixel : bool = False\n            If True the shift value is assumed to be in units of pixels, else\n            the physical units of the output plane (ie radians if focal_length\n            is None, else metres). \n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        super().__init__(pixel_scale=pixel_scale, npixels=npixels,\n                         focal_length=focal_length, inverse=inverse)\n\n        self.shift = np.asarray(shift, dtype=float)\n        self.pixel = bool(pixel)\n\n        if self.shift.shape != (2,):\n            raise TypeError('shift must be an array of shape (2,).')\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.shifted_IMFT(self.npixels, self.pixel_scale,\n                                          self.shift, self.focal_length, self.pixel)\n        else:\n            return wavefront.shifted_MFT(self.npixels, self.pixel_scale,\n                                         self.shift, self.focal_length, self.pixel)\n</pre> class ShiftedMFT(MFT):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane that is     defined in Cartesian units (ie metres/pixel), with a variable output     sampling in that plane.      Attributes     ----------     npixels : int         The number of pixels in the output plane.     pixel_scale : Array, metres/pixel or radians/pixel         The pixel scale in the output plane, measured in metres per pixel.     focal_length : Array, metres         The effective focal length of the lens/mirror this propagator         represents. If None, the pixel_scale is taken to be in radians/pixel,         else it is taken to be in metres/pixel.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel : bool         If True the shift value is assumed to be in units of pixels, else the         physical units of the output plane (ie radians if focal_length is None,         else metres).      inverse : bool         Should the propagation be performed in the inverse direction.     \"\"\"     shift: Array     pixel: bool      def __init__(self: Propagator,                  npixels: int,                  pixel_scale: Array,                  shift: Array,                  focal_length: Array = None,                  pixel: bool = False,                  inverse: bool = False):         \"\"\"         Constructor for VariableSampling propagators.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array, metres/pixel or radians/pixel             The pixel scale in the output plane, measured in metres or radians             per pixel for Cartesian or Angular Wavefront respectively.         shift : Array             The (x, y) shift to apply to the wavefront in the output plane.         focal_length : Array = None, metres             The effective focal_length of the lens/mirror this propagator             represents. If None, the pixel_scale is taken to be in              radians/pixel, else it is taken to be in metres/pixel.         pixel : bool = False             If True the shift value is assumed to be in units of pixels, else             the physical units of the output plane (ie radians if focal_length             is None, else metres).          inverse : bool = False             Should the propagation be performed in the inverse direction.         \"\"\"         super().__init__(pixel_scale=pixel_scale, npixels=npixels,                          focal_length=focal_length, inverse=inverse)          self.shift = np.asarray(shift, dtype=float)         self.pixel = bool(pixel)          if self.shift.shape != (2,):             raise TypeError('shift must be an array of shape (2,).')      def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         if self.inverse:             return wavefront.shifted_IMFT(self.npixels, self.pixel_scale,                                           self.shift, self.focal_length, self.pixel)         else:             return wavefront.shifted_MFT(self.npixels, self.pixel_scale,                                          self.shift, self.focal_length, self.pixel) In\u00a0[\u00a0]: Copied! <pre>class FarFieldFresnel(ShiftedMFT):\n\"\"\"\n    A propagator class to for Far-Field fresnel propagations. This classes\n    implements algorithms that use quadratic phase factors to better represent\n    out-of-plane behaviour of wavefronts, close to the focal plane. This class\n    is designed to work on Cartesian wavefronts, i.e. pixel units are in\n    metres/pixel in the output plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The focal_length of the lens/mirror this propagator represents.\n    focal_shift : Array, metres\n        The shift in the propagation distance of the wavefront.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or metres, radians). True\n        interprets the shift value in pixel units.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    focal_shift: Array\n\n    def __init__(self: Propagator,\n                 npixels: Array,\n                 pixel_scale: Array,\n                 focal_length: Array,\n                 focal_shift: Array,\n                 shift: Array = np.zeros(2),\n                 pixel: bool = False,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for the CartesianFresnel propagator\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The pixel scale in the output plane, measured in metres per pixel.\n        focal_length : Array, metres\n            The focal_length of the lens/mirror this propagator represents.\n        focal_shift : Array, metres\n            The shift in the propagation distance of the wavefront.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or metres, radians).\n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        if inverse:\n            raise NotImplementedError('Inverse propagation not implemented '\n                                      'for CartesianFresnel.')\n\n        self.focal_shift = np.asarray(focal_shift, dtype=float)\n        if self.focal_shift.ndim != 0:\n            raise TypeError('focal_shift must be a scalar.')\n\n        super().__init__(shift=shift, pixel=pixel, focal_length=focal_length,\n                         pixel_scale=pixel_scale, npixels=npixels, inverse=inverse)\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.shifted_fresnel_prop(self.npixels, self.pixel_scale,\n                                              self.shift, self.focal_length, self.focal_shift, self.pixel)\n</pre> class FarFieldFresnel(ShiftedMFT):     \"\"\"     A propagator class to for Far-Field fresnel propagations. This classes     implements algorithms that use quadratic phase factors to better represent     out-of-plane behaviour of wavefronts, close to the focal plane. This class     is designed to work on Cartesian wavefronts, i.e. pixel units are in     metres/pixel in the output plane.      Attributes     ----------     npixels : int         The number of pixels in the output plane.     pixel_scale : Array, metres/pixel         The pixel scale in the output plane, measured in metres per pixel.     focal_length : Array, metres         The focal_length of the lens/mirror this propagator represents.     focal_shift : Array, metres         The shift in the propagation distance of the wavefront.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel : bool         Should the shift value be considered in units of pixels, or in the         physical units of the output plane (ie pixels or metres, radians). True         interprets the shift value in pixel units.     inverse : bool         Should the propagation be performed in the inverse direction.     \"\"\"     focal_shift: Array      def __init__(self: Propagator,                  npixels: Array,                  pixel_scale: Array,                  focal_length: Array,                  focal_shift: Array,                  shift: Array = np.zeros(2),                  pixel: bool = False,                  inverse: bool = False):         \"\"\"         Constructor for the CartesianFresnel propagator          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array, metres/pixel             The pixel scale in the output plane, measured in metres per pixel.         focal_length : Array, metres             The focal_length of the lens/mirror this propagator represents.         focal_shift : Array, metres             The shift in the propagation distance of the wavefront.         shift : Array = np.array([0., 0.])             The (x, y) shift to apply to the wavefront in the output plane.         pixel : bool = False             Should the shift value be considered in units of pixel, or in the             physical units of the output plane (ie pixels or metres, radians).         inverse : bool = False             Should the propagation be performed in the inverse direction.         \"\"\"         if inverse:             raise NotImplementedError('Inverse propagation not implemented '                                       'for CartesianFresnel.')          self.focal_shift = np.asarray(focal_shift, dtype=float)         if self.focal_shift.ndim != 0:             raise TypeError('focal_shift must be a scalar.')          super().__init__(shift=shift, pixel=pixel, focal_length=focal_length,                          pixel_scale=pixel_scale, npixels=npixels, inverse=inverse)      def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:         \"\"\"         Applies the layer to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The transformed wavefront.         \"\"\"         return wavefront.shifted_fresnel_prop(self.npixels, self.pixel_scale,                                               self.shift, self.focal_length, self.focal_shift, self.pixel)"},{"location":"dLux/sources/","title":"Sources","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax.scipy.signal import convolve\nfrom jax import vmap, Array\nfrom zodiax import Base\nfrom abc import abstractmethod\nimport dLux\n\n__all__ = [\n    \"PointSource\",\n    \"PointSources\",\n    \"BinarySource\",\n    \"ResolvedSource\",\n    \"PointResolvedSource\"]\n</pre> from __future__ import annotations import jax.numpy as np from jax.scipy.signal import convolve from jax import vmap, Array from zodiax import Base from abc import abstractmethod import dLux  __all__ = [     \"PointSource\",     \"PointSources\",     \"BinarySource\",     \"ResolvedSource\",     \"PointResolvedSource\"]  In\u00a0[\u00a0]: Copied! <pre>class BaseSource(Base):\n    # TODO: Add this to allow custom sources\n\n    @abstractmethod\n    def normalise(self):  # pragma: no cover\n        pass\n\n    @abstractmethod\n    def model(self, optics, detector=None):  # pragma: no cover\n        pass\n\n\nclass Source(BaseSource):\n\"\"\"\n    Base class for source objects. The idea of these source classes is to allow\n    an arbitrary parametrisation of the underlying astrophysical objects. Each\n    source object requires a normalise(), format_inputs(), and model() methods,\n    along with the regular getter and setter methods.\n\n    The normalise() method should return a new instance of the class with all\n    the appropriate attributes normalised (ie spectral weights, resolved source\n    distribution).\n\n    The format_inputs() method should return the relevant wavelengths, weights,\n    positions etc., that are correctly formatted to be used by the model()\n    method. This should primarily interface with the spectrum object, and should\n    call the normalise() method.\n\n    The model() method should return a single psf of the source. This is done\n    inside the source object so that each class can be arbitrarily\n    parameterised as required. This method should call the format_inputs()\n    method.\n\n    A series of parametrisations have been provided to model a series of\n    different astrophysical objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    position: Array\n    flux: Array\n    spectrum: Spectrum\n\n    def __init__(self: Source,\n                 wavelengths: Array,\n                 position: Array = np.zeros(2),\n                 flux: Array = np.array(1.),\n                 weights: Array = None,\n                 spectrum: Spectrum = None,\n                 ):\n\"\"\"\n        Constructor for the Source class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined. Defaults\n            to a PointSource with a flat spectrum.\n        position : Array, radians = None\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = None\n            The flux of the object.\n        weights : Array = None\n            The spectral weights of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n            if provided it will overwrite the inputs wavelengths and weights.\n\n        \"\"\"\n        # Position and Flux\n        self.position = np.asarray(position, dtype=float)\n        self.flux = np.asarray(flux, dtype=float)\n\n        if self.position.shape != (2,):\n            raise ValueError(\"position must be a 1d array of shape (2,).\")\n\n        if self.flux.shape != ():\n            raise ValueError(\"flux must be a scalar, i.e. shape == ().\")\n\n        # Spectrum\n        if spectrum is not None:\n            if not isinstance(spectrum, dLux.spectra.Spectrum):\n                raise ValueError(\"spectrum must be a dLux Spectrum object.\")\n            self.spectrum = spectrum\n        else:\n            self.spectrum = dLux.spectra.Spectrum(wavelengths, weights)\n\n    def __getattr__(self: Source, key: str) -&gt; Any:\n\"\"\"\n        Getter method for the spectrum object.\n\n        Parameters\n        ----------\n        key : str\n            The key to get from the spectrum object.\n\n        Returns\n        -------\n        value : Any\n            The value of the key.\n        \"\"\"\n        if hasattr(self.spectrum, key):\n            return getattr(self.spectrum, key)\n        else:\n            raise AttributeError(f\"{self.__class__.__name__} has no \"\n                                 f\"attribute {key}.\")\n\n    def normalise(self: Source) -&gt; Source:\n\"\"\"\n        Method for returning a new normalised source object.\n\n        Returns\n        -------\n        source : Source\n            The normalised source object.\n        \"\"\"\n        norm_spectrum = self.spectrum.normalise()\n        return self.set('spectrum', norm_spectrum)\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the source modelled through the optics.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights * self.flux\n        return optics.propagate(self.wavelengths, self.position, weights)\n\n\nclass RelativeFluxSource(Source):\n\"\"\"\n    Abstract class that extend the methods of Source to allow for binary-object\n    sources to be parameterised by their relative flux. Classes that inherit\n    from this class must instantiate a contrast attribute.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    contrast: Array\n\n    def __init__(self: Source,\n                 contrast: Array,\n                 **kwargs):\n\"\"\"\n        Constructor for the RelativeFluxSource class.\n\n        Parameters\n        ----------\n        contrast : Array\n            The contrast ratio between the two sources.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.contrast = np.asarray(contrast, dtype=float)\n\n        if self.contrast.shape != ():\n            raise ValueError(\"contrast must have shape ().\")\n\n    @property\n    def fluxes(self: Source) -&gt; Array:\n\"\"\"\n        Getter method for the fluxes. This parametrises the source such that\n        flux refers to the mean_flux and contrast is defined as the ratio of\n        the flux of the first entry divided by the second entry.\n\n        Returns\n        -------\n        flux : Array, photons\n            The flux (flux1, flux2) of the binary object.\n        \"\"\"\n        flux_A = 2 * self.contrast * self.flux / (1 + self.contrast)\n        flux_B = 2 * self.flux / (1 + self.contrast)\n        return np.array([flux_A, flux_B])\n\n\nclass RelativePositionSource(Source):\n\"\"\"\n    Abstract class that extend the methods of Source to allow for binary-object\n    sources to be parameterised by their relative position. Classes that\n    inherit from this class must instantiate a separation attribute.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The field angle between the two sources measure from the positive\n        x-axis.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    separation: Array\n    position_angle: Array\n\n    def __init__(self: Source,\n                 separation: Array,\n                 position_angle: Array,\n                 **kwargs):\n\"\"\"\n        Constructor for the RelativePositionSource class.\n\n        Parameters\n        ----------\n        separation : Array, radians\n            The separation of the two sources in radians.\n        position_angle : Array, radians\n            The field angle between the two sources measure from the positive\n            x-axis.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.separation = np.asarray(separation, dtype=float)\n        self.position_angle = np.asarray(position_angle, dtype=float)\n\n        if self.separation.shape != ():\n            raise ValueError(\"separation must have shape ().\")\n\n        if self.position_angle.shape != ():\n            raise ValueError(\"position_angle must have shape ().\")\n\n    @property\n    def positions(self: Source) -&gt; Array:\n\"\"\"\n        Getter method for the position.\n\n        Returns\n        -------\n        position : Array, radians\n            The ((x, y), (x, y)) on-sky position of this object.\n        \"\"\"\n        r, phi = self.separation / 2, self.position_angle\n        sep_vec = np.array([r * np.sin(phi), r * np.cos(phi)])\n        return np.array([self.position + sep_vec,\n                         self.position - sep_vec])\n</pre> class BaseSource(Base):     # TODO: Add this to allow custom sources      @abstractmethod     def normalise(self):  # pragma: no cover         pass      @abstractmethod     def model(self, optics, detector=None):  # pragma: no cover         pass   class Source(BaseSource):     \"\"\"     Base class for source objects. The idea of these source classes is to allow     an arbitrary parametrisation of the underlying astrophysical objects. Each     source object requires a normalise(), format_inputs(), and model() methods,     along with the regular getter and setter methods.      The normalise() method should return a new instance of the class with all     the appropriate attributes normalised (ie spectral weights, resolved source     distribution).      The format_inputs() method should return the relevant wavelengths, weights,     positions etc., that are correctly formatted to be used by the model()     method. This should primarily interface with the spectrum object, and should     call the normalise() method.      The model() method should return a single psf of the source. This is done     inside the source object so that each class can be arbitrarily     parameterised as required. This method should call the format_inputs()     method.      A series of parametrisations have been provided to model a series of     different astrophysical objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     \"\"\"     position: Array     flux: Array     spectrum: Spectrum      def __init__(self: Source,                  wavelengths: Array,                  position: Array = np.zeros(2),                  flux: Array = np.array(1.),                  weights: Array = None,                  spectrum: Spectrum = None,                  ):         \"\"\"         Constructor for the Source class.          Parameters         ----------         wavelengths : Array, metres             The array of wavelengths at which the spectrum is defined. Defaults             to a PointSource with a flat spectrum.         position : Array, radians = None             The (x, y) on-sky position of this object.         flux : Array, photons = None             The flux of the object.         weights : Array = None             The spectral weights of the object.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.             if provided it will overwrite the inputs wavelengths and weights.          \"\"\"         # Position and Flux         self.position = np.asarray(position, dtype=float)         self.flux = np.asarray(flux, dtype=float)          if self.position.shape != (2,):             raise ValueError(\"position must be a 1d array of shape (2,).\")          if self.flux.shape != ():             raise ValueError(\"flux must be a scalar, i.e. shape == ().\")          # Spectrum         if spectrum is not None:             if not isinstance(spectrum, dLux.spectra.Spectrum):                 raise ValueError(\"spectrum must be a dLux Spectrum object.\")             self.spectrum = spectrum         else:             self.spectrum = dLux.spectra.Spectrum(wavelengths, weights)      def __getattr__(self: Source, key: str) -&gt; Any:         \"\"\"         Getter method for the spectrum object.          Parameters         ----------         key : str             The key to get from the spectrum object.          Returns         -------         value : Any             The value of the key.         \"\"\"         if hasattr(self.spectrum, key):             return getattr(self.spectrum, key)         else:             raise AttributeError(f\"{self.__class__.__name__} has no \"                                  f\"attribute {key}.\")      def normalise(self: Source) -&gt; Source:         \"\"\"         Method for returning a new normalised source object.          Returns         -------         source : Source             The normalised source object.         \"\"\"         norm_spectrum = self.spectrum.normalise()         return self.set('spectrum', norm_spectrum)      def model(self: Source, optics: Optics) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.          Returns         -------         psf : Array             The PSF of the source modelled through the optics.         \"\"\"         self = self.normalise()         weights = self.weights * self.flux         return optics.propagate(self.wavelengths, self.position, weights)   class RelativeFluxSource(Source):     \"\"\"     Abstract class that extend the methods of Source to allow for binary-object     sources to be parameterised by their relative flux. Classes that inherit     from this class must instantiate a contrast attribute.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     contrast : Array         The contrast ratio between the two sources.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     \"\"\"     contrast: Array      def __init__(self: Source,                  contrast: Array,                  **kwargs):         \"\"\"         Constructor for the RelativeFluxSource class.          Parameters         ----------         contrast : Array             The contrast ratio between the two sources.         \"\"\"         super().__init__(**kwargs)         self.contrast = np.asarray(contrast, dtype=float)          if self.contrast.shape != ():             raise ValueError(\"contrast must have shape ().\")      @property     def fluxes(self: Source) -&gt; Array:         \"\"\"         Getter method for the fluxes. This parametrises the source such that         flux refers to the mean_flux and contrast is defined as the ratio of         the flux of the first entry divided by the second entry.          Returns         -------         flux : Array, photons             The flux (flux1, flux2) of the binary object.         \"\"\"         flux_A = 2 * self.contrast * self.flux / (1 + self.contrast)         flux_B = 2 * self.flux / (1 + self.contrast)         return np.array([flux_A, flux_B])   class RelativePositionSource(Source):     \"\"\"     Abstract class that extend the methods of Source to allow for binary-object     sources to be parameterised by their relative position. Classes that     inherit from this class must instantiate a separation attribute.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     separation : Array, radians         The separation of the two sources in radians.     position_angle : Array, radians         The field angle between the two sources measure from the positive         x-axis.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     \"\"\"     separation: Array     position_angle: Array      def __init__(self: Source,                  separation: Array,                  position_angle: Array,                  **kwargs):         \"\"\"         Constructor for the RelativePositionSource class.          Parameters         ----------         separation : Array, radians             The separation of the two sources in radians.         position_angle : Array, radians             The field angle between the two sources measure from the positive             x-axis.         \"\"\"         super().__init__(**kwargs)         self.separation = np.asarray(separation, dtype=float)         self.position_angle = np.asarray(position_angle, dtype=float)          if self.separation.shape != ():             raise ValueError(\"separation must have shape ().\")          if self.position_angle.shape != ():             raise ValueError(\"position_angle must have shape ().\")      @property     def positions(self: Source) -&gt; Array:         \"\"\"         Getter method for the position.          Returns         -------         position : Array, radians             The ((x, y), (x, y)) on-sky position of this object.         \"\"\"         r, phi = self.separation / 2, self.position_angle         sep_vec = np.array([r * np.sin(phi), r * np.cos(phi)])         return np.array([self.position + sep_vec,                          self.position - sep_vec])  In\u00a0[\u00a0]: Copied! <pre>class PointSource(Source):\n\"\"\"\n    Concrete Class for unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n\nclass PointSources(Source):\n\"\"\"\n    Concrete Class for multiple unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky positions of these sources.\n    flux : Array, photons\n        The fluxes of the sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array,\n                 position: Array = np.zeros(2),\n                 flux: Array = None,\n                 weights: Array = None,\n                 spectrum: Spectrum = None):\n\"\"\"\n        Constructor for the PointSources class.\n\n        Parameters\n        ----------\n        position : Array, radians\n            The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.\n        flux : Array, photons = None\n            The fluxes of the sources.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n            Every source in this class will have an identical spectrum.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        super().__init__(spectrum=spectrum, wavelengths=wavelengths,\n                         weights=weights)\n\n        # More complex parameter checks here because of extra dims\n        self.position = np.asarray(position, dtype=float)\n        if self.position.ndim != 2:\n            raise ValueError(\"position must be a 2d array.\")\n\n        if flux is None:\n            self.flux = np.ones(len(self.position))\n        else:\n            self.flux = np.asarray(flux, dtype=float)\n\n            if self.flux.ndim != 1:\n                raise ValueError(\"flux must be a 1d array.\")\n\n            if len(self.flux) != len(self.position):\n                raise ValueError(\"Length of flux must be equal to length of \"\n                                 \"position.\")\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the source modelled through the optics.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights[None, :] * self.flux[:, None]\n        propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n        return propagator(self.wavelengths, self.position, weights).sum(0)\n\n\nclass ResolvedSource(Source):\n\"\"\"\n    A class for modelling resolved sources that parametrise their resolved\n    component using an array of intensities.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    \"\"\"\n    distribution: Array\n\n    def __init__(self: Source,\n                 wavelengths: Array,\n                 position: Array = np.zeros(2),\n                 flux: Array = np.array(1.),\n                 distribution: Array = np.ones((3, 3)),\n                 weights: Array = None,\n                 spectrum: Spectrum = None):\n\"\"\"\n        Constructor for the ResolvedSource class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        distribution = np.asarray(distribution, dtype=float)\n        self.distribution = distribution / distribution.sum()\n\n        if self.distribution.ndim != 2:\n            raise ValueError(\"distribution must be a 2d array.\")\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum,\n                         wavelengths=wavelengths, weights=weights)\n\n    def normalise(self: Source) -&gt; Source:\n\"\"\"\n        Method for returning a new source object with a normalised total\n        spectrum and source distribution.\n\n        Returns\n        -------\n        source : Source\n            The source object with the normalised spectrum and distribution.\n        \"\"\"\n        spectrum = self.spectrum.normalise()\n        distribution_floor = np.maximum(self.distribution, 0.)\n        distribution = distribution_floor / distribution_floor.sum()\n        return self.set(['spectrum', 'distribution'], [spectrum, distribution])\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self = self.normalise()\n        psf = optics.propagate(self.wavelengths, self.position, self.weights)\n        convolved = convolve(psf, self.distribution, mode='same')\n        return self.flux * convolved\n\n\nclass BinarySource(RelativePositionSource, RelativeFluxSource):\n\"\"\"\n    A parameterised binary source.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the sources.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a CombinedSpectrum object.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array = None,\n                 position: Array = np.array([0., 0.]),\n                 flux: Array = np.array(1.),\n                 separation: Array = None,\n                 position_angle: Array = np.pi / 2,\n                 contrast: Array = np.array(1.),\n                 spectrum: Spectrum = None,\n                 weights: Array = None):\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the sources.\n        separation : Array, radians = None\n            The separation of the two sources in radians.\n        position_angle : Array, radians = np.pi/2\n            The position angle between the two sources measured clockwise from\n            the vertical axis.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the two sources.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        wavelengths = np.asarray(wavelengths, dtype=float)\n        if weights is None:\n            weights = np.ones((2, len(wavelengths)))\n\n        super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                         separation=separation, position_angle=position_angle,\n                         contrast=contrast, spectrum=spectrum, weights=weights)\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the source modelled through the optics.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights * self.fluxes[:, None]\n        propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n        return propagator(self.wavelengths, self.positions, weights).sum(0)\n\n\nclass PointResolvedSource(RelativeFluxSource, ResolvedSource):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source. An example would be an unresolved star with\n    a resolved dust shell or debris disk. These two objects share the same\n    spectra but have their fluxes defined by flux (the mean flux) and the flux\n    ratio (contrast) between the point source and resolved distribution. The\n    resolved component is defined by an array (ie this class inherits from\n    ResolvedSource).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolved source.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array = None,\n                 position: Array = np.zeros(2),\n                 flux: Array = np.array(1.),\n                 distribution: Array = np.ones((3, 3)),\n                 contrast: Array = np.array(1.),\n                 spectrum: Spectrum = None,\n                 weights: Array = None) -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the point and resolved source.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                         distribution=distribution, spectrum=spectrum, weights=weights,\n                         contrast=contrast)\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self = self.normalise()\n        psf = optics.propagate(self.wavelengths, self.position, self.weights)\n        convolved = convolve(psf, self.distribution, mode='same')\n        return self.fluxes[0] * psf + self.fluxes[1] * convolved\n</pre> class PointSource(Source):     \"\"\"     Concrete Class for unresolved point source objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     \"\"\"   class PointSources(Source):     \"\"\"     Concrete Class for multiple unresolved point source objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky positions of these sources.     flux : Array, photons         The fluxes of the sources.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.         Every source in this class will have an identical spectrum.     \"\"\"      def __init__(self: Source,                  wavelengths: Array,                  position: Array = np.zeros(2),                  flux: Array = None,                  weights: Array = None,                  spectrum: Spectrum = None):         \"\"\"         Constructor for the PointSources class.          Parameters         ----------         position : Array, radians             The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.         flux : Array, photons = None             The fluxes of the sources.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.             Every source in this class will have an identical spectrum.         wavelengths : Array, metres = None             The array of wavelengths at which the spectrum is defined.         \"\"\"         super().__init__(spectrum=spectrum, wavelengths=wavelengths,                          weights=weights)          # More complex parameter checks here because of extra dims         self.position = np.asarray(position, dtype=float)         if self.position.ndim != 2:             raise ValueError(\"position must be a 2d array.\")          if flux is None:             self.flux = np.ones(len(self.position))         else:             self.flux = np.asarray(flux, dtype=float)              if self.flux.ndim != 1:                 raise ValueError(\"flux must be a 1d array.\")              if len(self.flux) != len(self.position):                 raise ValueError(\"Length of flux must be equal to length of \"                                  \"position.\")      def model(self: Source, optics: Optics) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.          Returns         -------         psf : Array             The PSF of the source modelled through the optics.         \"\"\"         self = self.normalise()         weights = self.weights[None, :] * self.flux[:, None]         propagator = vmap(optics.propagate, in_axes=(None, 0, 0))         return propagator(self.wavelengths, self.position, weights).sum(0)   class ResolvedSource(Source):     \"\"\"     A class for modelling resolved sources that parametrise their resolved     component using an array of intensities.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     distribution : Array         The array of intensities representing the resolved source.     \"\"\"     distribution: Array      def __init__(self: Source,                  wavelengths: Array,                  position: Array = np.zeros(2),                  flux: Array = np.array(1.),                  distribution: Array = np.ones((3, 3)),                  weights: Array = None,                  spectrum: Spectrum = None):         \"\"\"         Constructor for the ResolvedSource class.          Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The flux of the object.         distribution : Array = np.ones((3, 3))             The array of intensities representing the resolved source.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         wavelengths : Array, metres = None             The array of wavelengths at which the spectrum is defined.         \"\"\"         distribution = np.asarray(distribution, dtype=float)         self.distribution = distribution / distribution.sum()          if self.distribution.ndim != 2:             raise ValueError(\"distribution must be a 2d array.\")          super().__init__(position=position, flux=flux, spectrum=spectrum,                          wavelengths=wavelengths, weights=weights)      def normalise(self: Source) -&gt; Source:         \"\"\"         Method for returning a new source object with a normalised total         spectrum and source distribution.          Returns         -------         source : Source             The source object with the normalised spectrum and distribution.         \"\"\"         spectrum = self.spectrum.normalise()         distribution_floor = np.maximum(self.distribution, 0.)         distribution = distribution_floor / distribution_floor.sum()         return self.set(['spectrum', 'distribution'], [spectrum, distribution])      def model(self: Source, optics: Optics) -&gt; Array:         \"\"\"         Method to model the psf of the source through the optics. Implements a         basic convolution with the psf and source distribution.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.          Returns         -------         psf : Array             The psf of the source modelled through the optics.         \"\"\"         # Normalise and get parameters         self = self.normalise()         psf = optics.propagate(self.wavelengths, self.position, self.weights)         convolved = convolve(psf, self.distribution, mode='same')         return self.flux * convolved   class BinarySource(RelativePositionSource, RelativeFluxSource):     \"\"\"     A parameterised binary source.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The mean flux of the sources.     separation : Array, radians         The separation of the two sources in radians.     position_angle : Array, radians         The position angle between the two sources measured clockwise from         the vertical axis.     contrast : Array         The contrast ratio between the two sources.     spectrum : Spectrum         The spectrum of this object, represented by a CombinedSpectrum object.     \"\"\"      def __init__(self: Source,                  wavelengths: Array = None,                  position: Array = np.array([0., 0.]),                  flux: Array = np.array(1.),                  separation: Array = None,                  position_angle: Array = np.pi / 2,                  contrast: Array = np.array(1.),                  spectrum: Spectrum = None,                  weights: Array = None):         \"\"\"         Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The mean flux of the sources.         separation : Array, radians = None             The separation of the two sources in radians.         position_angle : Array, radians = np.pi/2             The position angle between the two sources measured clockwise from             the vertical axis.         contrast : Array = np.array(1.)             The contrast ratio between the two sources.         spectrum : CombinedSpectrum = None             The spectrum of this object, represented by a CombinedSpectrum.         wavelengths : Array, metres = None             The array of wavelengths at which the spectrum is defined.         \"\"\"         wavelengths = np.asarray(wavelengths, dtype=float)         if weights is None:             weights = np.ones((2, len(wavelengths)))          super().__init__(wavelengths=wavelengths, position=position, flux=flux,                          separation=separation, position_angle=position_angle,                          contrast=contrast, spectrum=spectrum, weights=weights)      def model(self: Source, optics: Optics) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.          Returns         -------         psf : Array             The PSF of the source modelled through the optics.         \"\"\"         self = self.normalise()         weights = self.weights * self.fluxes[:, None]         propagator = vmap(optics.propagate, in_axes=(None, 0, 0))         return propagator(self.wavelengths, self.positions, weights).sum(0)   class PointResolvedSource(RelativeFluxSource, ResolvedSource):     \"\"\"     A class for modelling a point source and a resolved source that is defined     relative to the point source. An example would be an unresolved star with     a resolved dust shell or debris disk. These two objects share the same     spectra but have their fluxes defined by flux (the mean flux) and the flux     ratio (contrast) between the point source and resolved distribution. The     resolved component is defined by an array (ie this class inherits from     ResolvedSource).      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The mean flux of the point and resolved source.     distribution : Array         The array of intensities representing the resolved source.     contrast : Array         The contrast ratio between the point source and the resolved         source.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     \"\"\"      def __init__(self: Source,                  wavelengths: Array = None,                  position: Array = np.zeros(2),                  flux: Array = np.array(1.),                  distribution: Array = np.ones((3, 3)),                  contrast: Array = np.array(1.),                  spectrum: Spectrum = None,                  weights: Array = None) -&gt; Source:         \"\"\"         Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The mean flux of the point and resolved source.         distribution : Array = np.ones((3, 3))             The array of intensities representing the resolved source.         contrast : Array = np.array(1.)             The contrast ratio between the point source and the resolved             source.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         wavelengths : Array, metres = None             The array of wavelengths at which the spectrum is defined.         \"\"\"         super().__init__(wavelengths=wavelengths, position=position, flux=flux,                          distribution=distribution, spectrum=spectrum, weights=weights,                          contrast=contrast)      def model(self: Source, optics: Optics) -&gt; Array:         \"\"\"         Method to model the psf of the source through the optics. Implements a         basic convolution with the psf and source distribution, while also         modelling the single point source psf.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.          Returns         -------         psf : Array             The psf of the source modelled through the optics.         \"\"\"         # Normalise and get parameters         self = self.normalise()         psf = optics.propagate(self.wavelengths, self.position, self.weights)         convolved = convolve(psf, self.distribution, mode='same')         return self.fluxes[0] * psf + self.fluxes[1] * convolved"},{"location":"dLux/sources/#private-classes","title":"Private Classes\u00b6","text":"<p>######################</p>"},{"location":"dLux/sources/#concrete-classes","title":"Concrete Classes\u00b6","text":"<p>#######################</p>"},{"location":"dLux/spectra/","title":"Spectra","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import abstractmethod\nimport jax.numpy as np\nfrom zodiax import Base\nfrom jax import vmap, Array\n</pre> from __future__ import annotations from abc import abstractmethod import jax.numpy as np from zodiax import Base from jax import vmap, Array In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"Spectrum\", \"PolySpectrum\"]\n</pre> __all__ = [\"Spectrum\", \"PolySpectrum\"] In\u00a0[\u00a0]: Copied! <pre>class BaseSpectrum(Base):\n\"\"\"\n    Abstract base class for arbitrary spectral parametrisations.\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    \"\"\"\n    wavelengths: Array\n\n    def __init__(self: Spectrum,\n                 wavelengths: Array):\n\"\"\"\n        Constructor for the Spectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        self.wavelengths = np.asarray(wavelengths, dtype=float)\n        super().__init__()\n\n    @abstractmethod\n    def normalise(self: Spectrum) -&gt; Spectrum:  # pragma: no cover\n\"\"\"\n        Abstract method to normalise the spectrum. Must be overwritten by child\n        classes.\n        \"\"\"\n</pre> class BaseSpectrum(Base):     \"\"\"     Abstract base class for arbitrary spectral parametrisations.      Attributes     ----------     wavelengths : Array, metres         The array of wavelengths at which the spectrum is defined.     \"\"\"     wavelengths: Array      def __init__(self: Spectrum,                  wavelengths: Array):         \"\"\"         Constructor for the Spectrum class.          Parameters         ----------         wavelengths : Array, metres             The array of wavelengths at which the spectrum is defined.         \"\"\"         self.wavelengths = np.asarray(wavelengths, dtype=float)         super().__init__()      @abstractmethod     def normalise(self: Spectrum) -&gt; Spectrum:  # pragma: no cover         \"\"\"         Abstract method to normalise the spectrum. Must be overwritten by child         classes.         \"\"\" In\u00a0[\u00a0]: Copied! <pre>class Spectrum(BaseSpectrum):\n\"\"\"\n    A Spectrum class that internally parametrises the spectrum via arrays (i.e.\n    wavelengths and weights)\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array\n        The relative weights of each wavelength.\n    \"\"\"\n    weights: Array\n\n    def __init__(self: Spectrum,\n                 wavelengths: Array,\n                 weights: Array = None):\n\"\"\"\n        Constructor for the Spectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        weights : Array = None\n            The relative weights of each wavelength. Defaults to uniform\n            spectrum. Weights are automatically normalised to a sum of 1.\n        \"\"\"\n        super().__init__(wavelengths)\n        if weights is None:\n            in_shape = self.wavelengths.shape\n            weights = np.ones(in_shape) / in_shape[-1]\n\n        weights = np.asarray(weights, dtype=float)\n        if weights.ndim == 2:\n            self.weights = weights / weights.sum(-1)[:, None]\n        else:\n            self.weights = weights / weights.sum()\n\n        if self.weights.ndim == 1:\n            if self.wavelengths.shape != self.weights.shape:\n                raise ValueError(\"wavelengths and weights must have the same \"\n                                 \"shape.\")\n        else:\n            if self.wavelengths.shape != self.weights.shape[-1:]:\n                raise ValueError(\"wavelengths and weights must have the same \"\n                                 \"shape.\")\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum.\n\n        Returns\n        -------\n        spectrum : Spectrum\n            The spectrum object with the normalised spectrum.\n        \"\"\"\n        if self.weights.ndim == 2:\n            weight_sum = self.weights.sum(-1)[:, None]\n        else:\n            weight_sum = self.weights.sum()\n        return self.divide('weights', weight_sum)\n</pre> class Spectrum(BaseSpectrum):     \"\"\"     A Spectrum class that internally parametrises the spectrum via arrays (i.e.     wavelengths and weights)      Attributes     ----------     wavelengths : Array, metres         The array of wavelengths at which the spectrum is defined.     weights : Array         The relative weights of each wavelength.     \"\"\"     weights: Array      def __init__(self: Spectrum,                  wavelengths: Array,                  weights: Array = None):         \"\"\"         Constructor for the Spectrum class.          Parameters         ----------         wavelengths : Array, metres             The array of wavelengths at which the spectrum is defined.         weights : Array = None             The relative weights of each wavelength. Defaults to uniform             spectrum. Weights are automatically normalised to a sum of 1.         \"\"\"         super().__init__(wavelengths)         if weights is None:             in_shape = self.wavelengths.shape             weights = np.ones(in_shape) / in_shape[-1]          weights = np.asarray(weights, dtype=float)         if weights.ndim == 2:             self.weights = weights / weights.sum(-1)[:, None]         else:             self.weights = weights / weights.sum()          if self.weights.ndim == 1:             if self.wavelengths.shape != self.weights.shape:                 raise ValueError(\"wavelengths and weights must have the same \"                                  \"shape.\")         else:             if self.wavelengths.shape != self.weights.shape[-1:]:                 raise ValueError(\"wavelengths and weights must have the same \"                                  \"shape.\")      def normalise(self: Spectrum) -&gt; Spectrum:         \"\"\"         Method for returning a new spectrum object with a normalised total         spectrum.          Returns         -------         spectrum : Spectrum             The spectrum object with the normalised spectrum.         \"\"\"         if self.weights.ndim == 2:             weight_sum = self.weights.sum(-1)[:, None]         else:             weight_sum = self.weights.sum()         return self.divide('weights', weight_sum) In\u00a0[\u00a0]: Copied! <pre>class PolySpectrum(BaseSpectrum):\n\"\"\"\n    Implements a generic polynomial spectrum. This is likely not needed and\n    will probably just be turned into LinearSpectrum in the future.\n\n    This implements a polynomial as follows:\n    f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    \"\"\"\n    coefficients: Array\n\n    def __init__(self: Spectrum,\n                 wavelengths: Array,\n                 coefficients: Array):\n\"\"\"\n        Constructor for the PolySpectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        coefficients : Array\n            The array of polynomial coefficient values.\n        \"\"\"\n        super().__init__(wavelengths)\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n        if self.coefficients.ndim != 1:\n            raise ValueError(\"Coefficients must be a 1d array.\")\n\n    def _eval_weight(self, wavelength):\n        return np.array([self.coefficients[i] * wavelength ** i\n                         for i in range(len(self.coefficients))]).sum()\n\n    @property\n    def weights(self: Spectrum) -&gt; Array:\n\"\"\"\n        Gets the relative spectral weights by evaluating the polynomial\n        function at the internal wavelengths. This automatically normalises\n        the weights to have unitary amplitude.\n\n        Returns\n        -------\n        weights : Array\n            The normalised relative weights of each wavelength.\n        \"\"\"\n        weights = vmap(self._eval_weight)(self.wavelengths)\n        return weights / weights.sum()\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n        Calculated weights are automatically normalised, but could be\n        calculated from the shift term (ie b in y = mx + b) \n\n        Returns\n        --------\n        spectrum : Spectrum\n            The unmodified spectrum object\n        \"\"\"\n        return self\n</pre> class PolySpectrum(BaseSpectrum):     \"\"\"     Implements a generic polynomial spectrum. This is likely not needed and     will probably just be turned into LinearSpectrum in the future.      This implements a polynomial as follows:     f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n      Attributes     ----------     wavelengths : Array, metres         The array of wavelengths at which the spectrum is defined.     coefficients : Array         The array of polynomial coefficient values.     \"\"\"     coefficients: Array      def __init__(self: Spectrum,                  wavelengths: Array,                  coefficients: Array):         \"\"\"         Constructor for the PolySpectrum class.          Parameters         ----------         wavelengths : Array, metres             The array of wavelengths at which the spectrum is defined.         coefficients : Array             The array of polynomial coefficient values.         \"\"\"         super().__init__(wavelengths)         self.coefficients = np.asarray(coefficients, dtype=float)          if self.coefficients.ndim != 1:             raise ValueError(\"Coefficients must be a 1d array.\")      def _eval_weight(self, wavelength):         return np.array([self.coefficients[i] * wavelength ** i                          for i in range(len(self.coefficients))]).sum()      @property     def weights(self: Spectrum) -&gt; Array:         \"\"\"         Gets the relative spectral weights by evaluating the polynomial         function at the internal wavelengths. This automatically normalises         the weights to have unitary amplitude.          Returns         -------         weights : Array             The normalised relative weights of each wavelength.         \"\"\"         weights = vmap(self._eval_weight)(self.wavelengths)         return weights / weights.sum()      def normalise(self: Spectrum) -&gt; Spectrum:         \"\"\"         Calculated weights are automatically normalised, but could be         calculated from the shift term (ie b in y = mx + b)           Returns         --------         spectrum : Spectrum             The unmodified spectrum object         \"\"\"         return self"},{"location":"dLux/wavefronts/","title":"Wavefronts","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax import vmap, Array\nfrom zodiax import Base\nimport dLux.utils as dlu\nimport dLux\n</pre> from __future__ import annotations import jax.numpy as np from jax import vmap, Array from zodiax import Base import dLux.utils as dlu import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"Wavefront\", \"FresnelWavefront\"]\n</pre> __all__ = [\"Wavefront\", \"FresnelWavefront\"] In\u00a0[\u00a0]: Copied! <pre>Aberration = lambda: dLux.optical_layers.AberrationLayer\nAperture = lambda: dLux.apertures.ApertureLayer\nPropagator = lambda: dLux.propagators.Propagator\nOpticalLayer = lambda: dLux.optical_layers.OpticalLayer\n</pre> Aberration = lambda: dLux.optical_layers.AberrationLayer Aperture = lambda: dLux.apertures.ApertureLayer Propagator = lambda: dLux.propagators.Propagator OpticalLayer = lambda: dLux.optical_layers.OpticalLayer In\u00a0[\u00a0]: Copied! <pre>class Wavefront(Base):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    two helper parameters, plane and units.\n\n    All wavefronts currently only support square amplitude and phase arrays.\n\n    Attributes\n    ----------\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, metres/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        can be in units of either metres per pixel or radians per pixel\n        depending on if 'unit' is 'Cartesian' or 'Angular'.\n    plane : str\n        The current plane type of wavefront, can be 'Pupil', 'Focal' or\n        'Intermediate'.\n    units : str\n        The current units of the wavefront, can be 'Cartesian' or 'Angular'.\n    \"\"\"\n    wavelength: Array\n    pixel_scale: Array\n    amplitude: Array\n    phase: Array\n    plane: str\n    units: str\n\n    def __init__(self: Wavefront,\n                 npixels: int,\n                 diameter: Array,\n                 wavelength: Array):\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        diameter : float, metres\n            The physical dimensions of each square pixel.\n        wavelength : float, metres\n            The wavelength of the `Wavefront`.\n        \"\"\"\n        self.wavelength = np.asarray(wavelength, dtype=float)\n        self.pixel_scale = np.asarray(diameter / npixels, dtype=float)\n        self.amplitude = np.ones((npixels, npixels), dtype=float)\n        self.phase = np.zeros((npixels, npixels), dtype=float)\n\n        # Input checks\n        if self.wavelength.shape != ():\n            raise ValueError(\"wavelength must have shape ().\")\n        if self.diameter.shape != ():\n            raise ValueError(\"diameter must have shape ().\")\n\n        # Always initialised in Pupil plane with Cartesian Coords\n        self.plane = 'Pupil'\n        self.units = 'Cartesian'\n\n    ########################\n    ### Getter Functions ###\n    ########################\n    @property\n    def diameter(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the current wavefront diameter calculated using the pixel scale\n        and number of pixels.\n\n        Returns\n        -------\n        diameter : Array, metres or radians\n            The current diameter of the wavefront.\n        \"\"\"\n        return self.npixels * self.pixel_scale\n\n    @property\n    def npixels(self: Wavefront) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        wavefront. Taken from the last axis of the amplitude array.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[-1]\n\n    @property\n    def real(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the real component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The real component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.cos(self.phase)\n\n    @property\n    def imaginary(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the imaginary component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The imaginary component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.sin(self.phase)\n\n    @property\n    def phasor(self: Wavefront) -&gt; Array:\n\"\"\"\n        The electric field phasor described by this Wavefront in complex form.\n\n        Returns\n        -------\n        field : Array\n            The electric field phasor of the wavefront.\n        \"\"\"\n        return self.amplitude * np.exp(1j * self.phase)\n\n    @property\n    def psf(self: Wavefront) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), i.e. the squared modulus\n        of the complex wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return self.amplitude ** 2\n\n    @property\n    def coordinates(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the physical positions of the wavefront pixels in metres.\n\n        Returns\n        -------\n        coordinates : Array\n            The coordinates of the centers of each pixel representing the\n            wavefront.\n        \"\"\"\n        return dlu.pixel_coords(self.npixels, self.pixel_scale)\n\n    @property\n    def wavenumber(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the wavenumber of the wavefront (2 * pi / wavelength).\n\n        Returns\n        -------\n        wavenumber : Array, 1/meters\n            The wavenumber of the wavefront.\n        \"\"\"\n        return 2 * np.pi / self.wavelength\n\n    @property\n    def fringe_size(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the size of the fringes in angular units.\n\n        # TODO Units check\n        # TODO Possibly output in unit based on units attribute\n        # TODO make methods use this\n        Returns\n        -------\n        fringe_size : Array, radians\n            The wavenumber of the wavefront.\n        \"\"\"\n        return self.wavelength / self.diameter\n\n    #####################\n    ### Magic Methods ###\n    #####################\n    def __add__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of OPD values and is added to the wavefront. If it is an\n        Aberration, the wavefront is passed to the layer and the output\n        wavefront is returned.\n        Parameters\n        ----------\n        other : Array or Aberration\n            The input to add to the wavefront.\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type\n        if other is None:\n            return self\n\n        # Some Optical Layer\n        if isinstance(other, OpticalLayer()):\n            return other(self)\n\n        # Array based inputs - Defaults to OPD\n        if isinstance(other, (Array, float, int)):\n            return self.add_opd(other)\n\n        # Other\n        else:\n            raise TypeError(\"Can only add an array or OpticalLayer to \"\n                            f\"Wavefront. Got: {type(other)}.\")\n\n    def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of OPD values and is added to the wavefront. If it is an\n        Aberration, the wavefront is passed to the layer and the output\n        wavefront is returned.\n        Parameters\n        ----------\n        other : Array or Aberration\n            The input to add to the wavefront.\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__add__(other)\n\n    def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of transmission values and is multiplied by the wavefront\n        amplitude. If it is an Aperture, Aberration, or Propagator, the\n        wavefront is passed to the layer and the output wavefront is returned.\n        Parameters\n        ----------\n        other : Array or Aberration or Aperture or Propagator\n            The input to add to the wavefront.\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type, return None\n        if other is None:\n            return self\n\n        # Some Optical Layer, apply it\n        if isinstance(other, OpticalLayer()):\n            return other(self)\n\n        # Array based inputs\n        if isinstance(other, (Array, float, int)):\n\n            # Complex array - Multiply the phasors\n            if isinstance(other, Array) and other.dtype.kind == 'c':\n                phasor = self.phasor * other\n                return self.set([\"amplitude\", \"phase\"],\n                                [np.abs(phasor), np.angle(phasor)])\n\n            # Scalar array - Multiply amplitude\n            else:\n                return self.multiply('amplitude', other)\n\n        # Other\n        else:\n            raise TypeError(\"Can only multiply Wavefront by array or \"\n                            f\"OpticalLayer. Got: {type(other)}.\")\n\n    def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of transmission values and is multiplied by the wavefront\n        amplitude. If it is an Aperture, Aberration, or Propagator, the\n        wavefront is passed to the layer and the output wavefront is returned.\n        Parameters\n        ----------\n        other : Array or Aberration or Aperture or Propagator\n            The input to add to the wavefront.\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__mul__(other)\n\n    #######################\n    ### Adder Functions ###\n    #######################\n    def add_opd(self: Wavefront, path_difference: Array) -&gt; Wavefront:\n\"\"\"\n        Applies the wavelength-dependent phase based on the supplied optical\n        path difference.\n\n        Parameters\n        ----------\n        path_difference : Array, metres\n            The physical optical path difference of either the entire wavefront\n            or each pixel individually.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phases updated according to the supplied\n            path_difference\n        \"\"\"\n        phase_difference = self.wavenumber * path_difference\n        return self.add('phase', phase_difference)\n\n    def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:\n\"\"\"\n        Applies input array to the phase of the wavefront.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            The phase to be added to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with updated phases.\n        \"\"\"\n        # Add this extra None check to allow PhaseOptics to have a None phase\n        # and still be able to be 'added' to it, making this the phase \n        # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`\n        if phase is not None:\n            return self.add('phase', phase)\n        return self\n\n    #######################\n    ### Other Functions ###\n    #######################\n    def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:\n\"\"\"\n        Tilts the wavefront by the angles in the (x, y) by modifying the \n        phase arrays.\n\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The tilted wavefront.\n        \"\"\"\n        if not isinstance(angles, Array) or angles.shape != (2,):\n            raise ValueError(\"angles must be an array of shape (2,).\")\n        opd = - (angles[:, None, None] * self.coordinates).sum(0)\n        return self.add_opd(opd)\n\n    def normalise(self: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the total power of the wavefront to 1.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the normalised electric field amplitudes.\n        \"\"\"\n        return self.divide('amplitude', np.linalg.norm(self.amplitude))\n\n    def _to_field(self: Wavefront, complex: bool = False) -&gt; Array:\n\"\"\"\n        Returns the wavefront in either (amplitude, phase) or (real, imaginary)\n        form.\n\n        Parameters\n        ----------\n        complex : bool = False\n            Whether to return the wavefront in (real, imaginary) form.\n        Returns\n        -------\n        field : Array\n            The wavefront in either (amplitude, phase) or (real, imaginary) form.\n        \"\"\"\n        if complex:\n            return np.array([self.real, self.imaginary])\n        return np.array([self.amplitude, self.phase])\n\n    def _to_amplitude_phase(self: Wavefront, field: Array) -&gt; Array:\n\"\"\"\n        Returns the input field in (real, imaginary) (amplitude, phase) form.\n\n        Parameters\n        ----------\n        field : Array\n            The wavefront field in (amplitude, phase) form.\n        Returns\n        -------\n        field : Array\n            The wavefront field in (real, imaginary) form.\n        \"\"\"\n        amplitude = np.hypot(field[0], field[1])\n        phase = np.arctan2(field[1], field[0])\n        return np.array([amplitude, phase])\n\n    def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:\n\"\"\"\n        Flips the amplitude and phase of the wavefront along the specified axes.\n\n        Parameters\n        ----------\n        axis : tuple\n            The axes along which to flip the wavefront.\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the flipped amplitude and phase.\n        \"\"\"\n        field = self._to_field()\n        flipper = vmap(np.flip, (0, None))\n        amplitude, phase = flipper(field, axis)\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    def scale_to(self: Wavefront,\n                 npixels: int,\n                 pixel_scale: Array,\n                 complex: bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial interpolation on the wavefront, determined by the\n        pixel_scale_out and npixels parameters. The transformation is done\n        on the amplitude and phase arrays, but can be done on the real and\n        imaginary components by passing `complex=True`.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels representing the wavefront after the\n            interpolation.\n        pixel_scale: Array\n            The pixel scale of the array after the interpolation.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront interpolated to the size and shape determined by\n            npixels and pixel_scale_out, with the updated pixel_scale.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Scale the field\n        scaler = vmap(dlu.scale, (0, None, None))\n        field = scaler(field, npixels, pixel_scale / self.pixel_scale)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase'], [field[0], field[1]])\n\n    def rotate(self: Wavefront,\n               angle: Array,\n               order: int = 1,\n               complex: bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial rotation on the wavefront, determined by the\n        angle parameter, using interpolation. The transformation is done\n        on the amplitude and phase arrays, but can be done on the real and\n        imaginary components by passing `complex=True`.\n\n        Parameters\n        ----------\n        angle : Array, radians\n            The angle by which to rotate the wavefront in a clockwise direction.\n        order : int = 1\n            The interpolation order to use.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront rotated by angle in the clockwise direction.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Rotate the field\n        rotator = vmap(dlu.rotate, (0, None, None))\n        field = rotator(field, angle, order)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase'], [field[0], field[1]])\n\n    ############################\n    ### Padding and Cropping ###\n    ############################\n    def pad_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n        Paraxially zero-pads the `Wavefront` to the size determined by\n        npixels. Note this only supports padding arrays of even dimension\n        to even dimension, and odd dimension to odd dimension, i.e. 2 -&gt; 4 or\n        3 -&gt; 5.\n\n        Parameters\n        ----------\n        npixels : int\n            The size of the array to pad to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` zero-padded to the size npixels.\n        \"\"\"\n        npixels_in = self.npixels\n        if npixels_in % 2 != npixels % 2:\n            raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n        if npixels &lt; npixels_in:\n            raise ValueError(\"npixels must be larger than the current array \"\n                             \"size: {}\".format(npixels_in))\n\n        new_centre = npixels // 2\n        centre = npixels_in // 2\n        remainder = npixels_in % 2\n        padded = np.zeros([npixels, npixels])\n\n        amplitude = padded.at[\n                    new_centre - centre: centre + new_centre + remainder,\n                    new_centre - centre: centre + new_centre + remainder\n                    ].set(self.amplitude)\n        phase = padded.at[\n                new_centre - centre: centre + new_centre + remainder,\n                new_centre - centre: centre + new_centre + remainder\n                ].set(self.phase)\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    def crop_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n        Paraxially crops the `Wavefront` to the size determined by npixels.\n        Note this only supports padding arrays of even dimension to even\n        dimension, and odd dimension to odd dimension, i.e. 4 -&gt; 2 or 5 -&gt; 3.\n\n        Parameters\n        ----------\n        npixels : int\n            The size of the array to crop to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` cropped to the size npixels.\n        \"\"\"\n        npixels_in = self.npixels\n\n        if npixels_in % 2 != npixels % 2:\n            raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n        if npixels &gt; npixels_in:\n            raise ValueError(\"npixels must be smaller than the current array \"\n                             \"size: {}\".format(npixels_in))\n\n        new_centre = npixels_in // 2\n        centre = npixels // 2\n\n        amplitude = self.amplitude[\n                    new_centre - centre: new_centre + centre,\n                    new_centre - centre: new_centre + centre]\n        phase = self.phase[\n                new_centre - centre: new_centre + centre,\n                new_centre - centre: new_centre + centre]\n\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    #############################\n    ### Propagation Functions ###\n    #############################\n    def _FFT_output(self         : Wavefront,\n                    pad_factor   : int = 1,\n                    focal_length : Array = None, \n                    inverse      : bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane, unit, and pixel scale.\n\n        Parameters\n        ----------\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            If True, the propagation is treated as an inverse FFT.\n\n        Returns\n        -------\n        plane : str\n            The output plane of the propagation.\n        units : str\n            The units of the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        \"\"\"\n        pixel_scale = self.fringe_size / pad_factor\n        if focal_length is None:\n            units = 'Angular'\n        else:\n            units = 'Cartesian'\n            pixel_scale *= focal_length\n\n            # Check for invalid propagation\n            if self.units == 'Angular':\n                raise ValueError(\"focal_length can not be specific when\"\n                                 \"propagating from a Focal plane with angular units.\")\n\n        # Check planes\n        if inverse:\n            if self.plane != 'Focal':\n                raise ValueError(\"Can only do an IFFT from a Focal plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Pupil'\n            units = 'Cartesian'\n        else:\n            if self.plane != 'Pupil':\n                raise ValueError(\"Can only do an FFT from a Pupil plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Focal'\n\n        return plane, units, pixel_scale\n\n    # TODO: focal_length not used?\n    def _FFT(self: Wavefront,\n             phasor: Array,\n             focal_length: Array = None,\n             inverse: bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane, unit, pixel scale, and returns the\n        appropriate propagation function\n\n        Parameters\n        ----------\n        inverse : bool = False\n            If True, the inverse FFT is used.\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        if inverse:\n            return np.fft.fft2(np.fft.ifftshift(phasor)) / phasor.shape[-1]\n        else:\n            return np.fft.fftshift(np.fft.ifft2(phasor)) * phasor.shape[-1]\n\n    def FFT(self: Wavefront,\n            pad: int = 2,\n            focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a Fast Fourier Transform.\n\n        Parameters\n        ----------\n        pad : int = 2\n            The padding factory to apply to the input wavefront before\n            performing the FFT.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units, pixel_scale = self._FFT_output(pad, focal_length)\n\n        # Pad must be int\n        npixels = (self.npixels * (pad - 1)) // 2\n        amplitude = np.pad(self.amplitude, npixels)\n        phase = np.pad(self.phase, npixels)\n        phasor = amplitude * np.exp(1j * phase)\n        phasor = self._FFT(phasor, focal_length)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def IFFT(self: Wavefront,\n             pad: int = 2,\n             focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing an Inverse Fast Fourier\n        Transform.\n\n        Parameters\n        ----------\n        pad : int = 2\n            The padding factory to apply to the input wavefront before\n            performing the FFT.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units, pixel_scale = self._FFT_output(pad, focal_length, \n            inverse=True)\n\n        # Pad must be int\n        npixels = (self.npixels * (pad - 1)) // 2\n        amplitude = np.pad(self.amplitude, npixels)\n        phase = np.pad(self.phase, npixels)\n        phasor = amplitude * np.exp(1j * phase)\n        phasor = self._FFT(phasor, focal_length, inverse=True)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def _MFT_output(self: Wavefront,\n                    focal_length: Array = None,\n                    inverse: bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane and unit for the MFT\n\n        Parameters\n        ----------\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            If True, the inverse MFT is used.\n        Returns\n        -------\n        plane : str\n            The output plane of the propagation.\n        units : str\n            The units of the output plane.\n        \"\"\"\n        # Get units\n        if focal_length is None:\n            units = 'Angular'\n        else:\n            units = 'Cartesian'\n\n            # Check for invalid propagation\n            if self.units == 'Angular':\n                raise ValueError(\"focal_length can not be specific when\"\n                                 \"propagating from a Focal plane with angular units.\")\n\n        # Check planes\n        if inverse:\n            if self.plane != 'Focal':\n                raise ValueError(\"Can only do an IMFT from a Focal plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Pupil'\n            units = 'Cartesian'\n        else:\n            if self.plane != 'Pupil':\n                raise ValueError(\"Can only do an MFT from a Pupil plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Focal'\n\n        return plane, units\n\n    def _nfringes(self: Wavefront,\n                  npixels: int,\n                  pixel_scale: Array,\n                  focal_length: Array = None) -&gt; Array:\n\"\"\"\n        Calculates the number of fringes in the output plane.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        Returns\n        -------\n        nfringes : Array\n            The number of fringes in the output plane.\n        \"\"\"\n        output_size = npixels * pixel_scale\n\n        # Angular\n        if focal_length is None:\n            return output_size / self.fringe_size\n\n        # Cartesian\n        else:\n            return output_size / (self.fringe_size * focal_length)\n\n    def _transfer_matrix(self: Wavefront,\n                         npixels: int,\n                         pixel_scale: Array,\n                         shift: Array = 0.,\n                         focal_length: Array = None,\n                         inverse: bool = False) -&gt; Array:\n\"\"\"\n        Calculates the transfer matrix for the MFT.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        shift : Array = 0.\n            The shift to apply to the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            Is this a forward or inverse MFT.\n        Returns\n        -------\n        transfer_matrix : Array\n            The transfer matrix for the MFT.\n        \"\"\"\n        scale_in = 1.0 / self.npixels\n        scale_out = self._nfringes(npixels, pixel_scale, focal_length) / npixels\n        in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)\n        out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)\n\n        if not inverse:\n            return np.exp(2j * np.pi * np.outer(in_vec, out_vec))\n        else:\n            return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))\n\n    def _MFT(self: Wavefront,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array = None,\n             shift: Array = np.zeros(2),\n             inverse: bool = False) -&gt; Array:\n\"\"\"\n        Performs the actual phasor propagation and normalises the output\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        shift : Array = np.zeros(2)\n            The shift in the center of the output plane.\n        inverse : bool = False\n            Is this a forward or inverse MFT.\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        # Transfer Matrices\n        x_matrix = self._transfer_matrix(npixels, pixel_scale, shift[0],\n                                         focal_length, inverse=inverse)\n        y_matrix = self._transfer_matrix(npixels, pixel_scale, shift[1],\n                                         focal_length, inverse=inverse).T\n\n        # Propagation\n        phasor = (y_matrix @ self.phasor) @ x_matrix\n        nfringes = self._nfringes(npixels, pixel_scale, focal_length)\n        phasor *= np.exp(np.log(nfringes) -\n                         (np.log(self.npixels) + np.log(npixels)))\n        return phasor\n\n    def MFT(self: Wavefront,\n            npixels: int,\n            pixel_scale: Array,\n            focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a 2-sided Matrix Fourier\n        Transform. TODO: Add link to Soumer et al. 2007(?).\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length)\n        phasor = self._MFT(npixels, pixel_scale, focal_length)\n\n        # Return new wavefront\n        pixel_scale = np.array(pixel_scale)  # Allow float input\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def IMFT(self: Wavefront,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a, inverse 2-sided Matrix Fourier\n        Transform. TODO: Add link to Soumer et al. 2007(?).\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length, inverse=True)\n        phasor = self._MFT(npixels, pixel_scale, focal_length, inverse=True)\n\n        # Return new wavefront\n        pixel_scale = np.array(pixel_scale)  # Allow float input\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def shifted_MFT(self: Wavefront,\n                    npixels: int,\n                    pixel_scale: Array,\n                    shift: Array,\n                    focal_length: Array = None,\n                    pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a 2-sided Matrix Fourier\n        Transform with a shift in the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        shift : Array\n            The shift in the center of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        pixel : bool = True\n            Whether the shift is in pixels or the units of pixel_scale.\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length)\n        shift = shift if pixel else shift / pixel_scale\n        phasor = self._MFT(npixels, pixel_scale, focal_length, shift)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def shifted_IMFT(self: Wavefront,\n                     npixels: int,\n                     pixel_scale: Array,\n                     shift: Array,\n                     focal_length: Array = None,\n                     pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a, Inverse 2-sided Matrix Fourier\n        Transform with a shift in the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        shift : Array\n            The shift in the center of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        pixel : bool = True\n            Whether the shift is in pixels or the units of pixel_scale.\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length, inverse=True)\n        shift = shift if pixel else shift / pixel_scale\n        phasor = self._MFT(npixels, pixel_scale, focal_length, shift,\n                           inverse=True)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</pre> class Wavefront(Base):     \"\"\"     A class representing some wavefront, designed to track the various     parameters such as wavelength, pixel_scale, amplitude and phase, as well as     two helper parameters, plane and units.      All wavefronts currently only support square amplitude and phase arrays.      Attributes     ----------     wavelength : float, metres         The wavelength of the `Wavefront`.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     pixel_scale : float, metres/pixel or radians/pixel         The physical dimensions of the pixels representing the wavefront. This         can be in units of either metres per pixel or radians per pixel         depending on if 'unit' is 'Cartesian' or 'Angular'.     plane : str         The current plane type of wavefront, can be 'Pupil', 'Focal' or         'Intermediate'.     units : str         The current units of the wavefront, can be 'Cartesian' or 'Angular'.     \"\"\"     wavelength: Array     pixel_scale: Array     amplitude: Array     phase: Array     plane: str     units: str      def __init__(self: Wavefront,                  npixels: int,                  diameter: Array,                  wavelength: Array):         \"\"\"         Constructor for the wavefront.          Parameters         ----------         npixels : int             The number of pixels that represent the `Wavefront`.         diameter : float, metres             The physical dimensions of each square pixel.         wavelength : float, metres             The wavelength of the `Wavefront`.         \"\"\"         self.wavelength = np.asarray(wavelength, dtype=float)         self.pixel_scale = np.asarray(diameter / npixels, dtype=float)         self.amplitude = np.ones((npixels, npixels), dtype=float)         self.phase = np.zeros((npixels, npixels), dtype=float)          # Input checks         if self.wavelength.shape != ():             raise ValueError(\"wavelength must have shape ().\")         if self.diameter.shape != ():             raise ValueError(\"diameter must have shape ().\")          # Always initialised in Pupil plane with Cartesian Coords         self.plane = 'Pupil'         self.units = 'Cartesian'      ########################     ### Getter Functions ###     ########################     @property     def diameter(self: Wavefront) -&gt; Array:         \"\"\"         Returns the current wavefront diameter calculated using the pixel scale         and number of pixels.          Returns         -------         diameter : Array, metres or radians             The current diameter of the wavefront.         \"\"\"         return self.npixels * self.pixel_scale      @property     def npixels(self: Wavefront) -&gt; int:         \"\"\"         Returns the side length of the arrays currently representing the         wavefront. Taken from the last axis of the amplitude array.          Returns         -------         pixels : int             The number of pixels that represent the `Wavefront`.         \"\"\"         return self.amplitude.shape[-1]      @property     def real(self: Wavefront) -&gt; Array:         \"\"\"         Returns the real component of the `Wavefront`.          Returns         -------         wavefront : Array             The real component of the `Wavefront` phasor.         \"\"\"         return self.amplitude * np.cos(self.phase)      @property     def imaginary(self: Wavefront) -&gt; Array:         \"\"\"         Returns the imaginary component of the `Wavefront`.          Returns         -------         wavefront : Array             The imaginary component of the `Wavefront` phasor.         \"\"\"         return self.amplitude * np.sin(self.phase)      @property     def phasor(self: Wavefront) -&gt; Array:         \"\"\"         The electric field phasor described by this Wavefront in complex form.          Returns         -------         field : Array             The electric field phasor of the wavefront.         \"\"\"         return self.amplitude * np.exp(1j * self.phase)      @property     def psf(self: Wavefront) -&gt; Array:         \"\"\"         Calculates the Point Spread Function (PSF), i.e. the squared modulus         of the complex wavefront.          Returns         -------         psf : Array             The PSF of the wavefront.         \"\"\"         return self.amplitude ** 2      @property     def coordinates(self: Wavefront) -&gt; Array:         \"\"\"         Returns the physical positions of the wavefront pixels in metres.          Returns         -------         coordinates : Array             The coordinates of the centers of each pixel representing the             wavefront.         \"\"\"         return dlu.pixel_coords(self.npixels, self.pixel_scale)      @property     def wavenumber(self: Wavefront) -&gt; Array:         \"\"\"         Returns the wavenumber of the wavefront (2 * pi / wavelength).          Returns         -------         wavenumber : Array, 1/meters             The wavenumber of the wavefront.         \"\"\"         return 2 * np.pi / self.wavelength      @property     def fringe_size(self: Wavefront) -&gt; Array:         \"\"\"         Returns the size of the fringes in angular units.          # TODO Units check         # TODO Possibly output in unit based on units attribute         # TODO make methods use this         Returns         -------         fringe_size : Array, radians             The wavenumber of the wavefront.         \"\"\"         return self.wavelength / self.diameter      #####################     ### Magic Methods ###     #####################     def __add__(self: Wavefront, other: Any) -&gt; Wavefront:         \"\"\"         Magic method used to give a simple API for interaction with different         layer types and arrays. If the input 'other' in an array it is treated         as an array of OPD values and is added to the wavefront. If it is an         Aberration, the wavefront is passed to the layer and the output         wavefront is returned.                  Parameters         ----------         other : Array or Aberration             The input to add to the wavefront.                  Returns         -------         wavefront : Wavefront             The output wavefront.         \"\"\"         # None Type         if other is None:             return self          # Some Optical Layer         if isinstance(other, OpticalLayer()):             return other(self)          # Array based inputs - Defaults to OPD         if isinstance(other, (Array, float, int)):             return self.add_opd(other)          # Other         else:             raise TypeError(\"Can only add an array or OpticalLayer to \"                             f\"Wavefront. Got: {type(other)}.\")      def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:         \"\"\"         Magic method used to give a simple API for interaction with different         layer types and arrays. If the input 'other' in an array it is treated         as an array of OPD values and is added to the wavefront. If it is an         Aberration, the wavefront is passed to the layer and the output         wavefront is returned.                  Parameters         ----------         other : Array or Aberration             The input to add to the wavefront.                  Returns         -------         wavefront : Wavefront             The output wavefront.         \"\"\"         return self.__add__(other)      def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:         \"\"\"         Magic method used to give a simple API for interaction with different         layer types and arrays. If the input 'other' in an array it is treated         as an array of transmission values and is multiplied by the wavefront         amplitude. If it is an Aperture, Aberration, or Propagator, the         wavefront is passed to the layer and the output wavefront is returned.                  Parameters         ----------         other : Array or Aberration or Aperture or Propagator             The input to add to the wavefront.                  Returns         -------         wavefront : Wavefront             The output wavefront.         \"\"\"         # None Type, return None         if other is None:             return self          # Some Optical Layer, apply it         if isinstance(other, OpticalLayer()):             return other(self)          # Array based inputs         if isinstance(other, (Array, float, int)):              # Complex array - Multiply the phasors             if isinstance(other, Array) and other.dtype.kind == 'c':                 phasor = self.phasor * other                 return self.set([\"amplitude\", \"phase\"],                                 [np.abs(phasor), np.angle(phasor)])              # Scalar array - Multiply amplitude             else:                 return self.multiply('amplitude', other)          # Other         else:             raise TypeError(\"Can only multiply Wavefront by array or \"                             f\"OpticalLayer. Got: {type(other)}.\")      def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:         \"\"\"         Magic method used to give a simple API for interaction with different         layer types and arrays. If the input 'other' in an array it is treated         as an array of transmission values and is multiplied by the wavefront         amplitude. If it is an Aperture, Aberration, or Propagator, the         wavefront is passed to the layer and the output wavefront is returned.                  Parameters         ----------         other : Array or Aberration or Aperture or Propagator             The input to add to the wavefront.                  Returns         -------         wavefront : Wavefront             The output wavefront.         \"\"\"         return self.__mul__(other)      #######################     ### Adder Functions ###     #######################     def add_opd(self: Wavefront, path_difference: Array) -&gt; Wavefront:         \"\"\"         Applies the wavelength-dependent phase based on the supplied optical         path difference.          Parameters         ----------         path_difference : Array, metres             The physical optical path difference of either the entire wavefront             or each pixel individually.          Returns         -------         wavefront : Wavefront             The new wavefront with the phases updated according to the supplied             path_difference         \"\"\"         phase_difference = self.wavenumber * path_difference         return self.add('phase', phase_difference)      def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:         \"\"\"         Applies input array to the phase of the wavefront.          Parameters         ----------         phase : Array, radians             The phase to be added to the wavefront.          Returns         -------         wavefront : Wavefront             The new wavefront with updated phases.         \"\"\"         # Add this extra None check to allow PhaseOptics to have a None phase         # and still be able to be 'added' to it, making this the phase          # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`         if phase is not None:             return self.add('phase', phase)         return self      #######################     ### Other Functions ###     #######################     def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:         \"\"\"         Tilts the wavefront by the angles in the (x, y) by modifying the          phase arrays.          Parameters         ----------         angles : Array, radians             The (x, y) angles by which to tilt the wavefront.          Returns         -------         wavefront : Wavefront             The tilted wavefront.         \"\"\"         if not isinstance(angles, Array) or angles.shape != (2,):             raise ValueError(\"angles must be an array of shape (2,).\")         opd = - (angles[:, None, None] * self.coordinates).sum(0)         return self.add_opd(opd)      def normalise(self: Wavefront) -&gt; Wavefront:         \"\"\"         Normalises the total power of the wavefront to 1.          Returns         -------         wavefront : Wavefront             The new wavefront with the normalised electric field amplitudes.         \"\"\"         return self.divide('amplitude', np.linalg.norm(self.amplitude))      def _to_field(self: Wavefront, complex: bool = False) -&gt; Array:         \"\"\"         Returns the wavefront in either (amplitude, phase) or (real, imaginary)         form.          Parameters         ----------         complex : bool = False             Whether to return the wavefront in (real, imaginary) form.                  Returns         -------         field : Array             The wavefront in either (amplitude, phase) or (real, imaginary) form.         \"\"\"         if complex:             return np.array([self.real, self.imaginary])         return np.array([self.amplitude, self.phase])      def _to_amplitude_phase(self: Wavefront, field: Array) -&gt; Array:         \"\"\"         Returns the input field in (real, imaginary) (amplitude, phase) form.          Parameters         ----------         field : Array             The wavefront field in (amplitude, phase) form.                  Returns         -------         field : Array             The wavefront field in (real, imaginary) form.         \"\"\"         amplitude = np.hypot(field[0], field[1])         phase = np.arctan2(field[1], field[0])         return np.array([amplitude, phase])      def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:         \"\"\"         Flips the amplitude and phase of the wavefront along the specified axes.          Parameters         ----------         axis : tuple             The axes along which to flip the wavefront.                  Returns         -------         wavefront : Wavefront             The new wavefront with the flipped amplitude and phase.         \"\"\"         field = self._to_field()         flipper = vmap(np.flip, (0, None))         amplitude, phase = flipper(field, axis)         return self.set(['amplitude', 'phase'], [amplitude, phase])      def scale_to(self: Wavefront,                  npixels: int,                  pixel_scale: Array,                  complex: bool = False) -&gt; Wavefront:         \"\"\"         Performs a paraxial interpolation on the wavefront, determined by the         pixel_scale_out and npixels parameters. The transformation is done         on the amplitude and phase arrays, but can be done on the real and         imaginary components by passing `complex=True`.          Parameters         ----------         npixels : int             The number of pixels representing the wavefront after the             interpolation.         pixel_scale: Array             The pixel scale of the array after the interpolation.         complex : bool = False             Whether to rotate the real and imaginary representation of the             wavefront as opposed to the amplitude and phase representation.          Returns         -------         wavefront : Wavefront             The new wavefront interpolated to the size and shape determined by             npixels and pixel_scale_out, with the updated pixel_scale.         \"\"\"         # Get field in either (amplitude, phase) or (real, imaginary)         field = self._to_field(complex=complex)          # Scale the field         scaler = vmap(dlu.scale, (0, None, None))         field = scaler(field, npixels, pixel_scale / self.pixel_scale)          # Cast back to (amplitude, phase) if needed         if complex:             field = self._to_amplitude_phase(field)          # Return new wavefront         return self.set(['amplitude', 'phase'], [field[0], field[1]])      def rotate(self: Wavefront,                angle: Array,                order: int = 1,                complex: bool = False) -&gt; Wavefront:         \"\"\"         Performs a paraxial rotation on the wavefront, determined by the         angle parameter, using interpolation. The transformation is done         on the amplitude and phase arrays, but can be done on the real and         imaginary components by passing `complex=True`.          Parameters         ----------         angle : Array, radians             The angle by which to rotate the wavefront in a clockwise direction.         order : int = 1             The interpolation order to use.         complex : bool = False             Whether to rotate the real and imaginary representation of the             wavefront as opposed to the amplitude and phase representation.          Returns         -------         wavefront : Wavefront             The new wavefront rotated by angle in the clockwise direction.         \"\"\"         # Get field in either (amplitude, phase) or (real, imaginary)         field = self._to_field(complex=complex)          # Rotate the field         rotator = vmap(dlu.rotate, (0, None, None))         field = rotator(field, angle, order)          # Cast back to (amplitude, phase) if needed         if complex:             field = self._to_amplitude_phase(field)          # Return new wavefront         return self.set(['amplitude', 'phase'], [field[0], field[1]])      ############################     ### Padding and Cropping ###     ############################     def pad_to(self: Wavefront, npixels: int) -&gt; Wavefront:         \"\"\"         Paraxially zero-pads the `Wavefront` to the size determined by         npixels. Note this only supports padding arrays of even dimension         to even dimension, and odd dimension to odd dimension, i.e. 2 -&gt; 4 or         3 -&gt; 5.          Parameters         ----------         npixels : int             The size of the array to pad to the wavefront to.          Returns         -------         wavefront : Wavefront             The new `Wavefront` zero-padded to the size npixels.         \"\"\"         npixels_in = self.npixels         if npixels_in % 2 != npixels % 2:             raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")         if npixels &lt; npixels_in:             raise ValueError(\"npixels must be larger than the current array \"                              \"size: {}\".format(npixels_in))          new_centre = npixels // 2         centre = npixels_in // 2         remainder = npixels_in % 2         padded = np.zeros([npixels, npixels])          amplitude = padded.at[                     new_centre - centre: centre + new_centre + remainder,                     new_centre - centre: centre + new_centre + remainder                     ].set(self.amplitude)         phase = padded.at[                 new_centre - centre: centre + new_centre + remainder,                 new_centre - centre: centre + new_centre + remainder                 ].set(self.phase)         return self.set(['amplitude', 'phase'], [amplitude, phase])      def crop_to(self: Wavefront, npixels: int) -&gt; Wavefront:         \"\"\"         Paraxially crops the `Wavefront` to the size determined by npixels.         Note this only supports padding arrays of even dimension to even         dimension, and odd dimension to odd dimension, i.e. 4 -&gt; 2 or 5 -&gt; 3.          Parameters         ----------         npixels : int             The size of the array to crop to the wavefront to.          Returns         -------         wavefront : Wavefront             The new `Wavefront` cropped to the size npixels.         \"\"\"         npixels_in = self.npixels          if npixels_in % 2 != npixels % 2:             raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")         if npixels &gt; npixels_in:             raise ValueError(\"npixels must be smaller than the current array \"                              \"size: {}\".format(npixels_in))          new_centre = npixels_in // 2         centre = npixels // 2          amplitude = self.amplitude[                     new_centre - centre: new_centre + centre,                     new_centre - centre: new_centre + centre]         phase = self.phase[                 new_centre - centre: new_centre + centre,                 new_centre - centre: new_centre + centre]          return self.set(['amplitude', 'phase'], [amplitude, phase])      #############################     ### Propagation Functions ###     #############################     def _FFT_output(self         : Wavefront,                     pad_factor   : int = 1,                     focal_length : Array = None,                      inverse      : bool = False) -&gt; tuple:         \"\"\"         Calculates the output plane, unit, and pixel scale.          Parameters         ----------         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         inverse : bool = False             If True, the propagation is treated as an inverse FFT.          Returns         -------         plane : str             The output plane of the propagation.         units : str             The units of the output plane.         pixel_scale : Array             The pixel scale of the output plane.         \"\"\"         pixel_scale = self.fringe_size / pad_factor         if focal_length is None:             units = 'Angular'         else:             units = 'Cartesian'             pixel_scale *= focal_length              # Check for invalid propagation             if self.units == 'Angular':                 raise ValueError(\"focal_length can not be specific when\"                                  \"propagating from a Focal plane with angular units.\")          # Check planes         if inverse:             if self.plane != 'Focal':                 raise ValueError(\"Can only do an IFFT from a Focal plane, \"                                  f\"current plane is {self.plane}.\")             plane = 'Pupil'             units = 'Cartesian'         else:             if self.plane != 'Pupil':                 raise ValueError(\"Can only do an FFT from a Pupil plane, \"                                  f\"current plane is {self.plane}.\")             plane = 'Focal'          return plane, units, pixel_scale      # TODO: focal_length not used?     def _FFT(self: Wavefront,              phasor: Array,              focal_length: Array = None,              inverse: bool = False) -&gt; tuple:         \"\"\"         Calculates the output plane, unit, pixel scale, and returns the         appropriate propagation function          Parameters         ----------         inverse : bool = False             If True, the inverse FFT is used.                  Returns         -------         phasor : Array             The propagated phasor.         \"\"\"         if inverse:             return np.fft.fft2(np.fft.ifftshift(phasor)) / phasor.shape[-1]         else:             return np.fft.fftshift(np.fft.ifft2(phasor)) * phasor.shape[-1]      def FFT(self: Wavefront,             pad: int = 2,             focal_length: Array = None) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing a Fast Fourier Transform.          Parameters         ----------         pad : int = 2             The padding factory to apply to the input wavefront before             performing the FFT.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.          Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units, pixel_scale = self._FFT_output(pad, focal_length)          # Pad must be int         npixels = (self.npixels * (pad - 1)) // 2         amplitude = np.pad(self.amplitude, npixels)         phase = np.pad(self.phase, npixels)         phasor = amplitude * np.exp(1j * phase)         phasor = self._FFT(phasor, focal_length)          # Return new wavefront         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])      def IFFT(self: Wavefront,              pad: int = 2,              focal_length: Array = None) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing an Inverse Fast Fourier         Transform.          Parameters         ----------         pad : int = 2             The padding factory to apply to the input wavefront before             performing the FFT.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.          Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units, pixel_scale = self._FFT_output(pad, focal_length,              inverse=True)          # Pad must be int         npixels = (self.npixels * (pad - 1)) // 2         amplitude = np.pad(self.amplitude, npixels)         phase = np.pad(self.phase, npixels)         phasor = amplitude * np.exp(1j * phase)         phasor = self._FFT(phasor, focal_length, inverse=True)          # Return new wavefront         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])      def _MFT_output(self: Wavefront,                     focal_length: Array = None,                     inverse: bool = False) -&gt; tuple:         \"\"\"         Calculates the output plane and unit for the MFT          Parameters         ----------         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         inverse : bool = False             If True, the inverse MFT is used.                  Returns         -------         plane : str             The output plane of the propagation.         units : str             The units of the output plane.         \"\"\"         # Get units         if focal_length is None:             units = 'Angular'         else:             units = 'Cartesian'              # Check for invalid propagation             if self.units == 'Angular':                 raise ValueError(\"focal_length can not be specific when\"                                  \"propagating from a Focal plane with angular units.\")          # Check planes         if inverse:             if self.plane != 'Focal':                 raise ValueError(\"Can only do an IMFT from a Focal plane, \"                                  f\"current plane is {self.plane}.\")             plane = 'Pupil'             units = 'Cartesian'         else:             if self.plane != 'Pupil':                 raise ValueError(\"Can only do an MFT from a Pupil plane, \"                                  f\"current plane is {self.plane}.\")             plane = 'Focal'          return plane, units      def _nfringes(self: Wavefront,                   npixels: int,                   pixel_scale: Array,                   focal_length: Array = None) -&gt; Array:         \"\"\"         Calculates the number of fringes in the output plane.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array             The pixel scale of the output plane.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.                  Returns         -------         nfringes : Array             The number of fringes in the output plane.         \"\"\"         output_size = npixels * pixel_scale          # Angular         if focal_length is None:             return output_size / self.fringe_size          # Cartesian         else:             return output_size / (self.fringe_size * focal_length)      def _transfer_matrix(self: Wavefront,                          npixels: int,                          pixel_scale: Array,                          shift: Array = 0.,                          focal_length: Array = None,                          inverse: bool = False) -&gt; Array:         \"\"\"         Calculates the transfer matrix for the MFT.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array             The pixel scale of the output plane.         shift : Array = 0.             The shift to apply to the output plane.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         inverse : bool = False             Is this a forward or inverse MFT.                  Returns         -------         transfer_matrix : Array             The transfer matrix for the MFT.         \"\"\"         scale_in = 1.0 / self.npixels         scale_out = self._nfringes(npixels, pixel_scale, focal_length) / npixels         in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)         out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)          if not inverse:             return np.exp(2j * np.pi * np.outer(in_vec, out_vec))         else:             return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))      def _MFT(self: Wavefront,              npixels: int,              pixel_scale: Array,              focal_length: Array = None,              shift: Array = np.zeros(2),              inverse: bool = False) -&gt; Array:         \"\"\"         Performs the actual phasor propagation and normalises the output          Parameters         ----------         npixels : int             The number of pixels in the output wavefront.         pixel_scale : Array             The pixel scale of the output wavefront.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         shift : Array = np.zeros(2)             The shift in the center of the output plane.         inverse : bool = False             Is this a forward or inverse MFT.                  Returns         -------         phasor : Array             The propagated phasor.         \"\"\"         # Transfer Matrices         x_matrix = self._transfer_matrix(npixels, pixel_scale, shift[0],                                          focal_length, inverse=inverse)         y_matrix = self._transfer_matrix(npixels, pixel_scale, shift[1],                                          focal_length, inverse=inverse).T          # Propagation         phasor = (y_matrix @ self.phasor) @ x_matrix         nfringes = self._nfringes(npixels, pixel_scale, focal_length)         phasor *= np.exp(np.log(nfringes) -                          (np.log(self.npixels) + np.log(npixels)))         return phasor      def MFT(self: Wavefront,             npixels: int,             pixel_scale: Array,             focal_length: Array = None) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing a 2-sided Matrix Fourier         Transform. TODO: Add link to Soumer et al. 2007(?).          Parameters         ----------         npixels : int             The number of pixels in the output wavefront.         pixel_scale : Array             The pixel scale of the output wavefront.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.          Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units = self._MFT_output(focal_length)         phasor = self._MFT(npixels, pixel_scale, focal_length)          # Return new wavefront         pixel_scale = np.array(pixel_scale)  # Allow float input         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])      def IMFT(self: Wavefront,              npixels: int,              pixel_scale: Array,              focal_length: Array = None) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing a, inverse 2-sided Matrix Fourier         Transform. TODO: Add link to Soumer et al. 2007(?).          Parameters         ----------         npixels : int             The number of pixels in the output wavefront.         pixel_scale : Array             The pixel scale of the output wavefront.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.          Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units = self._MFT_output(focal_length, inverse=True)         phasor = self._MFT(npixels, pixel_scale, focal_length, inverse=True)          # Return new wavefront         pixel_scale = np.array(pixel_scale)  # Allow float input         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])      def shifted_MFT(self: Wavefront,                     npixels: int,                     pixel_scale: Array,                     shift: Array,                     focal_length: Array = None,                     pixel: bool = True) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing a 2-sided Matrix Fourier         Transform with a shift in the center of the output plane.         TODO: Add link to Soumer et al. 2007(?),           Parameters         ----------         npixels : int             The number of pixels in the output wavefront.         pixel_scale : Array             The pixel scale of the output wavefront.         shift : Array             The shift in the center of the output plane.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         pixel : bool = True             Whether the shift is in pixels or the units of pixel_scale.                  Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units = self._MFT_output(focal_length)         shift = shift if pixel else shift / pixel_scale         phasor = self._MFT(npixels, pixel_scale, focal_length, shift)          # Return new wavefront         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])      def shifted_IMFT(self: Wavefront,                      npixels: int,                      pixel_scale: Array,                      shift: Array,                      focal_length: Array = None,                      pixel: bool = True) -&gt; Wavefront:         \"\"\"         Propagates the wavefront by performing a, Inverse 2-sided Matrix Fourier         Transform with a shift in the center of the output plane.         TODO: Add link to Soumer et al. 2007(?),           Parameters         ----------         npixels : int             The number of pixels in the output wavefront.         pixel_scale : Array             The pixel scale of the output wavefront.         shift : Array             The shift in the center of the output plane.         focal_length : Array = None             The focal length of the propagation. If None, the propagation is             treated as an 'angular' propagation, else it is treated as a             'Cartesian' propagation.         pixel : bool = True             Whether the shift is in pixels or the units of pixel_scale.                  Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate         plane, units = self._MFT_output(focal_length, inverse=True)         shift = shift if pixel else shift / pixel_scale         phasor = self._MFT(npixels, pixel_scale, focal_length, shift,                            inverse=True)          # Return new wavefront         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units]) In\u00a0[\u00a0]: Copied! <pre>class FresnelWavefront(Wavefront):\n\"\"\"\n    A class to represent a wavefront that can be propagated to a Far Field\n    Fresnel plane.\n\n    Parameters\n    ----------\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, metres/pixel\n        The physical dimensions of each square pixel.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane : str\n        The current plane of wavefront, can be Pupil, Focal, or Intermediate.\n    units : str\n        The units of the wavefront, can be 'Cartesian' or 'Angular'.\n    \"\"\"\n\n    def __init__(self: Wavefront,\n                 npixels: int,\n                 diameter: Array,\n                 wavelength: Array) -&gt; Wavefront:\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : float, metres/pixel\n            The physical dimensions of each square pixel.\n        wavelength : float, metres\n            The wavelength of the `Wavefront`.\n        \"\"\"\n        super().__init__(\n            npixels=npixels,\n            wavelength=wavelength,\n            diameter=diameter,\n        )\n\n    def _nfringes(self: Wavefront,\n                  npixels: int,\n                  pixel_scale: Array,\n                  focal_shift: Array,\n                  focal_length: Array) -&gt; Array:\n\"\"\"\n        Calculates the number of fringes in the output plane.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        focal_length : Array, metres\n            The focal length of the lens.\n        Returns\n        -------\n        nfringes : Array\n            The number of fringes in the output plane.\n        \"\"\"\n        propagation_distance = focal_length + focal_shift\n        output_size = npixels * pixel_scale\n\n        # # Angular - Not Implemented\n        # if focal_length is None:\n        #     return output_size / self.fringe_size\n\n        # Cartesian\n        return output_size / (self.fringe_size * propagation_distance)\n\n    # Move to utils as thinlens?\n    def quadratic_phase(self: Wavefront,\n                        x_coordinates: Array,\n                        y_coordinates: Array,\n                        distance: Array) -&gt; Array:\n\"\"\"\n        A convenience function for calculating quadratic phase factors.\n\n        Parameters\n        ----------\n        x_coordinates : Array, metres\n            The x coordinates of the pixels. This will be different\n            in the plane of propagation and the initial plane.\n        y_coordinates : Array, metres\n            The y coordinates of the pixels. This will be different\n            in the plane of propagation and the initial plane.\n        distance : Array, metres\n            The distance that is to be propagated.\n\n        Returns\n        -------\n        quadratic_phase : Array\n            A set of phase factors that are useful in optical calculations.\n        \"\"\"\n        r_coordinates = np.hypot(x_coordinates, y_coordinates)\n        return np.exp(0.5j * self.wavenumber * r_coordinates ** 2 / distance)\n\n    def transfer_function(self: Wavefront,\n                          distance: Array) -&gt; Array:\n\"\"\"\n        The Optical Transfer Function defining the phase evolution of the\n        wavefront when propagating to a non-conjugate plane.\n\n        Parameters\n        ----------\n        distance : Array, metres\n            The distance that is being propagated in metres.\n\n        Returns\n        -------\n        field : Array\n            The field that represents the optical transfer.\n        \"\"\"\n        return np.exp(1.0j * self.wavenumber * distance)\n\n    def _transfer_matrix(self: Wavefront,\n                         npixels: int,\n                         pixel_scale: Array,\n                         focal_shift: Array,\n                         focal_length: Array,\n                         shift: Array = 0.) -&gt; Array:\n\"\"\"\n        Calculates the transfer matrix for the MFT.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        focal_length : Array, metres\n            The focal length of the lens.\n        shift : Array = 0., metres\n            The shift to apply to the output plane.\n\n        Returns\n        -------\n        transfer_matrix : Array\n            The transfer matrix for the MFT.\n        \"\"\"\n        scale_in = 1.0 / self.npixels\n        scale_out = self._nfringes(npixels, pixel_scale, focal_shift,\n                                   focal_length) / npixels\n        in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)\n        out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)\n\n        if self.plane == 'Pupil':\n            return np.exp(2j * np.pi * np.outer(in_vec, out_vec))\n        else:\n            raise ValueError(f\"plane must be 'Pupil' Got {self.plane}\")\n\n        # elif self.plane == 'Focal':\n        #     return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))\n\n    def _MFT(self: Wavefront,\n             phasor: Array,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array,\n             focal_shift: Array,\n             shift: Array = np.zeros(2)) -&gt; Array:\n\"\"\"\n        Performs the MFT.\n\n        Parameters\n        ----------\n        phasor : Array\n            The phasor to be propagated.\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        shift : Array = np.zeros(2), metres\n            The shift to apply to the output plane.\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        # Set up\n        nfringes = self._nfringes(npixels, pixel_scale, focal_shift,\n                                  focal_length)\n        x_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,\n                                         focal_length, shift[0])\n        y_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,\n                                         focal_length, shift[1]).T\n\n        # Perform and normalise\n        phasor = (y_matrix @ phasor) @ x_matrix\n        phasor *= np.exp(np.log(nfringes) - \\\n                         (np.log(self.npixels) + np.log(npixels)))\n        return phasor\n\n    def _phase_factors(self: Wavefront,\n                       npixels: int,\n                       pixel_scale: Array,\n                       focal_length: Array,\n                       focal_shift: Array) -&gt; tuple:\n\"\"\"\n        Calculates the phase factors for the Fresnel propagation.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        Returns\n        -------\n        first_factor : Array\n            The first factor in the Fresnel propagation.\n        second_factor : Array\n            The second factor in the Fresnel propagation.\n        third_factor : Array\n            The third factor in the Fresnel propagation.\n        fourth_factor : Array\n            The fourth factor in the Fresnel propagation.\n        \"\"\"\n        # Coordinates\n        prop_dist = focal_length + focal_shift\n        input_positions = self.coordinates\n        output_positions = dlu.pixel_coords(npixels, pixel_scale)\n\n        # Calculate phase values\n        first_factor = self.quadratic_phase(*input_positions, -focal_length)\n        second_factor = self.quadratic_phase(*input_positions, prop_dist)\n        third_factor = self.transfer_function(prop_dist)\n        fourth_factor = self.quadratic_phase(*output_positions, prop_dist)\n        return first_factor, second_factor, third_factor, fourth_factor\n\n    def fresnel_prop(self: Wavefront,\n                     npixels: int,\n                     pixel_scale: Array,\n                     focal_length: Array,\n                     focal_shift: Array) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Fresnel Transform using a Matrix Fourier Transform.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate phase values\n        first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                           focal_length, focal_shift)\n\n        # Apply phases\n        phasor = self.phasor\n        phasor *= first\n        phasor *= second\n\n        # Propagate\n        phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                           focal_shift)\n\n        # Apply phases\n        phasor *= third\n        phasor *= fourth\n\n        # Update\n        pixel_scale = np.array(pixel_scale)\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                         'Cartesian'])\n\n    def shifted_fresnel_prop(self: Wavefront,\n                             npixels: int,\n                             pixel_scale: Array,\n                             shift: Array,\n                             focal_length: Array,\n                             focal_shift: Array,\n                             pixel: bool = True) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Fresnel Transform using a Matrix Fourier Transform with a shift in\n        the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n        \"\"\"\n        # Get shift\n        shift = shift if pixel else shift / pixel_scale\n\n        # Calculate phase values\n        first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                           focal_length, focal_shift)\n\n        # Apply phases\n        phasor = self.phasor\n        phasor *= first\n        phasor *= second\n\n        # Propagate\n        phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                           focal_shift, shift)\n\n        # Apply phases\n        phasor *= third\n        phasor *= fourth\n\n        # Update\n        pixel_scale = np.array(pixel_scale)\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                         'Cartesian'])\n</pre> class FresnelWavefront(Wavefront):     \"\"\"     A class to represent a wavefront that can be propagated to a Far Field     Fresnel plane.      Parameters     ----------     wavelength : float, metres         The wavelength of the `Wavefront`.     pixel_scale : float, metres/pixel         The physical dimensions of each square pixel.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     plane : str         The current plane of wavefront, can be Pupil, Focal, or Intermediate.     units : str         The units of the wavefront, can be 'Cartesian' or 'Angular'.     \"\"\"      def __init__(self: Wavefront,                  npixels: int,                  diameter: Array,                  wavelength: Array) -&gt; Wavefront:         \"\"\"         Constructor for the wavefront.          Parameters         ----------         npixels : int             The number of pixels that represent the `Wavefront`.         pixel_scale : float, metres/pixel             The physical dimensions of each square pixel.         wavelength : float, metres             The wavelength of the `Wavefront`.         \"\"\"         super().__init__(             npixels=npixels,             wavelength=wavelength,             diameter=diameter,         )      def _nfringes(self: Wavefront,                   npixels: int,                   pixel_scale: Array,                   focal_shift: Array,                   focal_length: Array) -&gt; Array:         \"\"\"         Calculates the number of fringes in the output plane.          Parameters         ----------         npixels : int             The number of pixels that represent the `Wavefront`.         pixel_scale : Array, metres/pixel             The physical dimensions of each square pixel.         focal_shift : Array, metres             The distance the focal plane is shifted from the focal length.         focal_length : Array, metres             The focal length of the lens.                  Returns         -------         nfringes : Array             The number of fringes in the output plane.         \"\"\"         propagation_distance = focal_length + focal_shift         output_size = npixels * pixel_scale          # # Angular - Not Implemented         # if focal_length is None:         #     return output_size / self.fringe_size          # Cartesian         return output_size / (self.fringe_size * propagation_distance)      # Move to utils as thinlens?     def quadratic_phase(self: Wavefront,                         x_coordinates: Array,                         y_coordinates: Array,                         distance: Array) -&gt; Array:         \"\"\"         A convenience function for calculating quadratic phase factors.          Parameters         ----------         x_coordinates : Array, metres             The x coordinates of the pixels. This will be different             in the plane of propagation and the initial plane.         y_coordinates : Array, metres             The y coordinates of the pixels. This will be different             in the plane of propagation and the initial plane.         distance : Array, metres             The distance that is to be propagated.          Returns         -------         quadratic_phase : Array             A set of phase factors that are useful in optical calculations.         \"\"\"         r_coordinates = np.hypot(x_coordinates, y_coordinates)         return np.exp(0.5j * self.wavenumber * r_coordinates ** 2 / distance)      def transfer_function(self: Wavefront,                           distance: Array) -&gt; Array:         \"\"\"         The Optical Transfer Function defining the phase evolution of the         wavefront when propagating to a non-conjugate plane.          Parameters         ----------         distance : Array, metres             The distance that is being propagated in metres.          Returns         -------         field : Array             The field that represents the optical transfer.         \"\"\"         return np.exp(1.0j * self.wavenumber * distance)      def _transfer_matrix(self: Wavefront,                          npixels: int,                          pixel_scale: Array,                          focal_shift: Array,                          focal_length: Array,                          shift: Array = 0.) -&gt; Array:         \"\"\"         Calculates the transfer matrix for the MFT.          Parameters         ----------         npixels : int             The number of pixels that represent the `Wavefront`.         pixel_scale : Array, metres/pixel             The physical dimensions of each square pixel.         focal_shift : Array, metres             The distance the focal plane is shifted from the focal length.         focal_length : Array, metres             The focal length of the lens.         shift : Array = 0., metres             The shift to apply to the output plane.          Returns         -------         transfer_matrix : Array             The transfer matrix for the MFT.         \"\"\"         scale_in = 1.0 / self.npixels         scale_out = self._nfringes(npixels, pixel_scale, focal_shift,                                    focal_length) / npixels         in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)         out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)          if self.plane == 'Pupil':             return np.exp(2j * np.pi * np.outer(in_vec, out_vec))         else:             raise ValueError(f\"plane must be 'Pupil' Got {self.plane}\")          # elif self.plane == 'Focal':         #     return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))      def _MFT(self: Wavefront,              phasor: Array,              npixels: int,              pixel_scale: Array,              focal_length: Array,              focal_shift: Array,              shift: Array = np.zeros(2)) -&gt; Array:         \"\"\"         Performs the MFT.          Parameters         ----------         phasor : Array             The phasor to be propagated.         npixels : int             The number of pixels that represent the `Wavefront`.         pixel_scale : Array, metres/pixel             The physical dimensions of each square pixel.         focal_length : Array, metres             The focal length of the lens.         focal_shift : Array, metres             The distance the focal plane is shifted from the focal length.         shift : Array = np.zeros(2), metres             The shift to apply to the output plane.                  Returns         -------         phasor : Array             The propagated phasor.         \"\"\"         # Set up         nfringes = self._nfringes(npixels, pixel_scale, focal_shift,                                   focal_length)         x_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,                                          focal_length, shift[0])         y_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,                                          focal_length, shift[1]).T          # Perform and normalise         phasor = (y_matrix @ phasor) @ x_matrix         phasor *= np.exp(np.log(nfringes) - \\                          (np.log(self.npixels) + np.log(npixels)))         return phasor      def _phase_factors(self: Wavefront,                        npixels: int,                        pixel_scale: Array,                        focal_length: Array,                        focal_shift: Array) -&gt; tuple:         \"\"\"         Calculates the phase factors for the Fresnel propagation.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array, metres/pixel             The physical dimensions of each square pixel.         focal_length : Array, metres             The focal length of the lens.         focal_shift : Array, metres             The distance the focal plane is shifted from the focal length.                  Returns         -------         first_factor : Array             The first factor in the Fresnel propagation.         second_factor : Array             The second factor in the Fresnel propagation.         third_factor : Array             The third factor in the Fresnel propagation.         fourth_factor : Array             The fourth factor in the Fresnel propagation.         \"\"\"         # Coordinates         prop_dist = focal_length + focal_shift         input_positions = self.coordinates         output_positions = dlu.pixel_coords(npixels, pixel_scale)          # Calculate phase values         first_factor = self.quadratic_phase(*input_positions, -focal_length)         second_factor = self.quadratic_phase(*input_positions, prop_dist)         third_factor = self.transfer_function(prop_dist)         fourth_factor = self.quadratic_phase(*output_positions, prop_dist)         return first_factor, second_factor, third_factor, fourth_factor      def fresnel_prop(self: Wavefront,                      npixels: int,                      pixel_scale: Array,                      focal_length: Array,                      focal_shift: Array) -&gt; Array:         \"\"\"         Propagates the wavefront from the input plane to the output plane using         a Fresnel Transform using a Matrix Fourier Transform.          Parameters         ----------         npixels : int             The number of pixels in the output plane.         pixel_scale : Array, metres/pixel             The physical dimensions of each square pixel.         focal_length : Array, metres             The focal length of the lens.         focal_shift : Array, metres             The distance the focal plane is shifted from the focal length.          Returns         -------         wavefront : Wavefront             The propagated wavefront.         \"\"\"         # Calculate phase values         first, second, third, fourth = self._phase_factors(npixels, pixel_scale,                                                            focal_length, focal_shift)          # Apply phases         phasor = self.phasor         phasor *= first         phasor *= second          # Propagate         phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,                            focal_shift)          # Apply phases         phasor *= third         phasor *= fourth          # Update         pixel_scale = np.array(pixel_scale)         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',                          'Cartesian'])      def shifted_fresnel_prop(self: Wavefront,                              npixels: int,                              pixel_scale: Array,                              shift: Array,                              focal_length: Array,                              focal_shift: Array,                              pixel: bool = True) -&gt; Array:         \"\"\"         Propagates the wavefront from the input plane to the output plane using         a Fresnel Transform using a Matrix Fourier Transform with a shift in         the center of the output plane.         TODO: Add link to Soumer et al. 2007(?),          \"\"\"         # Get shift         shift = shift if pixel else shift / pixel_scale          # Calculate phase values         first, second, third, fourth = self._phase_factors(npixels, pixel_scale,                                                            focal_length, focal_shift)          # Apply phases         phasor = self.phasor         phasor *= first         phasor *= second          # Propagate         phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,                            focal_shift, shift)          # Apply phases         phasor *= third         phasor *= fourth          # Update         pixel_scale = np.array(pixel_scale)         return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],                         [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',                          'Cartesian'])"},{"location":"dLux/dev/FFTfresnel/","title":"FFTfresnel","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import dLux\nimport typing\nimport jax \nimport jax.numpy as np\nimport equinox as eqx\n</pre> import dLux import typing import jax  import jax.numpy as np import equinox as eqx In\u00a0[\u00a0]: Copied! <pre>Scalar = typing.NewType(\"Scalar\", np.ndarray) # 0d\nVector = typing.NewType(\"Vector\", np.ndarray) # 1d\nArray =  typing.NewType(\"Array\",  np.ndarray) # 2d +\n</pre> Scalar = typing.NewType(\"Scalar\", np.ndarray) # 0d Vector = typing.NewType(\"Vector\", np.ndarray) # 1d Array =  typing.NewType(\"Array\",  np.ndarray) # 2d + In\u00a0[\u00a0]: Copied! <pre># Base \u2202Lux Objects\nWavefront   = typing.NewType(\"Wavefront\",   dLux.Wavefront)\nPropagator  = typing.NewType(\"Propagator\",  dLux.Propagator)\nPlaneType   = typing.NewType(\"PlaneType\",   dLux.PlaneType)\nLayer       = typing.NewType(\"Layers\",  object)\n</pre> # Base \u2202Lux Objects Wavefront   = typing.NewType(\"Wavefront\",   dLux.Wavefront) Propagator  = typing.NewType(\"Propagator\",  dLux.Propagator) PlaneType   = typing.NewType(\"PlaneType\",   dLux.PlaneType) Layer       = typing.NewType(\"Layers\",  object) In\u00a0[\u00a0]: Copied! <pre>class GaussianWavefront(dLux.Wavefront):\n\"\"\"\n    Expresses the behaviour and state of a wavefront propagating in \n    an optical system under the fresnel assumptions. This \n    implementation is based on the same class from the `poppy` \n    library [poppy](https://github.com/spacetelescope/poppy/fresnel.py)\n    and Chapter 3 from _Applied Optics and Optical Engineering_\n    by Lawrence G. N.\n\n    Approximates the wavefront as a Gaussian Beam parameterised by the \n    radius of the beam, the phase radius, the phase factor and the \n    Rayleigh distance. Propagation is based on two different regimes \n    for a total of four different opertations. \n    Attributes\n    ----------\n    position : float, metres\n        The position of the wavefront in the optical system.\n    beam_radius : float, metres \n        The *initial* radius of the beam. \n    waist_position : float, metres\n        The position of the beam waist along the optical axis. \n    spherical : bool\n        A convinience tracker for knowing if the wavefront is \n        currently spherical.\n    rayleigh_factor : float\n        Used to determine the range over which the wavefront remains\n        planar. \n    focal_length : float, metres\n        Used for the conversion between angular and physical units. \n    \"\"\"\n    angular : bool\n    spherical : bool\n    waist_radius : Scalar\n    position : Scalar\n    waist_position : Scalar\n    rayleigh_factor : Scalar\n    focal_length : Scalar\n    \n \n    def __init__(self            : Wavefront,\n                 wavelength      : Scalar,\n                 offset          : Vector,\n                 pixel_scale     : Scalar,\n                 plane_type      : PlaneType,\n                 amplitude       : Array, \n                 phase           : Array,\n                 waist_radius    : Scalar,\n                 rayleigh_factor : Scalar = 2.) -&gt; Wavefront:\n\"\"\"\n        Creates a wavefront with an empty amplitude and phase \n        arrays but of a given wavelength and phase offset. \n        Assumes that the beam starts at the waist following from \n        the `poppy` convention.\n\n        Parameters\n        ----------\n        beam_radius : float, metres\n            Radius of the beam at the initial optical plane.\n        wavelength : float, metres\n            The wavelength of the `Wavefront`.\n        offset : Array, radians\n            The (x, y) angular offset of the `Wavefront` from \n            the optical axis.\n        rayleigh_factor : float\n            A multiplicative factor determining the threshold for \n            considering the wavefront spherical.\n        \"\"\"\n        super().__init__(wavelength, offset, pixel_scale, plane_type,\n                        amplitude, phase)\n        self.waist_radius = np.asarray(waist_radius).astype(float)  \n        self.position = np.asarray(0., dtype=float)\n        self.waist_position = np.asarray(0., dtype=float)\n        self.rayleigh_factor = np.asarray(rayleigh_factor, dtype=float)\n        self.focal_length = np.inf \n        self.angular = np.asarray(False, dtype=bool)\n        self.spherical = np.asarray(False, dtype=bool)\n\n        \n    ### Getters ###\n    def get_position(self : Wavefront) -&gt; float:\n\"\"\"\n        Accessor for the position of the wavefront. \n\n        Returns \n        -------\n        position : float \n            The position of the `Wavefront` from its starting point \n            in metres.\n        \"\"\"\n        return self.position\n    \n\n    def get_phase_radius(self : Wavefront) -&gt; float:\n\"\"\"\n        Accessor for the phase radius of the wavefront.\n\n        Returns\n        -------\n        phase_radius : float \n            The phase radius of the wavefront. This is a unitless \n            quantity.\n        \"\"\"\n        return self.phase_radius\n    \n    \n    def get_pixel_positions(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns\n        -------\n        positions : Tensor, metres\n            The position of each pixel aligned according to the `fft` \n            algorithm that is implemented by `numpy`.\n        \"\"\"\n        pixels = self.number_of_pixels()\n        positions = np.array(np.indices((pixels, pixels)) - pixels / 2.)\n        return self.get_pixel_scale() * positions\n\n\n    def is_angular(self : Wavefront) -&gt; bool:\n\"\"\"\n        \"\"\"\n        return self.angular\n    \n    # NOTE: The pixel scale cannot be set when self.angular == True\n    # NOTE: This has the correct units always/\n    def get_pixel_scale(self : Wavefront):\n\"\"\"\n        NOTE - This seems dodgey, becuase if we enfore only using\n        getter and setter this would result in inifinite recursion.\n        Maybe this is okay though becuase it IS The getter\n        Returns\n        -------\n        pixel_scale : The width of a single pixel in the array\n            representing the `Wavefront`. Note that this differs\n            from `poppy` because it includes the oversample. \n        \"\"\"\n        return jax.lax.cond(self.is_angular(),\n            lambda : self.pixel_scale / self.focal_length,\n            lambda : self.pixel_scale)\n    \n    \n    def get_waist_radius(self : Wavefront):\n\"\"\"\n        Calculates the current waist radius as half of the diameter\n        Mainly just exists to keep consistency with textbook terms\n        \"\"\"\n        return self.waist_radius\n\n\n    def rayleigh_distance(self : Wavefront) -&gt; Scalar:\n\"\"\"\n        Calculates the rayleigh distance of the Gaussian beam.\n        Returns\n        -------\n        rayleigh_distance : float\n            The Rayleigh distance of the wavefront in metres.\n        \"\"\"\n        return np.pi * self.get_waist_radius() ** 2 / self.get_wavelength()\n    \n    \n    ### Setters ###\n    # NOT USED\n    def set_position(self : Wavefront, \n            position : float) -&gt; Wavefront:\n\"\"\"\n        Mutator for the position of the wavefront. Changes the \n        pixel_scale which is a function of the position.  \n\n        Parameters\n        ----------\n        position : float\n            The new position of the wavefront from its starting point \n            assumed to be in metres. \n        Returns\n        -------\n        wavefront : Wavefront\n            This wavefront at the new position. \n        \"\"\"\n        return eqx.tree_at(\n            lambda wavefront : wavefront.position, self, position,\n            is_leaf = lambda leaf : leaf is None)\n    \n    \n    # NOT UESD\n    def set_phase_radius(self : Wavefront, \n            phase_radius : float) -&gt; Wavefront:\n\"\"\"\n        Mutator for the phase_radius.\n\n        Parameters\n        ----------\n        phase_radius : float\n            The new phase_radius in metres.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            A modified Wavefront with the new phase_radius.\n        \"\"\"\n        return eqx.tree_at(lambda wavefront : wavefront.phase_radius, \n            self, phase_radius, is_leaf = lambda leaf : leaf is None)\n    \n    \n    # NOTE: ordering convention: dunder, _..., ..._at, ..._after, \n    # set_... get_...\n    # NOTE: naming conventself._outside_to_outsideion: position -&gt; absolute place on optical\n    # axis and distance -&gt; movement.\n    def set_waist_position(self : Wavefront, waist_position : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        waist_position : float, metres \n            The absolute position of the waist of the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The `Wavefront` with the updated parameters.  \n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.waist_position,\n            self, waist_position)    \n    \n\n    def set_waist_radius(self : Wavefront, waist_radius : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        beam_radius : float\n            The new beam_radius in metres.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            A modified `Wavefront` with the new `beam_radius`.\n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.waist_radius,\n            self, waist_radius)\n\n\n    def set_spherical(self : Wavefront, spherical : bool) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        spherical : bool\n            Toggle the state of the `Wavefront` to and from `spherical`.\n        Returns\n        -------\n        wavefront : Wavefront \n            The `Wavefront` with the parameters modified. \n        \"\"\"\n        \n        # Pretty sure the 'spherical' input need to wrapped into a jnp array\n        return eqx.tree_at(lambda wave : wave.spherical, self, spherical)\n    \n\n    # TODO: Do I even want to include this functionality as it is \n    # only for the translation between the angular and the physical\n    # coordinates. I'm not sure that we need this. \n    def set_focal_length(self : Wavefront, focal_length : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        focal_length : float, metres\n            The `focal_length` of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The `Wavefront` with the parameters modified. \n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.focal_length,\n            self, focal_length)\n\n\n    # NOT USED\n    def calculate_pixel_scale(self: Wavefront, position: float) -&gt; None:\n\"\"\"\n        The pixel scale at the position along the axis of propagation.\n\n        Parameters\n        ----------\n        position : float\n            The position of the wavefront along the axis of propagation\n            in metres.\n        \"\"\"\n        new_pixel_scale = self.get_wavelength() * np.abs(position) / \\\n            self.number_of_pixels() / self.get_pixel_scale()  \n        return new_pixel_scale \n        \n    \n    # NOT USED\n    def is_inside(self: Wavefront, distance: float) -&gt; bool:\n\"\"\" \n        Determines whether a point at along the axis of propagation \n        at distance away from the current position is inside the \n        rayleigh distance. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to test in metres.\n\n        Returns\n        -------\n        inside : bool\n            true if the point is within the rayleigh distance false \n            otherwise.\n        \"\"\"\n        return np.abs(self.get_position() + distance - \\\n            self.waist_position) &lt;= self.rayleigh_distance()\n\n\n    # NOTE: This also needs an ..._after name. I could use something\n    # like quadratic_phase_after() or phase_after() \n    def quadratic_phase(self : Wavefront, distance : Scalar) -&gt; Array:\n\"\"\"\n        Convinience function that simplifies many of the diffraction\n        equations. Caclulates a quadratic phase factor associated with \n        Parameters\n        ----------\n        distance : float\n            The distance of the propagation measured in metres. \n\n        Returns\n        -------\n        phase : float\n            The near-field quadratic phase accumulated by the beam\n            from a propagation of distance.\n        \"\"\"      \n        positions = self.get_pixel_positions()\n        rho_squared = (positions ** 2).sum(axis = 0) \n        return np.exp(1.j * np.pi * rho_squared / distance /\\\n            self.wavelength)\n\n\n    def transfer(self : Wavefront, distance : Scalar) -&gt; Array:\n\"\"\"\n        The optical transfer function (OTF) for the Gaussian beam.\n        Assumes propagation is along the axis. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to propagate the wavefront along the beam \n            via the optical transfer function in metres.\n\n        Returns\n        -------\n        phase : float \n            A phase representing the evolution of the wavefront over \n            the distance. \n        \"\"\"\n        positions = self.get_pixel_positions()\n        x, y = positions[0], positions[1]\n        rho_squared = \\\n            (x / (self.get_pixel_scale() ** 2 \\\n                * self.number_of_pixels())) ** 2 + \\\n            (y / (self.get_pixel_scale() ** 2 \\\n                * self.number_of_pixels())) ** 2\n        # Transfer Function of diffraction propagation eq. 22, eq. 87\n        return np.exp(-1.j * np.pi * self.wavelength * \\\n                distance * rho_squared)\n\n\n    def curvature_at(self : Wavefront, position : float) -&gt; float:\n\"\"\"\n        Calculate the radius of curvature of the `Wavefront` phase\n        at the absolute position: `position`.\n\n        Parameters\n        ----------\n        position : float, metres\n            The absolute position of the wave along the optical axis \n            from spawn.\n\n        Returns\n        -------\n        radius_of_curvature : float, radians\n            The radius of phase curvature for the wavefront. \n        \"\"\"\n        relative_position = position - self.waist_position\n        return relative_position + \\\n            self.rayleigh_distance() ** 2 / relative_position\n\n\n    def radius_at(self : Wavefront, position : Scalar) -&gt; Scalar:\n\"\"\"\n        Calculate the radius of the `Wavefront` at an absolute\n        position.\n\n        Parameters\n        ----------\n        position : float, metres\n            The absolute position of the `Wavefront` since spawn.\n        Returns\n        -------\n        radius : float, metres\n            The radius of the beam. \n        \"\"\"\n        relative_position = position - self.waist_position\n        return self.get_waist_radius() * \\\n            np.sqrt(1.0 + \\\n                (relative_position / self.rayleigh_distance()) ** 2)\n\n    \n    def is_planar_at(self : Wavefront, position : Scalar) -&gt; bool:\n\"\"\" \n        Determines whether a point at along the axis of propagation \n        at distance away from the current position is inside the \n        rayleigh distance. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to test in metres.\n\n        Returns\n        -------\n        inside : bool\n            true if the point is within the rayleigh distance false \n            otherwise.\n        \"\"\"\n        return np.abs(self.waist_position - position) \\\n            &lt; self.rayleigh_distance()\n\n    \n    # NOTE: Also updates, so I want better names for these rather than \n    # after. \n    # NOTE: This is only for transitions from planar to spherical \n    # or vice versa so it needs a much better name than current. \n    def pixel_scale_after(self : Wavefront, distance : float) -&gt; Wavefront:\n\"\"\"\n        Calculate and assign the pixel scale of the `Wavefront` after\n        travelling distance. Note that this transformation is dependent\n        on the mode of propagation and is only correct for\n        `_spherical_to_waist` and `_waist_to_spherical` but not for \n        `_plane_to_plane`. \n\n        Parameters\n        ----------\n        distance : float, metres\n            The distance of propagation from the current position.\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront but the pixel_scale has been updated.\n        \"\"\"\n        pixel_scale = self.get_wavelength() * np.abs(distance) /\\\n            (self.number_of_pixels() * self.get_pixel_scale())\n        return self.set_pixel_scale(pixel_scale)\n\n    \n    def position_after(self : Wavefront, \n            distance : Scalar) -&gt; Wavefront:\n\"\"\"\n        Move the wavefront forward by `distance`.\n\n        Parameters\n        ----------\n        distance : float, metres\n            The distance of propagation.\n        Returns\n        -------\n        wavefront : Wavefront \n            The `Wavefront` with the `position` leaf updated.\n        \"\"\"\n        position = self.position + distance\n        return eqx.tree_at(lambda wave : wave.position, self, position)\n</pre> class GaussianWavefront(dLux.Wavefront):     \"\"\"     Expresses the behaviour and state of a wavefront propagating in      an optical system under the fresnel assumptions. This      implementation is based on the same class from the `poppy`      library [poppy](https://github.com/spacetelescope/poppy/fresnel.py)     and Chapter 3 from _Applied Optics and Optical Engineering_     by Lawrence G. N.      Approximates the wavefront as a Gaussian Beam parameterised by the      radius of the beam, the phase radius, the phase factor and the      Rayleigh distance. Propagation is based on two different regimes      for a total of four different opertations.           Attributes     ----------     position : float, metres         The position of the wavefront in the optical system.              beam_radius : float, metres          The *initial* radius of the beam.                        waist_position : float, metres         The position of the beam waist along the optical axis.      spherical : bool         A convinience tracker for knowing if the wavefront is          currently spherical.     rayleigh_factor : float         Used to determine the range over which the wavefront remains         planar.      focal_length : float, metres         Used for the conversion between angular and physical units.      \"\"\"     angular : bool     spherical : bool     waist_radius : Scalar     position : Scalar     waist_position : Scalar     rayleigh_factor : Scalar     focal_length : Scalar            def __init__(self            : Wavefront,                  wavelength      : Scalar,                  offset          : Vector,                  pixel_scale     : Scalar,                  plane_type      : PlaneType,                  amplitude       : Array,                   phase           : Array,                  waist_radius    : Scalar,                  rayleigh_factor : Scalar = 2.) -&gt; Wavefront:         \"\"\"         Creates a wavefront with an empty amplitude and phase          arrays but of a given wavelength and phase offset.          Assumes that the beam starts at the waist following from          the `poppy` convention.          Parameters         ----------         beam_radius : float, metres             Radius of the beam at the initial optical plane.         wavelength : float, metres             The wavelength of the `Wavefront`.         offset : Array, radians             The (x, y) angular offset of the `Wavefront` from              the optical axis.         rayleigh_factor : float             A multiplicative factor determining the threshold for              considering the wavefront spherical.         \"\"\"         super().__init__(wavelength, offset, pixel_scale, plane_type,                         amplitude, phase)         self.waist_radius = np.asarray(waist_radius).astype(float)           self.position = np.asarray(0., dtype=float)         self.waist_position = np.asarray(0., dtype=float)         self.rayleigh_factor = np.asarray(rayleigh_factor, dtype=float)         self.focal_length = np.inf          self.angular = np.asarray(False, dtype=bool)         self.spherical = np.asarray(False, dtype=bool)               ### Getters ###     def get_position(self : Wavefront) -&gt; float:         \"\"\"         Accessor for the position of the wavefront.           Returns          -------         position : float              The position of the `Wavefront` from its starting point              in metres.         \"\"\"         return self.position           def get_phase_radius(self : Wavefront) -&gt; float:         \"\"\"         Accessor for the phase radius of the wavefront.          Returns         -------         phase_radius : float              The phase radius of the wavefront. This is a unitless              quantity.         \"\"\"         return self.phase_radius               def get_pixel_positions(self : Wavefront) -&gt; Array:         \"\"\"         Returns         -------         positions : Tensor, metres             The position of each pixel aligned according to the `fft`              algorithm that is implemented by `numpy`.         \"\"\"         pixels = self.number_of_pixels()         positions = np.array(np.indices((pixels, pixels)) - pixels / 2.)         return self.get_pixel_scale() * positions       def is_angular(self : Wavefront) -&gt; bool:         \"\"\"                  \"\"\"         return self.angular          # NOTE: The pixel scale cannot be set when self.angular == True     # NOTE: This has the correct units always/     def get_pixel_scale(self : Wavefront):         \"\"\"                  NOTE - This seems dodgey, becuase if we enfore only using         getter and setter this would result in inifinite recursion.         Maybe this is okay though becuase it IS The getter                  Returns         -------         pixel_scale : The width of a single pixel in the array             representing the `Wavefront`. Note that this differs             from `poppy` because it includes the oversample.          \"\"\"         return jax.lax.cond(self.is_angular(),             lambda : self.pixel_scale / self.focal_length,             lambda : self.pixel_scale)               def get_waist_radius(self : Wavefront):         \"\"\"         Calculates the current waist radius as half of the diameter                  Mainly just exists to keep consistency with textbook terms         \"\"\"         return self.waist_radius       def rayleigh_distance(self : Wavefront) -&gt; Scalar:         \"\"\"         Calculates the rayleigh distance of the Gaussian beam.                  Returns         -------         rayleigh_distance : float             The Rayleigh distance of the wavefront in metres.         \"\"\"         return np.pi * self.get_waist_radius() ** 2 / self.get_wavelength()               ### Setters ###     # NOT USED     def set_position(self : Wavefront,              position : float) -&gt; Wavefront:         \"\"\"         Mutator for the position of the wavefront. Changes the          pixel_scale which is a function of the position.            Parameters         ----------         position : float             The new position of the wavefront from its starting point              assumed to be in metres.                   Returns         -------         wavefront : Wavefront             This wavefront at the new position.          \"\"\"         return eqx.tree_at(             lambda wavefront : wavefront.position, self, position,             is_leaf = lambda leaf : leaf is None)               # NOT UESD     def set_phase_radius(self : Wavefront,              phase_radius : float) -&gt; Wavefront:         \"\"\"         Mutator for the phase_radius.          Parameters         ----------         phase_radius : float             The new phase_radius in metres.          Returns         -------         wavefront : Wavefront             A modified Wavefront with the new phase_radius.         \"\"\"         return eqx.tree_at(lambda wavefront : wavefront.phase_radius,              self, phase_radius, is_leaf = lambda leaf : leaf is None)               # NOTE: ordering convention: dunder, _..., ..._at, ..._after,      # set_... get_...     # NOTE: naming conventself._outside_to_outsideion: position -&gt; absolute place on optical     # axis and distance -&gt; movement.     def set_waist_position(self : Wavefront, waist_position : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         waist_position : float, metres              The absolute position of the waist of the wavefront.          Returns         -------         wavefront : Wavefront             The `Wavefront` with the updated parameters.           \"\"\"         return eqx.tree_at(lambda wave : wave.waist_position,             self, waist_position)               def set_waist_radius(self : Wavefront, waist_radius : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         beam_radius : float             The new beam_radius in metres.          Returns         -------         wavefront : Wavefront             A modified `Wavefront` with the new `beam_radius`.         \"\"\"         return eqx.tree_at(lambda wave : wave.waist_radius,             self, waist_radius)       def set_spherical(self : Wavefront, spherical : bool) -&gt; Wavefront:         \"\"\"         Parameters         ----------         spherical : bool             Toggle the state of the `Wavefront` to and from `spherical`.                  Returns         -------         wavefront : Wavefront              The `Wavefront` with the parameters modified.          \"\"\"                  # Pretty sure the 'spherical' input need to wrapped into a jnp array         return eqx.tree_at(lambda wave : wave.spherical, self, spherical)           # TODO: Do I even want to include this functionality as it is      # only for the translation between the angular and the physical     # coordinates. I'm not sure that we need this.      def set_focal_length(self : Wavefront, focal_length : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         focal_length : float, metres             The `focal_length` of the `Wavefront`.          Returns         -------         wavefront : Wavefront             The `Wavefront` with the parameters modified.          \"\"\"         return eqx.tree_at(lambda wave : wave.focal_length,             self, focal_length)       # NOT USED     def calculate_pixel_scale(self: Wavefront, position: float) -&gt; None:         \"\"\"         The pixel scale at the position along the axis of propagation.          Parameters         ----------         position : float             The position of the wavefront along the axis of propagation             in metres.         \"\"\"         new_pixel_scale = self.get_wavelength() * np.abs(position) / \\             self.number_of_pixels() / self.get_pixel_scale()           return new_pixel_scale                    # NOT USED     def is_inside(self: Wavefront, distance: float) -&gt; bool:         \"\"\"          Determines whether a point at along the axis of propagation          at distance away from the current position is inside the          rayleigh distance.           Parameters         ----------         distance : float             The distance to test in metres.          Returns         -------         inside : bool             true if the point is within the rayleigh distance false              otherwise.         \"\"\"         return np.abs(self.get_position() + distance - \\             self.waist_position) &lt;= self.rayleigh_distance()       # NOTE: This also needs an ..._after name. I could use something     # like quadratic_phase_after() or phase_after()      def quadratic_phase(self : Wavefront, distance : Scalar) -&gt; Array:         \"\"\"         Convinience function that simplifies many of the diffraction         equations. Caclulates a quadratic phase factor associated with          Parameters         ----------         distance : float             The distance of the propagation measured in metres.           Returns         -------         phase : float             The near-field quadratic phase accumulated by the beam             from a propagation of distance.         \"\"\"               positions = self.get_pixel_positions()         rho_squared = (positions ** 2).sum(axis = 0)          return np.exp(1.j * np.pi * rho_squared / distance /\\             self.wavelength)       def transfer(self : Wavefront, distance : Scalar) -&gt; Array:         \"\"\"         The optical transfer function (OTF) for the Gaussian beam.         Assumes propagation is along the axis.           Parameters         ----------         distance : float             The distance to propagate the wavefront along the beam              via the optical transfer function in metres.          Returns         -------         phase : float              A phase representing the evolution of the wavefront over              the distance.          \"\"\"         positions = self.get_pixel_positions()         x, y = positions[0], positions[1]         rho_squared = \\             (x / (self.get_pixel_scale() ** 2 \\                 * self.number_of_pixels())) ** 2 + \\             (y / (self.get_pixel_scale() ** 2 \\                 * self.number_of_pixels())) ** 2         # Transfer Function of diffraction propagation eq. 22, eq. 87         return np.exp(-1.j * np.pi * self.wavelength * \\                 distance * rho_squared)       def curvature_at(self : Wavefront, position : float) -&gt; float:         \"\"\"         Calculate the radius of curvature of the `Wavefront` phase         at the absolute position: `position`.          Parameters         ----------         position : float, metres             The absolute position of the wave along the optical axis              from spawn.          Returns         -------         radius_of_curvature : float, radians             The radius of phase curvature for the wavefront.          \"\"\"         relative_position = position - self.waist_position         return relative_position + \\             self.rayleigh_distance() ** 2 / relative_position       def radius_at(self : Wavefront, position : Scalar) -&gt; Scalar:         \"\"\"         Calculate the radius of the `Wavefront` at an absolute         position.          Parameters         ----------         position : float, metres             The absolute position of the `Wavefront` since spawn.                  Returns         -------         radius : float, metres             The radius of the beam.          \"\"\"         relative_position = position - self.waist_position         return self.get_waist_radius() * \\             np.sqrt(1.0 + \\                 (relative_position / self.rayleigh_distance()) ** 2)           def is_planar_at(self : Wavefront, position : Scalar) -&gt; bool:         \"\"\"          Determines whether a point at along the axis of propagation          at distance away from the current position is inside the          rayleigh distance.           Parameters         ----------         distance : float             The distance to test in metres.          Returns         -------         inside : bool             true if the point is within the rayleigh distance false              otherwise.         \"\"\"         return np.abs(self.waist_position - position) \\             &lt; self.rayleigh_distance()           # NOTE: Also updates, so I want better names for these rather than      # after.      # NOTE: This is only for transitions from planar to spherical      # or vice versa so it needs a much better name than current.      def pixel_scale_after(self : Wavefront, distance : float) -&gt; Wavefront:         \"\"\"         Calculate and assign the pixel scale of the `Wavefront` after         travelling distance. Note that this transformation is dependent         on the mode of propagation and is only correct for         `_spherical_to_waist` and `_waist_to_spherical` but not for          `_plane_to_plane`.           Parameters         ----------         distance : float, metres             The distance of propagation from the current position.                  Returns         -------         wavefront : Wavefront             The wavefront but the pixel_scale has been updated.         \"\"\"         pixel_scale = self.get_wavelength() * np.abs(distance) /\\             (self.number_of_pixels() * self.get_pixel_scale())         return self.set_pixel_scale(pixel_scale)           def position_after(self : Wavefront,              distance : Scalar) -&gt; Wavefront:         \"\"\"         Move the wavefront forward by `distance`.          Parameters         ----------         distance : float, metres             The distance of propagation.                  Returns         -------         wavefront : Wavefront              The `Wavefront` with the `position` leaf updated.         \"\"\"         position = self.position + distance         return eqx.tree_at(lambda wave : wave.position, self, position) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class GaussianPropagator(eqx.Module):\n    distance : float\n\n    def __init__(self            : Propagator, \n                 distance        : float):\n        self.distance = np.asarray(distance).astype(float)\n\n    def _fourier_transform(self : Propagator, field : Array) -&gt; Array:\n        return 1 / field.shape[0] * np.fft.fft2(field)\n\n    def _inverse_fourier_transform(self : Propagator, field : Array) -&gt; Array:\n        return field.shape[0] * np.fft.ifft2(field)\n\n    # NOTE: need to add in the standard FFT normalising factor\n    # as in the propagator. \n    def _propagate(self : Propagator, field : Array, \n            distance : float) -&gt; Array:\n        return jax.lax.cond(distance &gt; 0,\n            lambda : self._inverse_fourier_transform(field),\n            lambda : self._fourier_transform(field))\n        \n    # NOTE: Wavefront must be planar \n    # NOTE: Uses eq. 82, 86, 87\n    def _plane_to_plane(self : Propagator, wavefront : Wavefront,\n            distance : float):\n        # NOTE: Seriously need to change the name to get_field()        \n        field = self._fourier_transform(wavefront.get_complex_form())\n        field *= np.fft.fftshift(wavefront.transfer(distance))  # eq. 6.68\n        field = self._inverse_fourier_transform(field)\n        \n        wavefront =  wavefront\\\n            .position_after(distance)\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\n        return wavefront\n \n    # NOTE: I'm thinking that the logic for repacking the wavefront\n    # should occur somewhere else although I guess that it can't really\n    # NOTE: Must start with a planar wavefront\n    def _waist_to_spherical(self : Propagator, wavefront : Wavefront, \n            distance : float) -&gt; Wavefront:\n        \n        # Lawrence eq. 83,88\n        field = wavefront.get_complex_form()\n        field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent\n        field = self._propagate(field, distance) # Wrapper for forwards/reverse FFTs\n        wavefront =  wavefront\\\n            .pixel_scale_after(distance)\\\n            .position_after(distance)\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\\\n            .set_spherical(True)   \n        return wavefront\n\n\n    # Wavefront.spherical must be True initially\n    def _spherical_to_waist(self : Propagator, wavefront : Wavefront,\n            distance : float) -&gt; Wavefront:\n        # Lawrence eq. 89\n        field = wavefront.get_complex_form()\n        field = self._propagate(field, distance)\n        wavefront = wavefront.pixel_scale_after(distance)\n        field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent\n        \n        wavefront = wavefront\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\\\n            .set_spherical(True)\\\n            .position_after(distance)\n        return wavefront\n\n    def _inside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:        \n        wave = self._plane_to_plane(wave, self.distance)\n        return wave\n\n\n    def _inside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront: \n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._plane_to_plane(wave, wave.waist_position - start)\n        wave = self._waist_to_spherical(wave, end - wave.waist_position)\n        return wave\n\n\n    def _outside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._spherical_to_waist(wave, wave.waist_position - start)\n        wave = self._plane_to_plane(wave, end - wave.waist_position)\n        return wave\n\n\n    def _outside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._spherical_to_waist(wave, wave.waist_position - start)\n        wave = self._waist_to_spherical(wave, end - wave.waist_position)\n        return wave\n\n\n    # NOTE: So I could attempt to move all of the functionality into \n    # the wavefront class and do very little here. Damn, I need to \n    # fit it into the overall architecture. \n    # TODO: Implement the oversample in the fixed sampling propagator\n    # Coordiantes must be in metres for the propagator\n    def __call__(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        # NOTE: need to understand this mystery. \n        field = np.fft.fftshift(wave.get_complex_form())\n        wave = wave.update_phasor(np.abs(field), np.angle(field))\n        position = wave.position + self.distance\n        decision = 2 * wave.spherical + wave.is_planar_at(position)\n        \n        wave = jax.lax.switch(\n            decision,\n            [self._inside_to_outside, self._inside_to_inside, \n            self._outside_to_outside, self._outside_to_inside], wave) \n\n        field = np.fft.fftshift(wave.get_complex_form())\n        wave = wave.update_phasor(np.abs(field), np.angle(field))        \n        return wave\n</pre> class GaussianPropagator(eqx.Module):     distance : float      def __init__(self            : Propagator,                   distance        : float):         self.distance = np.asarray(distance).astype(float)      def _fourier_transform(self : Propagator, field : Array) -&gt; Array:         return 1 / field.shape[0] * np.fft.fft2(field)      def _inverse_fourier_transform(self : Propagator, field : Array) -&gt; Array:         return field.shape[0] * np.fft.ifft2(field)      # NOTE: need to add in the standard FFT normalising factor     # as in the propagator.      def _propagate(self : Propagator, field : Array,              distance : float) -&gt; Array:         return jax.lax.cond(distance &gt; 0,             lambda : self._inverse_fourier_transform(field),             lambda : self._fourier_transform(field))              # NOTE: Wavefront must be planar      # NOTE: Uses eq. 82, 86, 87     def _plane_to_plane(self : Propagator, wavefront : Wavefront,             distance : float):         # NOTE: Seriously need to change the name to get_field()                 field = self._fourier_transform(wavefront.get_complex_form())         field *= np.fft.fftshift(wavefront.transfer(distance))  # eq. 6.68         field = self._inverse_fourier_transform(field)                  wavefront =  wavefront\\             .position_after(distance)\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))         return wavefront       # NOTE: I'm thinking that the logic for repacking the wavefront     # should occur somewhere else although I guess that it can't really     # NOTE: Must start with a planar wavefront     def _waist_to_spherical(self : Propagator, wavefront : Wavefront,              distance : float) -&gt; Wavefront:                  # Lawrence eq. 83,88         field = wavefront.get_complex_form()         field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent         field = self._propagate(field, distance) # Wrapper for forwards/reverse FFTs         wavefront =  wavefront\\             .pixel_scale_after(distance)\\             .position_after(distance)\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))\\             .set_spherical(True)            return wavefront       # Wavefront.spherical must be True initially     def _spherical_to_waist(self : Propagator, wavefront : Wavefront,             distance : float) -&gt; Wavefront:         # Lawrence eq. 89         field = wavefront.get_complex_form()         field = self._propagate(field, distance)         wavefront = wavefront.pixel_scale_after(distance)         field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent                  wavefront = wavefront\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))\\             .set_spherical(True)\\             .position_after(distance)         return wavefront      def _inside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:                 wave = self._plane_to_plane(wave, self.distance)         return wave       def _inside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:          start = wave.position         end = wave.position + self.distance         wave = self._plane_to_plane(wave, wave.waist_position - start)         wave = self._waist_to_spherical(wave, end - wave.waist_position)         return wave       def _outside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:         start = wave.position         end = wave.position + self.distance         wave = self._spherical_to_waist(wave, wave.waist_position - start)         wave = self._plane_to_plane(wave, end - wave.waist_position)         return wave       def _outside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:         start = wave.position         end = wave.position + self.distance         wave = self._spherical_to_waist(wave, wave.waist_position - start)         wave = self._waist_to_spherical(wave, end - wave.waist_position)         return wave       # NOTE: So I could attempt to move all of the functionality into      # the wavefront class and do very little here. Damn, I need to      # fit it into the overall architecture.      # TODO: Implement the oversample in the fixed sampling propagator     # Coordiantes must be in metres for the propagator     def __call__(self : Propagator, wave : Wavefront) -&gt; Wavefront:         # NOTE: need to understand this mystery.          field = np.fft.fftshift(wave.get_complex_form())         wave = wave.update_phasor(np.abs(field), np.angle(field))         position = wave.position + self.distance         decision = 2 * wave.spherical + wave.is_planar_at(position)                  wave = jax.lax.switch(             decision,             [self._inside_to_outside, self._inside_to_inside,              self._outside_to_outside, self._outside_to_inside], wave)           field = np.fft.fftshift(wave.get_complex_form())         wave = wave.update_phasor(np.abs(field), np.angle(field))                 return wave In\u00a0[\u00a0]: Copied! <pre>class GaussianLens(eqx.Module):\n    focal_length : float\n    # TODO: Should this store its position in the optical system?\n    # No I don't think that it should. \n\n    def __init__(self : Layer, focal_length : float) -&gt; Layer:\n        self.focal_length = np.asarray(focal_length).astype(float)\n\n\n    def _phase(self : Layer, wave : Wavefront, \n            distance : float) -&gt; Array:\n        position = wave.get_pixel_positions()\n        rho_squared = (position ** 2).sum(axis = 0)\n        return np.exp(1.j / np.pi * rho_squared / distance *\\\n            wave.wavelength)\n\n\n    def __call__(self : Layer, wave : Wavefront) -&gt; Wavefront:\n        from_waist = wave.waist_position - wave.position\n        was_spherical = np.abs(from_waist) &gt; wave.rayleigh_factor * \\\n            wave.rayleigh_distance()\n\n        curve = wave.curvature_at(wave.position)\n\n        curve_at = jax.lax.cond(\n            was_spherical,\n            lambda : from_waist,\n            lambda : np.inf)\n\n        curve_after = jax.lax.cond(\n            was_spherical,\n            lambda : 1. / (1. / curve  - 1. / self.focal_length),\n            lambda : -self.focal_length)\n\n        radius = wave.radius_at(wave.position)\n        curve_ratio = (wave.wavelength * curve_after / np.pi / radius ** 2) ** 2\n        curve_matched = curve == self.focal_length\n\n        waist_position_after = jax.lax.cond(\n            curve_matched,\n            lambda : wave.position,\n            lambda : -curve_after / (1. + curve_ratio) + wave.position)\n\n        waist_radius_after = jax.lax.cond(\n            curve_matched,\n            lambda : radius,\n            lambda : radius / np.sqrt(1. + 1. / curve_ratio))\n\n        focal_length_after = jax.lax.cond(\n            np.isinf(wave.focal_length),\n            lambda : self.focal_length,\n            lambda : curve_after / curve_at * wave.focal_length)\n\n        wave = wave\\\n            .set_focal_length(focal_length_after)\\\n            .set_waist_radius(waist_radius_after)\\\n            .set_waist_position(waist_position_after)\n\n        from_new_waist = waist_position_after - wave.position\n        is_spherical = np.abs(from_new_waist) &gt; wave.rayleigh_distance()\n \n        distance = 1. / jax.lax.cond(\n            wave.spherical,\n            lambda : jax.lax.cond(\n                is_spherical,\n                lambda : 1. / self.focal_length + 1. / from_new_waist - 1. / curve_at,\n                lambda : 1. / self.focal_length - 1. / curve_at),\n            lambda : jax.lax.cond(\n                is_spherical, \n                lambda : 1. / self.focal_length + 1. / from_new_waist,\n                lambda : 1. / self.focal_length))\n\n        field = wave.get_complex_form() * self._phase(wave, distance)\n        phase = np.angle(field)\n        amplitude = np.abs(field)\n\n        return wave\\\n            .set_phase(phase)\\\n            .set_amplitude(amplitude)\\\n            .set_spherical(is_spherical)\\\n            .set_waist_position(waist_position_after)\\\n            .set_waist_radius(waist_radius_after)\\\n            .set_focal_length(focal_length_after)\n</pre> class GaussianLens(eqx.Module):     focal_length : float     # TODO: Should this store its position in the optical system?     # No I don't think that it should.       def __init__(self : Layer, focal_length : float) -&gt; Layer:         self.focal_length = np.asarray(focal_length).astype(float)       def _phase(self : Layer, wave : Wavefront,              distance : float) -&gt; Array:         position = wave.get_pixel_positions()         rho_squared = (position ** 2).sum(axis = 0)         return np.exp(1.j / np.pi * rho_squared / distance *\\             wave.wavelength)       def __call__(self : Layer, wave : Wavefront) -&gt; Wavefront:         from_waist = wave.waist_position - wave.position         was_spherical = np.abs(from_waist) &gt; wave.rayleigh_factor * \\             wave.rayleigh_distance()          curve = wave.curvature_at(wave.position)          curve_at = jax.lax.cond(             was_spherical,             lambda : from_waist,             lambda : np.inf)          curve_after = jax.lax.cond(             was_spherical,             lambda : 1. / (1. / curve  - 1. / self.focal_length),             lambda : -self.focal_length)          radius = wave.radius_at(wave.position)         curve_ratio = (wave.wavelength * curve_after / np.pi / radius ** 2) ** 2         curve_matched = curve == self.focal_length          waist_position_after = jax.lax.cond(             curve_matched,             lambda : wave.position,             lambda : -curve_after / (1. + curve_ratio) + wave.position)          waist_radius_after = jax.lax.cond(             curve_matched,             lambda : radius,             lambda : radius / np.sqrt(1. + 1. / curve_ratio))          focal_length_after = jax.lax.cond(             np.isinf(wave.focal_length),             lambda : self.focal_length,             lambda : curve_after / curve_at * wave.focal_length)          wave = wave\\             .set_focal_length(focal_length_after)\\             .set_waist_radius(waist_radius_after)\\             .set_waist_position(waist_position_after)          from_new_waist = waist_position_after - wave.position         is_spherical = np.abs(from_new_waist) &gt; wave.rayleigh_distance()           distance = 1. / jax.lax.cond(             wave.spherical,             lambda : jax.lax.cond(                 is_spherical,                 lambda : 1. / self.focal_length + 1. / from_new_waist - 1. / curve_at,                 lambda : 1. / self.focal_length - 1. / curve_at),             lambda : jax.lax.cond(                 is_spherical,                  lambda : 1. / self.focal_length + 1. / from_new_waist,                 lambda : 1. / self.focal_length))          field = wave.get_complex_form() * self._phase(wave, distance)         phase = np.angle(field)         amplitude = np.abs(field)          return wave\\             .set_phase(phase)\\             .set_amplitude(amplitude)\\             .set_spherical(is_spherical)\\             .set_waist_position(waist_position_after)\\             .set_waist_radius(waist_radius_after)\\             .set_focal_length(focal_length_after)"},{"location":"dLux/dev/Filters/","title":"Filters","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>class Filter(Base):\n\"\"\"\n    NOTE: This class is under development.\n\n    A class for modelling optical filters.\n\n    Attributes\n    ----------\n    wavelengths : Array\n        The wavelengths at which the filter is defined.\n    throughput : Array\n        The throughput of the filter at the corresponding wavelength.\n    filter_name : str\n        A string identifier that can be used to initialise specific filters.\n    \"\"\"\n    wavelengths  : Array\n    throughput   : Array\n    filter_name  : str\n\n\n    def __init__(self        : Filter,\n                 wavelengths : Array = None,\n                 throughput  : Array = None,\n                 filter_name : str   = None) -&gt; Filter:\n\"\"\"\n        Constructor for the Filter class. All inputs are optional and defaults\n        to uniform unitary throughput. If filter_name is specified then\n        wavelengths and weights must not be specified.\n\n        Parameters\n        ----------\n        wavelengths : Array = None\n            The wavelengths at which the filter is defined.\n        throughput : Array = None\n            The throughput of the filter at the corresponding wavelength.\n        filter_name : str = None\n            A string identifier that can be used to initialise specific filters.\n            Currently no pre-built filters are implemented.\n        \"\"\"\n        # Take the filter name as the priority input\n        if filter_name is not None:\n            # TODO: Pre load filters\n            raise NotImplementedError(\"You know what this means.\")\n            pass\n\n            # Check that wavelengths and throughput are not specified\n            if wavelengths is not None or throughput is not None:\n                raise ValueError(\"If filter_name is specified, wavelengths \"\n                \"and throughput can not be specified.\")\n\n        # Check that both wavelengths and throughput are specified\n        elif (wavelengths is     None and throughput is not None) or \\\n             (wavelengths is not None and throughput is     None):\n            raise ValueError(\"If either wavelengths or throughput is \"\n            \"specified, then both must be specified.\")\n\n        # Neither is specified\n        elif wavelengths is None and throughput is None:\n            self.wavelengths = np.array([0., np.inf])\n            self.throughput  = np.array([1., 1.])\n            self.filter_name = 'Unitary'\n\n        # Both wavelengths and throughputs are specified\n        else:\n            self.wavelengths = np.asarray(wavelengths, dtype=float)\n            self.throughput  = np.asarray(throughput,  dtype=float)\n            self.filter_name = 'Custom'\n\n            # Check bounds\n            assert self.wavelengths.ndim == 1 and self.throughput.ndim == 1, \\\n            \"Both wavelengths and throughput must be 1 dimensional.\"\n            assert self.wavelengths.shape == self.throughput.shape, \\\n            (\"wavelengths and throughput must have the same length.\")\n            assert np.min(self.wavelengths) &gt;= 0, \\\n            (\"wavelengths can not be less than 0.\")\n            assert (self.throughput &gt;= 0).all() and \\\n            (self.throughput &lt;= 1).all(), (\"throughput must be between 0-1.\")\n            assert np.min(wavelengths) &lt; np.max(wavelengths), \\\n            (\"wavelengths must be in-order from small to large.\")\n\n\n    def get_throughput(self : Filter, sample_wavelenghts : Array) -&gt; Array:\n\"\"\"\n        Gets the average throughput of the bandpass defined the differences\n        between each sample wavelength, i.e. if sample wavelengths are:\n            [10, 20, 30, 40],\n        the bandpasses for each sample wavelength will be\n            [5-15, 15-25, 25-30, 35-40].\n        The throughput is calculated as the average throughput over that\n        bandpass.\n\n        Parameters\n        ----------\n        sample_wavelengths : Array, metres\n            The wavelengths at which to sample the filter. Must contain at\n            least two values.\n\n        Returns\n        -------\n        throughputs : Array\n            The average throughput for each bandpass defined by\n            sample_wavelengths.\n        \"\"\"\n        mids = (sample_wavelenghts[1:] + sample_wavelenghts[:-1]) / 2\n        diffs = np.diff(sample_wavelenghts)\n\n        start = np.array([sample_wavelenghts[0] - diffs[0]/2])\n        end = np.array([sample_wavelenghts[-1] + diffs[-1]/2])\n        min_val = np.array([self.wavelengths.min()])\n        max_val = np.array([self.wavelengths.max()])\n        bounds = np.concatenate([start, mids, end])\n\n        # Translate input wavelengths to indexes\n        min_wavelength = self.wavelengths.min()\n        max_wavelength = self.wavelengths.max()\n        num_wavelength = len(self.wavelengths)\n        wavelength_range = max_wavelength - min_wavelength\n        bnd_indxs = num_wavelength * (bounds - min_wavelength)/wavelength_range\n        bnd_indxs = np.clip(bnd_indxs, a_min=0, a_max=len(self.wavelengths))\n        bnd_inds = np.round(bnd_indxs, decimals=0).astype(int)\n\n        def nan_div(y, x):\n            x_new = np.where(x == 0, 1, x)\n            return np.where(x == 0, 0., y/x_new)\n\n        def get_tp(start, end, weights, indexes):\n            size = (end - start)\n            val = np.where((indexes &lt;= start) | (indexes &gt;= end), \\\n                           0., weights).sum()\n            return nan_div(val, size)\n\n        starts = bnd_inds[:-1]\n        ends   = bnd_inds[1:]\n        # dwavelength = self.wavelengths[1] - self.wavelengths[0]\n        indexes = np.arange(len(self.wavelengths))\n\n        # weights = self.throughput/self.throughput.sum()\n        weights = self.throughput\n        out = vmap(get_tp, in_axes=(0, 0, None, None))(starts, ends, weights, indexes)\n        return out\n\n\n    def model(self : Filter, optics : Optics, **kwargs):\n\"\"\"\n        A base level modelling function designed to robustly handle the\n        different combinations of inputs. Models the sources through the\n        instrument optics and detector. Users must provide optics and some form\n        of source, either via a scene, sources or single source input, but not\n        multiple.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector to use with the observation. Defaults to the\n            internally stored value.\n        scene : Scene = None\n            The scene to observe. Defaults to the internally stored value.\n        sources : Union[dict, list, tuple) = None\n            The sources to observe.\n        source : dLux.sources.Source = None\n            The source to observe.\n        normalise_sources : bool = True\n            Whether to normalise the sources before modelling. Default is True.\n        flatten : bool = False\n            Whether the output image should be flattened. Default is False.\n        return_tree : bool = False\n            Whether to return a Pytree like object with matching tree structure\n            as the input scene/sources/source. Default is False.\n\n        Returns\n        -------\n        image : Array, Pytree\n            The image of the scene modelled through the optics with detector and\n            filter effects applied if they are supplied. Returns either as a\n            single array (if return_tree is false), or a pytree like object\n            with matching tree strucutre as the input scene/sources/source.\n        \"\"\"\n        return model(optics, filter=self, **kwargs)\n</pre> class Filter(Base):     \"\"\"     NOTE: This class is under development.      A class for modelling optical filters.      Attributes     ----------     wavelengths : Array         The wavelengths at which the filter is defined.     throughput : Array         The throughput of the filter at the corresponding wavelength.     filter_name : str         A string identifier that can be used to initialise specific filters.     \"\"\"     wavelengths  : Array     throughput   : Array     filter_name  : str       def __init__(self        : Filter,                  wavelengths : Array = None,                  throughput  : Array = None,                  filter_name : str   = None) -&gt; Filter:         \"\"\"         Constructor for the Filter class. All inputs are optional and defaults         to uniform unitary throughput. If filter_name is specified then         wavelengths and weights must not be specified.          Parameters         ----------         wavelengths : Array = None             The wavelengths at which the filter is defined.         throughput : Array = None             The throughput of the filter at the corresponding wavelength.         filter_name : str = None             A string identifier that can be used to initialise specific filters.             Currently no pre-built filters are implemented.         \"\"\"         # Take the filter name as the priority input         if filter_name is not None:             # TODO: Pre load filters             raise NotImplementedError(\"You know what this means.\")             pass              # Check that wavelengths and throughput are not specified             if wavelengths is not None or throughput is not None:                 raise ValueError(\"If filter_name is specified, wavelengths \"                 \"and throughput can not be specified.\")          # Check that both wavelengths and throughput are specified         elif (wavelengths is     None and throughput is not None) or \\              (wavelengths is not None and throughput is     None):             raise ValueError(\"If either wavelengths or throughput is \"             \"specified, then both must be specified.\")          # Neither is specified         elif wavelengths is None and throughput is None:             self.wavelengths = np.array([0., np.inf])             self.throughput  = np.array([1., 1.])             self.filter_name = 'Unitary'          # Both wavelengths and throughputs are specified         else:             self.wavelengths = np.asarray(wavelengths, dtype=float)             self.throughput  = np.asarray(throughput,  dtype=float)             self.filter_name = 'Custom'              # Check bounds             assert self.wavelengths.ndim == 1 and self.throughput.ndim == 1, \\             \"Both wavelengths and throughput must be 1 dimensional.\"             assert self.wavelengths.shape == self.throughput.shape, \\             (\"wavelengths and throughput must have the same length.\")             assert np.min(self.wavelengths) &gt;= 0, \\             (\"wavelengths can not be less than 0.\")             assert (self.throughput &gt;= 0).all() and \\             (self.throughput &lt;= 1).all(), (\"throughput must be between 0-1.\")             assert np.min(wavelengths) &lt; np.max(wavelengths), \\             (\"wavelengths must be in-order from small to large.\")       def get_throughput(self : Filter, sample_wavelenghts : Array) -&gt; Array:         \"\"\"         Gets the average throughput of the bandpass defined the differences         between each sample wavelength, i.e. if sample wavelengths are:             [10, 20, 30, 40],         the bandpasses for each sample wavelength will be             [5-15, 15-25, 25-30, 35-40].         The throughput is calculated as the average throughput over that         bandpass.          Parameters         ----------         sample_wavelengths : Array, metres             The wavelengths at which to sample the filter. Must contain at             least two values.          Returns         -------         throughputs : Array             The average throughput for each bandpass defined by             sample_wavelengths.         \"\"\"         mids = (sample_wavelenghts[1:] + sample_wavelenghts[:-1]) / 2         diffs = np.diff(sample_wavelenghts)          start = np.array([sample_wavelenghts[0] - diffs[0]/2])         end = np.array([sample_wavelenghts[-1] + diffs[-1]/2])         min_val = np.array([self.wavelengths.min()])         max_val = np.array([self.wavelengths.max()])         bounds = np.concatenate([start, mids, end])          # Translate input wavelengths to indexes         min_wavelength = self.wavelengths.min()         max_wavelength = self.wavelengths.max()         num_wavelength = len(self.wavelengths)         wavelength_range = max_wavelength - min_wavelength         bnd_indxs = num_wavelength * (bounds - min_wavelength)/wavelength_range         bnd_indxs = np.clip(bnd_indxs, a_min=0, a_max=len(self.wavelengths))         bnd_inds = np.round(bnd_indxs, decimals=0).astype(int)          def nan_div(y, x):             x_new = np.where(x == 0, 1, x)             return np.where(x == 0, 0., y/x_new)          def get_tp(start, end, weights, indexes):             size = (end - start)             val = np.where((indexes &lt;= start) | (indexes &gt;= end), \\                            0., weights).sum()             return nan_div(val, size)          starts = bnd_inds[:-1]         ends   = bnd_inds[1:]         # dwavelength = self.wavelengths[1] - self.wavelengths[0]         indexes = np.arange(len(self.wavelengths))          # weights = self.throughput/self.throughput.sum()         weights = self.throughput         out = vmap(get_tp, in_axes=(0, 0, None, None))(starts, ends, weights, indexes)         return out       def model(self : Filter, optics : Optics, **kwargs):         \"\"\"         A base level modelling function designed to robustly handle the         different combinations of inputs. Models the sources through the         instrument optics and detector. Users must provide optics and some form         of source, either via a scene, sources or single source input, but not         multiple.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector to use with the observation. Defaults to the             internally stored value.         scene : Scene = None             The scene to observe. Defaults to the internally stored value.         sources : Union[dict, list, tuple) = None             The sources to observe.         source : dLux.sources.Source = None             The source to observe.         normalise_sources : bool = True             Whether to normalise the sources before modelling. Default is True.         flatten : bool = False             Whether the output image should be flattened. Default is False.         return_tree : bool = False             Whether to return a Pytree like object with matching tree structure             as the input scene/sources/source. Default is False.          Returns         -------         image : Array, Pytree             The image of the scene modelled through the optics with detector and             filter effects applied if they are supplied. Returns either as a             single array (if return_tree is false), or a pytree like object             with matching tree strucutre as the input scene/sources/source.         \"\"\"         return model(optics, filter=self, **kwargs)"},{"location":"dLux/utils/__init__/","title":"init","text":"In\u00a0[\u00a0]: Copied! <pre>name = \"utils\"\n</pre> name = \"utils\" In\u00a0[\u00a0]: Copied! <pre># Import as modules\nfrom . import coordinates\nfrom . import helpers\nfrom . import interpolation\nfrom . import units\nfrom . import optics\nfrom . import math\n</pre> # Import as modules from . import coordinates from . import helpers from . import interpolation from . import units from . import optics from . import math In\u00a0[\u00a0]: Copied! <pre># Dont import all functions from modules\nfrom .coordinates     import *\nfrom .helpers         import *\nfrom .interpolation   import *\nfrom .units           import *\nfrom .optics          import *\nfrom .math            import *\n</pre> # Dont import all functions from modules from .coordinates     import * from .helpers         import * from .interpolation   import * from .units           import * from .optics          import * from .math            import * In\u00a0[\u00a0]: Copied! <pre># Add to __all__\nmodules = [\n    coordinates,\n    helpers,\n    interpolation,\n    units,\n    optics,\n    math,\n]\n</pre> # Add to __all__ modules = [     coordinates,     helpers,     interpolation,     units,     optics,     math, ] In\u00a0[\u00a0]: Copied! <pre>__all__ = [module.__all__ for module in modules]\n</pre> __all__ = [module.__all__ for module in modules]"},{"location":"dLux/utils/coordinates/","title":"Coordinates","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\nfrom jax.tree_util import tree_map\nfrom typing import Union\n</pre> import jax.numpy as np from jax import Array from jax.tree_util import tree_map from typing import Union In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"cart_to_polar\", \"polar_to_cart\", \"pixel_coords\",\n           \"pixel_coordinates\"]\n</pre> __all__ = [\"cart_to_polar\", \"polar_to_cart\", \"pixel_coords\",            \"pixel_coordinates\"] In\u00a0[\u00a0]: Copied! <pre>### Coordinate conversions ###\ndef cart_to_polar(coordinates: Array) -&gt; Array:\n\"\"\"\n    Converts the input (x, y) Cartesian coordinates into (r, phi) polar\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (x, y) Cartesian coordinates to be converted into polar coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input Cartesian coordinates converted into (r, phi) polar\n        coordinates.\n    \"\"\"\n    x, y = coordinates\n    return np.array([np.hypot(x, y), np.arctan2(y, x)])\n</pre> ### Coordinate conversions ### def cart_to_polar(coordinates: Array) -&gt; Array:     \"\"\"     Converts the input (x, y) Cartesian coordinates into (r, phi) polar     coordinates.      Parameters     ----------     coordinates : Array         The (x, y) Cartesian coordinates to be converted into polar coordinates.      Returns     -------     coordinates : Array         The input Cartesian coordinates converted into (r, phi) polar         coordinates.     \"\"\"     x, y = coordinates     return np.array([np.hypot(x, y), np.arctan2(y, x)]) In\u00a0[\u00a0]: Copied! <pre>def polar_to_cart(coordinates: Array) -&gt; Array:\n\"\"\"\n    Converts the input (r, phi) polar coordinates into (x, y) Cartesian\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (r, phi) polar coordinates to be converted into Cartesian\n        coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input polar coordinates converted into (x, y) Cartesian coordinates.\n    \"\"\"\n    r, phi = coordinates\n    return np.array([r * np.cos(phi), r * np.sin(phi)])\n</pre> def polar_to_cart(coordinates: Array) -&gt; Array:     \"\"\"     Converts the input (r, phi) polar coordinates into (x, y) Cartesian     coordinates.      Parameters     ----------     coordinates : Array         The (r, phi) polar coordinates to be converted into Cartesian         coordinates.      Returns     -------     coordinates : Array         The input polar coordinates converted into (x, y) Cartesian coordinates.     \"\"\"     r, phi = coordinates     return np.array([r * np.cos(phi), r * np.sin(phi)]) In\u00a0[\u00a0]: Copied! <pre>### Positions Calculations ###\ndef pixel_coords(\n        npixels: int,\n        pixel_scale: float = 1,\n        ndims: int = 2,\n        polar=False,\n        ) -&gt; Array:\n\"\"\"\n    Calculates the coordinates of the pixel centers for the given input,\n    assuming an equal size and pixel scale in all dimensions. All \n    coordinates are output in units of metres. This function is essentially a\n    reduced version of the full `pixel_coordinates` function that gives\n    flexibility to have different dimension sizes and scales.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in all dimensions.\n    pixel_scale : float = 1\n        The pixel scale in all dimensions.\n    ndims : int = 2\n        The number of output dimensions.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        Cartesian coordinates. ndims must be 2 if polar is True.\n    Returns\n    -------\n    coordinates : Array\n        The array of pixel center coordinates.\n    \"\"\"\n    npixels = (npixels,) * ndims\n    pixel_scale = (pixel_scale,) * ndims\n    return pixel_coordinates(npixels, pixel_scale, polar=polar)\n</pre> ### Positions Calculations ### def pixel_coords(         npixels: int,         pixel_scale: float = 1,         ndims: int = 2,         polar=False,         ) -&gt; Array:     \"\"\"     Calculates the coordinates of the pixel centers for the given input,     assuming an equal size and pixel scale in all dimensions. All      coordinates are output in units of metres. This function is essentially a     reduced version of the full `pixel_coordinates` function that gives     flexibility to have different dimension sizes and scales.      Parameters     ----------     npixels : int         The number of pixels in all dimensions.     pixel_scale : float = 1         The pixel scale in all dimensions.     ndims : int = 2         The number of output dimensions.     polar : bool = False         If True, the output is in polar coordinates. If False, the output is in         Cartesian coordinates. ndims must be 2 if polar is True.          Returns     -------     coordinates : Array         The array of pixel center coordinates.     \"\"\"     npixels = (npixels,) * ndims     pixel_scale = (pixel_scale,) * ndims     return pixel_coordinates(npixels, pixel_scale, polar=polar) In\u00a0[\u00a0]: Copied! <pre>def pixel_coordinates(\n        npixels: Union[int, tuple],\n        pixel_scales: Union[tuple, float] = 1.,\n        offsets: Union[tuple, float] = 0.,\n        polar: bool = False,\n        indexing: str = 'xy'\n) -&gt; Array:\n\"\"\"\n    Calculates the coordinates of the pixel centers for the given input. All \n    coordinates are output in units of metres. \n    The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the\n    string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a\n    meshgrid with Cartesian indexing. In the 2-D case with inputs of length M\n    and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for\n    \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs\n    are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.\n    If the output is in polar coordinates, indexing is set to 'xy' and the\n    input must be 2d.\n    Parameters\n    ----------\n    npixels : Union[int, tuple]\n        The number of pixels in each dimension.\n    pixel_scales : Union[tuple, float] = 1.\n        The pixel scales in each dimension. If a tuple, the length\n        of the tuple must match the number of dimensions. If a float, the same\n        scale is applied to all dimensions. If None, the scale is set to 1.\n    offsets : Union[tuple, float] = 0.\n        The offset of the pixel centers in each dimension. If a tuple, the \n        length of the tuple must match the number of dimensions. If a float, \n        the same offset is applied to all dimensions. If None, the offset is \n        set to 0.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        Cartesian coordinates. Default is False.\n    indexing : str = 'xy'\n        The indexing of the output. Default is 'xy'. See numpy.meshgrid for more\n        details.\n    Returns\n    -------\n    positions : Array\n        The positions of the pixel centers in the given dimensions.\n    \"\"\"\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\"indexing must be either 'xy' or 'ij'.\")\n\n    if polar and indexing == 'ij':\n        indexing = 'xy'\n\n    if not isinstance(npixels, tuple):\n        npixels = (npixels,)\n\n    # Assume equal pixel scales if not given\n    if not isinstance(pixel_scales, tuple):\n        pixel_scales = (pixel_scales,) * len(npixels)\n\n    # Assume no offset if not given\n    if not isinstance(offsets, tuple):\n        offsets = (offsets,) * len(npixels)\n\n    def pixel_fn(n, offset, scale):\n        pix = np.arange(n) - (n - 1) / 2.\n        pix *= scale\n        pix -= offset\n        return pix\n\n    pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)\n\n    # output (x, y) for 2d, else in order\n    positions = np.array(np.meshgrid(*pixels, indexing=indexing))\n\n    if polar:\n        if len(npixels) != 2:\n            raise ValueError(\"polar coordinates are only defined for 2D arrays.\")\n        return cart_to_polar(positions)\n\n    # Squeeze for empty axis removal with 1d\n    return np.squeeze(positions)\n</pre> def pixel_coordinates(         npixels: Union[int, tuple],         pixel_scales: Union[tuple, float] = 1.,         offsets: Union[tuple, float] = 0.,         polar: bool = False,         indexing: str = 'xy' ) -&gt; Array:     \"\"\"     Calculates the coordinates of the pixel centers for the given input. All      coordinates are output in units of metres.           The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the     string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a     meshgrid with Cartesian indexing. In the 2-D case with inputs of length M     and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for     \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs     are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.     If the output is in polar coordinates, indexing is set to 'xy' and the     input must be 2d.          Parameters     ----------     npixels : Union[int, tuple]         The number of pixels in each dimension.     pixel_scales : Union[tuple, float] = 1.         The pixel scales in each dimension. If a tuple, the length         of the tuple must match the number of dimensions. If a float, the same         scale is applied to all dimensions. If None, the scale is set to 1.     offsets : Union[tuple, float] = 0.         The offset of the pixel centers in each dimension. If a tuple, the          length of the tuple must match the number of dimensions. If a float,          the same offset is applied to all dimensions. If None, the offset is          set to 0.     polar : bool = False         If True, the output is in polar coordinates. If False, the output is in         Cartesian coordinates. Default is False.     indexing : str = 'xy'         The indexing of the output. Default is 'xy'. See numpy.meshgrid for more         details.          Returns     -------     positions : Array         The positions of the pixel centers in the given dimensions.     \"\"\"     if indexing not in ['xy', 'ij']:         raise ValueError(\"indexing must be either 'xy' or 'ij'.\")      if polar and indexing == 'ij':         indexing = 'xy'      if not isinstance(npixels, tuple):         npixels = (npixels,)      # Assume equal pixel scales if not given     if not isinstance(pixel_scales, tuple):         pixel_scales = (pixel_scales,) * len(npixels)      # Assume no offset if not given     if not isinstance(offsets, tuple):         offsets = (offsets,) * len(npixels)      def pixel_fn(n, offset, scale):         pix = np.arange(n) - (n - 1) / 2.         pix *= scale         pix -= offset         return pix      pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)      # output (x, y) for 2d, else in order     positions = np.array(np.meshgrid(*pixels, indexing=indexing))      if polar:         if len(npixels) != 2:             raise ValueError(\"polar coordinates are only defined for 2D arrays.\")         return cart_to_polar(positions)      # Squeeze for empty axis removal with 1d     return np.squeeze(positions)"},{"location":"dLux/utils/helpers/","title":"Helpers","text":"In\u00a0[\u00a0]: Copied! <pre>from collections import OrderedDict\n</pre> from collections import OrderedDict In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"list_to_dictionary\"]\n</pre> __all__ = [\"list_to_dictionary\"] In\u00a0[\u00a0]: Copied! <pre>def list_to_dictionary(\n        list_in: list,\n        ordered: bool,\n        allowed_types: tuple = ()) -&gt; dict:\n\"\"\"\n    Converts some input list of dLux layers and converts them into an\n    OrderedDict with the correct structure, ensuring that all keys are unique.\n\n    Parameters\n    ----------\n    list_in : list\n        The list of dLux Layers to be converted into a dictionary.\n    ordered : bool\n        Whether to return an ordered or regular dictionary.\n    allowed_types : tuple\n        The allowed types of layers to be included in the dictionary.\n\n    Returns\n    -------\n    dictionary : dict\n        The equivalent dictionary or ordered dictionary.\n    \"\"\"\n    # Construct names list and identify repeats\n    names, repeats = [], []\n    for item in list_in:\n\n        # Check for specified names\n        if isinstance(item, tuple):\n            item, name = item\n        else:\n            name = item.__class__.__name__\n\n        # Check input types\n        if allowed_types != () and not isinstance(item, allowed_types):\n            raise TypeError(f\"Item {name} is not an allowed type, got \"\n                            f\"{type(item)}\")\n\n        # Check for Repeats\n        if name in names:\n            repeats.append(name)\n        names.append(name)\n\n    # Get list of unique repeats\n    repeats = list(set(repeats))\n\n    # Iterate over repeat names\n    for i in range(len(repeats)):\n\n        # Iterate over names list and append index value to name\n        idx = 0\n        for j in range(len(names)):\n            if repeats[i] == names[j]:\n                names[j] = names[j] + '_{}'.format(idx)\n                idx += 1\n\n    # Turn list into Dictionary\n    dict_out = OrderedDict() if ordered else {}\n    for i in range(len(names)):\n\n        # Check for spaces in names\n        if ' ' in names[i]:\n            raise ValueError(f\"Names can not contain spaces, got {names[i]}\")\n\n        # Add to dict\n        if isinstance(list_in[i], tuple):\n            item = list_in[i][0]\n        else:\n            item = list_in[i]\n        dict_out[names[i]] = item\n    return dict_out\n</pre> def list_to_dictionary(         list_in: list,         ordered: bool,         allowed_types: tuple = ()) -&gt; dict:     \"\"\"     Converts some input list of dLux layers and converts them into an     OrderedDict with the correct structure, ensuring that all keys are unique.      Parameters     ----------     list_in : list         The list of dLux Layers to be converted into a dictionary.     ordered : bool         Whether to return an ordered or regular dictionary.     allowed_types : tuple         The allowed types of layers to be included in the dictionary.      Returns     -------     dictionary : dict         The equivalent dictionary or ordered dictionary.     \"\"\"     # Construct names list and identify repeats     names, repeats = [], []     for item in list_in:          # Check for specified names         if isinstance(item, tuple):             item, name = item         else:             name = item.__class__.__name__          # Check input types         if allowed_types != () and not isinstance(item, allowed_types):             raise TypeError(f\"Item {name} is not an allowed type, got \"                             f\"{type(item)}\")          # Check for Repeats         if name in names:             repeats.append(name)         names.append(name)      # Get list of unique repeats     repeats = list(set(repeats))      # Iterate over repeat names     for i in range(len(repeats)):          # Iterate over names list and append index value to name         idx = 0         for j in range(len(names)):             if repeats[i] == names[j]:                 names[j] = names[j] + '_{}'.format(idx)                 idx += 1      # Turn list into Dictionary     dict_out = OrderedDict() if ordered else {}     for i in range(len(names)):          # Check for spaces in names         if ' ' in names[i]:             raise ValueError(f\"Names can not contain spaces, got {names[i]}\")          # Add to dict         if isinstance(list_in[i], tuple):             item = list_in[i][0]         else:             item = list_in[i]         dict_out[names[i]] = item     return dict_out"},{"location":"dLux/utils/interpolation/","title":"Interpolation","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\nfrom jax.scipy.ndimage import map_coordinates\nimport dLux.utils as dlu\n</pre> import jax.numpy as np from jax import Array from jax.scipy.ndimage import map_coordinates import dLux.utils as dlu In\u00a0[\u00a0]: Copied! <pre># TODO: Resolve scale and scale_array\n__all__ = [\"scale_array\", \"downsample\", \"generate_coordinates\", \"scale\",\n           \"rotate\", \"fourier_rotate\"]\n</pre> # TODO: Resolve scale and scale_array __all__ = [\"scale_array\", \"downsample\", \"generate_coordinates\", \"scale\",            \"rotate\", \"fourier_rotate\"] In\u00a0[\u00a0]: Copied! <pre>def scale_array(array: Array,\n                size_out: int,\n                order: int) -&gt; Array:\n\"\"\"\n    Scales some input array to size_out using interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to scale.\n    size_out : int\n        The output size of the mask\n    order : int\n        The interpolation order. Supports 0 and 1.\n\n    Returns\n    -------\n    array : Array\n        The array scaled to size_out\n    \"\"\"\n    xs = np.linspace(0, array.shape[0], size_out)\n    xs, ys = np.meshgrid(xs, xs)\n    return map_coordinates(array, np.array([ys, xs]), order=order)\n</pre> def scale_array(array: Array,                 size_out: int,                 order: int) -&gt; Array:     \"\"\"     Scales some input array to size_out using interpolation.      Parameters     ----------     array : Array         The array to scale.     size_out : int         The output size of the mask     order : int         The interpolation order. Supports 0 and 1.      Returns     -------     array : Array         The array scaled to size_out     \"\"\"     xs = np.linspace(0, array.shape[0], size_out)     xs, ys = np.meshgrid(xs, xs)     return map_coordinates(array, np.array([ys, xs]), order=order) In\u00a0[\u00a0]: Copied! <pre>def downsample(array: Array, n: int, method='mean') -&gt; Array:\n\"\"\"\n    Downsamples the input array by n.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to downsample.\n    n : int\n        The factor by which to downsample the array.\n    method : str = 'mean'\n        The method by which to downsample the array. Can be 'mean' or 'sum'.\n\n    Returns\n    -------\n    array : Array\n        The downsampled array.\n    \"\"\"\n    if method == 'sum':\n        method = np.sum\n    elif method == 'mean':\n        method = np.mean\n    else:\n        raise ValueError('Invalid method. Choose \"mean\" or \"sum\".')\n\n    size_in = array.shape[0]\n    size_out = size_in // n\n\n    # Downsample first dimension\n    array = method(array.reshape((size_in * size_out, n)), 1)\n    array = array.reshape(size_in, size_out).T\n\n    # Downsample second dimension\n    array = method(array.reshape((size_out * size_out, n)), 1)\n    array = array.reshape(size_out, size_out).T\n    return array\n</pre> def downsample(array: Array, n: int, method='mean') -&gt; Array:     \"\"\"     Downsamples the input array by n.      Parameters     ----------     array : Array         The input array to downsample.     n : int         The factor by which to downsample the array.     method : str = 'mean'         The method by which to downsample the array. Can be 'mean' or 'sum'.      Returns     -------     array : Array         The downsampled array.     \"\"\"     if method == 'sum':         method = np.sum     elif method == 'mean':         method = np.mean     else:         raise ValueError('Invalid method. Choose \"mean\" or \"sum\".')      size_in = array.shape[0]     size_out = size_in // n      # Downsample first dimension     array = method(array.reshape((size_in * size_out, n)), 1)     array = array.reshape(size_in, size_out).T      # Downsample second dimension     array = method(array.reshape((size_out * size_out, n)), 1)     array = array.reshape(size_out, size_out).T     return array In\u00a0[\u00a0]: Copied! <pre>def generate_coordinates(npixels_in: int,\n                         npixels_out: int,\n                         sampling_ratio: Array,\n                         x_shift: Array = np.array(0.),\n                         y_shift: Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Generates a new set of paraxial coordinates which can be used for\n    interpolation.\n\n    Parameters\n    ----------\n    npixels_in : int\n        The number of pixels in the original array.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        i.e. pixel_scale_out/pixel_scale_in.\n    x_shift : Array, pixels = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixels = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    coordinates : Array\n        The output coordinates at which to interpolate onto.\n    \"\"\"\n    old_centre = (npixels_in - 1) / 2\n    new_centre = (npixels_out - 1) / 2\n    pixels = sampling_ratio * np.linspace(-new_centre, new_centre,\n                                          npixels_out) + old_centre\n    x_pixels, y_pixels = np.meshgrid(pixels + x_shift, pixels + y_shift)\n    return np.array([y_pixels, x_pixels])\n</pre> def generate_coordinates(npixels_in: int,                          npixels_out: int,                          sampling_ratio: Array,                          x_shift: Array = np.array(0.),                          y_shift: Array = np.array(0.)) -&gt; Array:     \"\"\"     Generates a new set of paraxial coordinates which can be used for     interpolation.      Parameters     ----------     npixels_in : int         The number of pixels in the original array.     npixels_out : int         The number of pixel in the output array.     sampling_ratio : Array         The ratio of pixel sizes in the input and output array,         i.e. pixel_scale_out/pixel_scale_in.     x_shift : Array, pixels = np.array(0.)         How much to shift the x_coordinates in the output array, in the pixel         units of the output array.     y_shift : Array, pixels = np.array(0.)         How much to shift the y_coordinates in the output array, in the pixel         units of the output array.      Returns     -------     coordinates : Array         The output coordinates at which to interpolate onto.     \"\"\"     old_centre = (npixels_in - 1) / 2     new_centre = (npixels_out - 1) / 2     pixels = sampling_ratio * np.linspace(-new_centre, new_centre,                                           npixels_out) + old_centre     x_pixels, y_pixels = np.meshgrid(pixels + x_shift, pixels + y_shift)     return np.array([y_pixels, x_pixels]) In\u00a0[\u00a0]: Copied! <pre>def scale(array: Array,\n          npixels: int,\n          ratio: float,\n          order: int = 1) -&gt; Array:\n\"\"\"\n    Paraxially interpolates a wavefront field (either in amplitude and phase, or\n    real and imaginary) based on the sampling ratio, and npixels_out.\n\n    # TODO: Check if a half-pixel offset is produced\n\n    Parameters\n    ----------\n    array : Array\n        The input field to interpolate, either in amplitude and phase, or real\n        and imaginary.\n    npixels : int\n        The number of pixel in the output array.\n    ratio : float\n        The relative input to output scales, TODO: does 2 make it bigger or \n        smaller? i.e. input scale/output scale. &lt;- get this right.\n    order : int = 1\n        The interpolation order to use.\n\n    Returns\n    -------\n    field : Array\n        The interpolated output amplitude and phase arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = array.shape[-1]\n    # TODO: Update with utils.pixel_coordinates\n    coordinates = generate_coordinates(npixels_in, npixels, ratio)\n    return map_coordinates(array, coordinates, order=order)\n</pre> def scale(array: Array,           npixels: int,           ratio: float,           order: int = 1) -&gt; Array:     \"\"\"     Paraxially interpolates a wavefront field (either in amplitude and phase, or     real and imaginary) based on the sampling ratio, and npixels_out.      # TODO: Check if a half-pixel offset is produced      Parameters     ----------     array : Array         The input field to interpolate, either in amplitude and phase, or real         and imaginary.     npixels : int         The number of pixel in the output array.     ratio : float         The relative input to output scales, TODO: does 2 make it bigger or          smaller? i.e. input scale/output scale. &lt;- get this right.     order : int = 1         The interpolation order to use.      Returns     -------     field : Array         The interpolated output amplitude and phase arrays.     \"\"\"     # Get coords arrays     npixels_in = array.shape[-1]     # TODO: Update with utils.pixel_coordinates     coordinates = generate_coordinates(npixels_in, npixels, ratio)     return map_coordinates(array, coordinates, order=order) In\u00a0[\u00a0]: Copied! <pre>def rotate(array: Array, angle: Array, order: int = 1) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using linear interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    order : int = 1\n        The interpolation order to use.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n\n    def _rotate(coordinates: Array, rotation: Array) -&gt; Array:\n        x, y = coordinates[0], coordinates[1]\n        new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n        new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n        return np.array([new_x, new_y])\n\n    # Get coordinates\n    npixels = array.shape[0]\n    centre = (npixels - 1) / 2\n    coordinates = dlu.pixel_coordinates((npixels, npixels), indexing='ij')\n    coordinates_rotated = _rotate(coordinates, angle) + centre\n\n    # Interpolate\n    return map_coordinates(array, coordinates_rotated, order=order)\n</pre> def rotate(array: Array, angle: Array, order: int = 1) -&gt; Array:     \"\"\"     Rotates an array by the angle, using linear interpolation.      Parameters     ----------     array : Array         The array to rotate.     angle : Array, radians         The angle to rotate the array by.     order : int = 1         The interpolation order to use.      Returns     -------     array : Array         The rotated array.     \"\"\"      def _rotate(coordinates: Array, rotation: Array) -&gt; Array:         x, y = coordinates[0], coordinates[1]         new_x = np.cos(-rotation) * x + np.sin(-rotation) * y         new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y         return np.array([new_x, new_y])      # Get coordinates     npixels = array.shape[0]     centre = (npixels - 1) / 2     coordinates = dlu.pixel_coordinates((npixels, npixels), indexing='ij')     coordinates_rotated = _rotate(coordinates, angle) + centre      # Interpolate     return map_coordinates(array, coordinates_rotated, order=order) In\u00a0[\u00a0]: Copied! <pre>def fourier_rotate(array: Array,\n                   angle: Array,\n                   padding: int = 2) -&gt; Array:  # pragma: no cover\n\"\"\"\n    Rotates an array by the angle, using a fourier rotation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    padding : int = 2\n        The amount of fourier padding to use.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n    raise NotImplementedError(\"Fourier rotation is under development.\")\n    # TODO implement\n    in_shape = array.shape\n    array_shape = np.array(in_shape, dtype=int) + 3\n    array = np.full(array_shape, np.nan, dtype=float) \\\n                .at[1: in_shape[0] + 1, 1: in_shape[1] + 1] \\\n        .set(array)\n\n    # FFT rotation only work in the -45:+45 range\n    # So I need to work out how to determine the quadrant that\n    # angle is in and hence the\n    # number of required pi/2 rotations and angle in radians.\n    half_pi_to_1st_quadrant = angle // (np.pi / 2)\n    angle_in_1st_quadrant = - angle + (half_pi_to_1st_quadrant * np.pi / 2)\n\n    array = np.rot90(array, half_pi_to_1st_quadrant) \\\n                .at[:-1, :-1] \\\n        .get()\n\n    width, height = array.shape\n    left_corner = int(((padding - 1) / 2.) * width)\n    right_corner = int(((padding + 1) / 2.) * width)\n    top_corner = int(((padding - 1) / 2.) * height)\n    bottom_corner = int(((padding + 1) / 2.) * height)\n\n    # Make the padded array\n    out_shape = (width * padding, height * padding)\n    padded_array = np.full(out_shape, np.nan, dtype=float) \\\n                       .at[left_corner: right_corner, top_corner: bottom_corner] \\\n        .set(array)\n\n    padded_mask = np.ones(out_shape, dtype=bool) \\\n                      .at[left_corner: right_corner, top_corner: bottom_corner] \\\n        .set(np.where(np.isnan(array), True, False))\n\n    # Rotate the mask, to know what part is actually the array\n    padded_mask = self.__rotate(padded_mask, -angle_in_1st_quadrant)\n\n    # Replace part outside the array which are NaN by 0, and go into \n    # Fourier space.\n    padded_array = np.where(np.isnan(padded_array), 0., padded_array)\n\n    uncentered_angular_displacement = np.tan(angle_in_1st_quadrant / 2.)\n    centered_angular_displacement = -np.sin(angle_in_1st_quadrant)\n\n    uncentered_frequencies = np.fft.fftfreq(out_shape[0])\n    centered_frequencies = np.arange(-out_shape[0] / 2., out_shape[0] / 2.)\n\n    pi_factor = -2.j * np.pi * np.ones(out_shape, dtype=float)\n\n    uncentered_phase = np.exp(\n        uncentered_angular_displacement * \\\n        ((pi_factor * uncentered_frequencies).T * \\\n         centered_frequencies).T)\n\n    centered_phase = np.exp(\n        centered_angular_displacement * \\\n        (pi_factor * centered_frequencies).T * \\\n        uncentered_frequencies)\n\n    f1 = np.fft.ifft(\n        (np.fft.fft(padded_array, axis=0).T * uncentered_phase).T, axis=0)\n\n    f2 = np.fft.ifft(\n        np.fft.fft(f1, axis=1) * centered_phase, axis=1)\n\n    rotated_array = np.fft.ifft(\n        (np.fft.fft(f2, axis=0).T * uncentered_phase).T, axis=0) \\\n        .at[padded_mask] \\\n        .set(np.nan)\n\n    return np.real(rotated_array \\\n                   .at[left_corner + 1: right_corner - 1,\n                   top_corner + 1: bottom_corner - 1] \\\n                   .get()).copy()\n</pre> def fourier_rotate(array: Array,                    angle: Array,                    padding: int = 2) -&gt; Array:  # pragma: no cover     \"\"\"     Rotates an array by the angle, using a fourier rotation.      Parameters     ----------     array : Array         The array to rotate.     angle : Array, radians         The angle to rotate the array by.     padding : int = 2         The amount of fourier padding to use.      Returns     -------     array : Array         The rotated array.     \"\"\"     raise NotImplementedError(\"Fourier rotation is under development.\")     # TODO implement     in_shape = array.shape     array_shape = np.array(in_shape, dtype=int) + 3     array = np.full(array_shape, np.nan, dtype=float) \\                 .at[1: in_shape[0] + 1, 1: in_shape[1] + 1] \\         .set(array)      # FFT rotation only work in the -45:+45 range     # So I need to work out how to determine the quadrant that     # angle is in and hence the     # number of required pi/2 rotations and angle in radians.     half_pi_to_1st_quadrant = angle // (np.pi / 2)     angle_in_1st_quadrant = - angle + (half_pi_to_1st_quadrant * np.pi / 2)      array = np.rot90(array, half_pi_to_1st_quadrant) \\                 .at[:-1, :-1] \\         .get()      width, height = array.shape     left_corner = int(((padding - 1) / 2.) * width)     right_corner = int(((padding + 1) / 2.) * width)     top_corner = int(((padding - 1) / 2.) * height)     bottom_corner = int(((padding + 1) / 2.) * height)      # Make the padded array     out_shape = (width * padding, height * padding)     padded_array = np.full(out_shape, np.nan, dtype=float) \\                        .at[left_corner: right_corner, top_corner: bottom_corner] \\         .set(array)      padded_mask = np.ones(out_shape, dtype=bool) \\                       .at[left_corner: right_corner, top_corner: bottom_corner] \\         .set(np.where(np.isnan(array), True, False))      # Rotate the mask, to know what part is actually the array     padded_mask = self.__rotate(padded_mask, -angle_in_1st_quadrant)      # Replace part outside the array which are NaN by 0, and go into      # Fourier space.     padded_array = np.where(np.isnan(padded_array), 0., padded_array)      uncentered_angular_displacement = np.tan(angle_in_1st_quadrant / 2.)     centered_angular_displacement = -np.sin(angle_in_1st_quadrant)      uncentered_frequencies = np.fft.fftfreq(out_shape[0])     centered_frequencies = np.arange(-out_shape[0] / 2., out_shape[0] / 2.)      pi_factor = -2.j * np.pi * np.ones(out_shape, dtype=float)      uncentered_phase = np.exp(         uncentered_angular_displacement * \\         ((pi_factor * uncentered_frequencies).T * \\          centered_frequencies).T)      centered_phase = np.exp(         centered_angular_displacement * \\         (pi_factor * centered_frequencies).T * \\         uncentered_frequencies)      f1 = np.fft.ifft(         (np.fft.fft(padded_array, axis=0).T * uncentered_phase).T, axis=0)      f2 = np.fft.ifft(         np.fft.fft(f1, axis=1) * centered_phase, axis=1)      rotated_array = np.fft.ifft(         (np.fft.fft(f2, axis=0).T * uncentered_phase).T, axis=0) \\         .at[padded_mask] \\         .set(np.nan)      return np.real(rotated_array \\                    .at[left_corner + 1: right_corner - 1,                    top_corner + 1: bottom_corner - 1] \\                    .get()).copy()"},{"location":"dLux/utils/math/","title":"Math","text":"In\u00a0[\u00a0]: Copied! <pre>from jax import lax\n</pre> from jax import lax In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"factorial\", \"triangular_number\"]\n</pre> __all__ = [\"factorial\", \"triangular_number\"] In\u00a0[\u00a0]: Copied! <pre># TODO: Use lax.cond to make n == 0 a safe case\ndef factorial(n: float) -&gt; float:\n\"\"\"\n    Calculate n! in a jax friendly way. Note that n == 0 is not a \n    safe case.  \n    Parameters\n    ----------\n    n : float\n        The value to calculate the factorial of.\n    Returns\n    -------\n    n! : float\n        The factorial of the value.\n    \"\"\"\n    return lax.exp(lax.lgamma(n + 1.))\n</pre> # TODO: Use lax.cond to make n == 0 a safe case def factorial(n: float) -&gt; float:     \"\"\"     Calculate n! in a jax friendly way. Note that n == 0 is not a      safe case.         Parameters     ----------     n : float         The value to calculate the factorial of.       Returns     -------     n! : float         The factorial of the value.     \"\"\"     return lax.exp(lax.lgamma(n + 1.)) In\u00a0[\u00a0]: Copied! <pre>def triangular_number(n: int) -&gt; int:\n\"\"\"\n    Calculate the nth triangular number.\n    Parameters\n    ----------\n    n : int\n        The nth triangular number to calculate.\n    Returns\n    -------\n    n : int\n        The nth triangular number.\n    \"\"\"\n    return n * (n + 1) / 2\n</pre> def triangular_number(n: int) -&gt; int:     \"\"\"     Calculate the nth triangular number.          Parameters     ----------     n : int         The nth triangular number to calculate.          Returns     -------     n : int         The nth triangular number.     \"\"\"     return n * (n + 1) / 2"},{"location":"dLux/utils/optics/","title":"Optics","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\n</pre> import jax.numpy as np from jax import Array In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"opd_to_phase\", \"phase_to_opd\", \"get_fringe_size\",\n           \"get_pixels_per_fringe\", \"get_pixel_scale\", \"get_airy_pixel_scale\"]\n</pre> __all__ = [\"opd_to_phase\", \"phase_to_opd\", \"get_fringe_size\",            \"get_pixels_per_fringe\", \"get_pixel_scale\", \"get_airy_pixel_scale\"] In\u00a0[\u00a0]: Copied! <pre>def opd_to_phase(opd: Array, wavelength: Array) -&gt; Array:\n\"\"\"\n    Converts the input Optical Path Difference (opd) in units of metres to\n    phases in units of radians for the given wavelength.\n\n    Parameters\n    ----------\n    opd : Array, metres\n        The Optical Path Difference (opd) to be converted into phase.\n    wavelength : Array, metres\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    phase : Array, radians\n        The equivalent phase value for the given opd and wavelength.\n    \"\"\"\n    return 2 * np.pi * opd / wavelength\n</pre> def opd_to_phase(opd: Array, wavelength: Array) -&gt; Array:     \"\"\"     Converts the input Optical Path Difference (opd) in units of metres to     phases in units of radians for the given wavelength.      Parameters     ----------     opd : Array, metres         The Optical Path Difference (opd) to be converted into phase.     wavelength : Array, metres         The wavelength at which to calculate the phase for.      Returns     -------     phase : Array, radians         The equivalent phase value for the given opd and wavelength.     \"\"\"     return 2 * np.pi * opd / wavelength In\u00a0[\u00a0]: Copied! <pre>def phase_to_opd(phase: Array, wavelength: Array) -&gt; Array:\n\"\"\"\n    Converts the input phase in units of radians to the equivalent Optical Path\n    Difference (opd) in metres for the given wavelength.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be converted into Optical Path Difference (opd)\n    wavelength : Array, metres\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    opd : Array, metres\n        The equivalent opd value for the given phase and wavelength.\n    \"\"\"\n    return phase * wavelength / (2 * np.pi)\n</pre> def phase_to_opd(phase: Array, wavelength: Array) -&gt; Array:     \"\"\"     Converts the input phase in units of radians to the equivalent Optical Path     Difference (opd) in metres for the given wavelength.      Parameters     ----------     phase : Array, radians         The phase to be converted into Optical Path Difference (opd)     wavelength : Array, metres         The wavelength at which to calculate the phase for.      Returns     -------     opd : Array, metres         The equivalent opd value for the given phase and wavelength.     \"\"\"     return phase * wavelength / (2 * np.pi) In\u00a0[\u00a0]: Copied! <pre>def get_fringe_size(wavelength: Array, aperture: Array) -&gt; Array:\n\"\"\"\n    Calculates the angular size of the diffraction fringes.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, metres\n        The size of the aperture.\n\n    Returns\n    -------\n    fringe_size : Array, radians\n        The angular fringe size in units of radians.\n    \"\"\"\n    return wavelength / aperture\n</pre> def get_fringe_size(wavelength: Array, aperture: Array) -&gt; Array:     \"\"\"     Calculates the angular size of the diffraction fringes.      Parameters     ----------     wavelength : Array, metres         The wavelength at which to calculate the diffraction fringe for.     aperture : Array, metres         The size of the aperture.      Returns     -------     fringe_size : Array, radians         The angular fringe size in units of radians.     \"\"\"     return wavelength / aperture In\u00a0[\u00a0]: Copied! <pre>def get_pixels_per_fringe(wavelength: Array,\n                          aperture: Array,\n                          pixel_scale: Array,\n                          focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the number of pixels per diffraction fringe, i.e. the fringe\n    sampling rate.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, metres\n        The size of the aperture.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The size of each pixel. This is taken in units of radians per pixel if\n        no focal length is provided, else it is taken in size of metres per\n        pixel.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is taken in units of radians per pixel, else it is taken in\n        metres per pixel.\n\n    Returns\n    -------\n    sampling : Array\n        The sampling rate of the fringes in units of pixels.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to metres if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Return sampling\n    return fringe_size / pixel_scale\n    # return pixel_scale/fringe_size\n</pre> def get_pixels_per_fringe(wavelength: Array,                           aperture: Array,                           pixel_scale: Array,                           focal_length: Array = None) -&gt; Array:     \"\"\"     Calculates the number of pixels per diffraction fringe, i.e. the fringe     sampling rate.      Parameters     ----------     wavelength : Array, metres         The wavelength at which to calculate the diffraction fringe for.     aperture : Array, metres         The size of the aperture.     pixel_scale : Array, metres/pixel or radians/pixel         The size of each pixel. This is taken in units of radians per pixel if         no focal length is provided, else it is taken in size of metres per         pixel.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is taken in units of radians per pixel, else it is taken in         metres per pixel.      Returns     -------     sampling : Array         The sampling rate of the fringes in units of pixels.     \"\"\"     # Get fringe size     fringe_size = get_fringe_size(wavelength, aperture)      # Convert to metres if focal_length is provided     if focal_length is not None:         fringe_size *= focal_length      # Return sampling     return fringe_size / pixel_scale     # return pixel_scale/fringe_size In\u00a0[\u00a0]: Copied! <pre>def get_pixel_scale(sampling_rate: Array,\n                    wavelength: Array,\n                    aperture: Array,\n                    focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, metres\n        The observation wavelength.\n    aperture : Array, metres\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        metres per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or metres per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radians per pixel if no focal length is\n        provided, else in units of metres per pixel.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to metres if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Get sampling rate\n    return fringe_size / sampling_rate\n</pre> def get_pixel_scale(sampling_rate: Array,                     wavelength: Array,                     aperture: Array,                     focal_length: Array = None) -&gt; Array:     \"\"\"     Calculates the pixel_size needed in order to sample the diffraction fringes     at the given sampling rate.      Parameters     ----------     sampling_rate : Array         The rate at which to sample the diffraction fringes. A value of 2 will         give nyquist sampled pixels.     wavelength : Array, metres         The observation wavelength.     aperture : Array, metres         The size of the aperture.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is given in units of radians per pixel, else it is given in         metres per pixel.      Returns     -------     pixel_scale : Array, radians per pixel or metres per pixel         The pixel_size needed to sample the diffraction fringes at the input         sampling rate, in units of radians per pixel if no focal length is         provided, else in units of metres per pixel.     \"\"\"     # Get fringe size     fringe_size = get_fringe_size(wavelength, aperture)      # Convert to metres if focal_length is provided     if focal_length is not None:         fringe_size *= focal_length      # Get sampling rate     return fringe_size / sampling_rate In\u00a0[\u00a0]: Copied! <pre>def get_airy_pixel_scale(sampling_rate: Array,\n                         wavelength: Array,\n                         aperture: Array,\n                         focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the pixel_size needed to sample the diffraction fringes\n    at the given sampling rate. Applies the 1.22 multiplier for Airy disk\n    diffraction fringes given by a circular aperture.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, metres\n        The observation wavelength.\n    aperture : Array, metres\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        metres per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or metres per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radians per pixel if no focal length is\n        provided, else in units of metres per pixel.\n    \"\"\"\n    return get_pixel_scale(sampling_rate, 1.22 * wavelength, aperture,\n                           focal_length)\n</pre> def get_airy_pixel_scale(sampling_rate: Array,                          wavelength: Array,                          aperture: Array,                          focal_length: Array = None) -&gt; Array:     \"\"\"     Calculates the pixel_size needed to sample the diffraction fringes     at the given sampling rate. Applies the 1.22 multiplier for Airy disk     diffraction fringes given by a circular aperture.      Parameters     ----------     sampling_rate : Array         The rate at which to sample the diffraction fringes. A value of 2 will         give nyquist sampled pixels.     wavelength : Array, metres         The observation wavelength.     aperture : Array, metres         The size of the aperture.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is given in units of radians per pixel, else it is given in         metres per pixel.      Returns     -------     pixel_scale : Array, radians per pixel or metres per pixel         The pixel_size needed to sample the diffraction fringes at the input         sampling rate, in units of radians per pixel if no focal length is         provided, else in units of metres per pixel.     \"\"\"     return get_pixel_scale(sampling_rate, 1.22 * wavelength, aperture,                            focal_length)"},{"location":"dLux/utils/units/","title":"Units","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\n</pre> import jax.numpy as np from jax import Array In\u00a0[\u00a0]: Copied! <pre>__all__ = [\n    \"rad_to_arcsec\", \"rad_to_deg\", \"rad_to_arcmin\",\n    \"deg_to_rad\", \"deg_to_arcmin\", \"deg_to_arcsec\",\n    \"arcmin_to_rad\", \"arcmin_to_deg\", \"arcmin_to_arcsec\",\n    \"arcsec_to_rad\", \"arcsec_to_deg\", \"arcsec_to_arcmin\"]\n</pre> __all__ = [     \"rad_to_arcsec\", \"rad_to_deg\", \"rad_to_arcmin\",     \"deg_to_rad\", \"deg_to_arcmin\", \"deg_to_arcsec\",     \"arcmin_to_rad\", \"arcmin_to_deg\", \"arcmin_to_arcsec\",     \"arcsec_to_rad\", \"arcsec_to_deg\", \"arcsec_to_arcmin\"] In\u00a0[\u00a0]: Copied! <pre># Radians to:\ndef rad_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcseconds.\n\n    Can also be imported as r2s.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600 * 180 / np.pi\n</pre> # Radians to: def rad_to_arcsec(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to arcseconds.      Can also be imported as r2s.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 3600 * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre>def rad_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to degrees.\n\n    Can also be imported as r2d.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values * 180 / np.pi\n</pre> def rad_to_deg(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to degrees.      Can also be imported as r2d.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre>def rad_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcminutes.\n\n    Can also be imported as r2m.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60 * 180 / np.pi\n</pre> def rad_to_arcmin(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to arcminutes.      Can also be imported as r2m.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values * 60 * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre># Degrees to:\ndef deg_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to radians.\n\n    Can also be imported as d2r.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / 180\n</pre> # Degrees to: def deg_to_rad(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to radians.      Can also be imported as d2r.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / 180 In\u00a0[\u00a0]: Copied! <pre>def deg_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcminutes.\n\n    Can also be imported as d2m.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60\n</pre> def deg_to_arcmin(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to arcminutes.      Can also be imported as d2m.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values * 60 In\u00a0[\u00a0]: Copied! <pre>def deg_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcseconds.\n\n    Can also be imported as d2s.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600\n</pre> def deg_to_arcsec(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to arcseconds.      Can also be imported as d2s.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 3600 In\u00a0[\u00a0]: Copied! <pre># Arcminutes to:\ndef arcmin_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to radians.\n\n    Can also be imported as m2r.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (60 * 180)\n</pre> # Arcminutes to: def arcmin_to_rad(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to radians.      Can also be imported as m2r.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / (60 * 180) In\u00a0[\u00a0]: Copied! <pre>def arcmin_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to degrees.\n\n    Can also be imported as m2d.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 60\n</pre> def arcmin_to_deg(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to degrees.      Can also be imported as m2d.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values / 60 In\u00a0[\u00a0]: Copied! <pre>def arcmin_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to arcseconds.\n\n    Can also be imported as m2s.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 60\n</pre> def arcmin_to_arcsec(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to arcseconds.      Can also be imported as m2s.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 60 In\u00a0[\u00a0]: Copied! <pre># Arcseconds to:\ndef arcsec_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to radians.\n\n    Can also be imported as s2r.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (3600 * 180)\n</pre> # Arcseconds to: def arcsec_to_rad(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to radians.      Can also be imported as s2r.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / (3600 * 180) In\u00a0[\u00a0]: Copied! <pre>def arcsec_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to degrees.\n\n    Can also be imported as s2d.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 3600\n</pre> def arcsec_to_deg(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to degrees.      Can also be imported as s2d.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values / 3600 In\u00a0[\u00a0]: Copied! <pre>def arcsec_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to arcminutes.\n\n    Can also be imported as s2m.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values / 60\n</pre> def arcsec_to_arcmin(values: Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to arcminutes.      Can also be imported as s2m.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values / 60"},{"location":"docs/faq/","title":"FAQ & Troubleshooting","text":"<p>We are yet to receive enough feedback to create a FAQ -- \u2202Lux must be flawless!</p> <p>If you do have any questions that aren't addressed in the documentation, please don't hesitate to email me!</p>"},{"location":"docs/installation/","title":"Installation","text":"<p>\u2202Lux is hosted on PyPI, so simply pip install!</p> <pre><code>pip install dLux\n</code></pre> <p>You can also build from source. To do so, clone the git repo, enter the directory, and run.</p> <pre><code>pip install .\n</code></pre> <p>We encourage the creation of a virtual environment to run \u2202Lux to prevent software conflicts as we keep the software up to date with the latest version of the core packages.</p>"},{"location":"docs/installation/#windowsgoogle-colab-quickstart","title":"Windows/Google Colab Quickstart","text":"<p><code>jaxlib</code> is currently not supported by the Jax team on windows, however there are two work-arounds!</p> <p>Firstly here is some community built software to install jax on windows! We do not use this ourselves so have limited knowledge, but some users seems to have got everyting working fine!</p> <p>Secondly, users can also run our software on Google Colab. If you want to instal from source in colab, run this at the start of your notebook!</p> <pre><code>!git clone https://github.com/LouisDesdoigts/dLux.git # Download latest version\n!cd dLux; pip install . -q # Navigate to \u2202Lux and install from source\n</code></pre> <p>From here everything should work! You can also run the code on GPU to take full advantage of Jax, simply by switch to a GPU runtime environment, no extra steps necessary!</p>"},{"location":"docs/populate_docs/","title":"Usage","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> import matplotlib.pyplot as plt plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 In\u00a0[2]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\nprint(optics)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  print(optics) <pre>AngularOptics(\n  wf_npixels=256,\n  diameter=1.0,\n  aperture=Optic(opd=None, normalise=True, transmission=f32[256,256]),\n  mask=None,\n  psf_npixels=128,\n  psf_oversample=4.0,\n  psf_pixel_scale=0.1\n)\n</pre> In\u00a0[3]: Copied! <pre># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/simple_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/simple_optics.png') In\u00a0[5]: Copied! <pre>import jax.numpy as np\nimport dLux.utils as dlu\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = dlu.arcsec_to_rad(0.1 / 4)\n\n# Construct the list of layers\nlayers = [\n    dl.ApertureFactory(wf_npixels),\n    dl.MFT(psf_npixels, psf_pixel_scale)\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n</pre> import jax.numpy as np import dLux.utils as dlu import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = dlu.arcsec_to_rad(0.1 / 4)  # Construct the list of layers layers = [     dl.ApertureFactory(wf_npixels),     dl.MFT(psf_npixels, psf_pixel_scale) ]  # Construct the optics class optics = dl.LayeredOptics(wf_npixels, diameter, layers) In\u00a0[6]: Copied! <pre>print(optics)\n</pre> print(optics) <pre>LayeredOptics(\n  wf_npixels=256,\n  diameter=1.0,\n  layers={\n    'Optic':\n    Optic(opd=None, normalise=True, transmission=f32[256,256]),\n    'MFT':\n    MFT(focal_length=None, inverse=False, npixels=128, pixel_scale=f32[])\n  }\n)\n</pre> In\u00a0[7]: Copied! <pre># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.Optic.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/layered_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.Optic.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/layered_optics.png') In\u00a0[9]: Copied! <pre>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Aberrations Parameters\nzernikes = np.arange(4, 10)\ncoefficients = 1e-7 * jr.normal(jr.PRNGKey(0), zernikes.shape)\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels, noll_indices=zernikes, \n    coefficients=coefficients)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths, flux=5e4)\ndata = jr.poisson(jr.PRNGKey(1), optics.model(source))\n</pre> import jax.numpy as np import jax.random as jr import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Aberrations Parameters zernikes = np.arange(4, 10) coefficients = 1e-7 * jr.normal(jr.PRNGKey(0), zernikes.shape)  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels, noll_indices=zernikes,      coefficients=coefficients)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths, flux=5e4) data = jr.poisson(jr.PRNGKey(1), optics.model(source)) In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.opd)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/aberrated_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.opd) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"Data\") plt.imshow(data) plt.colorbar() plt.tight_layout() plt.savefig('assets/aberrated_optics.png') In\u00a0[11]: Copied! <pre>import jax.scipy as jsp\nimport zodiax as zdx\nimport optax\n\n# Set aberration coefficents to zero\nparameter = 'aperture.coefficients'\nmodel = optics.multiply(parameter, 0.1)\n\n# Define the loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(parameter)\ndef loss_fn(model, source, data):\n    psf = model.model(source)\n    return -np.sum(jsp.stats.poisson.logpmf(data, psf))\n\n# Compile the loss function\nloss, grads = loss_fn(model, source, data)\n</pre> import jax.scipy as jsp import zodiax as zdx import optax  # Set aberration coefficents to zero parameter = 'aperture.coefficients' model = optics.multiply(parameter, 0.1)  # Define the loss function @zdx.filter_jit @zdx.filter_value_and_grad(parameter) def loss_fn(model, source, data):     psf = model.model(source)     return -np.sum(jsp.stats.poisson.logpmf(data, psf))  # Compile the loss function loss, grads = loss_fn(model, source, data) In\u00a0[12]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, parameter, optax.adam(2e-9))\n\nlosses, models_out = [], []\nfor i in range(100):\n    # calculate the loss and gradient\n    loss, grads = loss_fn(model, source, data) \n    \n    # apply the update\n    updates, opt_state = optim.update(grads, opt_state)\n    model = zdx.apply_updates(model, updates)\n    \n    # save results\n    models_out.append(model) \n    losses.append(loss)\n</pre> optim, opt_state = zdx.get_optimiser(model, parameter, optax.adam(2e-9))  losses, models_out = [], [] for i in range(100):     # calculate the loss and gradient     loss, grads = loss_fn(model, source, data)           # apply the update     updates, opt_state = optim.update(grads, opt_state)     model = zdx.apply_updates(model, updates)          # save results     models_out.append(model)      losses.append(loss) In\u00a0[13]: Copied! <pre>plt.figure(figsize=(12, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Loss\")\nplt.plot(losses)\nplt.xlabel(\"Epoch\")\n\nfound_coeffs = models_out[-1].aperture.coefficients\nplt.subplot(1, 2, 2)\nplt.title(\"Coefficients\")\nplt.scatter(coefficients, found_coeffs)\nplt.xlabel(\"True Coefficients\")\nplt.ylabel(\"Found Coefficients\")\n\n# Add y=x line\nv = np.max(np.abs(np.concatenate([coefficients, found_coeffs])))\nplt.plot([-v, v], [-v, v], color='k', linestyle='--')\n\nplt.tight_layout()\nplt.savefig('assets/loss_curve.png')\n\n# Plot data. model and residual\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\n\npsf = models_out[-1].model(source)\nplt.subplot(1, 3, 2)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Residual\")\nplt.imshow(data - psf)\nplt.colorbar()\n\nplt.tight_layout()\nplt.savefig('assets/recovered_model.png')\n</pre> plt.figure(figsize=(12, 4)) plt.subplot(1, 2, 1) plt.title(\"Loss\") plt.plot(losses) plt.xlabel(\"Epoch\")  found_coeffs = models_out[-1].aperture.coefficients plt.subplot(1, 2, 2) plt.title(\"Coefficients\") plt.scatter(coefficients, found_coeffs) plt.xlabel(\"True Coefficients\") plt.ylabel(\"Found Coefficients\")  # Add y=x line v = np.max(np.abs(np.concatenate([coefficients, found_coeffs]))) plt.plot([-v, v], [-v, v], color='k', linestyle='--')  plt.tight_layout() plt.savefig('assets/loss_curve.png')  # Plot data. model and residual plt.figure(figsize=(15, 4)) plt.subplot(1, 3, 1) plt.title(\"Data\") plt.imshow(data) plt.colorbar()  psf = models_out[-1].model(source) plt.subplot(1, 3, 2) plt.title(\"PSF\") plt.imshow(psf) plt.colorbar()  plt.subplot(1, 3, 3) plt.title(\"Residual\") plt.imshow(data - psf) plt.colorbar()  plt.tight_layout() plt.savefig('assets/recovered_model.png') In\u00a0[14]: Copied! <pre># Construct Detector Object\ndetector_layers = [dl.ApplyJitter(3), dl.IntegerDownsample(4)]\ndetector = dl.LayeredDetector(detector_layers)\n\n# Construct Dithered Observation\ndithers = 2.5e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Combine all into instrument and model\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</pre> # Construct Detector Object detector_layers = [dl.ApplyJitter(3), dl.IntegerDownsample(4)] detector = dl.LayeredDetector(detector_layers)  # Construct Dithered Observation dithers = 2.5e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) observation = dl.Dither(dithers)  # Combine all into instrument and model instrument = dl.Instrument(optics, source, detector, observation) psfs = instrument.observe() In\u00a0[15]: Copied! <pre>plt.figure(figsize=(20, 4))\nfor i, psf in enumerate(psfs):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"PSF {}\".format(i))\n    plt.imshow(psf)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/full_instrument.png')\n</pre> plt.figure(figsize=(20, 4)) for i, psf in enumerate(psfs):     plt.subplot(1, 4, i+1)     plt.title(\"PSF {}\".format(i))     plt.imshow(psf)     plt.colorbar() plt.tight_layout() plt.savefig('assets/full_instrument.png') In\u00a0[16]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[17]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/angular_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/angular_psf.png') In\u00a0[18]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 1 # microns\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.CartesianOptics(wf_npixels, diameter, aperture, focal_length,\n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 1 # microns psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.CartesianOptics(wf_npixels, diameter, aperture, focal_length,     psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[19]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/cartesian_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/cartesian_psf.png') In\u00a0[20]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\nfocal_shift = 2e-5 # metres\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct a Fresnel Propagator\npropagator = dl.FarFieldFresnel(psf_npixels, psf_pixel_scale, focal_length,\n    focal_shift)\n\n# Construct the optics class\noptics = dl.FlexibleOptics(wf_npixels, diameter, aperture, propagator)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 0.25e-6 # metres focal_shift = 2e-5 # metres  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct a Fresnel Propagator propagator = dl.FarFieldFresnel(psf_npixels, psf_pixel_scale, focal_length,     focal_shift)  # Construct the optics class optics = dl.FlexibleOptics(wf_npixels, diameter, aperture, propagator)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[21]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/fresnel_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/fresnel_psf.png') In\u00a0[22]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\n\n# Construct the list of optical layers\nlayers = [\n    (dl.ApertureFactory(wf_npixels), 'aperture'),\n    dl.MFT(psf_npixels, psf_pixel_scale, focal_length),\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 0.25e-6 # metres  # Construct the list of optical layers layers = [     (dl.ApertureFactory(wf_npixels), 'aperture'),     dl.MFT(psf_npixels, psf_pixel_scale, focal_length), ]  # Construct the optics class optics = dl.LayeredOptics(wf_npixels, diameter, layers)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[23]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/layered_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/layered_psf.png') In\u00a0[24]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\nimport dLux.utils as dlu\nimport dLux\n\n# We must inherit from the base optics class, `BaseOptics`. This will integrate\n# our class with the rest of the dLux code.\nclass MyOptics(dLux.optics.BaseOptics):\n    wf_npixels      : int\n    diameter        : float\n    aperture        : Array\n    mask            : Array\n    psf_pixel_scale : float\n    psf_npixels     : int\n\n    def __init__(self, wf_npixes, diameter, aperture, mask, psf_npixels, \n        psf_pixel_scale):\n'''Constructs the class'''\n        self.wf_npixels = wf_npixels\n        self.diameter = diameter\n        self.aperture = aperture\n        self.mask = mask\n        self.psf_npixels = psf_npixels\n        self.psf_pixel_scale = psf_pixel_scale\n    \n    # Our propagate_mono must have the expected behaviour of dLux optics,\n    # meaning it must take the same inputs (wavelength, offset, return_wf) and\n    # return the same outputs (psf).\n    def propagate_mono(self, wavelength, offset=np.zeros(2), return_wf=False):\n'''Propagates a monochromatic source'''\n\n        # Construct our wavefront\n        wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n\n        # Tilt the wavefront\n        wf = wf.tilt(offset)\n\n        # We can use the `self` keyword to access the class attributes\n        wf *= self.aperture\n\n        # Normalise the wavefront\n        wf = wf.normalise()\n\n        # Apply the mask as an array of OPDs\n        wf += self.mask\n\n        # Propagate the wavefront, casting the units of pixel scale to radians\n        pixel_scale = dlu.arcmin_to_rad(self.psf_pixel_scale)\n        wf = wf.MFT(self.psf_npixels, pixel_scale)\n\n        # Return the PSF\n        if return_wf:\n            return wf\n        else:\n            return wf.psf\n</pre> import jax.numpy as np from jax import Array import dLux.utils as dlu import dLux  # We must inherit from the base optics class, `BaseOptics`. This will integrate # our class with the rest of the dLux code. class MyOptics(dLux.optics.BaseOptics):     wf_npixels      : int     diameter        : float     aperture        : Array     mask            : Array     psf_pixel_scale : float     psf_npixels     : int      def __init__(self, wf_npixes, diameter, aperture, mask, psf_npixels,          psf_pixel_scale):         '''Constructs the class'''         self.wf_npixels = wf_npixels         self.diameter = diameter         self.aperture = aperture         self.mask = mask         self.psf_npixels = psf_npixels         self.psf_pixel_scale = psf_pixel_scale          # Our propagate_mono must have the expected behaviour of dLux optics,     # meaning it must take the same inputs (wavelength, offset, return_wf) and     # return the same outputs (psf).     def propagate_mono(self, wavelength, offset=np.zeros(2), return_wf=False):         '''Propagates a monochromatic source'''          # Construct our wavefront         wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)          # Tilt the wavefront         wf = wf.tilt(offset)          # We can use the `self` keyword to access the class attributes         wf *= self.aperture          # Normalise the wavefront         wf = wf.normalise()          # Apply the mask as an array of OPDs         wf += self.mask          # Propagate the wavefront, casting the units of pixel scale to radians         pixel_scale = dlu.arcmin_to_rad(self.psf_pixel_scale)         wf = wf.MFT(self.psf_npixels, pixel_scale)          # Return the PSF         if return_wf:             return wf         else:             return wf.psf In\u00a0[25]: Copied! <pre>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 128\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 5e-4 # arcminutes\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Make a mask of random OPDs\nmask = 4.e-7 * jr.normal(jr.PRNGKey(0), (wf_npixels, wf_npixels))\n\n# Construct the optics class\noptics = MyOptics(wf_npixels, diameter, aperture, mask, psf_npixels, \n    psf_pixel_scale)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import jax.random as jr import dLux as dl  # Define the parameters wf_npixels = 128 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 5e-4 # arcminutes  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Make a mask of random OPDs mask = 4.e-7 * jr.normal(jr.PRNGKey(0), (wf_npixels, wf_npixels))  # Construct the optics class optics = MyOptics(wf_npixels, diameter, aperture, mask, psf_npixels,      psf_pixel_scale)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission * optics.mask * 1e6)\nplt.colorbar(label=\"OPD (microns)\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/my_optics_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission * optics.mask * 1e6) plt.colorbar(label=\"OPD (microns)\")  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/my_optics_psf.png') In\u00a0[27]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Detector\ndetector = dl.LayeredDetector([dl.ApplyJitter(20)])\n\n# Construct Observation\nobservation = dl.Dither(np.array([[0, 0], [1e-6, 1e-6]]))\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths)  # Construct Detector detector = dl.LayeredDetector([dl.ApplyJitter(20)])  # Construct Observation observation = dl.Dither(np.array([[0, 0], [1e-6, 1e-6]]))  # Construct the instrument and observe instrument = dl.Instrument(optics, source, detector, observation) psfs = instrument.observe() In\u00a0[28]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"$\\sqrt{PSF_1}$\")\nplt.imshow(psfs[0]**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF_2}$\")\nplt.imshow(psfs[1]**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/instrument.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"$\\sqrt{PSF_1}$\") plt.imshow(psfs[0]**0.5) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF_2}$\") plt.imshow(psfs[1]**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/instrument.png') In\u00a0[29]: Copied! <pre># Array based spectrum\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nweights = np.linspace(.5, 1, 5)\nspectrum = dl.Spectrum(wavelengths, weights)\n</pre> # Array based spectrum wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres weights = np.linspace(.5, 1, 5) spectrum = dl.Spectrum(wavelengths, weights) In\u00a0[30]: Copied! <pre>import matplotlib.pyplot as plt\nplt.title(\"Spectrum\")\nplt.scatter(spectrum.wavelengths, spectrum.weights)\nplt.ylim(0)\nplt.xlabel(\"Wavelength (meters)\")\nplt.ylabel(\"Normalised Weight\")\nplt.tight_layout()\nplt.savefig('assets/spectrum.png')\n</pre> import matplotlib.pyplot as plt plt.title(\"Spectrum\") plt.scatter(spectrum.wavelengths, spectrum.weights) plt.ylim(0) plt.xlabel(\"Wavelength (meters)\") plt.ylabel(\"Normalised Weight\") plt.tight_layout() plt.savefig('assets/spectrum.png') In\u00a0[31]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Observation\ndithers = 1e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, observation=observation)\npsfs = instrument.observe()\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths)  # Construct Observation dithers = 1e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) observation = dl.Dither(dithers)  # Construct the instrument and observe instrument = dl.Instrument(optics, source, observation=observation) psfs = instrument.observe() In\u00a0[32]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(20, 4))\nfor i in range(4):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"$\\sqrt{PSF}$\")\n    plt.imshow(psfs[i]**0.5)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/observation.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(20, 4)) for i in range(4):     plt.subplot(1, 4, i+1)     plt.title(\"$\\sqrt{PSF}$\")     plt.imshow(psfs[i]**0.5)     plt.colorbar() plt.tight_layout() plt.savefig('assets/observation.png') In\u00a0[33]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample) In\u00a0[34]: Copied! <pre># Define wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\n\n# Construct PointSource\nsources = [dl.PointSource(wavelengths)]\n\n# Construct PointSources\npositions = 3e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nsources.append(dl.PointSources(wavelengths, positions))\n\n# Construct BinarySource\nseparation = 2e-6 # radians\nsources.append(dl.BinarySource(wavelengths, separation=separation))\n\n# Construct ResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.ResolvedSource(wavelengths, distribution=distribution))\n\n# Construct PointResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.PointResolvedSource(wavelengths, distribution=distribution, \n    contrast=3))\n</pre> # Define wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres  # Construct PointSource sources = [dl.PointSource(wavelengths)]  # Construct PointSources positions = 3e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) sources.append(dl.PointSources(wavelengths, positions))  # Construct BinarySource separation = 2e-6 # radians sources.append(dl.BinarySource(wavelengths, separation=separation))  # Construct ResolvedSource distribution = np.ones([10, 10]) sources.append(dl.ResolvedSource(wavelengths, distribution=distribution))  # Construct PointResolvedSource distribution = np.ones([10, 10]) sources.append(dl.PointResolvedSource(wavelengths, distribution=distribution,      contrast=3)) In\u00a0[35]: Copied! <pre>import matplotlib.pyplot as plt\ntitles = [\"PointSource\", \"PointSources\", \"BinarySource\", \"ResolvedSource\",\n    \"PointResolvedSource\"]\n\nplt.figure(figsize=(25, 4))\nfor i in range(5):\n    psf = sources[i].model(optics)\n    plt.subplot(1, 5, i+1)\n    plt.title(titles[i])\n    plt.imshow(psf**0.5)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/sources.png')\n</pre> import matplotlib.pyplot as plt titles = [\"PointSource\", \"PointSources\", \"BinarySource\", \"ResolvedSource\",     \"PointResolvedSource\"]  plt.figure(figsize=(25, 4)) for i in range(5):     psf = sources[i].model(optics)     plt.subplot(1, 5, i+1)     plt.title(titles[i])     plt.imshow(psf**0.5)     plt.colorbar() plt.tight_layout() plt.savefig('assets/sources.png') In\u00a0[36]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\nraw_psf = source.model(optics)\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths) raw_psf = source.model(optics) In\u00a0[37]: Copied! <pre># Construct Detector\ndetector = dl.LayeredDetector([\n    dl.ApplyJitter(20),\n    dl.IntegerDownsample(4),\n    dl.AddConstant(1),\n])\n\n# Combine into instrument and model\ninstrument = dl.Instrument(optics, source, detector)\npsf = instrument.model()\n</pre> # Construct Detector detector = dl.LayeredDetector([     dl.ApplyJitter(20),     dl.IntegerDownsample(4),     dl.AddConstant(1), ])  # Combine into instrument and model instrument = dl.Instrument(optics, source, detector) psf = instrument.model() In\u00a0[38]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Raw PSF\")\nplt.imshow(raw_psf**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Detector Transformed PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/detectors.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Raw PSF\") plt.imshow(raw_psf**0.5) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"Detector Transformed PSF\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/detectors.png') In\u00a0[39]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\nimage = dl.Image(np.ones((256, 256)), 0.1)\nimage *= 2\nimage += 1\nimage /= 2\n</pre> import jax.numpy as np import dLux as dl  image = dl.Image(np.ones((256, 256)), 0.1) image *= 2 image += 1 image /= 2 In\u00a0[40]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\nnpixels = 16\ndiameter = 1 # metres\nwavelength = 1e-6 # metres\n\nwf = dl.Wavefront(npixels, diameter, wavelength)\n\n# Multiply to modify the amplitude\nwf *= 0.5 # Halves the amplitude\n\n# Multiply by complex array to transform both ampltiude and phase\nwf *= np.ones((npixels, npixels)) * np.exp(1j * np.zeros((npixels, npixels)))\n\n# Multiply or Add by OpticalLayer to apply it\naperture = dl.ApertureFactory(16)\nwf *= aperture\nwf += aperture\n\n# Add to modify the phase through OPD units\nwf += 1 # Adds 1m of OPD across full wavefront\n</pre> import jax.numpy as np import dLux as dl  npixels = 16 diameter = 1 # metres wavelength = 1e-6 # metres  wf = dl.Wavefront(npixels, diameter, wavelength)  # Multiply to modify the amplitude wf *= 0.5 # Halves the amplitude  # Multiply by complex array to transform both ampltiude and phase wf *= np.ones((npixels, npixels)) * np.exp(1j * np.zeros((npixels, npixels)))  # Multiply or Add by OpticalLayer to apply it aperture = dl.ApertureFactory(16) wf *= aperture wf += aperture  # Add to modify the phase through OPD units wf += 1 # Adds 1m of OPD across full wavefront In\u00a0[41]: Copied! <pre>import dLux as dl\n\napertures = [\n    dl.CircularAperture(1.),\n    dl.CircularAperture(1., centre=[.5, .5]),\n    dl.CircularAperture(1., shear=[.05, .05]),\n    dl.CircularAperture(1., compression=[1.05, .95]),\n    dl.CircularAperture(1., softening=20),\n    dl.CircularAperture(1., occulting=True)\n]\n</pre> import dLux as dl  apertures = [     dl.CircularAperture(1.),     dl.CircularAperture(1., centre=[.5, .5]),     dl.CircularAperture(1., shear=[.05, .05]),     dl.CircularAperture(1., compression=[1.05, .95]),     dl.CircularAperture(1., softening=20),     dl.CircularAperture(1., occulting=True) ] In\u00a0[42]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(30, 4))\nfor i in range(len(apertures)):\n    plt.subplot(1, 6, i+1)\n    plt.imshow(apertures[i].transmission(256, 2))\nplt.tight_layout()\nplt.savefig(\"assets/basic_apertures.png\")\n</pre> import matplotlib.pyplot as plt  plt.figure(figsize=(30, 4)) for i in range(len(apertures)):     plt.subplot(1, 6, i+1)     plt.imshow(apertures[i].transmission(256, 2)) plt.tight_layout() plt.savefig(\"assets/basic_apertures.png\") In\u00a0[43]: Copied! <pre>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct a Hexagonal Aperture\nhex = dl.RegPolyAperture(6, 1.)\n\n# Turn it into an aberrated aperture\nzernikes = np.arange(1, 7)\ncoefficients = jr.normal(jr.PRNGKey(0), (6,))\naberrated_hex = dl.AberratedAperture(hex, zernikes, coefficients)\n\n# Promote it to static\nstatic_hex = aberrated_hex.make_static(256, 2)\n</pre> import dLux as dl import jax.numpy as np import jax.random as jr  # Construct a Hexagonal Aperture hex = dl.RegPolyAperture(6, 1.)  # Turn it into an aberrated aperture zernikes = np.arange(1, 7) coefficients = jr.normal(jr.PRNGKey(0), (6,)) aberrated_hex = dl.AberratedAperture(hex, zernikes, coefficients)  # Promote it to static static_hex = aberrated_hex.make_static(256, 2) In\u00a0[44]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(static_hex.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"OPD\")\nplt.imshow(static_hex.transmission * static_hex.opd)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/aberrated_apertures.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Transmission\") plt.imshow(static_hex.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"OPD\") plt.imshow(static_hex.transmission * static_hex.opd) plt.colorbar() plt.tight_layout() plt.savefig('assets/aberrated_apertures.png') In\u00a0[45]: Copied! <pre>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nradial_orders = [2, 3]\ncoefficients = jr.normal(jr.PRNGKey(0), (7,))\n\n# Construct aperture\naperture = dl.ApertureFactory(\n    npixels         = 512,\n    secondary_ratio = 0.1, \n    nstruts         = 4, \n    strut_ratio     = 0.01, \n    radial_orders   = radial_orders, \n    coefficients    = coefficients)\n</pre> import dLux as dl import jax.numpy as np import jax.random as jr  # Construct Zernikes radial_orders = [2, 3] coefficients = jr.normal(jr.PRNGKey(0), (7,))  # Construct aperture aperture = dl.ApertureFactory(     npixels         = 512,     secondary_ratio = 0.1,      nstruts         = 4,      strut_ratio     = 0.01,      radial_orders   = radial_orders,      coefficients    = coefficients) In\u00a0[46]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nopd = aperture.opd.at[aperture.transmission == 0].set(np.nan)\nplt.title(\"OPD\")\nplt.imshow(opd)\nplt.colorbar()\nplt.tight_layout()\nplt.tight_layout()\nplt.savefig('assets/aperture_factory.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Transmission\") plt.imshow(aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) opd = aperture.opd.at[aperture.transmission == 0].set(np.nan) plt.title(\"OPD\") plt.imshow(opd) plt.colorbar() plt.tight_layout() plt.tight_layout() plt.savefig('assets/aperture_factory.png') In\u00a0[47]: Copied! <pre>import dLux as dl\n\nzernike_basis = dl.ZernikeBasis(np.arange(1, 7))\n</pre> import dLux as dl  zernike_basis = dl.ZernikeBasis(np.arange(1, 7)) In\u00a0[48]: Copied! <pre>import matplotlib.pyplot as plt\n\nnpix = 256\ncoords = dl.utils.pixel_coords(npix, 2/npix)\nbasis = zernike_basis.calculate_basis(coords)\n\nplt.figure(figsize=(15, 8))\nfor i in range(len(basis)):\n    plt.subplot(2, 3, i+1)\n    plt.title(f\"{zernike_basis.noll_indices[i].name}\")\n    plt.imshow(basis[i])\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/zernike.png\")\n</pre> import matplotlib.pyplot as plt  npix = 256 coords = dl.utils.pixel_coords(npix, 2/npix) basis = zernike_basis.calculate_basis(coords)  plt.figure(figsize=(15, 8)) for i in range(len(basis)):     plt.subplot(2, 3, i+1)     plt.title(f\"{zernike_basis.noll_indices[i].name}\")     plt.imshow(basis[i])     plt.colorbar() plt.tight_layout() plt.savefig(\"assets/zernike.png\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"docs/populate_docs/#usage","title":"Usage\u00b6","text":""},{"location":"docs/populate_docs/#a-simple-optical-system","title":"A Simple Optical System\u00b6","text":""},{"location":"docs/populate_docs/#a-layered-optical-system","title":"A Layered Optical System\u00b6","text":""},{"location":"docs/populate_docs/#recovering-aberrations-from-an-optical-system","title":"Recovering Aberrations from an Optical System\u00b6","text":""},{"location":"docs/populate_docs/#adding-a-detector-observation-using-the-instrument-class","title":"Adding a Detector &amp; Observation using the Instrument class\u00b6","text":""},{"location":"docs/populate_docs/#angular-optics","title":"Angular Optics\u00b6","text":""},{"location":"docs/populate_docs/#instruments","title":"Instruments\u00b6","text":""},{"location":"docs/populate_docs/#spectra","title":"Spectra\u00b6","text":""},{"location":"docs/populate_docs/#observations","title":"Observations\u00b6","text":""},{"location":"docs/populate_docs/#sources","title":"Sources\u00b6","text":""},{"location":"docs/populate_docs/#detectors","title":"Detectors\u00b6","text":""},{"location":"docs/populate_docs/#images","title":"Images\u00b6","text":""},{"location":"docs/populate_docs/#wavefronts","title":"Wavefronts\u00b6","text":""},{"location":"docs/populate_docs/#apertures","title":"Apertures\u00b6","text":""},{"location":"docs/populate_docs/#aberrations","title":"Aberrations\u00b6","text":""},{"location":"docs/usage/","title":"Using \u2202Lux","text":"<p>\u2202Lux is built in Zodiax, so users should start with the Using Zodiax Tutorial, which covers the basics of the framework and how to use the optimisation tools used in \u2202Lux.</p>"},{"location":"docs/usage/#a-simple-optical-system","title":"A Simple Optical System","text":"<p>There are two different types of optical classes: Layered, and non-Layered.</p> <p>Layered gives full control over the wavefront at each step, but non-layered objects can be simpler to work with. We will first construct a non-Layered Optics class and then a Layered Optics class.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n</code></pre> <p>Let's have a look at our object:</p> <pre><code>print(optics)\n\n&gt; AngularOptics(\n&gt;   wf_npixels=256,\n&gt;   diameter=1.0,\n&gt;   aperture=Optic(opd=None, normalise=True, transmission=f32[256,256]),\n&gt;   mask=None,\n&gt;   psf_npixels=128,\n&gt;   psf_oversample=4.0,\n&gt;   psf_pixel_scale=0.1\n&gt; )\n</code></pre> <p>Now, we can simply propagate <code>wavelengths</code> through the optics like so:</p> <pre><code># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/simple_optics.png')\n</code></pre> <p></p> <p>Now, let's take a look at how we can create an identical optical system using the layered approach. This approach is more verbose, but gives us more control over the wavefront at each step.</p> <pre><code>import jax.numpy as np\nimport dLux.utils as dlu\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = dlu.arcsec_to_rad(0.1 / 4)\n\n# Construct the list of layers\nlayers = [\n    dl.ApertureFactory(wf_npixels),\n    dl.MFT(psf_npixels, psf_pixel_scale)\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n</code></pre> <p>Let's again look at our optics object to see how it has changed:</p> <pre><code>print(optics)\n\n&gt; LayeredOptics(\n&gt;   wf_npixels=256,\n&gt;   diameter=1.0,\n&gt;   layers={\n&gt;     'Optic':\n&gt;     Optic(opd=None, normalise=True, transmission=f32[256,256]),\n&gt;     'MFT':\n&gt;     MFT(focal_length=None, inverse=False, npixels=128, pixel_scale=f32[])\n&gt;   }\n&gt; )\n</code></pre> <p>We use the same method to propagate the wavelengths:</p> <pre><code># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.Optic.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/layered_optics.png')\n</code></pre> <p></p>"},{"location":"docs/usage/#basic-phase-retrieval","title":"Basic Phase Retrieval","text":"<p>Now that we know how to create a simple optical system, let's see how we can take advantage of the differentiable nature of \u2202Lux to perform phase retrieval. We will use the same optical system as before, but this time we will add a phase screen to the aperture.</p> <pre><code>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Aberrations Parameters\nzernikes = np.arange(4, 10)\ncoefficients = 1e-7 * jr.normal(jr.PRNGKey(0), zernikes.shape)\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels, noll_indices=zernikes, \n    coefficients=coefficients)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths, flux=5e4)\ndata = jr.poisson(jr.PRNGKey(1), optics.model(source))\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aberrations\")\nplt.imshow(optics.aperture.opd)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/aberrated_optics.png')\n</code></pre> <p></p> <p>Now, we just need to reset our aberration coefficients to zero and define our loss function:</p> <pre><code>import jax.scipy as jsp\nimport zodiax as zdx\nimport optax\n\n# Set aberration coefficents to zero\nparameter = 'aperture.coefficients'\nmodel = optics.multiply(parameter, 0.1)\n\n# Define the loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(parameter)\ndef loss_fn(model, source, data):\n    psf = model.model(source)\n    return -np.sum(jsp.stats.poisson.logpmf(data, psf))\n\n# Compile the loss function\nloss, grads = loss_fn(model, source, data)\n</code></pre> <p>Now, we optimise in a simple loop:</p> <pre><code>optim, opt_state = zdx.get_optimiser(model, parameter, optax.adam(2e-9))\n\nlosses, models_out = [], []\nfor i in range(100):\n    # calculate the loss and gradient\n    loss, grads = loss_fn(model, source, data) \n\n    # apply the update\n    updates, opt_state = optim.update(grads, opt_state)\n    model = zdx.apply_updates(model, updates)\n\n    # save results\n    models_out.append(model) \n    losses.append(loss)\n</code></pre> Plotting Code <pre><code>plt.figure(figsize=(12, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Loss\")\nplt.plot(losses)\nplt.xlabel(\"Epoch\")\n\nfound_coeffs = models_out[-1].aperture.coefficients\nplt.subplot(1, 2, 2)\nplt.title(\"Coefficients\")\nplt.scatter(coefficients, found_coeffs)\nplt.xlabel(\"True Coefficients\")\nplt.ylabel(\"Found Coefficients\")\n\n# Add y=x line\n\nv = np.max(np.abs(np.concatenate([coefficients, found_coeffs])))\nplt.plot([-v, v], [-v, v], color='k', linestyle='--')\n\nplt.tight_layout()\nplt.savefig('assets/loss_curve.png')\n\n# Plot data. model and residual\n\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\n\npsf = models_out[-1].model(source)\nplt.subplot(1, 3, 2)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Residual\")\nplt.imshow(data - psf)\nplt.colorbar()\n\nplt.tight_layout()\nplt.savefig('assets/recovered_model.png')\n</code></pre> <p></p> <p></p>"},{"location":"docs/usage/#complex-optical-systems","title":"Complex Optical Systems","text":"<p>So far we have looked at the \u2202Lux basics, but there is much more functionality available! Here we will show how to model the effects of a detector with a dithered observation pattern, using the same optics and source classes we defined above.</p> <pre><code># Construct Detector Object\ndetector_layers = [dl.ApplyJitter(3), dl.IntegerDownsample(4)]\ndetector = dl.LayeredDetector(detector_layers)\n\n# Construct Dithered Observation\ndithers = 2.5e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Combine all into instrument and model\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</code></pre> Plotting Code <pre><code>plt.figure(figsize=(20, 4))\nfor i, psf in enumerate(psfs):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"PSF {}\".format(i))\n    plt.imshow(psf)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/full_instrument.png')\n</code></pre> <p></p> <p>This has been a quick overview of how to use \u2202Lux! The next step from here would be to take a look at the rest of the tutorials, which show how to do more complex modelling and parameter recovery!</p>"},{"location":"docs/API/aberrations/","title":"Aberrations: aberrations.py","text":"<p>This module contains the classes that define the behaviour of Aberration Layers in dLux.</p> <p>There are two public classes:</p> <ul> <li><code>Zernike</code></li> <li><code>ZernikeBasis</code></li> </ul> <p>These classes are designed to generate Zernike polynomials dynamically. Typically, users should not need to interact with these classes directly, but rather through the <code>Aperture</code> classes.</p> <p>The Zernike class hold a single Zernike polynomial. It has one main method, <code>.calculate(coordinates, nsides)</code> that takes in a set of coordinates and calculates the Zernike polynomial on those coordinates.</p> <p>The ZernikeBasis class holds a set of Zernike polynomials. It has one main method, <code>.calculate_basis(coordinates, nsides)</code> that takes in a set of coordinates and calculates the Zernike polynomial basis on those coordinates.</p> Zernike Basis API <p>         Bases: <code>Base</code></p> <p>A class to calculate a set of Zernike polynomials on a dynamic set of coordinates.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>noll_indices</code> <code>list[Zernike]</code> <p>The list of Zernike polynomial classes to calculate.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>class ZernikeBasis(Base):\n\"\"\"\n    A class to calculate a set of Zernike polynomials on a dynamic set of\n    coordinates.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    noll_indices : list[Zernike]\n        The list of Zernike polynomial classes to calculate.\n    \"\"\"\n    noll_indices: list[Zernike]\n\n    def __init__(self: ZernikeBasis, js: list[int]):\n\"\"\"\n        Constructor for the DynamicZernike class.\n\n        Parameters\n        ----------\n        js : list[int]\n            The list of Zernike (noll) indices to calculate.\n        \"\"\"\n        self.noll_indices = [Zernike(j) for j in js]\n\n    def calculate_basis(self: ZernikeBasis,\n                        coordinates: Array,\n                        nsides: int = 0) -&gt; Array:\n\"\"\"\n        Calculates the full Zernike polynomial basis.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike basis upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike basis is\n            calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike_basis : Array\n            The Zernike polynomial basis.\n        \"\"\"\n        leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n        calculate_fn = lambda z: z.calculate(coordinates, nsides)\n        return np.array(jtu.tree_map(calculate_fn, self.noll_indices,\n                                     is_leaf=leaf_fn))\n</code></pre> Zernike API <p>         Bases: <code>Base</code></p> <p>A class to generate Zernike polynomials dynamically.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> <code>name</code> <code>str</code> <p>The name of the Zernike polynomial.</p> <code>_k</code> <code>Array</code> <p>The array of powers using the radial calculation. This is a  pre-calculated parameter and should not be changed.</p> <code>_c</code> <code>Array</code> <p>The array of normalisation coefficients used in the radial calculation. This is a pre-calculated parameter and should not be changed.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>class Zernike(Base):\n\"\"\"\n    A class to generate Zernike polynomials dynamically.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n\n    Attributes\n    ----------\n    j : int\n        The Zernike (noll) index.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    name : str\n        The name of the Zernike polynomial.\n    _k : Array\n        The array of powers using the radial calculation. This is a \n        pre-calculated parameter and should not be changed.\n    _c : Array\n        The array of normalisation coefficients used in the radial calculation.\n        This is a pre-calculated parameter and should not be changed.\n    \"\"\"\n    j: int\n    n: int\n    m: int\n    name: str\n    _k: Array\n    _c: Array\n\n    def __init__(self: Zernike, j: int):\n\"\"\"\n        Construct for the Zernike class.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n        \"\"\"\n        if int(j) &lt; 1:\n            raise ValueError('The Zernike index must be greater than 0.')\n        self.j = int(j)\n        self.n, self.m = self._noll_indices(self.j)\n        self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n            else f'Zernike {int(self.j)}'\n\n        # Calculate values\n        self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n        sign = lax.pow(-1., self._k)\n        _fact_1 = dlu.factorial(np.abs(self.n - self._k))\n        _fact_2 = dlu.factorial(self._k)\n        _fact_3 = dlu.factorial(((self.n + self.m) // 2) - self._k)\n        _fact_4 = dlu.factorial(((self.n - self.m) // 2) - self._k)\n        self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4\n\n    def _noll_indices(self: Zernike, j: int) -&gt; tuple[int]:\n\"\"\"\n        Calculate the radial and azimuthal orders of the Zernike polynomial.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n\n        Returns\n        -------\n        n, m : tuple[int]\n            The radial and azimuthal orders of the Zernike polynomial.\n        \"\"\"\n        n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)\n        smallest_j_in_row = n * (n + 1) / 2 + 1\n        number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2\n        sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2\n        base_case = (n &amp; 1)\n        m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)\n        return int(n), int(m)\n\n    def _calculate_radial(self: Zernike, rho: Array) -&gt; Array:\n\"\"\"\n        Calculates the radial component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        rho : Array\n            The radial coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        radial : Array\n            The radial component of the Zernike polynomial.\n        \"\"\"\n        rads = lax.pow(rho[:, :, None],\n                       (np.abs(self.n) - 2 * self._k)[None, None, :])\n        return (self._c * rads).sum(axis=2)\n\n    def _calculate_azimuthal(self: Zernike, theta: Array) -&gt; Array:\n\"\"\"\n        Calculates the azimuthal component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        theta : Array\n            The azimuthal coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        azimuthal : Array\n            The azimuthal component of the Zernike polynomial.\n        \"\"\"\n        norm_coeff = np.sqrt(self.n + 1)\n        if self.m != 0:\n            norm_coeff *= 1 + (np.sqrt(2) - 1)\n\n        if self.m &gt;= 0:\n            return norm_coeff * np.cos(np.abs(self.m) * theta)\n        else:\n            return norm_coeff * np.sin(np.abs(self.m) * theta)\n\n    def calculate_zernike(self: Zernike, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        polar_coordinates = dlu.cart_to_polar(coordinates)\n        rho = polar_coordinates[0]\n        theta = polar_coordinates[1]\n        aperture = rho &lt;= 1.\n        return aperture * self._calculate_radial(rho) * \\\n            self._calculate_azimuthal(theta)\n\n    def calculate_polike(self: Zernike,\n                         coordinates: Array,\n                         nsides: int) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial on an n-sided aperture.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture.\n\n        Returns\n        -------\n        polike : Array\n            The Zernike polynomial on an n-sided aperture.\n        \"\"\"\n        if nsides &lt; 3:\n            raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n        theta = dlu.cart_to_polar(coordinates)[1]\n        alpha = np.pi / nsides\n        phi = theta + alpha\n        wedge = np.floor((phi + alpha) / (2. * alpha))\n        u_alpha = phi - wedge * (2 * alpha)\n        r_alpha = np.cos(alpha) / np.cos(u_alpha)\n        return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n\n    def calculate(self: Zernike,\n                  coordinates: Array,\n                  nsides: int = 0) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike polynomial\n            is calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        if nsides == 0:\n            return self.calculate_zernike(coordinates)\n        else:\n            return self.calculate_polike(coordinates, nsides)\n</code></pre> <p>Let's construct a Zernike Basis:</p> <pre><code>import dLux as dl\nimport jax.numpy as np\n\nzernike_basis = dl.ZernikeBasis(np.arange(1, 7))\n</code></pre> <pre><code>&gt; ZernikeBasis(\n&gt;   zernikes=[\n&gt;     Zernike(j=1, n=0, m=0, name='Piston', _k=f32[1], _c=f32[1]),\n&gt;     Zernike(j=2, n=1, m=1, name='Tilt X', _k=f32[1], _c=f32[1]),\n&gt;     Zernike(j=3, n=1, m=-1, name='Tilt Y', _k=f32[2], _c=f32[2]),\n&gt;     Zernike(j=4, n=2, m=0, name='Defocus', _k=f32[2], _c=f32[2]),\n&gt;     Zernike(j=5, n=2, m=-2, name='Astig X', _k=f32[3], _c=f32[3]),\n&gt;     Zernike(j=6, n=2, m=2, name='Astig Y', _k=f32[1], _c=f32[1])\n&gt;   ]\n&gt; )\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\n\nnpix = 256\ncoords = dl.utils.pixel_coords(npix, 2/npix)\nbasis = zernike_basis.calculate_basis(coords)\n\nplt.figure(figsize=(15, 8))\nfor i in range(len(basis)):\n    plt.subplot(2, 3, i+1)\n    plt.title(f\"{zernike_basis.noll_indices[i].name}\")\n    plt.imshow(basis[i])\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/zernike.png\")\n</code></pre> <p></p>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.__init__","title":"<code>__init__(js)</code>","text":"<p>Constructor for the DynamicZernike class.</p> <p>Parameters:</p> Name Type Description Default <code>js</code> <code>list[int]</code> <p>The list of Zernike (noll) indices to calculate.</p> required Source code in <code>dLux/aberrations.py</code> <pre><code>def __init__(self: ZernikeBasis, js: list[int]):\n\"\"\"\n    Constructor for the DynamicZernike class.\n\n    Parameters\n    ----------\n    js : list[int]\n        The list of Zernike (noll) indices to calculate.\n    \"\"\"\n    self.noll_indices = [Zernike(j) for j in js]\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.calculate_basis","title":"<code>calculate_basis(coordinates, nsides=0)</code>","text":"<p>Calculates the full Zernike polynomial basis.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike basis upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike basis is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>zernike_basis</code> <code>Array</code> <p>The Zernike polynomial basis.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_basis(self: ZernikeBasis,\n                    coordinates: Array,\n                    nsides: int = 0) -&gt; Array:\n\"\"\"\n    Calculates the full Zernike polynomial basis.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike basis upon.\n    nsides : int\n        The number of sides of the aperture. If 0, the Zernike basis is\n        calculated on a circular aperture.\n\n    Returns\n    -------\n    zernike_basis : Array\n        The Zernike polynomial basis.\n    \"\"\"\n    leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n    calculate_fn = lambda z: z.calculate(coordinates, nsides)\n    return np.array(jtu.tree_map(calculate_fn, self.noll_indices,\n                                 is_leaf=leaf_fn))\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.__init__","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.calculate_basis","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.__init__","title":"<code>__init__(j)</code>","text":"<p>Construct for the Zernike class.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required Source code in <code>dLux/aberrations.py</code> <pre><code>def __init__(self: Zernike, j: int):\n\"\"\"\n    Construct for the Zernike class.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n    \"\"\"\n    if int(j) &lt; 1:\n        raise ValueError('The Zernike index must be greater than 0.')\n    self.j = int(j)\n    self.n, self.m = self._noll_indices(self.j)\n    self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n        else f'Zernike {int(self.j)}'\n\n    # Calculate values\n    self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n    sign = lax.pow(-1., self._k)\n    _fact_1 = dlu.factorial(np.abs(self.n - self._k))\n    _fact_2 = dlu.factorial(self._k)\n    _fact_3 = dlu.factorial(((self.n + self.m) // 2) - self._k)\n    _fact_4 = dlu.factorial(((self.n - self.m) // 2) - self._k)\n    self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate","title":"<code>calculate(coordinates, nsides=0)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike polynomial is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate(self: Zernike,\n              coordinates: Array,\n              nsides: int = 0) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    nsides : int\n        The number of sides of the aperture. If 0, the Zernike polynomial\n        is calculated on a circular aperture.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    if nsides == 0:\n        return self.calculate_zernike(coordinates)\n    else:\n        return self.calculate_polike(coordinates, nsides)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_polike","title":"<code>calculate_polike(coordinates, nsides)</code>","text":"<p>Calculates the Zernike polynomial on an n-sided aperture.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <p>Returns:</p> Name Type Description <code>polike</code> <code>Array</code> <p>The Zernike polynomial on an n-sided aperture.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_polike(self: Zernike,\n                     coordinates: Array,\n                     nsides: int) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial on an n-sided aperture.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    nsides : int\n        The number of sides of the aperture.\n\n    Returns\n    -------\n    polike : Array\n        The Zernike polynomial on an n-sided aperture.\n    \"\"\"\n    if nsides &lt; 3:\n        raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n    theta = dlu.cart_to_polar(coordinates)[1]\n    alpha = np.pi / nsides\n    phi = theta + alpha\n    wedge = np.floor((phi + alpha) / (2. * alpha))\n    u_alpha = phi - wedge * (2 * alpha)\n    r_alpha = np.cos(alpha) / np.cos(u_alpha)\n    return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_zernike","title":"<code>calculate_zernike(coordinates)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_zernike(self: Zernike, coordinates: Array) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    polar_coordinates = dlu.cart_to_polar(coordinates)\n    rho = polar_coordinates[0]\n    theta = polar_coordinates[1]\n    aperture = rho &lt;= 1.\n    return aperture * self._calculate_radial(rho) * \\\n        self._calculate_azimuthal(theta)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.__init__","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_polike","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_zernike","title":"Aberrations","text":""},{"location":"docs/API/apertures/","title":"Aperture Layers: <code>apertures.py</code>","text":"<p>This module contains the classes that define the behaviour of aperture layers in \u2202Lux.</p> <p>These classes provide a simple set of classes used to perform basic transformations of wavefronts.</p> <p>There are nine public classes:</p> <ul> <li><code>CircularAperture</code></li> <li><code>RectangularAperture</code></li> <li><code>RegPolyAperture</code></li> <li><code>IrregPolyAperture</code></li> <li><code>AberratedAperture</code></li> <li><code>UniformSpider</code></li> <li><code>CompoundAperture</code></li> <li><code>MultiAperture</code></li> </ul> <p>Plus also one public method, <code>ApertureFactory</code>, that allows for the easy construction of various simple apertures.</p>"},{"location":"docs/API/apertures/#api","title":"API","text":"Circular Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>A circular aperture parameterised by its radius.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>Array, metres</code> <p>The radius of the aperture.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class CircularAperture(DynamicAperture):\n\"\"\"\n    A circular aperture parameterised by its radius.\n\n    Attributes\n    ----------\n    radius: Array, metres\n        The radius of the aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    radius: Array\n\n    def __init__(\n        self: ApertureLayer,\n        radius: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Constructor for the CircularAperture class.\n\n        Parameters\n        ----------\n        radius: Array, metres\n            The radius of the aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.radius = np.asarray(radius).astype(float)\n        if self.radius.shape != ():\n            raise ValueError(\"radius must have shape ().\")\n\n    def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        scale = coordinates[0, 1] - coordinates[0, 0]\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(-coordinates + self.radius)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return (coordinates &lt; self.radius).astype(float)\n\n    def _extent(self: ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.radius\n</code></pre> Rectangular Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>A rectangular aperture parameterised by it height and width.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Array, metres</code> <p>The length of the aperture in the y-direction.</p> <code>width</code> <code>Array, metres</code> <p>The length of the aperture in the x-direction.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class RectangularAperture(DynamicAperture):\n\"\"\"\n    A rectangular aperture parameterised by it height and width.\n\n    Attributes\n    ----------\n    height: Array, metres\n        The length of the aperture in the y-direction.\n    width: Array, metres\n        The length of the aperture in the x-direction.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    height: Array\n    width: Array\n\n    def __init__(\n        self: ApertureLayer,\n        height: Array,\n        width: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RectangularAperture class.\n\n        Parameters\n        ----------\n        height: Array, metres\n            The length of the aperture in the y-direction.\n        width: Array, metres\n            The length of the aperture in the x-direction.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.height = np.asarray(height).astype(float)\n        self.width = np.asarray(width).astype(float)\n\n        if self.height.shape != ():\n            raise ValueError(\"height must have shape ().\")\n        if self.width.shape != ():\n            raise ValueError(\"width must have shape ().\")\n\n    def _soft_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        y_mask = self._soften(-np.abs(coordinates[1]) + self.height / 2.0)\n        x_mask = self._soften(-np.abs(coordinates[0]) + self.width / 2.0)\n        return x_mask * y_mask\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        y_mask = np.abs(coordinates[1]) &lt; self.height / 2.0\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.0\n        return (x_mask * y_mask).astype(float)\n\n    def _extent(self: ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.hypot(self.height / 2.0, self.width / 2.0)\n</code></pre> Regular Polygonal Aperture API <p>         Bases: <code>PolyAperture</code></p> <p>A regular polygonal aperture defined by its number of sides and the maximum radius to the vertices from its center.</p> <p>Attributes:</p> Name Type Description <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> <code>rmax</code> <code>Array, metres</code> <p>The maximum radius to the vertices from its center.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class RegPolyAperture(PolyAperture):\n\"\"\"\n    A regular polygonal aperture defined by its number of sides and the maximum\n    radius to the vertices from its center.\n\n    Attributes\n    ----------\n    nsides: int\n        The number of sides of the aperture.\n    rmax: Array, metres\n        The maximum radius to the vertices from its center.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    nsides: int\n    rmax: Array\n\n    def __init__(\n        self: ApertureLayer,\n        nsides: int,\n        rmax: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RegPolyAperture class.\n\n        Parameters\n        ----------\n        nsides: int\n            The number of sides of the aperture.\n        rmax: Array, metres\n            The maximum radius to the vertices from its center.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.nsides = int(nsides)\n        self.rmax = np.array(rmax).astype(float)\n        if self.rmax.shape != ():\n            raise ValueError(\"rmax must have shape ().\")\n\n    def _extent(self: ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n\n    def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x)\n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None]  # Dummy index\n        bounds = 2.0 * i * alpha\n\n        ms = -1 / np.tan(2.0 * i * alpha + alpha)\n        xs = self.rmax * np.cos(2.0 * i * alpha)\n        ys = self.rmax * np.sin(2.0 * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = self._soften(inside * dists)\n        return dist.prod(axis=0)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x)\n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None]  # Dummy index\n        bounds = 2.0 * i * alpha\n\n        ms = -1 / np.tan(2.0 * i * alpha + alpha)\n        xs = self.rmax * np.cos(2.0 * i * alpha)\n        ys = self.rmax * np.sin(2.0 * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = (inside * dists) &gt; 0.0\n        return dist.prod(axis=0)\n</code></pre> Irregular Polygonal Aperture API <p>         Bases: <code>PolyAperture</code></p> <p>An arbitrary aperture parameterised by a set of vertices.</p> <p>TODO: Check if the vertices need to be defined in a specific way, based on the methods this looks like the case (ie, ordered).</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>Array, metres</code> <p>The location of the vertices of the aperture.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class IrregPolyAperture(PolyAperture):\n\"\"\"\n    An arbitrary aperture parameterised by a set of vertices.\n\n    TODO: Check if the vertices need to be defined in a specific way, based on\n    the methods this looks like the case (ie, ordered).\n\n    Attributes\n    ----------\n    vertices: Array, metres\n        The location of the vertices of the aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a transmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    vertices: Array\n\n    def __init__(\n        self: ApertureLayer,\n        vertices: Array,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        occulting: bool = False,\n        softening: Array = np.array(1.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the IrregularPolygonalAperture class.\n\n        Parameters\n        ----------\n        vertices: Array, metres\n            The location of the vertices of the aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the\n            aperture. Hard edges can be achieved by setting the softening to 0.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.vertices = np.array(vertices).astype(float)\n        if self.vertices.ndim != 2 or self.vertices.shape[1] != 2:\n            raise ValueError(\"vertices must have shape (n, 2).\")\n\n    def _grads_from_many_points(self: ApertureLayer, xs: float, ys: float) -&gt; float:\n\"\"\"\n        Given a set of points, calculate the gradient of the line that connects\n        those points. This function assumes that the points are provided in the\n        order they are to be connected together. Notice that we also assume\n        there are more than two points, but more can be provided in which case\n        the shape is assumed to be closed. The output has the same shape as the\n        input and does not check for infinite (vertical) gradients.\n\n        Note: Due to the intensely vectorised nature of this code it is often\n        necessary to provide the parameters with expanded dimensions. This may\n        be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or\n        `np.expand_dims(x1, (1, 2))`.\n\n        Parameters\n        ----------\n        xs: float, metres\n            The x coordinates of the points that are to be connected.\n        ys: float, metres\n            The y coordinates of the points that are to be connected.\n            Must have the same shape as x.\n\n        Returns\n        -------\n        ms: float\n            The gradients of the lines that connect the vertices. The vertices\n            wrap around to form a closed shape whatever it may look like.\n        \"\"\"\n        x_diffs = xs - np.roll(xs, -1)\n        y_diffs = ys - np.roll(ys, -1)\n        return y_diffs / x_diffs\n\n    def _extent(self: ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for\n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        verts = self.vertices\n        dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])\n        return np.max(dist_to_verts)\n\n    def _soft_edged(self: ApertureLayer, coordinates: float) -&gt; float:\n\"\"\"\n        Calculates the soft-edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The soft-edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.0)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(\n            sorted_m, sorted_x1, sorted_y1, bc_x, bc_y\n        )\n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        soft_edges = self._soften(dist_sgn * dist_from_edges)\n\n        return (soft_edges).prod(axis=0)\n\n    def _hard_edged(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Calculates the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, metres\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.0)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(\n            sorted_m, sorted_x1, sorted_y1, bc_x, bc_y\n        )\n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        edges = (dist_from_edges * dist_sgn) &gt; 0.0\n\n        return (edges).prod(axis=0)\n</code></pre> Aberrated Aperture API <p>         Bases: <code>ApertureLayer</code>, <code>BasisLayer()</code></p> <p>A class for generating apertures with aberrations. This class generates the basis vectors of the aberrations at run time, allowing for the aperture and aberrations to be recovered simultaneously.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> <code>basis</code> <code>list[Zernike]</code> <p>A list of basis functions that represent the basis. The exact polynomials that are represented will depend on the aperture shape.</p> <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class AberratedAperture(ApertureLayer, BasisLayer()):\n\"\"\"\n    A class for generating apertures with aberrations. This class generates the\n    basis vectors of the aberrations at run time, allowing for the aperture and\n    aberrations to be recovered simultaneously.\n\n    Attributes\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    basis: list[Zernike]\n        A list of basis functions that represent the basis. The exact\n        polynomials that are represented will depend on the aperture shape.\n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    normalise: bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    aperture: ApertureLayer\n\n    def __init__(\n        self: ApertureLayer,\n        aperture: ApertureLayer,\n        noll_inds: Array,\n        coefficients: Array = None,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture on which the aberration basis is defined.\n        noll_inds: List[int]\n            The noll indices are a scheme for indexing the Zernike\n            polynomials. Normally these polynomials have two\n            indices but the noll indices prevent an order to\n            these pairs. All basis can be indexed using the noll\n            indices based on `n` and `m`.\n        coefficients: Array = None\n            The amplitude of each basis vector of the aberrations. If nothing\n            is provided, then the coefficients are set to zero.\n        \"\"\"\n        # Ensure aperture is dynamic\n        if not isinstance(aperture, DynamicAperture):\n            raise TypeError(\n                \"AberratedApertures can not contain Static, \"\n                \"Compound or Multi Apertures. AberratedApertures can be \"\n                \"placed in Compound or Multi Apertures, which can then be \"\n                \"promoted to Static.\"\n            )\n\n        # Ensure transmissive\n        if aperture.occulting:\n            raise ValueError(\"AberratedApertures can not be occulting.\")\n\n        super().__init__(normalise=aperture.normalise)\n\n        # Set Aperture\n        self.aperture = aperture\n        self.basis = ZernikeBasis()(noll_inds)\n\n        if coefficients is None:\n            coefficients = np.zeros(len(noll_inds))\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the transmission of the aperture on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the transmission on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self.aperture._transmission(coordinates)\n\n    def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        coordinates = wavefront.coordinates\n        transmission = self.aperture._transmission(coordinates)\n        phase = wavefront.phase + self._opd(coordinates) * wavefront.wavenumber\n        amplitude = transmission * wavefront.amplitude\n        wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])\n        if self.aperture.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n\n    def _basis(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aberration basis vectors on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the basis on.\n\n        Returns\n        -------\n        basis : Array\n            The array representing the basis vectors of the aperture.\n        \"\"\"\n        coordinates = self.aperture._normalised_coordinates(coordinates)\n\n        if isinstance(self.aperture, RegPolyAperture):\n            ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)\n        else:\n            ikes = self.basis.calculate_basis(coordinates)\n\n        is_reg_pol = isinstance(self.aperture, RegPolyAperture)\n        is_circ = isinstance(self.aperture, CircularAperture)\n\n        if is_circ or is_reg_pol:\n            return ikes\n        aperture = self.aperture._transmission(coordinates)\n        return self._orthonormalise(aperture, ikes)\n\n    def _opd(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the opd of the optical aberrations on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        opd : Array\n            The array representing the opd of the aberrations.\n        \"\"\"\n        return self.calculate(self._basis(coordinates), self.coefficients)\n\n    def _orthonormalise(self: ApertureLayer, aperture: Array, zernikes: Array) -&gt; Array:\n\"\"\"\n        Orthonomalises the zernike polynomials on the aperture.\n\n        Parameters\n        ----------\n        aperture : Array\n            An array representing the aperture.\n        zernikes : Array\n            The zernike polynomials to orthonormalise on the aperture.\n\n        Returns\n        -------\n        basis : Array\n            The orthonormalised zernike polynomials evaluated on the aperture.\n        \"\"\"\n        pixel_area = aperture.sum()\n        shape = zernikes.shape\n        basis = np.zeros(shape).at[0].set(aperture)\n\n        nterms = len(zernikes)\n        for j in range(nterms):\n            intermediate = zernikes[j] * aperture\n            coefficient = np.zeros((nterms, 1, 1), dtype=float)\n            mask = (np.arange(1, nterms) &gt; j + 1).reshape((-1, 1, 1))\n\n            coefficient = (\n                -1\n                / pixel_area\n                * (zernikes[j] * basis[1:] * aperture * mask)\n                .sum(axis=(1, 2))\n                .reshape(-1, 1, 1)\n            )\n\n            intermediate += (coefficient * basis[1:] * mask).sum(axis=0)\n            basis = basis.at[j].set(\n                intermediate / np.sqrt((intermediate**2).sum() / pixel_area)\n            )\n        return basis\n\n    def make_static(\n        self: ApertureLayer, npixels: int, diameter: float\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Returns the static version of the input aperture calculated on the\n        coordinates defined by npixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels across one edge of the aperture.\n        diameter : float, metres\n            The diameter of the aperture in metres.\n\n        Returns\n        -------\n        aperture: ApertureLayer\n            The BasisOptic version of this aperture.\n        \"\"\"\n        coordinates = dlu.pixel_coords(npixels, diameter / npixels)\n        transmission = self.aperture._transmission(coordinates)\n\n        basis = self._basis(coordinates)\n        return BasisOptic()(\n            basis=basis,\n            transmission=transmission,\n            coefficients=self.coefficients,\n            normalise=self.normalise,\n        )\n</code></pre> Compound Aperture API <p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture with spiders holding a secondary mirror.</p> <p>This class is distinct from the MultiAperture class in that the sub-apertures are combined by multiplying their respective transmissions together, i.e. the sub-apertures are overlapping.</p> <p>This class should not contain a MultiAperture, but MultiApertures can contain CompoundApertures.</p> <p>A single aberrated aperture can be placed into the set of apertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class CompoundAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture with spiders holding a secondary mirror.\n\n    This class is distinct from the MultiAperture class in that the\n    sub-apertures are combined by multiplying their respective transmissions\n    together, i.e. the sub-apertures are overlapping.\n\n    This class should not contain a MultiAperture, but MultiApertures can\n    contain CompoundApertures.\n\n    A single aberrated aperture can be placed into the set of apertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def __init__(\n        self: ApertureLayer,\n        apertures: list,\n        centre: Array = np.array([0.0, 0.0]),\n        shear: Array = np.array([0.0, 0.0]),\n        compression: Array = np.array([1.0, 1.0]),\n        rotation: Array = np.array(0.0),\n        normalise: bool = False,\n    ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompoundAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, metres = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperture.\n        compression: Array  = np.array([1., 1.])\n            The (x, y) compression of the aperture.\n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the\n            aperture.\n        \"\"\"\n        super().__init__(\n            apertures=apertures,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            normalise=normalise,\n        )\n\n        # Check for more than one aberrated aperture\n        naberrated = 0\n        for aperture in self.apertures.values():\n            if isinstance(aperture, AberratedAperture):\n                naberrated += 1\n            if naberrated &gt; 1:\n                raise TypeError(\n                    \"CompoundAperture can only have a single \" \"AberratedAperture.\"\n                )\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture transmission on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._stacked_apertures(coordinates).prod(axis=0)\n</code></pre> Multi Aperture API <p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture mask.</p> <p>This class is distinct from the CompoundAperture class in that the sub-apertures are combined by adding their respective transmissions together, i.e. the sub-apertures are not overlapping.</p> <p>This class can contain multiple CompoundApertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, metres</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class MultiAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture mask.\n\n    This class is distinct from the CompoundAperture class in that the\n    sub-apertures are combined by adding their respective transmissions\n    together, i.e. the sub-apertures are not overlapping.\n\n    This class can contain multiple CompoundApertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, metres\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperture.\n    compression: Array\n        The (x, y) compression of the aperture.\n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def _transmission(self: ApertureLayer, coordinates: Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the transmission of the aperture on the\n        provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, metres\n            The coordinate system to calculate the transmission on.\n\n        Returns\n        -------\n        transmission : Array\n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._stacked_apertures(coordinates).sum(axis=0)\n</code></pre> Aperture Factory API <p>This method is used to give a simple constructor interface that is used to construct the most commonly used apertures. It is able to construct hard-edged circular or regular polygonal apertures. Secondary mirrors obscurations with the same aperture shape can be constructed, along with uniformly spaced struts. The ratio of the primary aperture opening to the array size is determined by the <code>aperture_ratio</code> parameter, with secondary mirror obscurations and struts being scaled relative to the aperture diameter.</p> <p>Let's look at an example of how to construct a simple circular aperture with a secondary mirror obscuration held by 4 struts. For this example lets take a 2m diameter aperture, with a 20cm secondary mirror held by 3 struts with a width of 2cm. In this example the secondary mirror is 10% of the primary aperture diameter and the struts are 1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for the <code>secondary_ratio</code> and <code>strut_ratio</code> parameters. Let calculate this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>from dLux import ApertureFactory\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct aperture\naperture = ApertureFactory(512, secondary_ratio=0.1, nstruts=4,\n    strut_ratio=0.01)\n</code></pre> <p>The resulting aperture class has onc parameters, <code>.transmission</code> which represents the transmission of the aperture. <pre><code>We can also easily change this to a hexagonal aperture with 3 struts:\n\n```python\n# Make aperture\nhexagonal_aperture = ApertureFactory(512, nsides=6, secondary_ratio=0.1,\n    nstruts=3, strut_ratio=0.01)\n\n# Examine\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(hexagonal_aperture.transmission)\nplt.colorbar()\nplt.show()\n</code></pre></p> <p>These classes are broken into three categories: Dynamic Apertures, Aberrated Apertures, and Composite Apertures.</p>"},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.__init__","title":"<code>__init__(radius, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), occulting=False, softening=np.array(1.0), normalise=False)</code>","text":"<p>Constructor for the CircularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>Array</code> <p>The radius of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    radius: Array,\n    centre: Array = np.array([0.0, 0.0]),\n    shear: Array = np.array([0.0, 0.0]),\n    compression: Array = np.array([1.0, 1.0]),\n    occulting: bool = False,\n    softening: Array = np.array(1.0),\n    normalise: bool = False,\n) -&gt; Array:\n\"\"\"\n    Constructor for the CircularAperture class.\n\n    Parameters\n    ----------\n    radius: Array, metres\n        The radius of the aperture.\n    centre: Array, metres = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperture.\n    compression: Array  = np.array([1., 1.])\n        The (x, y) compression of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    \"\"\"\n    super().__init__(\n        centre=centre,\n        shear=shear,\n        compression=compression,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.radius = np.asarray(radius).astype(float)\n    if self.radius.shape != ():\n        raise ValueError(\"radius must have shape ().\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.__init__","title":"<code>__init__(height, width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), normalise=False)</code>","text":"<p>Constructor for the RectangularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>Array</code> <p>The length of the aperture in the y-direction.</p> required <code>width</code> <code>Array</code> <p>The length of the aperture in the x-direction.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    height: Array,\n    width: Array,\n    centre: Array = np.array([0.0, 0.0]),\n    shear: Array = np.array([0.0, 0.0]),\n    compression: Array = np.array([1.0, 1.0]),\n    rotation: Array = np.array(0.0),\n    occulting: bool = False,\n    softening: Array = np.array(1.0),\n    normalise: bool = False,\n) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the RectangularAperture class.\n\n    Parameters\n    ----------\n    height: Array, metres\n        The length of the aperture in the y-direction.\n    width: Array, metres\n        The length of the aperture in the x-direction.\n    centre: Array, metres = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperture.\n    compression: Array  = np.array([1., 1.])\n        The (x, y) compression of the aperture.\n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    \"\"\"\n    super().__init__(\n        centre=centre,\n        shear=shear,\n        compression=compression,\n        rotation=rotation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.height = np.asarray(height).astype(float)\n    self.width = np.asarray(width).astype(float)\n\n    if self.height.shape != ():\n        raise ValueError(\"height must have shape ().\")\n    if self.width.shape != ():\n        raise ValueError(\"width must have shape ().\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RegPolyAperture.__init__","title":"<code>__init__(nsides, rmax, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), normalise=False)</code>","text":"<p>Constructor for the RegPolyAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>rmax</code> <code>Array</code> <p>The maximum radius to the vertices from its center.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    nsides: int,\n    rmax: Array,\n    centre: Array = np.array([0.0, 0.0]),\n    shear: Array = np.array([0.0, 0.0]),\n    compression: Array = np.array([1.0, 1.0]),\n    rotation: Array = np.array(0.0),\n    occulting: bool = False,\n    softening: Array = np.array(1.0),\n    normalise: bool = False,\n) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the RegPolyAperture class.\n\n    Parameters\n    ----------\n    nsides: int\n        The number of sides of the aperture.\n    rmax: Array, metres\n        The maximum radius to the vertices from its center.\n    centre: Array, metres = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperture.\n    compression: Array  = np.array([1., 1.])\n        The (x, y) compression of the aperture.\n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    \"\"\"\n    super().__init__(\n        centre=centre,\n        shear=shear,\n        compression=compression,\n        rotation=rotation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.nsides = int(nsides)\n    self.rmax = np.array(rmax).astype(float)\n    if self.rmax.shape != ():\n        raise ValueError(\"rmax must have shape ().\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RegPolyAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RegPolyAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.IrregPolyAperture.__init__","title":"<code>__init__(vertices, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), normalise=False)</code>","text":"<p>Constructor for the IrregularPolygonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Array</code> <p>The location of the vertices of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    vertices: Array,\n    centre: Array = np.array([0.0, 0.0]),\n    shear: Array = np.array([0.0, 0.0]),\n    compression: Array = np.array([1.0, 1.0]),\n    rotation: Array = np.array(0.0),\n    occulting: bool = False,\n    softening: Array = np.array(1.0),\n    normalise: bool = False,\n) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the IrregularPolygonalAperture class.\n\n    Parameters\n    ----------\n    vertices: Array, metres\n        The location of the vertices of the aperture.\n    centre: Array, metres = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperture.\n    compression: Array  = np.array([1., 1.])\n        The (x, y) compression of the aperture.\n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the\n        aperture. Hard edges can be achieved by setting the softening to 0.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    \"\"\"\n    super().__init__(\n        centre=centre,\n        shear=shear,\n        compression=compression,\n        rotation=rotation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.vertices = np.array(vertices).astype(float)\n    if self.vertices.ndim != 2 or self.vertices.shape[1] != 2:\n        raise ValueError(\"vertices must have shape (n, 2).\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.IrregPolyAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.IrregPolyAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def __call__(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    coordinates = wavefront.coordinates\n    transmission = self.aperture._transmission(coordinates)\n    phase = wavefront.phase + self._opd(coordinates) * wavefront.wavenumber\n    amplitude = transmission * wavefront.amplitude\n    wavefront = wavefront.set([\"amplitude\", \"phase\"], [amplitude, phase])\n    if self.aperture.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__init__","title":"<code>__init__(aperture, noll_inds, coefficients=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> required <code>noll_inds</code> <code>Array</code> <p>The noll indices are a scheme for indexing the Zernike polynomials. Normally these polynomials have two indices but the noll indices prevent an order to these pairs. All basis can be indexed using the noll indices based on <code>n</code> and <code>m</code>.</p> required <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations. If nothing is provided, then the coefficients are set to zero.</p> <code>None</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    aperture: ApertureLayer,\n    noll_inds: Array,\n    coefficients: Array = None,\n) -&gt; ApertureLayer:\n\"\"\"\n    Parameters\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    noll_inds: List[int]\n        The noll indices are a scheme for indexing the Zernike\n        polynomials. Normally these polynomials have two\n        indices but the noll indices prevent an order to\n        these pairs. All basis can be indexed using the noll\n        indices based on `n` and `m`.\n    coefficients: Array = None\n        The amplitude of each basis vector of the aberrations. If nothing\n        is provided, then the coefficients are set to zero.\n    \"\"\"\n    # Ensure aperture is dynamic\n    if not isinstance(aperture, DynamicAperture):\n        raise TypeError(\n            \"AberratedApertures can not contain Static, \"\n            \"Compound or Multi Apertures. AberratedApertures can be \"\n            \"placed in Compound or Multi Apertures, which can then be \"\n            \"promoted to Static.\"\n        )\n\n    # Ensure transmissive\n    if aperture.occulting:\n        raise ValueError(\"AberratedApertures can not be occulting.\")\n\n    super().__init__(normalise=aperture.normalise)\n\n    # Set Aperture\n    self.aperture = aperture\n    self.basis = ZernikeBasis()(noll_inds)\n\n    if coefficients is None:\n        coefficients = np.zeros(len(noll_inds))\n    self.coefficients = np.asarray(coefficients, dtype=float)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.make_static","title":"<code>make_static(npixels, diameter)</code>","text":"<p>Returns the static version of the input aperture calculated on the coordinates defined by npixels and diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels across one edge of the aperture.</p> required <code>diameter</code> <code>float, metres</code> <p>The diameter of the aperture in metres.</p> required <p>Returns:</p> Name Type Description <code>aperture</code> <code>ApertureLayer</code> <p>The BasisOptic version of this aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def make_static(\n    self: ApertureLayer, npixels: int, diameter: float\n) -&gt; ApertureLayer:\n\"\"\"\n    Returns the static version of the input aperture calculated on the\n    coordinates defined by npixels and diameter.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels across one edge of the aperture.\n    diameter : float, metres\n        The diameter of the aperture in metres.\n\n    Returns\n    -------\n    aperture: ApertureLayer\n        The BasisOptic version of this aperture.\n    \"\"\"\n    coordinates = dlu.pixel_coords(npixels, diameter / npixels)\n    transmission = self.aperture._transmission(coordinates)\n\n    basis = self._basis(coordinates)\n    return BasisOptic()(\n        basis=basis,\n        transmission=transmission,\n        coefficients=self.coefficients,\n        normalise=self.normalise,\n    )\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__call__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.make_static","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.__init__","title":"<code>__init__(apertures, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), normalise=False)</code>","text":"<p>Constructor for the CompoundAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    apertures: list,\n    centre: Array = np.array([0.0, 0.0]),\n    shear: Array = np.array([0.0, 0.0]),\n    compression: Array = np.array([1.0, 1.0]),\n    rotation: Array = np.array(0.0),\n    normalise: bool = False,\n) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the CompoundAperture class.\n\n    Parameters\n    ----------\n    apertures: list[Aperture]\n        The sub-apertures that make up the full aperture.\n    centre: Array, metres = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperture.\n    compression: Array  = np.array([1., 1.])\n        The (x, y) compression of the aperture.\n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    \"\"\"\n    super().__init__(\n        apertures=apertures,\n        centre=centre,\n        shear=shear,\n        compression=compression,\n        rotation=rotation,\n        normalise=normalise,\n    )\n\n    # Check for more than one aberrated aperture\n    naberrated = 0\n    for aperture in self.apertures.values():\n        if isinstance(aperture, AberratedAperture):\n            naberrated += 1\n        if naberrated &gt; 1:\n            raise TypeError(\n                \"CompoundAperture can only have a single \" \"AberratedAperture.\"\n            )\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory--parameters","title":"Parameters","text":"<p>npixels : int     Number of pixels used to represent the aperture. radial_orders : Array = None     The radial orders of the zernike polynomials to be used for the     aberrations. Input of [0, 1] would give [Piston, Tilt X, Tilt Y],     [1, 2] would be [Tilt X, Tilt Y, Defocus, Astig X, Astig Y], etc.     The order must be increasing but does not have to be consecutive.     If you want to specify specific zernikes across radial orders the     noll_indices argument should be used instead. coefficients : Array = None     The zernike coefficients to be applied to the aberrations. Defaults     to an array of zeros. noll_indices : Array = None     The zernike noll indices to be used for the aberrations. [1, 2, 3]     would give [Piston, Tilt X, Tilt Y], [2, 3, 4] would be [Tilt X,     Tilt Y, Defocus. aperture_ratio : float = 1.     The ratio of the aperture size to the array size. A value of 1.     results in an aperture that fully spans the array, a value of 0.5     results in an aperture that is half the size of the array, which is     equivalent to a padding factor of 2. secondary_ratio : float = 0.     The ratio of the secondary mirror obscuration diameter to the     aperture diameter. A value of 0. results in no secondary mirror     obscuration. nsides : int = 0     Number of sides of the aperture. A zero input results in a circular     aperture. All other values of three and above are supported. secondary_nsides : int = 0     The number of sides of the secondary mirror obscuration. A zero input     results in a circular aperture. All other other values of three and     above are supported. rotation : float, radians = 0     The global rotation of the aperture in radians. nstruts : int = 0     The number of uniformly spaced struts holding the secondary mirror. strut_ratio : float = 0.     The ratio of the width of the strut to the aperture diameter. strut_rotation : float = 0     The rotation of the struts in radians. normalise : bool = True     Whether to normalise the wavefront after passing through the     aperture. static : bool = True     Whether to return a static aperture or a dynamic aperture.</p>"},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory--returns","title":"Returns","text":"<p>aperture : StaticAperture     Returns an appropriately constructed StaticAperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def ApertureFactory(\n    npixels: int,\n    radial_orders: Array = None,\n    coefficients: Array = None,\n    noll_indices: Array = None,\n    aperture_ratio: float = 1.0,\n    secondary_ratio: float = 0.0,\n    nsides: int = 0,\n    secondary_nsides: int = 0,\n    rotation: float = 0.0,\n    nstruts: int = 0,\n    strut_ratio: float = 0.0,\n    strut_rotation: float = 0.0,\n    normalise: bool = True,\n    static: bool = True,\n):\n\"\"\"\n    This method is used to\n    give a simple constructor interface that is used to construct the most\n    commonly used apertures. It is able to construct hard-edged circular or\n    regular polygonal apertures. Secondary mirrors obscurations with the same\n    aperture shape can be constructed, along with uniformly spaced struts. The\n    ratio of the primary aperture opening to the array size is determined by\n    the `aperture_ratio` parameter, with secondary mirror obscurations and\n    struts being scaled relative to the aperture diameter.\n\n    Let's look at an example of how to construct a simple circular aperture with\n    a secondary mirror obscuration held by 4 struts. For this example lets take\n    a 2m diameter aperture, with a 20cm secondary mirror held by 3 struts with\n    a width of 2cm. In this example the secondary mirror is 10% of the primary\n    aperture diameter and the struts are 1% of the primary aperture diameter,\n    giving us values of 0.1 and 0.01 for the `secondary_ratio` and\n    `strut_ratio` parameters. Let calculate this for a 512x512 array with the\n    aperture spanning the full array.\n\n    ```python\n    from dLux import ApertureFactory\n    import jax.numpy as np\n    import jax.random as jr\n\n    # Construct aperture\n    aperture = ApertureFactory(512, secondary_ratio=0.1, nstruts=4,\n        strut_ratio=0.01)\n    ```\n\n    The resulting aperture class has onc parameters, `.transmission` which\n    represents the transmission of the aperture.\n    ```\n\n    We can also easily change this to a hexagonal aperture with 3 struts:\n\n    ```python\n    # Make aperture\n    hexagonal_aperture = ApertureFactory(512, nsides=6, secondary_ratio=0.1,\n        nstruts=3, strut_ratio=0.01)\n\n    # Examine\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.transmission)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(hexagonal_aperture.transmission)\n    plt.colorbar()\n    plt.show()\n    ```\n\n    Parameters\n    ----------\n    npixels : int\n        Number of pixels used to represent the aperture.\n    radial_orders : Array = None\n        The radial orders of the zernike polynomials to be used for the\n        aberrations. Input of [0, 1] would give [Piston, Tilt X, Tilt Y],\n        [1, 2] would be [Tilt X, Tilt Y, Defocus, Astig X, Astig Y], etc.\n        The order must be increasing but does not have to be consecutive.\n        If you want to specify specific zernikes across radial orders the\n        noll_indices argument should be used instead.\n    coefficients : Array = None\n        The zernike coefficients to be applied to the aberrations. Defaults\n        to an array of zeros.\n    noll_indices : Array = None\n        The zernike noll indices to be used for the aberrations. [1, 2, 3]\n        would give [Piston, Tilt X, Tilt Y], [2, 3, 4] would be [Tilt X,\n        Tilt Y, Defocus.\n    aperture_ratio : float = 1.\n        The ratio of the aperture size to the array size. A value of 1.\n        results in an aperture that fully spans the array, a value of 0.5\n        results in an aperture that is half the size of the array, which is\n        equivalent to a padding factor of 2.\n    secondary_ratio : float = 0.\n        The ratio of the secondary mirror obscuration diameter to the\n        aperture diameter. A value of 0. results in no secondary mirror\n        obscuration.\n    nsides : int = 0\n        Number of sides of the aperture. A zero input results in a circular\n        aperture. All other values of three and above are supported.\n    secondary_nsides : int = 0\n        The number of sides of the secondary mirror obscuration. A zero input\n        results in a circular aperture. All other other values of three and\n        above are supported.\n    rotation : float, radians = 0\n        The global rotation of the aperture in radians.\n    nstruts : int = 0\n        The number of uniformly spaced struts holding the secondary mirror.\n    strut_ratio : float = 0.\n        The ratio of the width of the strut to the aperture diameter.\n    strut_rotation : float = 0\n        The rotation of the struts in radians.\n    normalise : bool = True\n        Whether to normalise the wavefront after passing through the\n        aperture.\n    static : bool = True\n        Whether to return a static aperture or a dynamic aperture.\n\n    Returns\n    -------\n    aperture : StaticAperture\n        Returns an appropriately constructed StaticAperture.\n    \"\"\"\n    # Check valid inputs\n    if nsides &lt; 3 and nsides != 0:\n        raise ValueError(\"nsides must be either 0 or &gt;=3\")\n\n    if secondary_nsides &lt; 3 and secondary_nsides != 0:\n        raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")\n\n    if aperture_ratio &lt;= 0:\n        raise ValueError(\"aperture_ratio must be &gt; 0\")\n\n    if secondary_ratio &lt; 0:\n        raise ValueError(\"secondary_ratio must be &gt;= 0\")\n\n    if strut_ratio &lt; 0:\n        raise ValueError(\"strut_ratio must be &gt;= 0\")\n\n    # Construct components\n    apertures = []\n\n    # Primary\n    if nsides == 0:\n        ap = CircularAperture(aperture_ratio / 2, softening=0)\n    else:\n        ap = RegPolyAperture(nsides, aperture_ratio / 2, softening=0, rotation=rotation)\n\n    # Aberrations\n    if radial_orders is not None:\n        radial_orders = np.array(radial_orders)\n\n        if (radial_orders &lt; 0).any():\n            raise ValueError(\"Radial orders must be &gt;= 0\")\n\n        noll_indices = []\n        for order in radial_orders:\n            start = dlu.triangular_number(order)\n            stop = dlu.triangular_number(order + 1)\n            noll_indices.append(np.arange(start, stop) + 1)\n        noll_indices = np.concatenate(noll_indices)\n\n    if noll_indices is None:\n        apertures.append(ap)\n    else:\n        ab_ap = AberratedAperture(ap, noll_indices, coefficients=coefficients)\n        apertures.append(ab_ap)\n\n    # Secondary\n    if secondary_ratio != 0:\n        secondary_rel = aperture_ratio * secondary_ratio\n\n        # Circular\n        if secondary_nsides == 0:\n            apertures.append(\n                CircularAperture(secondary_rel / 2, softening=0, occulting=True)\n            )\n        # Polygonal\n        else:\n            apertures.append(\n                RegPolyAperture(\n                    secondary_nsides,\n                    secondary_rel / 2,\n                    softening=0,\n                    rotation=rotation,\n                    occulting=True,\n                )\n            )\n\n    # Spiders\n    if nstruts &gt; 0:\n        if strut_ratio == 0:\n            raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")\n        strut_rel = aperture_ratio * strut_ratio\n        full_rotation = strut_rotation + rotation\n        apertures.append(\n            UniformSpider(nstruts, strut_rel, rotation=full_rotation, softening=0)\n        )\n\n    # Construct CompoundAperture\n    full_aperture = CompoundAperture(apertures, normalise=normalise)\n    if static:\n        return full_aperture.make_static(npixels, 1)\n    return full_aperture\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory--parameters","title":"Parameters","text":""},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory--returns","title":"Returns","text":""},{"location":"docs/API/apertures/#dynamic-apertures","title":"Dynamic Apertures","text":"<p>The Dynamic apertures are defined by physical units (such as radius) and are generated at run-time on the input coordinates. These apertures all have a set of input transformation parameters that can be used to modify the shape of the aperture. These parameters are:</p> <ul> <li><code>centre</code> The \\((x, y)\\) coordinates of the centre of the aperture.</li> <li><code>shear</code> The \\((x, y)\\) linear shear of the aperture.</li> <li><code>compression</code> The \\((x, y)\\) compression of the aperture.</li> <li><code>rotation</code> The clockwise rotation of the aperture.</li> <li><code>occulting</code> Is the aperture occulting (<code>True</code>) or transmissive (<code>False</code>).</li> <li><code>softening</code> The approximate pixel width of the soft boundary applied to the     aperture. Hard edges can be achieved by setting the softening to zero.</li> </ul>"},{"location":"docs/API/apertures/#aberrated-apertures","title":"Aberrated Apertures","text":"<p>The Aberrated apertures are defined by a set of Zernike coefficients. These apertures and coefficients are generated at run-time on the input coordinates. These classes contain a Dynamic aperture, plus a dynamic Zernike basis and coefficients.</p>"},{"location":"docs/API/apertures/#composite-apertures","title":"Composite Apertures","text":"<p>The Composite apertures are defined by a set of sub-apertures that are combined. These apertures are generated at run-time on the input coordinates. These classes contain a list of Dynamic apertures that are combined. <code>CompoundApertures</code> are apertures that are combined via a multiplication (i.e., combining a primary mirror and secondary mirror with spiders), whereas <code>MultiApertures</code> are apertures that are combined via an addition (i.e., combining different holes of an aperture mask).</p> <p>Most users will not need to use these dynamic features, so all of these classes have a <code>.make_static(npixels, diameter)</code> method that returns a static version of the aperture which is faster to use. These static versions are implemented as <code>Optic</code> classes, and can be used in the same way as any other <code>Optic</code> class.</p> <p>The primary interface for these classes is the <code>.transmission(npixels, diameter)</code> method that returns the transmission of the aperture on a set of coordinates defined by the number of pixels and diameter.</p>"},{"location":"docs/API/apertures/#examples","title":"Examples","text":"<p>Let's look at how to apply some simple transformations to circular apertures.</p> <pre><code>import dLux as dl\n\napertures = [\n    dl.CircularAperture(1.),\n    dl.CircularAperture(1., centre=[.5, .5]),\n    dl.CircularAperture(1., shear=[.05, .05]),\n    dl.CircularAperture(1., compression=[1.05, .95]),\n    dl.CircularAperture(1., softening=20),\n    dl.CircularAperture(1., occulting=True)\n]\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(30, 4))\nfor i in range(len(apertures)):\n    plt.subplot(1, 6, i+1)\n    plt.imshow(apertures[i].transmission(256, 2))\nplt.tight_layout()\nplt.savefig(\"assets/basic_apertures.png\")\n</code></pre> <p></p> <p>We can easily add aberrations to these, and make them static:</p> <pre><code>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct a Hexagonal Aperture\nhex = dl.RegPolyAperture(6, 1.)\n\n# Turn it into an aberrated aperture\nzernikes = np.arange(1, 7)\ncoefficients = jr.normal(jr.PRNGKey(0), (6,))\naberrated_hex = dl.AberratedAperture(hex, zernikes, coefficients)\n\n# Promote it to static\nstatic_hex = aberrated_hex.make_static(256, 2)\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(static_hex.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"OPD\")\nplt.imshow(static_hex.transmission * static_hex.opd)\nplt.colorbar()\nplt.savefig('assets/aberrated_apertures.png')\n</code></pre> <p></p> <p>We can also use the <code>ApertureFactory</code> class to construct a simple aperture:</p> <pre><code>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nradial_orders = [2, 3]\ncoefficients = jr.normal(jr.PRNGKey(0), (7,))\n\n# Construct aperture\naperture = dl.ApertureFactory(\n    npixels         = 512,\n    secondary_ratio = 0.1, \n    nstruts         = 4, \n    strut_ratio     = 0.01, \n    radial_orders   = radial_orders, \n    coefficients    = coefficients)\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nopd = aperture.opd.at[aperture.transmission == 0].set(np.nan)\nplt.title(\"OPD\")\nplt.imshow(opd)\nplt.colorbar()\nplt.savefig('assets/aperture_factory.png')\n</code></pre> <p></p>"},{"location":"docs/API/detector_layers/","title":"Detector Layers: <code>detector_layers.py</code>","text":"<p>This module contains the classes that define the behaviour of detector layers in \u2202Lux.</p> <p>There are six public classes:</p> <ul> <li><code>ApplyPixelResponse</code></li> <li><code>ApplyJitter</code></li> <li><code>ApplySaturation</code></li> <li><code>AddConstant</code></li> <li><code>IntegerDownsample</code></li> <li><code>Rotate</code></li> </ul> <p>These classes operate on <code>Image</code> classes. They have one main method: <code>.__call__(image)</code>, which takes in a \u2202Lux <code>Image</code> class and applies the detector layer to it.</p> <p>These classes are relatively simple, so let's quickly move through them.</p>"},{"location":"docs/API/detector_layers/#applypixelresponse","title":"<code>ApplyPixelResponse</code>","text":"<p>Applies a pixel response array to the input image via a multiplication.</p> ApplyPixelResponse API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a pixel response array to the input image, via a multiplication.</p> <p>Attributes:</p> Name Type Description <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>class ApplyPixelResponse(DetectorLayer):\n\"\"\"\n    Applies a pixel response array to the input image, via a multiplication.\n\n    Attributes\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image.\n    \"\"\"\n    pixel_response: Array\n\n    def __init__(self: DetectorLayer,\n                 pixel_response: Array):\n\"\"\"\n        Constructor for the ApplyPixelResponse class.\n\n        Parameters\n        ----------\n        pixel_response : Array\n            The pixel_response to apply to the input image. Must be a 2-dimensional\n            array equal to size of the image at time of application.\n        \"\"\"\n        super().__init__()\n        self.pixel_response = np.asarray(pixel_response, dtype=float)\n        if self.pixel_response.ndim != 2:\n            raise ValueError(\"pixel_response must be a 2 dimensional array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image:\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image * self.pixel_response\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyPixelResponse.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self: DetectorLayer, image: Image()) -&gt; Image:\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    return image * self.pixel_response\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyPixelResponse.__init__","title":"<code>__init__(pixel_response)</code>","text":"<p>Constructor for the ApplyPixelResponse class.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image. Must be a 2-dimensional array equal to size of the image at time of application.</p> required Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer,\n             pixel_response: Array):\n\"\"\"\n    Constructor for the ApplyPixelResponse class.\n\n    Parameters\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image. Must be a 2-dimensional\n        array equal to size of the image at time of application.\n    \"\"\"\n    super().__init__()\n    self.pixel_response = np.asarray(pixel_response, dtype=float)\n    if self.pixel_response.ndim != 2:\n        raise ValueError(\"pixel_response must be a 2 dimensional array.\")\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyPixelResponse","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyPixelResponse.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyPixelResponse.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#applyjitter","title":"<code>ApplyJitter</code>","text":"<p>Convolves the image with a Gaussian kernel parameterised by the standard deviation (<code>sigma</code>).</p> ApplyJitter API <p>         Bases: <code>DetectorLayer</code></p> <p>Convolves the image with a Gaussian kernel parameterised by the standard deviation (sigma).</p> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the Gaussian kernel, in units of pixels.</p> <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>class ApplyJitter(DetectorLayer):\n\"\"\"\n    Convolves the image with a Gaussian kernel parameterised by the standard\n    deviation (sigma).\n\n    Attributes\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the Gaussian kernel, in units of pixels.\n    kernel_size : int\n        The size of the convolution kernel to use.\n    \"\"\"\n    kernel_size: int\n    sigma: Array\n\n    def __init__(self: DetectorLayer,\n                 sigma: Array,\n                 kernel_size: int = 10):\n\"\"\"\n        Constructor for the ApplyJitter class.\n\n        Parameters\n        ----------\n        sigma : Array, pixels\n            The standard deviation of the Gaussian kernel, in units of pixels.\n        kernel_size : int = 10\n            The size of the convolution kernel to use.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n        self.sigma = np.asarray(sigma, dtype=float)\n        if self.sigma.ndim != 0:\n            raise ValueError(\"sigma must be a scalar array.\")\n\n    def generate_kernel(self: DetectorLayer, pixel_scale: Array) -&gt; Array:\n\"\"\"\n        Generates the normalised Gaussian kernel.\n\n        Returns\n        -------\n        kernel : Array\n            The Gaussian kernel.\n        \"\"\"\n        # Generate distribution\n        sigma = self.sigma * pixel_scale\n        x = np.linspace(-10, 10, self.kernel_size) * pixel_scale\n        kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)\n        return kernel / np.sum(kernel)\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        kernel = self.generate_kernel(image.pixel_scale)\n        return image.convolve(kernel)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    kernel = self.generate_kernel(image.pixel_scale)\n    return image.convolve(kernel)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.__init__","title":"<code>__init__(sigma, kernel_size=10)</code>","text":"<p>Constructor for the ApplyJitter class.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the Gaussian kernel, in units of pixels.</p> required <code>kernel_size</code> <code>int = 10</code> <p>The size of the convolution kernel to use.</p> <code>10</code> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer,\n             sigma: Array,\n             kernel_size: int = 10):\n\"\"\"\n    Constructor for the ApplyJitter class.\n\n    Parameters\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the Gaussian kernel, in units of pixels.\n    kernel_size : int = 10\n        The size of the convolution kernel to use.\n    \"\"\"\n    super().__init__()\n    self.kernel_size = int(kernel_size)\n    self.sigma = np.asarray(sigma, dtype=float)\n    if self.sigma.ndim != 0:\n        raise ValueError(\"sigma must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.generate_kernel","title":"<code>generate_kernel(pixel_scale)</code>","text":"<p>Generates the normalised Gaussian kernel.</p> <p>Returns:</p> Name Type Description <code>kernel</code> <code>Array</code> <p>The Gaussian kernel.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def generate_kernel(self: DetectorLayer, pixel_scale: Array) -&gt; Array:\n\"\"\"\n    Generates the normalised Gaussian kernel.\n\n    Returns\n    -------\n    kernel : Array\n        The Gaussian kernel.\n    \"\"\"\n    # Generate distribution\n    sigma = self.sigma * pixel_scale\n    x = np.linspace(-10, 10, self.kernel_size) * pixel_scale\n    kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)\n    return kernel / np.sum(kernel)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplyJitter.generate_kernel","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#applysaturation","title":"<code>ApplySaturation</code>","text":"<p>Applies a simple saturation model to the input image, by clipping any values above <code>saturation</code>.</p> ApplySaturation API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a simple saturation model to the input image, by clipping any values above saturation, to saturation.</p> <p>Attributes:</p> Name Type Description <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>class ApplySaturation(DetectorLayer):\n\"\"\"\n    Applies a simple saturation model to the input image, by clipping any\n    values above saturation, to saturation.\n\n    Attributes\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    \"\"\"\n    saturation: Array\n\n    def __init__(self: DetectorLayer, saturation: Array) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplySaturation class.\n\n        Parameters\n        ----------\n        saturation : Array\n            The value at which the saturation is applied.\n        \"\"\"\n        super().__init__()\n        self.saturation = np.asarray(saturation, dtype=float)\n        if self.saturation.ndim != 0:\n            raise ValueError(\"saturation must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.min('image', self.saturation)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplySaturation.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    return image.min('image', self.saturation)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplySaturation.__init__","title":"<code>__init__(saturation)</code>","text":"<p>Constructor for the ApplySaturation class.</p> <p>Parameters:</p> Name Type Description Default <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> required Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, saturation: Array) -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the ApplySaturation class.\n\n    Parameters\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    \"\"\"\n    super().__init__()\n    self.saturation = np.asarray(saturation, dtype=float)\n    if self.saturation.ndim != 0:\n        raise ValueError(\"saturation must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplySaturation","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplySaturation.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.ApplySaturation.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#addconstant","title":"<code>AddConstant</code>","text":"<p>Add a constant to the output image. This is typically used to model the mean value of the detector noise.</p> AddConstant API <p>         Bases: <code>DetectorLayer</code></p> <p>Add a constant to the output image. This is typically used to model the mean value of the detector noise.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Array</code> <p>The value to add to the image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>class AddConstant(DetectorLayer):\n\"\"\"\n    Add a constant to the output image. This is typically used to model the\n    mean value of the detector noise.\n\n    Attributes\n    ----------\n    value : Array\n        The value to add to the image.\n    \"\"\"\n    value: Array\n\n    def __init__(self: DetectorLayer, value: Array) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the AddConstant class.\n\n        Parameters\n        ----------\n        value : Array\n            The value to add to the image.\n        \"\"\"\n        super().__init__()\n        self.value = np.asarray(value, dtype=float)\n        if self.value.ndim != 0:\n            raise ValueError(\"value must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image + self.value\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.AddConstant.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    return image + self.value\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.AddConstant.__init__","title":"<code>__init__(value)</code>","text":"<p>Constructor for the AddConstant class.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Array</code> <p>The value to add to the image.</p> required Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, value: Array) -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the AddConstant class.\n\n    Parameters\n    ----------\n    value : Array\n        The value to add to the image.\n    \"\"\"\n    super().__init__()\n    self.value = np.asarray(value, dtype=float)\n    if self.value.ndim != 0:\n        raise ValueError(\"value must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.AddConstant","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.AddConstant.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.AddConstant.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#integerdownsample","title":"<code>IntegerDownsample</code>","text":"<p>Downsamples an input image by an integer number of pixels via a summation. The number of pixels in the input image must be integer divisible by <code>kernel_size</code>.</p> IntegerDownsample API <p>         Bases: <code>DetectorLayer</code></p> <p>Downsamples an input image by an integer number of pixels via a sum. The number of pixels in the input image must be integer divisible by the kernel_size.</p> <p>Attributes:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>class IntegerDownsample(DetectorLayer):\n\"\"\"\n    Downsamples an input image by an integer number of pixels via a sum.\n    The number of pixels in the input image must be integer divisible by the\n    kernel_size.\n\n    Attributes\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    \"\"\"\n    kernel_size: int\n\n    def __init__(self: DetectorLayer, kernel_size: int) -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the IntegerDownsample class.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the downsampling kernel.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n\n    def __call__(self, image):\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.downsample(self.kernel_size)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.IntegerDownsample.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self, image):\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    return image.downsample(self.kernel_size)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.IntegerDownsample.__init__","title":"<code>__init__(kernel_size)</code>","text":"<p>Constructor for the IntegerDownsample class.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> required Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, kernel_size: int) -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the IntegerDownsample class.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    \"\"\"\n    super().__init__()\n    self.kernel_size = int(kernel_size)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.IntegerDownsample","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.IntegerDownsample.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.IntegerDownsample.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#rotate","title":"<code>Rotate</code>","text":"<p>Applies a rotation to the image using interpolation methods.</p> Rotate API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a rotation to the image using interpolation methods.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required <code>order</code> <code>int</code> <p>The order of the interpolation.</p> <code>1</code> Source code in <code>dLux/detector_layers.py</code> <pre><code>class Rotate(DetectorLayer):\n\"\"\"\n    Applies a rotation to the image using interpolation methods.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the image in the clockwise direction.\n    order : int\n        The order of the interpolation.\n    \"\"\"\n    angle: Array\n    order: int\n\n    def __init__(self: DetectorLayer,\n                 angle: Array,\n                 order: int = 1):\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the image in the clockwise direction.\n        \"\"\"\n        super().__init__()\n        self.angle = np.asarray(angle, dtype=float)\n        self.order = int(order)\n        if self.angle.ndim != 0:\n            raise ValueError(\"angle must be a scalar array.\")\n\n    def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n        Applies the layer to the Image.\n\n        Parameters\n        ----------\n        image : Image\n            The image to operate on.\n\n        Returns\n        -------\n        image : Image\n            The transformed image.\n        \"\"\"\n        return image.rotate(self.angle, self.order)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.Rotate.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the layer to the Image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The image to operate on.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The transformed image.</p> Source code in <code>dLux/detector_layers.py</code> <pre><code>def __call__(self: DetectorLayer, image: Image()) -&gt; Image():\n\"\"\"\n    Applies the layer to the Image.\n\n    Parameters\n    ----------\n    image : Image\n        The image to operate on.\n\n    Returns\n    -------\n    image : Image\n        The transformed image.\n    \"\"\"\n    return image.rotate(self.angle, self.order)\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.Rotate.__init__","title":"<code>__init__(angle, order=1)</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required Source code in <code>dLux/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer,\n             angle: Array,\n             order: int = 1):\n\"\"\"\n    Constructor for the Rotate class.\n\n    Parameters\n    ----------\n    angle: float, radians\n        The angle by which to rotate the image in the clockwise direction.\n    \"\"\"\n    super().__init__()\n    self.angle = np.asarray(angle, dtype=float)\n    self.order = int(order)\n    if self.angle.ndim != 0:\n        raise ValueError(\"angle must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detector_layers/#dLux.detector_layers.Rotate","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.Rotate.__call__","title":"Detector Layers","text":""},{"location":"docs/API/detector_layers/#dLux.detector_layers.Rotate.__init__","title":"Detector Layers","text":""},{"location":"docs/API/detectors/","title":"Detector: <code>detector.py</code>","text":"<p>This module contains the classes that define the behaviour of detectors in \u2202Lux.</p> <p>There is one public class: <code>LayeredDetector</code>.</p> <p>This essentially operates in the same way as <code>LayeredOptics</code>; taking in a list of <code>DetectorLayer</code> objects and applying them sequentially (although they operate on <code>Image</code> classes). <code>LayeredOptics</code> has one main method: <code>.model(image)</code>, which applies the detector layers to the input image.</p> Detector API <p>         Bases: <code>BaseDetector</code></p> <p>A high level class designed to model the behaviour of some detectors response to some psf.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>dict</code> <p>A collections.OrderedDict of 'layers' that define the transformations and operations upon some input psf as it interacts with the detector.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class LayeredDetector(BaseDetector):\n\"\"\"\n    A high level class designed to model the behaviour of some detectors\n    response to some psf.\n\n    Attributes\n    ----------\n    layers: dict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input psf as it interacts with the detector.\n    \"\"\"\n    layers: OrderedDict\n\n    def __init__(self: Detector, layers: list):\n\"\"\"\n        Constructor for the Detector class.\n\n        Parameters\n        ----------\n        layers : list\n            An list of dLux detector layer classes that define the instrumental\n            effects for some detector.\n\n            A list of \u2202Lux 'layers' that define the transformations and\n            operations upon some input wavefront through an optical system.\n            The entries can either be dLux DetectorLayers, or tuples of the\n            form (DetectorLayer, key), with the key being used as the dictionary\n            key for the layer.\n        \"\"\"\n        self.layers = dlu.list_to_dictionary(layers, True, DetectorLayer())\n        super().__init__()\n\n    def __getattr__(self: Detector, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        else:\n            raise AttributeError(\"'{}' object has no attribute '{}'\"\n                                 .format(type(self), key))\n\n    def model(self: Detector, image: Array) -&gt; Array:\n\"\"\"\n        Applied the stored detector layers to the input image.\n\n        Parameters\n        ----------\n        image : Array\n            The input psf to be transformed.\n\n        Returns\n        -------\n        image : Array\n            The output 'image' after being transformed by the detector layers.\n        \"\"\"\n        for key, layer in self.layers.items():\n            image = layer(image)\n        return image.image\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the layers dictionary of this class via the 'class.attribute' method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __getattr__(self: Detector, key: str) -&gt; object:\n\"\"\"\n    Magic method designed to allow accessing of the various items within\n    the layers dictionary of this class via the 'class.attribute' method.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the layers dictionary.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the layers dictionary.\n    \"\"\"\n    if key in self.layers.keys():\n        return self.layers[key]\n    else:\n        raise AttributeError(\"'{}' object has no attribute '{}'\"\n                             .format(type(self), key))\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.__init__","title":"<code>__init__(layers)</code>","text":"<p>Constructor for the Detector class.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>An list of dLux detector layer classes that define the instrumental effects for some detector.</p> <p>A list of \u2202Lux 'layers' that define the transformations and operations upon some input wavefront through an optical system. The entries can either be dLux DetectorLayers, or tuples of the form (DetectorLayer, key), with the key being used as the dictionary key for the layer.</p> required Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self: Detector, layers: list):\n\"\"\"\n    Constructor for the Detector class.\n\n    Parameters\n    ----------\n    layers : list\n        An list of dLux detector layer classes that define the instrumental\n        effects for some detector.\n\n        A list of \u2202Lux 'layers' that define the transformations and\n        operations upon some input wavefront through an optical system.\n        The entries can either be dLux DetectorLayers, or tuples of the\n        form (DetectorLayer, key), with the key being used as the dictionary\n        key for the layer.\n    \"\"\"\n    self.layers = dlu.list_to_dictionary(layers, True, DetectorLayer())\n    super().__init__()\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.model","title":"<code>model(image)</code>","text":"<p>Applied the stored detector layers to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The input psf to be transformed.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The output 'image' after being transformed by the detector layers.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def model(self: Detector, image: Array) -&gt; Array:\n\"\"\"\n    Applied the stored detector layers to the input image.\n\n    Parameters\n    ----------\n    image : Array\n        The input psf to be transformed.\n\n    Returns\n    -------\n    image : Array\n        The output 'image' after being transformed by the detector layers.\n    \"\"\"\n    for key, layer in self.layers.items():\n        image = layer(image)\n    return image.image\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.__getattr__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.LayeredDetector.model","title":"Detectors","text":""},{"location":"docs/API/detectors/#examples","title":"Examples","text":"<p>Let's look at how we can construct a <code>LayeredDetector</code> class and apply it to a PSF.</p> <p>First we construct some optics and a source:</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\nraw_psf = source.model(optics)\n</code></pre> <p>Now we construct our detector:</p> <pre><code># Construct Detector\ndetector = dl.LayeredDetector([\n    dl.ApplyJitter(20),\n    dl.IntegerDownsample(4),\n    dl.AddConstant(1),\n])\n\n# Combine into instrument and model\ninstrument = dl.Instrument(optics, source, detector)\npsf = instrument.model()\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Raw PSF\")\nplt.imshow(raw_psf**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Detector Transformed PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('assets/detectors.png')\n</code></pre> <p></p>"},{"location":"docs/API/images/","title":"Images: <code>images.py</code>","text":"<p>This module contains the classes that define the behaviour of images in \u2202Lux.</p> <p>There is only a single public class:</p> <ul> <li><code>Image</code></li> </ul> <p>This class has two attributes:</p> <ul> <li><code>image</code></li> <li><code>pixel_scale</code></li> </ul> <p>The <code>image</code> attribute is a 2D array of the image. The <code>pixel_scale</code> is the pixel scale of the image, the units of which depends on the <code>Optics</code> used.</p> Image API <p>         Bases: <code>Base</code></p> <p>A class representing some image as it is transformed by the detector. It tracks the image via the <code>image</code> attribute, and the pixel scale via the <code>pixel_scale</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image as it is transformed by the detector.</p> <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the image.</p> Source code in <code>dLux/images.py</code> <pre><code>class Image(Base):\n\"\"\"\n    A class representing some image as it is transformed by the detector. It\n    tracks the image via the `image` attribute, and the pixel scale via the\n    `pixel_scale` attribute.\n\n    Attributes\n    ----------\n    image : Array\n        The image as it is transformed by the detector.\n    pixel_scale : Array\n        The pixel scale of the image.\n    \"\"\"\n    image: Array\n    pixel_scale: Array\n\n    def __init__(self: Image, image: Array, pixel_scale: Array):\n\"\"\"\n        Parameters\n        ----------\n        image : Array\n            The image as it is transformed by the detector.\n        pixel_scale : Array\n            The pixel scale of the image.\n        \"\"\"\n        self.image = np.asarray(image, dtype=float)\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n\n    @property\n    def npixels(self: Image) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        image.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Image`.\n        \"\"\"\n        return self.image.shape[-1]\n\n    def downsample(self: Image, n: int) -&gt; Image:\n\"\"\"\n        Downsamples the image by a factor of n. This is done by summing the\n        image pixels in n x n blocks.\n\n        Parameters\n        ----------\n        n : int\n            The factor by which to downsample the image.\n\n        Returns\n        -------\n        image : Image\n            The downsampled image.\n        \"\"\"\n        downsampled = dlu.downsample(self.image, n, 'sum')\n        return self.set('image', downsampled)\n\n    def convolve(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Convolves the image with another image. This is done using the\n        `jax.scipy.signal.convolve` function.\n\n        Parameters\n        ----------\n        other : Array\n            The image to convolve with.\n\n        Returns\n        -------\n        image : Image\n            The convolved image.\n        \"\"\"\n        return self.set('image', convolve(self.image, other, mode='same'))\n\n    def rotate(self: Image, angle: float, order: int = 1) -&gt; Image:\n\"\"\"\n        Rotates the image by a given angle. This is done using interpolation\n        methods.\n\n        Parameters\n        ----------\n        angle : float\n            The angle by which to rotate the image.\n        order : int\n            The order of the interpolation method to use.\n\n        Returns\n        -------\n        image : Image\n            The rotated image.\n        \"\"\"\n        return self.set('image', dlu.rotate(self.image, angle, order=order))\n\n    def __mul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the multiplication operator. This allows for the\n        multiplication of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to multiply the image by.\n\n        Returns\n        -------\n        image : Image\n            The multiplied image.\n        \"\"\"\n        return self.multiply('image', other)\n\n    def __imul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace multiplication operator. This allows for\n        the inplace multiplication of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to multiply the image by.\n\n        Returns\n        -------\n        image : Image\n            The multiplied image.\n        \"\"\"\n        return self.__mul__(other)\n\n    def __add__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the addition operator. This allows for the addition of\n        the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to add to the image.\n\n        Returns\n        -------\n        image : Image\n            The added image.\n        \"\"\"\n        return self.add('image', other)\n\n    def __iadd__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace addition operator. This allows for the\n        inplace addition of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to add to the image.\n\n        Returns\n        -------\n        image : Image\n            The added image.\n        \"\"\"\n        return self.__add__(other)\n\n    def __sub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the subtraction operator. This allows for the\n        subtraction of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to subtract from the image.\n\n        Returns\n        -------\n        image : Image\n            The subtracted image.\n        \"\"\"\n        return self.add('image', -other)\n\n    def __isub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace subtraction operator. This allows for the\n        inplace subtraction of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to subtract from the image.\n\n        Returns\n        -------\n        image : Image\n            The subtracted image.\n        \"\"\"\n        return self.__sub__(other)\n\n    def __truediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the division operator. This allows for the division of\n        the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to divide the image by.\n\n        Returns\n        -------\n        image : Image\n            The divided image.\n        \"\"\"\n        return self.divide('image', other)\n\n    def __itruediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n        Magic method for the inplace division operator. This allows for the\n        inplace division of the image by a scalar or another image.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or image to divide the image by.\n\n        Returns\n        -------\n        image : Image\n            The divided image.\n        \"\"\"\n        return self.__truediv__(other)\n</code></pre> <p>The <code>Image</code> class has a number of methods that allow for image manipulation. They are implemented as standard arithmetic operators, i.e.:</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\nimage = dl.Image(np.ones((256, 256)), 0.1)\nimage *= 2\nimage /= 2\nimage += 1\nimage -= 1\n</code></pre> <p>Here <code>*</code> and <code>/</code> scale the pixel values by the given factor, and <code>+</code> and <code>-</code> add or subtract the given value from all pixel values.</p> <p>On top of these operators, the <code>Image</code> class also implements a number of methods that allow for the manipulation of the image. For more details on these, see the <code>Image API</code> above. These methods are:</p>"},{"location":"docs/API/images/#dLux.images.Image.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the image.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of pixels that represent the <code>Image</code>.</p>"},{"location":"docs/API/images/#dLux.images.Image.__add__","title":"<code>__add__(other)</code>","text":"<p>Magic method for the addition operator. This allows for the addition of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to add to the image.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The added image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __add__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the addition operator. This allows for the addition of\n    the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to add to the image.\n\n    Returns\n    -------\n    image : Image\n        The added image.\n    \"\"\"\n    return self.add('image', other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Magic method for the inplace addition operator. This allows for the inplace addition of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to add to the image.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The added image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __iadd__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the inplace addition operator. This allows for the\n    inplace addition of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to add to the image.\n\n    Returns\n    -------\n    image : Image\n        The added image.\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__imul__","title":"<code>__imul__(other)</code>","text":"<p>Magic method for the inplace multiplication operator. This allows for the inplace multiplication of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to multiply the image by.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The multiplied image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __imul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the inplace multiplication operator. This allows for\n    the inplace multiplication of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to multiply the image by.\n\n    Returns\n    -------\n    image : Image\n        The multiplied image.\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__init__","title":"<code>__init__(image, pixel_scale)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image as it is transformed by the detector.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the image.</p> required Source code in <code>dLux/images.py</code> <pre><code>def __init__(self: Image, image: Array, pixel_scale: Array):\n\"\"\"\n    Parameters\n    ----------\n    image : Array\n        The image as it is transformed by the detector.\n    pixel_scale : Array\n        The pixel scale of the image.\n    \"\"\"\n    self.image = np.asarray(image, dtype=float)\n    self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Magic method for the inplace subtraction operator. This allows for the inplace subtraction of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to subtract from the image.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The subtracted image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __isub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the inplace subtraction operator. This allows for the\n    inplace subtraction of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to subtract from the image.\n\n    Returns\n    -------\n    image : Image\n        The subtracted image.\n    \"\"\"\n    return self.__sub__(other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__itruediv__","title":"<code>__itruediv__(other)</code>","text":"<p>Magic method for the inplace division operator. This allows for the inplace division of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to divide the image by.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The divided image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __itruediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the inplace division operator. This allows for the\n    inplace division of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to divide the image by.\n\n    Returns\n    -------\n    image : Image\n        The divided image.\n    \"\"\"\n    return self.__truediv__(other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Magic method for the multiplication operator. This allows for the multiplication of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to multiply the image by.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The multiplied image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __mul__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the multiplication operator. This allows for the\n    multiplication of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to multiply the image by.\n\n    Returns\n    -------\n    image : Image\n        The multiplied image.\n    \"\"\"\n    return self.multiply('image', other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Magic method for the subtraction operator. This allows for the subtraction of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to subtract from the image.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The subtracted image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __sub__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the subtraction operator. This allows for the\n    subtraction of the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to subtract from the image.\n\n    Returns\n    -------\n    image : Image\n        The subtracted image.\n    \"\"\"\n    return self.add('image', -other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Magic method for the division operator. This allows for the division of the image by a scalar or another image.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or image to divide the image by.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The divided image.</p> Source code in <code>dLux/images.py</code> <pre><code>def __truediv__(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Magic method for the division operator. This allows for the division of\n    the image by a scalar or another image.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or image to divide the image by.\n\n    Returns\n    -------\n    image : Image\n        The divided image.\n    \"\"\"\n    return self.divide('image', other)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.convolve","title":"<code>convolve(other)</code>","text":"<p>Convolves the image with another image. This is done using the <code>jax.scipy.signal.convolve</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The image to convolve with.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The convolved image.</p> Source code in <code>dLux/images.py</code> <pre><code>def convolve(self: Image, other: Array) -&gt; Image:\n\"\"\"\n    Convolves the image with another image. This is done using the\n    `jax.scipy.signal.convolve` function.\n\n    Parameters\n    ----------\n    other : Array\n        The image to convolve with.\n\n    Returns\n    -------\n    image : Image\n        The convolved image.\n    \"\"\"\n    return self.set('image', convolve(self.image, other, mode='same'))\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.downsample","title":"<code>downsample(n)</code>","text":"<p>Downsamples the image by a factor of n. This is done by summing the image pixels in n x n blocks.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The factor by which to downsample the image.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The downsampled image.</p> Source code in <code>dLux/images.py</code> <pre><code>def downsample(self: Image, n: int) -&gt; Image:\n\"\"\"\n    Downsamples the image by a factor of n. This is done by summing the\n    image pixels in n x n blocks.\n\n    Parameters\n    ----------\n    n : int\n        The factor by which to downsample the image.\n\n    Returns\n    -------\n    image : Image\n        The downsampled image.\n    \"\"\"\n    downsampled = dlu.downsample(self.image, n, 'sum')\n    return self.set('image', downsampled)\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image.rotate","title":"<code>rotate(angle, order=1)</code>","text":"<p>Rotates the image by a given angle. This is done using interpolation methods.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle by which to rotate the image.</p> required <code>order</code> <code>int</code> <p>The order of the interpolation method to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>image</code> <code>Image</code> <p>The rotated image.</p> Source code in <code>dLux/images.py</code> <pre><code>def rotate(self: Image, angle: float, order: int = 1) -&gt; Image:\n\"\"\"\n    Rotates the image by a given angle. This is done using interpolation\n    methods.\n\n    Parameters\n    ----------\n    angle : float\n        The angle by which to rotate the image.\n    order : int\n        The order of the interpolation method to use.\n\n    Returns\n    -------\n    image : Image\n        The rotated image.\n    \"\"\"\n    return self.set('image', dlu.rotate(self.image, angle, order=order))\n</code></pre>"},{"location":"docs/API/images/#dLux.images.Image","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.npixels","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__add__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__iadd__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__imul__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__init__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__isub__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__itruediv__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__mul__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__sub__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.__truediv__","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.convolve","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.downsample","title":"Images","text":""},{"location":"docs/API/images/#dLux.images.Image.rotate","title":"Images","text":""},{"location":"docs/API/images/#downsample","title":"<code>Downsample</code>","text":"<p>Downsamples the image by a factor of \\(n\\). This is done by summing the image pixels in \\(n \\times n\\) blocks.</p>"},{"location":"docs/API/images/#convolve","title":"<code>Convolve</code>","text":"<p>Convolves the image with another. This is done using the <code>jax.scipy.signal.convolve</code> function.</p>"},{"location":"docs/API/images/#rotate","title":"<code>Rotate</code>","text":"<p>Rotates the image by a given angle. This is done using interpolation methods.</p>"},{"location":"docs/API/instruments/","title":"Instruments: instruments.py","text":"<p>This module contains the classes that define the behaviour of instruments in \u2202Lux. Instrument classes hold the various types of \u2202Lux classes and handle the coherent modelling of these classes.</p> <p>There is one public class:</p> <ul> <li><code>Instrument</code></li> </ul> <p>The <code>Instrument</code> class has three main methods:</p> <ol> <li><code>model()</code> Models the sources through the instrument optics and detector.</li> <li><code>observe()</code> Calls the <code>observe</code> method of the stored observation class.</li> <li><code>normalise()</code> Returns a new instrument with normalised source objects. Note this method is automatically called during the <code>.model()</code> method to ensure quantities are conserved during optimisation loops.</li> </ol> Instrument API <p>         Bases: <code>Base</code></p> <p>A high level class designed to model the behaviour of a telescope. It stores a series different \u2202Lux objects, and primarily passes the relevant information between these objects in order to coherently model some telescope observation.</p> <p>Attributes:</p> Name Type Description <code>optics</code> <code>Optics</code> <p>A Optics object that defines some optical configuration.</p> <code>sources</code> <code>dict</code> <p>A dictionary of the various source objects that the instrument is observing.</p> <code>detector</code> <code>Detector</code> <p>A Detector object that is used to model the various instrumental effects on a psf.</p> <code>observation</code> <code>Observation</code> <p>An class that inherits from Observation. This is to allow flexibility in the different kind of observations, i.e. applying dithers, switching filters, etc.</p> Source code in <code>dLux/instruments.py</code> <pre><code>class Instrument(Base):\n\"\"\"\n    A high level class designed to model the behaviour of a telescope. It\n    stores a series different \u2202Lux objects, and primarily passes the relevant\n    information between these objects in order to coherently model some\n    telescope observation.\n\n    Attributes\n    ----------\n    optics : Optics\n        A Optics object that defines some optical configuration.\n    sources : dict\n        A dictionary of the various source objects that the instrument is\n        observing.\n    detector : Detector\n        A Detector object that is used to model the various\n        instrumental effects on a psf.\n    observation : Observation\n        An class that inherits from Observation. This is to allow flexibility\n        in the different kind of observations, i.e. applying dithers, switching\n        filters, etc.\n    \"\"\"\n    optics: Optics()\n    sources: dict\n    detector: Detector()\n    observation: Observation()\n\n    def __init__(self: Instrument,\n                 optics: Optics(),\n                 sources: Union[list, Source()],\n                 detector: Detector() = None,\n                 observation: Observation = None,\n                 ):\n\"\"\"\n        Constructor for the Instrument class.\n\n        Parameters\n        ----------\n        optics : Optics\n            A pre-configured Optics object.\n        sources : Union[list, Source]\n            Either a list of sources or an individual Source object.\n        detector : Detector = None\n            A pre-configured Detector object.\n        observation : Observation = None\n            An class that inherits from Observation. This is to allow\n            flexibility in the different kind of observations, i.e. applying\n            dithers, switching filters, etc.\n        \"\"\"\n        # Optics\n        if not isinstance(optics, Optics()):\n            raise TypeError(\"optics must be an Optics object.\")\n        self.optics = optics\n\n        # Sources\n        if isinstance(sources, (Source(), tuple)):\n            sources = [sources]\n        self.sources = dlu.list_to_dictionary(sources, False, Source())\n\n        # Detector\n        if not isinstance(detector, Detector()) and detector is not None:\n            raise TypeError(\"detector must be an Detector object. \"\n                            f\"Got type {type(detector)}\")\n        self.detector = detector\n\n        # Observation\n        if (not isinstance(observation, Observation()) and\n                observation is not None):\n            raise TypeError(\"observation must be an Observation object.\")\n        self.observation = observation\n\n    def observe(self: Instrument) -&gt; Any:\n\"\"\"\n        Calls the `observe` method of the stored observation class, passing in\n        any extra keyword arguments.\n\n        Returns\n        -------\n         : Any\n            The output of the stored observation class.\n        \"\"\"\n        return self.observation.model(self)\n\n    def __getattr__(self: Instrument, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the sub-dictionaries of this class via the 'class.attribute' method.\n        It is recommended that each dictionary key in the optical layers,\n        detector layers, and scene sources are unique to prevent unexpected\n        behaviour. In the case they there are identical keys across the\n        dictionaries This method prioritises searching for keys in the optical\n        layers, then detector layers, and then the scene sources.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the sub-dictionaries.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the sub-dictionaries.\n        \"\"\"\n        for attribute in self.__dict__.values():\n            if hasattr(attribute, key):\n                return getattr(attribute, key)\n        if key in self.sources.keys():\n            return self.sources[key]\n        for source in self.sources.values():\n            if hasattr(source, key):\n                return getattr(source, key)\n        raise AttributeError(f\"{self.__class__.__name__} has no attribute \"\n                             f\"{key}.\")\n\n    def normalise(self: Instrument) -&gt; Instrument:\n\"\"\"\n        Method for returning a new instrument with normalised source objects.\n\n        Returns\n        -------\n        instrument : Instrument\n            The normalised instrument object.\n        \"\"\"\n        is_source = lambda leaf: isinstance(leaf, Source())\n        norm_fn = lambda source: source.normalise()\n        sources = tree_map(norm_fn, self.sources, is_leaf=is_source)\n        return self.set('sources', sources)\n\n    def model(self: Instrument) -&gt; Union[Array, dict]:\n\"\"\"\n        A base level modelling function designed to robustly handle the\n        different combinations of inputs. Models the sources through the\n        instrument optics and detector.\n\n        Returns\n        -------\n        image : Array, dict\n            The image of the scene modelled through the optics with detector and\n            filter effects applied if they are supplied. Returns either as a\n            single array (if return_tree is false), or a dict of the output for\n            each source.\n        \"\"\"\n        psf = self.optics.model(list(self.sources.values()))\n        image = Image()(psf, self.optics.true_pixel_scale)\n        image = self.detector.model(image) if self.detector is not None else psf\n        return np.array(tree_flatten(image)[0]).sum(0)\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the sub-dictionaries of this class via the 'class.attribute' method. It is recommended that each dictionary key in the optical layers, detector layers, and scene sources are unique to prevent unexpected behaviour. In the case they there are identical keys across the dictionaries This method prioritises searching for keys in the optical layers, then detector layers, and then the scene sources.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the sub-dictionaries.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the sub-dictionaries.</p> Source code in <code>dLux/instruments.py</code> <pre><code>def __getattr__(self: Instrument, key: str) -&gt; object:\n\"\"\"\n    Magic method designed to allow accessing of the various items within\n    the sub-dictionaries of this class via the 'class.attribute' method.\n    It is recommended that each dictionary key in the optical layers,\n    detector layers, and scene sources are unique to prevent unexpected\n    behaviour. In the case they there are identical keys across the\n    dictionaries This method prioritises searching for keys in the optical\n    layers, then detector layers, and then the scene sources.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the sub-dictionaries.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the sub-dictionaries.\n    \"\"\"\n    for attribute in self.__dict__.values():\n        if hasattr(attribute, key):\n            return getattr(attribute, key)\n    if key in self.sources.keys():\n        return self.sources[key]\n    for source in self.sources.values():\n        if hasattr(source, key):\n            return getattr(source, key)\n    raise AttributeError(f\"{self.__class__.__name__} has no attribute \"\n                         f\"{key}.\")\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument.__init__","title":"<code>__init__(optics, sources, detector=None, observation=None)</code>","text":"<p>Constructor for the Instrument class.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>A pre-configured Optics object.</p> required <code>sources</code> <code>Union[list, Source]</code> <p>Either a list of sources or an individual Source object.</p> required <code>detector</code> <code>Detector = None</code> <p>A pre-configured Detector object.</p> <code>None</code> <code>observation</code> <code>Observation = None</code> <p>An class that inherits from Observation. This is to allow flexibility in the different kind of observations, i.e. applying dithers, switching filters, etc.</p> <code>None</code> Source code in <code>dLux/instruments.py</code> <pre><code>def __init__(self: Instrument,\n             optics: Optics(),\n             sources: Union[list, Source()],\n             detector: Detector() = None,\n             observation: Observation = None,\n             ):\n\"\"\"\n    Constructor for the Instrument class.\n\n    Parameters\n    ----------\n    optics : Optics\n        A pre-configured Optics object.\n    sources : Union[list, Source]\n        Either a list of sources or an individual Source object.\n    detector : Detector = None\n        A pre-configured Detector object.\n    observation : Observation = None\n        An class that inherits from Observation. This is to allow\n        flexibility in the different kind of observations, i.e. applying\n        dithers, switching filters, etc.\n    \"\"\"\n    # Optics\n    if not isinstance(optics, Optics()):\n        raise TypeError(\"optics must be an Optics object.\")\n    self.optics = optics\n\n    # Sources\n    if isinstance(sources, (Source(), tuple)):\n        sources = [sources]\n    self.sources = dlu.list_to_dictionary(sources, False, Source())\n\n    # Detector\n    if not isinstance(detector, Detector()) and detector is not None:\n        raise TypeError(\"detector must be an Detector object. \"\n                        f\"Got type {type(detector)}\")\n    self.detector = detector\n\n    # Observation\n    if (not isinstance(observation, Observation()) and\n            observation is not None):\n        raise TypeError(\"observation must be an Observation object.\")\n    self.observation = observation\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument.model","title":"<code>model()</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector.</p> <p>Returns:</p> Name Type Description <code>image</code> <code>Array, dict</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a dict of the output for each source.</p> Source code in <code>dLux/instruments.py</code> <pre><code>def model(self: Instrument) -&gt; Union[Array, dict]:\n\"\"\"\n    A base level modelling function designed to robustly handle the\n    different combinations of inputs. Models the sources through the\n    instrument optics and detector.\n\n    Returns\n    -------\n    image : Array, dict\n        The image of the scene modelled through the optics with detector and\n        filter effects applied if they are supplied. Returns either as a\n        single array (if return_tree is false), or a dict of the output for\n        each source.\n    \"\"\"\n    psf = self.optics.model(list(self.sources.values()))\n    image = Image()(psf, self.optics.true_pixel_scale)\n    image = self.detector.model(image) if self.detector is not None else psf\n    return np.array(tree_flatten(image)[0]).sum(0)\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new instrument with normalised source objects.</p> <p>Returns:</p> Name Type Description <code>instrument</code> <code>Instrument</code> <p>The normalised instrument object.</p> Source code in <code>dLux/instruments.py</code> <pre><code>def normalise(self: Instrument) -&gt; Instrument:\n\"\"\"\n    Method for returning a new instrument with normalised source objects.\n\n    Returns\n    -------\n    instrument : Instrument\n        The normalised instrument object.\n    \"\"\"\n    is_source = lambda leaf: isinstance(leaf, Source())\n    norm_fn = lambda source: source.normalise()\n    sources = tree_map(norm_fn, self.sources, is_leaf=is_source)\n    return self.set('sources', sources)\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument.observe","title":"<code>observe()</code>","text":"<p>Calls the <code>observe</code> method of the stored observation class, passing in any extra keyword arguments.</p> <p>Returns:</p> Type Description <code> : Any</code> <p>The output of the stored observation class.</p> Source code in <code>dLux/instruments.py</code> <pre><code>def observe(self: Instrument) -&gt; Any:\n\"\"\"\n    Calls the `observe` method of the stored observation class, passing in\n    any extra keyword arguments.\n\n    Returns\n    -------\n     : Any\n        The output of the stored observation class.\n    \"\"\"\n    return self.observation.model(self)\n</code></pre>"},{"location":"docs/API/instruments/#dLux.instruments.Instrument","title":"Instruments","text":""},{"location":"docs/API/instruments/#dLux.instruments.Instrument.__getattr__","title":"Instruments","text":""},{"location":"docs/API/instruments/#dLux.instruments.Instrument.__init__","title":"Instruments","text":""},{"location":"docs/API/instruments/#dLux.instruments.Instrument.model","title":"Instruments","text":""},{"location":"docs/API/instruments/#dLux.instruments.Instrument.normalise","title":"Instruments","text":""},{"location":"docs/API/instruments/#dLux.instruments.Instrument.observe","title":"Instruments","text":""},{"location":"docs/API/instruments/#examples","title":"Examples","text":"<p>Let's construct a minimal instrument object with all of its attributes populated.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Detector\ndetector = dl.LayeredDetector([dl.ApplyJitter(20)])\n\n# Construct Observation\nobservation = dl.Dither(np.array([[0, 0], [1e-6, 1e-6]]))\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</code></pre> Plotting Code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"$\\sqrt{PSF_1}$\")\nplt.imshow(psfs[0]**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF_2}$\")\nplt.imshow(psfs[1]**0.5)\nplt.colorbar()\nplt.savefig('assets/instrument.png')\n</code></pre> <p></p> <p>Model</p> <p>We can also use the <code>.model()</code> method to model the instrument without applying the observation class!</p>"},{"location":"docs/API/observations/","title":"Observations: observations.py","text":"<p>This module contains the classes that define the behaviour of observations in \u2202Lux. Observation classes are designed to be constructed by users in order to model arbitrary observation patterns. As an example, we have implemented a <code>Dither</code> class which applies a series of dithers to the source positions.</p> Observations API <p>All <code>Observation</code> classes should implement a <code>.model(instrument)</code> method that performs the actual calculation of the observation.</p> <p>Let's construct a simple dither observation class.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Observation\ndithers = 1e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, observation=observation)\npsfs = instrument.observe()\n</code></pre> Plotting Code <pre><code>plt.figure(figsize=(20, 4))\nfor i in range(4):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"$\\sqrt{PSF}$\")\n    plt.imshow(psfs[i]**0.5)\n    plt.colorbar()\nplt.savefig('assets/observation.png')\n</code></pre> <p></p>"},{"location":"docs/API/observations/#dLux.observations.BaseObservation","title":"<code>BaseObservation</code>","text":"<p>         Bases: <code>Base</code></p> <p>Abstract base class for observations. All observations should inherit from this class and must implement an <code>.model()</code> method that only takes in a single instance of <code>dLux.Instrument</code>.</p> Source code in <code>dLux/observations.py</code> <pre><code>class BaseObservation(Base):\n\"\"\"\n    Abstract base class for observations. All observations should inherit from\n    this class and must implement an `.model()` method that only takes in a\n    single instance of `dLux.Instrument`.\n    \"\"\"\n\n    @abstractmethod\n    def model(self: BaseObservation,\n              instrument: Instrument()):  # pragma: no cover\n\"\"\"\n        Abstract method for the observation function.\n        \"\"\"\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.BaseObservation.model","title":"<code>model(instrument)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the observation function.</p> Source code in <code>dLux/observations.py</code> <pre><code>@abstractmethod\ndef model(self: BaseObservation,\n          instrument: Instrument()):  # pragma: no cover\n\"\"\"\n    Abstract method for the observation function.\n    \"\"\"\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither","title":"<code>Dither</code>","text":"<p>         Bases: <code>BaseObservation</code></p> <p>Observation class designed to apply a series of dithers to the instrument and return the corresponding PSFs.</p> <p>Attributes:</p> Name Type Description <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> Source code in <code>dLux/observations.py</code> <pre><code>class Dither(BaseObservation):\n\"\"\"\n    Observation class designed to apply a series of dithers to the instrument\n    and return the corresponding PSFs.\n\n    Attributes\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2) where ndithers is the number of dithers\n        and the second dimension is the (x, y) dither in radians.\n    \"\"\"\n    dithers: Array\n\n    def __init__(self: Dither, dithers: Array):\n\"\"\"\n        Constructor for the Dither class.\n\n        Parameters\n        ----------\n        dithers : Array, (radians)\n            The array of dithers to apply to the source positions. The shape of\n            the array should be (ndithers, 2) where ndithers is the number of\n            dithers and the second dimension is the (x, y) dither in radians.\n        \"\"\"\n        super().__init__()\n        self.dithers = np.asarray(dithers, float)\n        if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:\n            raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")\n\n    def dither_position(self: Dither,\n                        instrument: Instrument,\n                        dither: Array) -&gt; Instrument:\n\"\"\"\n        Dithers the position of the source objects by dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The instrument to dither.\n        dither : Array, radians\n            The (x, y) dither to apply to the source positions.\n\n        Returns\n        -------\n        instrument : Instrument\n            The instrument with the sources dithered.\n        \"\"\"\n        # Define the dither function\n        dither_fn = lambda source: source.add('position', dither)\n\n        # Map the dithers across the sources\n        dithered_sources = tree_map(dither_fn, instrument.sources, \\\n                                    is_leaf=lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n        # Apply updates\n        return tree_at(lambda instrument: instrument.sources, instrument,\n                       dithered_sources)\n\n    def model(self: Dither,\n              instrument: Instrument,\n              *args, **kwargs) -&gt; Array:\n\"\"\"\n        Applies a series of dithers to the instrument sources and calls the\n        .model() method after applying each dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The array of dithers to apply to the source positions.\n\n        Returns\n        -------\n        psfs : Array\n            The psfs generated after applying the dithers to the source\n            positions.\n        \"\"\"\n        dith_fn = lambda dither: self.dither_position(instrument,\n                                                      dither).model(*args, **kwargs)\n        return vmap(dith_fn, 0)(self.dithers)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.__init__","title":"<code>__init__(dithers)</code>","text":"<p>Constructor for the Dither class.</p> <p>Parameters:</p> Name Type Description Default <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> required Source code in <code>dLux/observations.py</code> <pre><code>def __init__(self: Dither, dithers: Array):\n\"\"\"\n    Constructor for the Dither class.\n\n    Parameters\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of\n        the array should be (ndithers, 2) where ndithers is the number of\n        dithers and the second dimension is the (x, y) dither in radians.\n    \"\"\"\n    super().__init__()\n    self.dithers = np.asarray(dithers, float)\n    if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:\n        raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.dither_position","title":"<code>dither_position(instrument, dither)</code>","text":"<p>Dithers the position of the source objects by dither.</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>Instrument</code> <p>The instrument to dither.</p> required <code>dither</code> <code>Array, radians</code> <p>The (x, y) dither to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>instrument</code> <code>Instrument</code> <p>The instrument with the sources dithered.</p> Source code in <code>dLux/observations.py</code> <pre><code>def dither_position(self: Dither,\n                    instrument: Instrument,\n                    dither: Array) -&gt; Instrument:\n\"\"\"\n    Dithers the position of the source objects by dither.\n\n    Parameters\n    ----------\n    instrument : Instrument\n        The instrument to dither.\n    dither : Array, radians\n        The (x, y) dither to apply to the source positions.\n\n    Returns\n    -------\n    instrument : Instrument\n        The instrument with the sources dithered.\n    \"\"\"\n    # Define the dither function\n    dither_fn = lambda source: source.add('position', dither)\n\n    # Map the dithers across the sources\n    dithered_sources = tree_map(dither_fn, instrument.sources, \\\n                                is_leaf=lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n    # Apply updates\n    return tree_at(lambda instrument: instrument.sources, instrument,\n                   dithered_sources)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.model","title":"<code>model(instrument, *args, **kwargs)</code>","text":"<p>Applies a series of dithers to the instrument sources and calls the .model() method after applying each dither.</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>Instrument</code> <p>The array of dithers to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>psfs</code> <code>Array</code> <p>The psfs generated after applying the dithers to the source positions.</p> Source code in <code>dLux/observations.py</code> <pre><code>def model(self: Dither,\n          instrument: Instrument,\n          *args, **kwargs) -&gt; Array:\n\"\"\"\n    Applies a series of dithers to the instrument sources and calls the\n    .model() method after applying each dither.\n\n    Parameters\n    ----------\n    instrument : Instrument\n        The array of dithers to apply to the source positions.\n\n    Returns\n    -------\n    psfs : Array\n        The psfs generated after applying the dithers to the source\n        positions.\n    \"\"\"\n    dith_fn = lambda dither: self.dither_position(instrument,\n                                                  dither).model(*args, **kwargs)\n    return vmap(dith_fn, 0)(self.dithers)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.BaseObservation","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.BaseObservation.model","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.__init__","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.dither_position","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.model","title":"Observations","text":""},{"location":"docs/API/optical_layers/","title":"Optical Layers: <code>optical_layers.py</code>","text":"<p>This module contains the classes that define the behaviour of OpticalLayers in \u2202Lux.</p> <p>These classes provide a simple set of classes used to perform basic transformations on wavefronts.</p> <p>There are seven public classes:</p> <ul> <li><code>Optic</code></li> <li><code>PhaseOptic</code></li> <li><code>BasisOptic</code></li> <li><code>PhaseBasisOptic</code></li> <li><code>Tilt</code></li> <li><code>Normalise</code></li> <li><code>Rotate</code></li> </ul> <p>The optic classes (<code>Optic</code>, <code>PhaseOptic</code>, <code>BasisOptic</code>, <code>PhaseBasisOptic</code>) are quite general and are used to perform basic modifications to the wavefront amplitude and phase. They all have <code>transmission</code> and <code>normalise</code> attributes that modify the amplitude of the wavefront. It is optional to normalise the wavefront after it passes through the optic.</p> <p>The <code>Optic</code> class holds a static OPD array that is added to the wavefront. The <code>PhaseOptic</code> class holds a static phase array that is added to the wavefront.</p> Optics API <p>         Bases: <code>BaseTransmissiveOptic</code>, <code>BaseOPDOptic</code></p> <p>Optics class that holds both a transmission and OPD array.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>opd</code> <code>Array, metres</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class Optic(BaseTransmissiveOptic, BaseOPDOptic):\n\"\"\"\n    Optics class that holds both a transmission and OPD array.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    opd : Array, metres\n        The Array of OPD values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n\n    def __init__(self: OpticalLayer,\n                 transmission: Array = None,\n                 opd: Array = None,\n                 normalise: bool = False):\n\"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The Array of transmission values to be applied to the input\n            wavefront.\n        opd : Array, metres = None\n            The Array of OPD values to be applied to the input wavefront.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the\n            optic.\n        \"\"\"\n        super().__init__(transmission=transmission, opd=opd,\n                         normalise=normalise)\n\n        if self.opd is not None and self.transmission is not None:\n            if opd.shape != self.transmission.shape:\n                raise ValueError(\"opd and transmission must have the same \"\n                                 \"shape.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront += self.opd\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> PhaseOptic API <p>         Bases: <code>BaseTransmissiveOptic</code>, <code>BasePhaseOptic</code></p> <p>Optics class that holds both a transmission and phase array.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>phase</code> <code>Array, radians</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class PhaseOptic(BaseTransmissiveOptic, BasePhaseOptic):\n\"\"\"\n    Optics class that holds both a transmission and phase array.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    phase : Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n\n    def __init__(self: OpticalLayer,\n                 transmission: Array = None,\n                 phase: Array = None,\n                 normalise: bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The Array of transmission values to be applied to the input\n            wavefront.\n        phase : Array, radians = None\n            The Array of phase values to be applied to the input wavefront.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the\n            optic.\n        \"\"\"\n        super().__init__(transmission=transmission, phase=phase,\n                         normalise=normalise)\n\n        if self.phase is not None and self.transmission is not None:\n            if phase.shape != self.transmission.shape:\n                raise ValueError(\"phase and transmission must have the same \"\n                                 \"shape.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront = wavefront.add_phase(self.phase)\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> <p>The <code>BasisOptic</code> class holds a set of basis vectors and coefficients that are used to calculate the OPD array that is added to the wavefront. The <code>PhaseBasisOptic</code> class holds a set of basis vectors and coefficients that are used to calculate the phase array that is added to the wavefront.</p> BasisOptic API <p>         Bases: <code>BaseBasisOptic</code></p> <p>Adds an array of phase values to the input wavefront calculated from the Optical Path Difference (OPD). The OPDs are calculated from the basis arrays, and weighted by the coefficients, and converted to phases by the wavefront methods.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>basis</code> <code>Array, metres</code> <p>Arrays holding the pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class BasisOptic(BaseBasisOptic):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n\n    @property\n    def opd(self: OpticalLayer) -&gt; Array:\n\"\"\"\n        Calculates the total opd from the basis vectors and coefficients.\n\n        Returns\n        -------\n        opd : Array, metres\n            The total opd.\n        \"\"\"\n        return self.calculate(self.basis, self.coefficients)\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront += self.opd\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> PhaseBasisOptic API <p>         Bases: <code>BaseBasisOptic</code></p> <p>Adds an array of phase values to the input wavefront calculated from the Optical Path Difference (OPD). The OPDs are calculated from the basis arrays, and weighted by the coefficients, and converted to phases by the wavefront methods.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>basis</code> <code>Array, metres</code> <p>Arrays holding the pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class PhaseBasisOptic(BaseBasisOptic):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n\n    @property\n    def phase(self: OpticalLayer) -&gt; Array:\n\"\"\"\n        Calculates the total phase from the basis vectors and coefficients.\n\n        Returns\n        -------\n        phase : Array, radians\n            The total phase.\n        \"\"\"\n        return self.calculate(self.basis, self.coefficients)\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront = wavefront.add_phase(self.phase)\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> <p>The <code>Tilt</code> class tilts the wavefront by the input angles.</p> Tilt API <p>         Bases: <code>OpticalLayer</code></p> <p>Tilts the wavefront by the input angles.</p> <p>Attributes:</p> Name Type Description <code>angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class Tilt(OpticalLayer):\n\"\"\"\n    Tilts the wavefront by the input angles.\n\n    Attributes\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    \"\"\"\n    angles: Array\n\n    def __init__(self: OpticalLayer, angles: Array) -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TiltWavefront class.\n\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n        \"\"\"\n        super().__init__()\n        self.angles = np.asarray(angles, dtype=float)\n\n        if self.angles.shape != (2,):\n            raise ValueError(\"angles must have have (2,)\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.tilt(self.angles)\n</code></pre> <p>The <code>Normalise</code> class normalises the wavefront.</p> Normalise API <p>         Bases: <code>OpticalLayer</code></p> <p>Normalises the wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class Normalise(OpticalLayer):\n\"\"\"Normalises the wavefront.\"\"\"\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.normalise()\n</code></pre> <p>The <code>Rotate</code> class rotates the wavefront by the input angle.</p> Rotate API <p>         Bases: <code>OpticalLayer</code></p> <p>Applies a rotation to the wavefront using interpolation methods.</p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in the clockwise direction.</p> <code>order</code> <code>int = 1</code> <p>The order of the interpolation to use. Only applies if fourier is False. Must be 0, 1, or 3.</p> <code>complex</code> <code>bool = False</code> <p>Should the rotation be performed on the 'complex' (real, imaginary), as opposed to the default 'phasor' (amplitude, phase) arrays.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>class Rotate(OpticalLayer):\n\"\"\"\n    Applies a rotation to the wavefront using interpolation methods.\n\n    Attributes\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in the clockwise direction.\n    order : int = 1\n        The order of the interpolation to use. Only applies if fourier is\n        False. Must be 0, 1, or 3.\n    complex : bool = False\n        Should the rotation be performed on the 'complex' (real, imaginary),\n        as opposed to the default 'phasor' (amplitude, phase) arrays.\n    \"\"\"\n    angle: Array\n    order: int\n    complex: bool\n\n    def __init__(self: OpticalLayer,\n                 angle: Array,\n                 order: int = 1,\n                 complex: bool = False):\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the wavefront in the clockwise \n            direction.\n        order : int = 1\n            The order of the interpolation to use. Must be 0, or 1.\n        complex : bool = False\n            Should the rotation be performed on the 'complex' (real, imaginary),\n            as opposed to the default 'phasor' (amplitude, phase) arrays.\n        \"\"\"\n        super().__init__()\n        self.angle = np.asarray(angle, dtype=float)\n        self.order = int(order)\n        self.complex = bool(complex)\n\n        if self.order not in (0, 1):\n            raise ValueError(\"Order must be 0, 1\")\n        if self.angle.ndim != 0:\n            raise ValueError(f\"angle must be a zero-dimensional, has \"\n                             f\"{self.angle.ndim} dimensions.\")\n\n    def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.rotate(self.angle, self.order, self.complex)\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Optic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    wavefront += self.opd\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Optic.__init__","title":"<code>__init__(transmission=None, opd=None, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>None</code> <code>opd</code> <code>Array, metres = None</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>None</code> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> <code>False</code> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __init__(self: OpticalLayer,\n             transmission: Array = None,\n             opd: Array = None,\n             normalise: bool = False):\n\"\"\"\n    Parameters\n    ----------\n    transmission: Array = None\n        The Array of transmission values to be applied to the input\n        wavefront.\n    opd : Array, metres = None\n        The Array of OPD values to be applied to the input wavefront.\n    normalise: bool = False\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n    super().__init__(transmission=transmission, opd=opd,\n                     normalise=normalise)\n\n    if self.opd is not None and self.transmission is not None:\n        if opd.shape != self.transmission.shape:\n            raise ValueError(\"opd and transmission must have the same \"\n                             \"shape.\")\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Optic","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Optic.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Optic.__init__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseOptic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    wavefront = wavefront.add_phase(self.phase)\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseOptic.__init__","title":"<code>__init__(transmission=None, phase=None, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>None</code> <code>phase</code> <code>Array, radians = None</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>None</code> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> <code>False</code> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __init__(self: OpticalLayer,\n             transmission: Array = None,\n             phase: Array = None,\n             normalise: bool = False) -&gt; OpticalLayer:\n\"\"\"\n    Parameters\n    ----------\n    transmission: Array = None\n        The Array of transmission values to be applied to the input\n        wavefront.\n    phase : Array, radians = None\n        The Array of phase values to be applied to the input wavefront.\n    normalise: bool = False\n        Whether to normalise the wavefront after passing through the\n        optic.\n    \"\"\"\n    super().__init__(transmission=transmission, phase=phase,\n                     normalise=normalise)\n\n    if self.phase is not None and self.transmission is not None:\n        if phase.shape != self.transmission.shape:\n            raise ValueError(\"phase and transmission must have the same \"\n                             \"shape.\")\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseOptic","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseOptic.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseOptic.__init__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.BasisOptic.opd","title":"<code>opd: Array</code>  <code>property</code>","text":"<p>Calculates the total opd from the basis vectors and coefficients.</p> <p>Returns:</p> Name Type Description <code>opd</code> <code>Array, metres</code> <p>The total opd.</p>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.BasisOptic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    wavefront += self.opd\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.BasisOptic","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.BasisOptic.opd","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.BasisOptic.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseBasisOptic.phase","title":"<code>phase: Array</code>  <code>property</code>","text":"<p>Calculates the total phase from the basis vectors and coefficients.</p> <p>Returns:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The total phase.</p>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseBasisOptic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    wavefront = wavefront.add_phase(self.phase)\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseBasisOptic","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseBasisOptic.phase","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.PhaseBasisOptic.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Tilt.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.tilt(self.angles)\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Tilt.__init__","title":"<code>__init__(angles)</code>","text":"<p>Constructor for the TiltWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required Source code in <code>dLux/optical_layers.py</code> <pre><code>def __init__(self: OpticalLayer, angles: Array) -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the TiltWavefront class.\n\n    Parameters\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    \"\"\"\n    super().__init__()\n    self.angles = np.asarray(angles, dtype=float)\n\n    if self.angles.shape != (2,):\n        raise ValueError(\"angles must have have (2,)\")\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Tilt","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Tilt.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Tilt.__init__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Normalise.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.normalise()\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Normalise","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Normalise.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Rotate.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __call__(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.rotate(self.angle, self.order, self.complex)\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Rotate.__init__","title":"<code>__init__(angle, order=1, complex=False)</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the wavefront in the clockwise  direction.</p> required <code>order</code> <code>int = 1</code> <p>The order of the interpolation to use. Must be 0, or 1.</p> <code>1</code> <code>complex</code> <code>bool = False</code> <p>Should the rotation be performed on the 'complex' (real, imaginary), as opposed to the default 'phasor' (amplitude, phase) arrays.</p> <code>False</code> Source code in <code>dLux/optical_layers.py</code> <pre><code>def __init__(self: OpticalLayer,\n             angle: Array,\n             order: int = 1,\n             complex: bool = False):\n\"\"\"\n    Constructor for the Rotate class.\n\n    Parameters\n    ----------\n    angle: float, radians\n        The angle by which to rotate the wavefront in the clockwise \n        direction.\n    order : int = 1\n        The order of the interpolation to use. Must be 0, or 1.\n    complex : bool = False\n        Should the rotation be performed on the 'complex' (real, imaginary),\n        as opposed to the default 'phasor' (amplitude, phase) arrays.\n    \"\"\"\n    super().__init__()\n    self.angle = np.asarray(angle, dtype=float)\n    self.order = int(order)\n    self.complex = bool(complex)\n\n    if self.order not in (0, 1):\n        raise ValueError(\"Order must be 0, 1\")\n    if self.angle.ndim != 0:\n        raise ValueError(f\"angle must be a zero-dimensional, has \"\n                         f\"{self.angle.ndim} dimensions.\")\n</code></pre>"},{"location":"docs/API/optical_layers/#dLux.optical_layers.Rotate","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Rotate.__call__","title":"Optical Layers","text":""},{"location":"docs/API/optical_layers/#dLux.optical_layers.Rotate.__init__","title":"Optical Layers","text":""},{"location":"docs/API/optics/","title":"Optical Systems: <code>optics.py</code>","text":"<p>This module contains the classes that define the behaviour of optical systems in \u2202Lux. The classes are designed to be as flexible as possible, allowing users to easily create their own optical systems.</p> <p>There are four public classes:</p> <ul> <li><code>AngularOptics</code></li> <li><code>CartesianOptics</code></li> <li><code>FlexibleOptics</code></li> <li><code>LayeredOptics</code></li> </ul> <p>Optics classes store <code>OpticalLayers</code> that operate on <code>Wavefronts</code>.</p> <p>There are two types of optics classes: Layered and non-Layered. Layered optics classes take in a list of <code>OpticalLayers</code> and apply them sequentially to the wavefront, giving users full control and flexibility in the modelling of their optical system.</p> <p>Non-Layered optics classes are designed to be simple and easy to use, taking in few parameters that define the behaviour of a common optical system. We will explore these further in the Examples section below.</p> <p>All public optics classes have three main methods:</p> <ol> <li><code>model(sources)</code> Models \u2202Lux <code>Source</code> objects through the optics.</li> <li><code>propagate(wavelengths, offset, weights)</code> Models a polychromatic point source through the optics.</li> <li><code>propagate_mono(wavelength, offset)</code> Propagates a monochromatic point source through the optics.</li> </ol> <p>The <code>propagate_mono</code> method is where the actual wavefront propagation through the optics occurs, but <code>propagate</code> vectorises the calculations across wavelengths for efficiency.</p>"},{"location":"docs/API/optics/#examples","title":"Examples","text":"<p>We will start here with the non-layered optics classes as they are simpler.</p>"},{"location":"docs/API/optics/#angularoptics","title":"AngularOptics","text":"Angular Optics API <p>         Bases: <code>NonPropagatorOptics</code>, <code>AperturedOptics</code>, <code>SimpleOptics</code></p> <p>A simple optical system that propagates a wavefront to an image plane with <code>psf_pixel_scale</code> in units of arcseconds.</p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> <code>mask</code> <code>Union[Array, OpticalLayer]</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>psf_pixel_scale</code> <code>float</code> <p>The pixel scale of the final PSF.</p> <code>psf_oversample</code> <code>float</code> <p>The oversampling factor of the final PSF.</p> <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> Source code in <code>dLux/optics.py</code> <pre><code>class AngularOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    with `psf_pixel_scale` in units of arcseconds.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    psf_pixel_scale : float\n        The pixel scale of the final PSF.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    \"\"\"\n\n    def __init__(\n        self: AngularOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        psf_oversample: float = 1,\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, arcseconds\n            The pixel scale of the final PSF in units of arcseconds.\n        psf_oversample : float\n            The oversampling factor of the final PSF.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            psf_npixels=psf_npixels,\n            mask=mask,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n        )\n\n    def propagate_mono(\n        self: AngularOptics,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n\n        # Propagate\n        pixel_scale = self.psf_pixel_scale / self.psf_oversample\n        pixel_scale_radians = dlu.arcsec_to_rad(pixel_scale)\n        wf = wf.MFT(self.psf_npixels, pixel_scale_radians)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n</code></pre> <p>To construct an <code>AngularOptics</code> class we need to define five things:</p> <ol> <li>The number of pixels of the initial wavefront</li> <li>The diameter of the initial wavefront</li> <li>The aperture of the system</li> <li>The number of pixels of the final PSF</li> <li>The pixel scale of the final PSF</li> </ol> <p>Units</p> <p>Most code in \u2202Lux is written in SI units, but this class breaks from this convention, with <code>psf_pixel_scale</code> taken in units of arcseconds.</p> <p>Apertures</p> <p>The <code>aperture</code> parameter can also be supplied as an array, where it will treated as an array of transmission values!</p> <p>The following code snippet shows how to construct a simple angular optical system and propagate a point source through it.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('angular_psf.png')\n</code></pre> <p></p>"},{"location":"docs/API/optics/#dLux.optics.AngularOptics.__init__","title":"<code>__init__(wf_npixels, diameter, aperture, psf_npixels, psf_pixel_scale, psf_oversample=1, mask=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> required <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> required <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> required <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> required <code>psf_pixel_scale</code> <code>float, arcseconds</code> <p>The pixel scale of the final PSF in units of arcseconds.</p> required <code>psf_oversample</code> <code>float</code> <p>The oversampling factor of the final PSF.</p> <code>1</code> <code>mask</code> <code>Union[Array, OpticalLayer] = None</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>None</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(\n    self: AngularOptics,\n    wf_npixels: int,\n    diameter: float,\n    aperture: Union[Array, OpticalLayer()],\n    psf_npixels: int,\n    psf_pixel_scale: float,\n    psf_oversample: float = 1,\n    mask: Union[Array, OpticalLayer()] = None,\n):\n\"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, arcseconds\n        The pixel scale of the final PSF in units of arcseconds.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    mask : Union[Array, OpticalLayer] = None\n        The mask to apply to the wavefront. Can be an Array or an\n        OpticalLayer. If an Array it is treated as a transmissive mask.\n    \"\"\"\n    super().__init__(\n        wf_npixels=wf_npixels,\n        diameter=diameter,\n        aperture=aperture,\n        psf_npixels=psf_npixels,\n        mask=mask,\n        psf_pixel_scale=psf_pixel_scale,\n        psf_oversample=psf_oversample,\n    )\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AngularOptics.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians, = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>return_wf</code> <code>bool, = False</code> <p>If True, the wavefront object after propagation is returned.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> <code>wavefront</code> <code>Wavefront</code> <p>The wavefront object after propagation. Only returned if return_wf is True.</p> Source code in <code>dLux/optics.py</code> <pre><code>def propagate_mono(\n    self: AngularOptics,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n\"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians, = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    return_wf : bool, = False\n        If True, the wavefront object after propagation is returned.\n\n    Returns\n    -------\n    psf : Array\n        The monochromatic point spread function after being propagated\n        though the optical layers.\n    wavefront : Wavefront\n        The wavefront object after propagation. Only returned if\n        return_wf is True.\n    \"\"\"\n    wf = self._apply_aperture(wavelength, offset)\n\n    # Propagate\n    pixel_scale = self.psf_pixel_scale / self.psf_oversample\n    pixel_scale_radians = dlu.arcsec_to_rad(pixel_scale)\n    wf = wf.MFT(self.psf_npixels, pixel_scale_radians)\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wf\n    return wf.psf\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AngularOptics","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AngularOptics.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AngularOptics.propagate_mono","title":"Optics","text":""},{"location":"docs/API/optics/#cartesianoptics","title":"CartesianOptics","text":"<p>The <code>CartesianOptics</code> class is very similar to the <code>AngularOptics</code> class, but it also takes in a focal length, and the units of <code>psf_pixel_scale</code> are microns.</p> Cartesian Optics API <p>         Bases: <code>NonPropagatorOptics</code>, <code>AperturedOptics</code>, <code>SimpleOptics</code></p> <p>A simple optical system that propagates a wavefront to an image plane with <code>psf_pixel_scale</code> in units of microns.</p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> <code>focal_length</code> <code>float, metres</code> <p>The focal length of the optical system.</p> <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> <code>mask</code> <code>Union[Array, OpticalLayer]</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>psf_pixel_scale</code> <code>float, microns</code> <p>The pixel scale of the final PSF.</p> <code>psf_oversample</code> <code>float</code> <p>The oversampling factor of the final PSF.</p> <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> Source code in <code>dLux/optics.py</code> <pre><code>class CartesianOptics(NonPropagatorOptics, AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    with `psf_pixel_scale` in units of microns.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    focal_length : float, metres\n        The focal length of the optical system.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    psf_pixel_scale : float, microns\n        The pixel scale of the final PSF.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    \"\"\"\n\n    focal_length: None\n\n    def __init__(\n        self: CartesianOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        focal_length: float,\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        psf_oversample: int = 1,\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        focal_length : float, metres\n            The focal length of the optical system.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, microns\n            The pixel scale of the final PSF in units of microns.\n        psf_oversample : float\n            The oversampling factor of the final PSF.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        self.focal_length = float(focal_length)\n\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n            mask=mask,\n        )\n\n    def propagate_mono(\n        self: SimpleToliman,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n\n        # Propagate\n        pixel_scale = 1e-6 * self.psf_pixel_scale / self.psf_oversample\n        wf = wf.MFT(self.psf_npixels, pixel_scale, focal_length=self.focal_length)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n</code></pre> <p>The following code snippet shows how to construct a simple Cartesian optical system and propagate a point source through it.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 1 # microns\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.CartesianOptics(wf_npixels, diameter, aperture, focal_length,\n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('cartesian_psf.png')\n</code></pre> <p></p>"},{"location":"docs/API/optics/#dLux.optics.CartesianOptics.__init__","title":"<code>__init__(wf_npixels, diameter, aperture, focal_length, psf_npixels, psf_pixel_scale, psf_oversample=1, mask=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> required <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> required <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> required <code>focal_length</code> <code>float, metres</code> <p>The focal length of the optical system.</p> required <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> required <code>psf_pixel_scale</code> <code>float, microns</code> <p>The pixel scale of the final PSF in units of microns.</p> required <code>psf_oversample</code> <code>float</code> <p>The oversampling factor of the final PSF.</p> <code>1</code> <code>mask</code> <code>Union[Array, OpticalLayer] = None</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>None</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(\n    self: CartesianOptics,\n    wf_npixels: int,\n    diameter: float,\n    aperture: Union[Array, OpticalLayer()],\n    focal_length: float,\n    psf_npixels: int,\n    psf_pixel_scale: float,\n    psf_oversample: int = 1,\n    mask: Union[Array, OpticalLayer()] = None,\n):\n\"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    focal_length : float, metres\n        The focal length of the optical system.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, microns\n        The pixel scale of the final PSF in units of microns.\n    psf_oversample : float\n        The oversampling factor of the final PSF.\n    mask : Union[Array, OpticalLayer] = None\n        The mask to apply to the wavefront. Can be an Array or an\n        OpticalLayer. If an Array it is treated as a transmissive mask.\n    \"\"\"\n    self.focal_length = float(focal_length)\n\n    super().__init__(\n        wf_npixels=wf_npixels,\n        diameter=diameter,\n        aperture=aperture,\n        psf_npixels=psf_npixels,\n        psf_pixel_scale=psf_pixel_scale,\n        psf_oversample=psf_oversample,\n        mask=mask,\n    )\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CartesianOptics.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians, = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>return_wf</code> <code>bool, = False</code> <p>If True, the wavefront object after propagation is returned.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> <code>wavefront</code> <code>Wavefront</code> <p>The wavefront object after propagation. Only returned if return_wf is True.</p> Source code in <code>dLux/optics.py</code> <pre><code>def propagate_mono(\n    self: SimpleToliman,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n\"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians, = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    return_wf : bool, = False\n        If True, the wavefront object after propagation is returned.\n\n    Returns\n    -------\n    psf : Array\n        The monochromatic point spread function after being propagated\n        though the optical layers.\n    wavefront : Wavefront\n        The wavefront object after propagation. Only returned if\n        return_wf is True.\n    \"\"\"\n    wf = self._apply_aperture(wavelength, offset)\n\n    # Propagate\n    pixel_scale = 1e-6 * self.psf_pixel_scale / self.psf_oversample\n    wf = wf.MFT(self.psf_npixels, pixel_scale, focal_length=self.focal_length)\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wf\n    return wf.psf\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CartesianOptics","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.CartesianOptics.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.CartesianOptics.propagate_mono","title":"Optics","text":""},{"location":"docs/API/optics/#flexibleoptics","title":"FlexibleOptics","text":"<p>The <code>FlexibleOptics</code> class allows for the use of any <code>Propagator</code> class in \u2202Lux. Let's have a look at how we can use this propagator to model a PSF with a Fresnel defocus.</p> Flexible Optics API <p>         Bases: <code>AperturedOptics</code>, <code>SimpleOptics</code></p> <p>A simple optical system that propagates a wavefront to an image plane using the user-supplied propagator. This allows for propagation of fresnel wavefronts.</p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> <code>mask</code> <code>Union[Array, OpticalLayer]</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>propagator</code> <code>Propagator</code> <p>The propagator to use to propagate the wavefront through the optics.</p> Source code in <code>dLux/optics.py</code> <pre><code>class FlexibleOptics(AperturedOptics, SimpleOptics):\n\"\"\"\n    A simple optical system that propagates a wavefront to an image plane\n    using the user-supplied propagator. This allows for propagation of fresnel\n    wavefronts.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    mask : Union[Array, OpticalLayer]\n        The mask to apply to the wavefront. Can be an Array or an OpticalLayer.\n        If an Array it is treated as a transmissive mask.\n    propagator : Propagator\n        The propagator to use to propagate the wavefront through the optics.\n    \"\"\"\n\n    propagator: None\n\n    def __init__(\n        self: BaseOptics,\n        wf_npixels: int,\n        diameter: float,\n        aperture: Union[Array, OpticalLayer()],\n        propagator: Propagator(),\n        mask: Union[Array, OpticalLayer()] = None,\n    ):\n\"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        aperture : Union[Array, OpticalLayer]\n            The aperture of the system. Can be an Array or a OpticalLayer.\n        propagator : Propagator\n            The propagator to use to propagate the wavefront through the optics.\n        mask : Union[Array, OpticalLayer] = None\n            The mask to apply to the wavefront. Can be an Array or an\n            OpticalLayer. If an Array it is treated as a transmissive mask.\n        \"\"\"\n        if not isinstance(propagator, Propagator()):\n            raise TypeError(\n                \"propagator must be a Propagator object, \" f\"got {type(propagator)}.\"\n            )\n        self.propagator = propagator\n        super().__init__(\n            wf_npixels=wf_npixels, diameter=diameter, aperture=aperture, mask=mask\n        )\n\n    @property\n    def true_pixel_scale(self):\n\"\"\"\n        Returns the true pixel scale of the PSF.\n        \"\"\"\n        return self.propagator.pixel_scale\n\n    def _construct_wavefront(\n        self: BaseOptics, wavelength: Array, offset: Array = np.zeros(2)\n    ) -&gt; Array:\n\"\"\"\n        Constructs the appropriate tilted wavefront object for the optical\n        system.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optics.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront object to propagate through the optics.\n        \"\"\"\n        if isinstance(self.propagator, dLux.propagators.FarFieldFresnel):\n            wf = dLux.FresnelWavefront(self.wf_npixels, self.diameter, wavelength)\n        else:\n            wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n        return wf.tilt(offset)\n\n    def propagate_mono(\n        self: SimpleToliman,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wf = self._apply_aperture(wavelength, offset)\n        wf = self.propagator(wf)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n</code></pre> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\nfocal_shift = 2e-5 # metres\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct a Fresnel Propagator\npropagator = dl.FarFieldFresnel(psf_npixels, psf_pixel_scale, focal_length,\n    focal_shift)\n\n# Construct the optics class\noptics = dl.FlexibleOptics(wf_npixels, diameter, aperture, propagator)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('fresnel_psf.png')\n</code></pre> <p></p>"},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.true_pixel_scale","title":"<code>true_pixel_scale</code>  <code>property</code>","text":"<p>Returns the true pixel scale of the PSF.</p>"},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.__init__","title":"<code>__init__(wf_npixels, diameter, aperture, propagator, mask=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> required <code>diameter</code> <code>Array, metres</code> <p>The diameter of the initial wavefront to propagate.</p> required <code>aperture</code> <code>Union[Array, OpticalLayer]</code> <p>The aperture of the system. Can be an Array or a OpticalLayer.</p> required <code>propagator</code> <code>Propagator</code> <p>The propagator to use to propagate the wavefront through the optics.</p> required <code>mask</code> <code>Union[Array, OpticalLayer] = None</code> <p>The mask to apply to the wavefront. Can be an Array or an OpticalLayer. If an Array it is treated as a transmissive mask.</p> <code>None</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(\n    self: BaseOptics,\n    wf_npixels: int,\n    diameter: float,\n    aperture: Union[Array, OpticalLayer()],\n    propagator: Propagator(),\n    mask: Union[Array, OpticalLayer()] = None,\n):\n\"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    aperture : Union[Array, OpticalLayer]\n        The aperture of the system. Can be an Array or a OpticalLayer.\n    propagator : Propagator\n        The propagator to use to propagate the wavefront through the optics.\n    mask : Union[Array, OpticalLayer] = None\n        The mask to apply to the wavefront. Can be an Array or an\n        OpticalLayer. If an Array it is treated as a transmissive mask.\n    \"\"\"\n    if not isinstance(propagator, Propagator()):\n        raise TypeError(\n            \"propagator must be a Propagator object, \" f\"got {type(propagator)}.\"\n        )\n    self.propagator = propagator\n    super().__init__(\n        wf_npixels=wf_npixels, diameter=diameter, aperture=aperture, mask=mask\n    )\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians, = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>return_wf</code> <code>bool, = False</code> <p>If True, the wavefront object after propagation is returned.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> <code>wavefront</code> <code>Wavefront</code> <p>The wavefront object after propagation. Only returned if return_wf is True.</p> Source code in <code>dLux/optics.py</code> <pre><code>def propagate_mono(\n    self: SimpleToliman,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n\"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians, = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    return_wf : bool, = False\n        If True, the wavefront object after propagation is returned.\n\n    Returns\n    -------\n    psf : Array\n        The monochromatic point spread function after being propagated\n        though the optical layers.\n    wavefront : Wavefront\n        The wavefront object after propagation. Only returned if\n        return_wf is True.\n    \"\"\"\n    wf = self._apply_aperture(wavelength, offset)\n    wf = self.propagator(wf)\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wf\n    return wf.psf\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.true_pixel_scale","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.FlexibleOptics.propagate_mono","title":"Optics","text":""},{"location":"docs/API/optics/#layeredoptics","title":"LayeredOptics","text":"<p>The <code>LayeredOptics</code> class allows us to define a list of <code>OpticalLayers</code> that operate on a wavefront. This allows us to model more complex optical systems than the previous classes, while also allowing users to define their own <code>OpticalLayers</code>! Look at the <code>OpticalLayers</code> documentation for more information.</p> Layered Optics API <p>         Bases: <code>SimpleOptics</code></p> <p>A fully flexible optical system that allows for the arbitrary chaining of dLux OpticalLayers.</p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The size of the initial wavefront to propagate.</p> <code>diameter</code> <code>Array</code> <p>The diameter of the wavefront to model through the system in metres.</p> <code>layers</code> <code>OrderedDict</code> <p>A collections.OrderedDict of 'layers' that define the transformations and operations upon some input wavefront through an optical system.</p> Source code in <code>dLux/optics.py</code> <pre><code>class LayeredOptics(SimpleOptics):\n\"\"\"\n    A fully flexible optical system that allows for the arbitrary chaining of\n    dLux OpticalLayers.\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The size of the initial wavefront to propagate.\n    diameter : Array\n        The diameter of the wavefront to model through the system in metres.\n    layers : OrderedDict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input wavefront through an optical system.\n    \"\"\"\n\n    layers: OrderedDict\n\n    def __init__(\n        self: Optics, wf_npixels: int, diameter: float, layers: list\n    ) -&gt; Optics:\n\"\"\"\n        Constructor for the Optics class.\n\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels to use when propagating the wavefront through\n            the optical system.\n        diameter : float\n            The diameter of the wavefront to model through the system in metres.\n        layers : list\n            A list of dLux 'layers' that define the transformations and\n            operations upon some input wavefront through an optical system.\n            The entries can either be dLux OpticalLayers, or tuples of the\n            form (OpticalLayer, key), with the key being used as the dictionary\n            key for the layer.\n        \"\"\"\n        super().__init__(wf_npixels=wf_npixels, diameter=diameter)\n        self.layers = dlu.list_to_dictionary(layers, True, OpticalLayer())\n\n    def __getattr__(self: Optics, key: str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        super().__getattr__(key)\n\n    @property\n    def true_pixel_scale(self):\n\"\"\"\n        Returns the true pixel scale of the PSF.\n        \"\"\"\n        # Note: This is a bit inefficient, but should work\n        for layer in self.layers.values():\n            if isinstance(layer, Propagator()):\n                propagator = layer\n        return propagator.pixel_scale\n\n    def propagate_mono(\n        self: BaseOptics,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        return_wf : bool, = False\n            If True, the wavefront object after propagation is returned.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        wavefront : Wavefront\n            The wavefront object after propagation. Only returned if\n            return_wf is True.\n        \"\"\"\n        wavefront = self._construct_wavefront(wavelength, offset)\n        for layer in list(self.layers.values()):\n            wavefront *= layer\n\n        if return_wf:\n            return wavefront\n        return wavefront.psf\n</code></pre> <p>Let's have a look at how we can use this class to model a simple optical system.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\n\n# Construct the list of optical layers\nlayers = [\n    (dl.ApertureFactory(wf_npixels), 'aperture'),\n    dl.MFT(psf_npixels, psf_pixel_scale, focal_length),\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> <p>Accessing Layers</p> <p>Note that we can pass in a tuple of the form (OpticalLayer, key) to the LayeredOptics class. OpticalLayers and transformed into an OrderedDict and this key is then used for that layer. This allows us to access the layers in the class via the <code>class.attribute</code> method, i.e. <code>optics.aperture</code>. This can be very helpful when using Zodiax methods!</p> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('layered_psf.png')\n</code></pre> <p></p>"},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.true_pixel_scale","title":"<code>true_pixel_scale</code>  <code>property</code>","text":"<p>Returns the true pixel scale of the PSF.</p>"},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the layers dictionary of this class via the 'class.attribute' method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __getattr__(self: Optics, key: str) -&gt; object:\n\"\"\"\n    Magic method designed to allow accessing of the various items within\n    the layers dictionary of this class via the 'class.attribute' method.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the layers dictionary.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the layers dictionary.\n    \"\"\"\n    if key in self.layers.keys():\n        return self.layers[key]\n    super().__getattr__(key)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.__init__","title":"<code>__init__(wf_npixels, diameter, layers)</code>","text":"<p>Constructor for the Optics class.</p> <p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels to use when propagating the wavefront through the optical system.</p> required <code>diameter</code> <code>float</code> <p>The diameter of the wavefront to model through the system in metres.</p> required <code>layers</code> <code>list</code> <p>A list of dLux 'layers' that define the transformations and operations upon some input wavefront through an optical system. The entries can either be dLux OpticalLayers, or tuples of the form (OpticalLayer, key), with the key being used as the dictionary key for the layer.</p> required Source code in <code>dLux/optics.py</code> <pre><code>def __init__(\n    self: Optics, wf_npixels: int, diameter: float, layers: list\n) -&gt; Optics:\n\"\"\"\n    Constructor for the Optics class.\n\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels to use when propagating the wavefront through\n        the optical system.\n    diameter : float\n        The diameter of the wavefront to model through the system in metres.\n    layers : list\n        A list of dLux 'layers' that define the transformations and\n        operations upon some input wavefront through an optical system.\n        The entries can either be dLux OpticalLayers, or tuples of the\n        form (OpticalLayer, key), with the key being used as the dictionary\n        key for the layer.\n    \"\"\"\n    super().__init__(wf_npixels=wf_npixels, diameter=diameter)\n    self.layers = dlu.list_to_dictionary(layers, True, OpticalLayer())\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians, = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>return_wf</code> <code>bool, = False</code> <p>If True, the wavefront object after propagation is returned.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> <code>wavefront</code> <code>Wavefront</code> <p>The wavefront object after propagation. Only returned if return_wf is True.</p> Source code in <code>dLux/optics.py</code> <pre><code>def propagate_mono(\n    self: BaseOptics,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n\"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians, = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    return_wf : bool, = False\n        If True, the wavefront object after propagation is returned.\n\n    Returns\n    -------\n    psf : Array\n        The monochromatic point spread function after being propagated\n        though the optical layers.\n    wavefront : Wavefront\n        The wavefront object after propagation. Only returned if\n        return_wf is True.\n    \"\"\"\n    wavefront = self._construct_wavefront(wavelength, offset)\n    for layer in list(self.layers.values()):\n        wavefront *= layer\n\n    if return_wf:\n        return wavefront\n    return wavefront.psf\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.LayeredOptics","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.true_pixel_scale","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.__getattr__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.LayeredOptics.propagate_mono","title":"Optics","text":""},{"location":"docs/API/optics/#building-your-own-optical-system","title":"Building your own Optical System","text":"<p>It can often be helpful to create your own Optical System class to provide a more complex optical models. For example, the dLuxJWST and dLuxToliman repos built by the \u2202Lux devs! \u2202Lux is designed to facilitate this, requiring users to only implement two methods in order to have a class that entirely integrates with the wider \u2202Lux ecosystem.</p> <p>Note: \u2202Lux is built in Zodiax. If you are unfamiliar, you should read this tutorial before this example.</p> <p>Let's have a look at how we can create a simple optical system from the ground up, using a pixel scale in units of arcseconds and a transmissive mask. To do this, we need to implement both the <code>__init__</code> and <code>propagate_mono</code> methods. It will have six attributes: <code>wf_npixels</code>, <code>diameter</code>, <code>aperture</code>, <code>mask</code>, <code>psf_pixel_scale</code>, <code>psf_npixels</code>.</p> <pre><code>from jax import Array\nimport dLux.utils as dlu\nimport dLux\n\n# We must inherit from the base optics class, `BaseOptics`. This will integrate\n# our class with the rest of the dLux code.\nclass MyOptics(dLux.optics.BaseOptics):\n    wf_npixels      : int\n    diameter        : float\n    aperture        : Array\n    mask            : Array\n    psf_pixel_scale : float\n    psf_npixels     : int\n\n    def __init__(self, wf_npixes, diameter, aperture, mask, psf_npixels, \n        psf_pixel_scale):\n'''Constructs the class'''\n        self.wf_npixels = wf_npixels\n        self.diameter = diameter\n        self.aperture = aperture\n        self.mask = mask\n        self.psf_npixels = psf_npixels\n        self.psf_pixel_scale = psf_pixel_scale\n\n    # Our propagate_mono must have the expected behaviour of dLux optics,\n    # meaning it must take the same inputs (wavelength, offset, return_wf) and\n    # return the same outputs (psf).\n    def propagate_mono(self, wavelength, offset=np.zeros(2), return_wf=False):\n'''Propagates a monochromatic source'''\n\n        # Construct our wavefront\n        wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n\n        # Tilt the wavefront\n        wf = wf.tilt(offset)\n\n        # We can use the `self` keyword to access the class attributes\n        wf *= self.aperture\n\n        # Normalise the wavefront\n        wf = wf.normalise()\n\n        # Apply the mask as an array of OPDs\n        wf += self.mask\n\n        # Propagate the wavefront, casting the units of pixel scale to radians\n        pixel_scale = dlu.arcmin_to_rad(self.psf_pixel_scale)\n        wf = wf.MFT(self.psf_npixels, pixel_scale)\n\n        # Return the PSF\n        if return_wf:\n            return wf\n        else:\n            return wf.psf\n</code></pre> <p>Applying Optical Layers</p> <p>We can apply <code>OpticalLayer</code> and arrays to wavefronts using the <code>*=</code> operator. This is equivalent to <code>wf = layer(wf)</code>.</p> <p>Now we can use this optical system as per usual! This class will now be recognised by all \u2202Lux functions that take in an optics class, such as <code>Sources</code> and <code>Instruments</code>.</p> <pre><code>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 128\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 5e-4 # arcminutes\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Make a mask of random OPDs\nmask = 4.e-7 * jr.normal(jr.PRNGKey(0), (wf_npixels, wf_npixels))\n\n# Construct the optics class\noptics = MyOptics(wf_npixels, diameter, aperture, mask, psf_npixels, \n    psf_pixel_scale)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.savefig('my_optics_psf.png')\n</code></pre> <p></p>"},{"location":"docs/API/optics/#private-classes","title":"Private classes","text":"<p>To further facilitate the creation of custom optics classes, \u2202Lux provides a few base classes that can be used to build your own optics classes.</p> <p>The private classes are as follows:</p> <ul> <li><code>BaseOptics</code></li> <li><code>SimpleOptics</code></li> <li><code>NonPropagatorOptics</code></li> <li><code>AperturedOptics</code></li> </ul> <p>These classes are not intended to be used directly, but rather to be inherited from and extended. Let's look at them one by one.</p> <p>The <code>BaseOptics</code> class is the base class for all optics classes in \u2202Lux, so if you inherit from <code>SimpleOptics</code>,<code>NonPropagatorOptics</code>, or <code>AperturedOptics</code>, you will automatically inherit from <code>BaseOptics</code>. It implements the <code>model</code> and <code>propagate</code> methods, and defines the <code>propagate_mono</code> method as an abstract method. This means that any class that inherits from <code>BaseOptics</code> must implement a <code>propagate_mono</code> method with the same signature as the abstract method. This is the only requirement for a class to be recognised as an optics class by \u2202Lux.</p> <p>The <code>SimpleOptics</code> class adds the <code>wf_npixels</code> and <code>diameter</code> attributes, and adds a single method: <code>_construct_wavefront(wavelength, offset)</code>, which constructs a wavefront of the correct size and width and performs the initial tilt from the <code>offset</code> value.</p> <p>The <code>NonPropagatorOptics</code> class adds the <code>psf_npixels</code>, <code>psf_pixel_scale</code>, and <code>psf_oversample</code> attributes, along with a <code>true_pixel_scale</code>.</p> <p>The <code>AperturedOptics</code> class adds the <code>aperture</code> and <code>mask</code> attributes, along with an <code>_apply_aperture(wavelength, offset)</code> method that applies the aperture and mask to the wavefront, calling the <code>_construct_wavefront</code> method under the hood. Note that by default, the <code>mask</code> attribute is applied as a transmissive mask if it supplied as an array.</p>"},{"location":"docs/API/overview/","title":"Overview","text":"<p>\u2202Lux has two modules, <code>dLux</code> and <code>dLux.utils</code>. The <code>dLux</code> repo contains the core functionality of \u2202Lux, while <code>dLux.utils</code> contains various functions that are used throughout the package. </p> <p>\u2202Lux contains a few different sets of classes:</p>"},{"location":"docs/API/overview/#wavefront-objects-and-classes-that-modify-them","title":"<code>Wavefront</code> objects and classes that modify them","text":"<p>\u2202Lux, at its core, is a diffraction engine that models optical systems by performing transformations on wavefronts. There are three main types of classes: Wavefronts, Optical Layers and Optics. <code>Wavefront</code> objects (<code>wavefronts.py</code>) represent the state of some monochromatic wavefront. <code>OpticalLayer</code> classes perform transformations on <code>Wavefront</code> objects. Finally, <code>Optics</code> classes (<code>optics.py</code>) hold a series of Optical Layers in order to model an optical system.</p> <p>The <code>OpticalLayers</code> classes are split into four different scripts:</p> <ul> <li><code>optical_layers.py</code>, containing basic optics classes allowing for the modification of the amplitude, OPD and phase of wavefronts (plus tilts, rotations, etc.).</li> <li><code>apertures.py</code>, containing classes that model apertures dynamically. It is extensive and allows for the modelling of most apertures.</li> <li><code>aberrations.py</code>, containing classes that model aberrations dynamically.</li> <li><code>propagators.py</code>, containing classes that perform the wavefront propagation.</li> </ul>"},{"location":"docs/API/overview/#image-objects-and-classes-that-modify-them","title":"<code>Image</code> objects and classes that modify them","text":"<p>The <code>dLux</code> module also contains a series of <code>Image</code> classes (<code>images.py</code>), which represent and modify the state of some PSF as it is transformed through a detector. The structure of <code>Image</code> classes matches that of <code>Wavefront</code> classes; here, <code>DetectorLayer</code> classes (<code>detector_layers.py</code>) perform transformations on <code>Image</code> objects, and <code>Detector</code> classes (<code>detectors.py</code>) hold a series of Detector Layers in order to model some detector.</p>"},{"location":"docs/API/overview/#source-and-spectrum-objects","title":"<code>Source</code> and <code>Spectrum</code> objects","text":"<p>The <code>dLux</code> module also contains a series of classes that represent sources and their spectra. The <code>Source</code> classes (<code>sources.py</code>) represent some parametric source, while the <code>Spectrum</code> classes (<code>spectra.py</code>) represent the source's spectrum.</p>"},{"location":"docs/API/overview/#instrument-and-observation-objects","title":"<code>Instrument</code> and <code>Observation</code> objects","text":"<p>The <code>Instrument</code> class (<code>instruments.py</code>) is designed to coherently model the interaction between these aforementioned components.  The <code>Observation</code> classes (<code>observations.py</code>) allow for fine-grained control over the modelling of <code>Instrument</code> objects. An example of this is the modelling of dithering patterns, or observing a source with different instrumental filters.</p>"},{"location":"docs/API/propagators/","title":"Propagators: <code>propagators.py</code>","text":"<p>This module contains the classes that define the behaviour of propagator layers in \u2202Lux.</p> <p>These classes do not implement the propagation functionality themselves, but instead store the parameters of the propagation and call inbuilt methods of the <code>Wavefront</code> class; thus, its API is essentially a mirror of those methods.</p> <p>There are four public classes:</p> <ul> <li><code>MFT</code></li> <li><code>FFT</code></li> <li><code>ShiftedMFT</code></li> <li><code>FarFieldFresnel</code></li> </ul>"},{"location":"docs/API/propagators/#mftnpixels-pixel_scale-focal_lengthnone-inversefalse","title":"<code>MFT(npixels, pixel_scale, focal_length=None, inverse=False)</code>","text":"<p>Performs a Matrix Fourier Transform (MFT) on the wavefront, propagating from Pupil to Focal plane. If <code>focal_length</code> is <code>None</code>, <code>pixel_scale</code> is assumed to be in angular units (radians), otherwise it is assumed to be in Cartesian units (metres).</p> MFT API <p>         Bases: <code>Propagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane that is defined in Cartesian units (ie metres/pixel).</p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>Array, metres/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in metres per pixel.</p> <code>focal_length</code> <code>Array, metres</code> <p>The effective focal length of the lens/mirror this propagator represents. If None, the pixel_scale is taken to be in radians/pixel, else it is taken to be in metres/pixel.</p> <code>inverse</code> <code>bool</code> <p>Should the propagation be performed in the inverse direction.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class MFT(Propagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in Cartesian units (ie metres/pixel).\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The effective focal length of the lens/mirror this propagator\n        represents. If None, the pixel_scale is taken to be in radians/pixel,\n        else it is taken to be in metres/pixel.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    npixels: int\n    pixel_scale: Array\n\n    def __init__(self: Propagator,\n                 npixels: int,\n                 pixel_scale: Array,\n                 focal_length: Array = None,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for VariableSampling propagators.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel or radians/pixel\n            The pixel scale in the output plane, measured in radians per pixel\n            if focal_length is None, else metres per pixel\n        focal_length : Array = None, metres\n            The focal_length of the lens/mirror this propagator represents.\n            If None, the pixel_scale is taken to be in radians/pixel, else it\n            is taken to be in metres/pixel.\n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        super().__init__(focal_length=focal_length, inverse=inverse)\n\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n        self.npixels = int(npixels)\n\n        if self.pixel_scale.ndim != 0:\n            raise TypeError('pixel_scale must be a scalar.')\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.IMFT(self.npixels, self.pixel_scale,\n                                  focal_length=self.focal_length)\n        else:\n            return wavefront.MFT(self.npixels, self.pixel_scale,\n                                 focal_length=self.focal_length)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.MFT.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    if self.inverse:\n        return wavefront.IMFT(self.npixels, self.pixel_scale,\n                              focal_length=self.focal_length)\n    else:\n        return wavefront.MFT(self.npixels, self.pixel_scale,\n                             focal_length=self.focal_length)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.MFT.__init__","title":"<code>__init__(npixels, pixel_scale, focal_length=None, inverse=False)</code>","text":"<p>Constructor for VariableSampling propagators.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>Array, metres/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in radians per pixel if focal_length is None, else metres per pixel</p> required <code>focal_length</code> <code>Array = None, metres</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the pixel_scale is taken to be in radians/pixel, else it is taken to be in metres/pixel.</p> <code>None</code> <code>inverse</code> <code>bool = False</code> <p>Should the propagation be performed in the inverse direction.</p> <code>False</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self: Propagator,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array = None,\n             inverse: bool = False):\n\"\"\"\n    Constructor for VariableSampling propagators.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in radians per pixel\n        if focal_length is None, else metres per pixel\n    focal_length : Array = None, metres\n        The focal_length of the lens/mirror this propagator represents.\n        If None, the pixel_scale is taken to be in radians/pixel, else it\n        is taken to be in metres/pixel.\n    inverse : bool = False\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    super().__init__(focal_length=focal_length, inverse=inverse)\n\n    self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n    self.npixels = int(npixels)\n\n    if self.pixel_scale.ndim != 0:\n        raise TypeError('pixel_scale must be a scalar.')\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.MFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.MFT.__call__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.MFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#fftpad-focal_lengthnone-inversefalse","title":"<code>FFT(pad, focal_length=None, inverse=False)</code>","text":"<p>Performs a Fast Fourier Transform (FFT) on the wavefront, propagating from Pupil to Focal plane. If <code>focal_length</code> is <code>None</code>, the output units will angular (radians), otherwise cartesian (metres).</p> FFT API <p>         Bases: <code>Propagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane using a Fast Fourier Transform.</p>"},{"location":"docs/API/propagators/#dLux.propagators.FFT--todo-update-padding-to-take-in-units-of-npixels-rather-than-factor","title":"TODO: Update padding to take in units of npixels, rather than factor.","text":"<p>Attributes:</p> Name Type Description <code>focal_length</code> <code>Array, metres</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>pad</code> <code>int</code> <p>The amount of padding to apply to the wavefront before propagating.</p> <code>inverse</code> <code>bool</code> <p>Should the propagation be performed in the inverse direction.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class FFT(Propagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transform.\n\n    # TODO: Update padding to take in units of npixels, rather than factor.\n\n    Attributes\n    ----------\n    focal_length : Array, metres\n        The focal_length of the lens/mirror this propagator represents.\n    pad : int\n        The amount of padding to apply to the wavefront before propagating.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    pad: int\n\n    def __init__(\n        self         : Propagator, \n        focal_length : Array = None,\n        pad          : int = 2,\n        inverse      : bool = False) -&gt; Propagator:\n        super().__init__(focal_length=focal_length, inverse=inverse)\n        self.pad = int(pad)\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.IFFT(self.pad, self.focal_length)\n        else:\n            return wavefront.FFT(self.pad, self.focal_length)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.FFT.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    if self.inverse:\n        return wavefront.IFFT(self.pad, self.focal_length)\n    else:\n        return wavefront.FFT(self.pad, self.focal_length)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.FFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.FFT--todo-update-padding-to-take-in-units-of-npixels-rather-than-factor","title":"TODO: Update padding to take in units of npixels, rather than factor.","text":""},{"location":"docs/API/propagators/#dLux.propagators.FFT.__call__","title":"Propagators","text":""},{"location":"docs/API/propagators/#shiftedmftnpixels-pixel_scale-shift-focal_lengthnone-pixeltrue-inversefalse","title":"<code>shiftedMFT(npixels, pixel_scale, shift, focal_length=None, pixel=True, inverse=False)</code>","text":"<p>Performs a Matrix Fourier Transform (MFT) on the wavefront, propagating from Pupil to Focal plane. If <code>focal_length</code> is <code>None</code>, <code>pixel_scale</code> is assumed to be in angular units (radians), otherwise it is assumed to be in Cartesian units (metres). The <code>shift</code> parameter is used to shift the center of the output plane, which is treated in units of pixels by default, otherwise it is treated in the units of <code>pixel_scale</code>.</p> Shifted MFT API <p>         Bases: <code>MFT</code></p> <p>A Propagator class designed to propagate a wavefront to a plane that is defined in Cartesian units (ie metres/pixel), with a variable output sampling in that plane.</p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>Array, metres/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in metres per pixel.</p> <code>focal_length</code> <code>Array, metres</code> <p>The effective focal length of the lens/mirror this propagator represents. If None, the pixel_scale is taken to be in radians/pixel, else it is taken to be in metres/pixel.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel</code> <code>bool</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane (ie radians if focal_length is None, else metres). </p> <code>inverse</code> <code>bool</code> <p>Should the propagation be performed in the inverse direction.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class ShiftedMFT(MFT):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in Cartesian units (ie metres/pixel), with a variable output\n    sampling in that plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The effective focal length of the lens/mirror this propagator\n        represents. If None, the pixel_scale is taken to be in radians/pixel,\n        else it is taken to be in metres/pixel.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        If True the shift value is assumed to be in units of pixels, else the\n        physical units of the output plane (ie radians if focal_length is None,\n        else metres). \n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    shift: Array\n    pixel: bool\n\n    def __init__(self: Propagator,\n                 npixels: int,\n                 pixel_scale: Array,\n                 shift: Array,\n                 focal_length: Array = None,\n                 pixel: bool = False,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for VariableSampling propagators.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel or radians/pixel\n            The pixel scale in the output plane, measured in metres or radians\n            per pixel for Cartesian or Angular Wavefront respectively.\n        shift : Array\n            The (x, y) shift to apply to the wavefront in the output plane.\n        focal_length : Array = None, metres\n            The effective focal_length of the lens/mirror this propagator\n            represents. If None, the pixel_scale is taken to be in \n            radians/pixel, else it is taken to be in metres/pixel.\n        pixel : bool = False\n            If True the shift value is assumed to be in units of pixels, else\n            the physical units of the output plane (ie radians if focal_length\n            is None, else metres). \n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        super().__init__(pixel_scale=pixel_scale, npixels=npixels,\n                         focal_length=focal_length, inverse=inverse)\n\n        self.shift = np.asarray(shift, dtype=float)\n        self.pixel = bool(pixel)\n\n        if self.shift.shape != (2,):\n            raise TypeError('shift must be an array of shape (2,).')\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        if self.inverse:\n            return wavefront.shifted_IMFT(self.npixels, self.pixel_scale,\n                                          self.shift, self.focal_length, self.pixel)\n        else:\n            return wavefront.shifted_MFT(self.npixels, self.pixel_scale,\n                                         self.shift, self.focal_length, self.pixel)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.ShiftedMFT.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    if self.inverse:\n        return wavefront.shifted_IMFT(self.npixels, self.pixel_scale,\n                                      self.shift, self.focal_length, self.pixel)\n    else:\n        return wavefront.shifted_MFT(self.npixels, self.pixel_scale,\n                                     self.shift, self.focal_length, self.pixel)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.ShiftedMFT.__init__","title":"<code>__init__(npixels, pixel_scale, shift, focal_length=None, pixel=False, inverse=False)</code>","text":"<p>Constructor for VariableSampling propagators.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>Array, metres/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in metres or radians per pixel for Cartesian or Angular Wavefront respectively.</p> required <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> required <code>focal_length</code> <code>Array = None, metres</code> <p>The effective focal_length of the lens/mirror this propagator represents. If None, the pixel_scale is taken to be in  radians/pixel, else it is taken to be in metres/pixel.</p> <code>None</code> <code>pixel</code> <code>bool = False</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane (ie radians if focal_length is None, else metres).</p> <code>False</code> <code>inverse</code> <code>bool = False</code> <p>Should the propagation be performed in the inverse direction.</p> <code>False</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self: Propagator,\n             npixels: int,\n             pixel_scale: Array,\n             shift: Array,\n             focal_length: Array = None,\n             pixel: bool = False,\n             inverse: bool = False):\n\"\"\"\n    Constructor for VariableSampling propagators.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The pixel scale in the output plane, measured in metres or radians\n        per pixel for Cartesian or Angular Wavefront respectively.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    focal_length : Array = None, metres\n        The effective focal_length of the lens/mirror this propagator\n        represents. If None, the pixel_scale is taken to be in \n        radians/pixel, else it is taken to be in metres/pixel.\n    pixel : bool = False\n        If True the shift value is assumed to be in units of pixels, else\n        the physical units of the output plane (ie radians if focal_length\n        is None, else metres). \n    inverse : bool = False\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    super().__init__(pixel_scale=pixel_scale, npixels=npixels,\n                     focal_length=focal_length, inverse=inverse)\n\n    self.shift = np.asarray(shift, dtype=float)\n    self.pixel = bool(pixel)\n\n    if self.shift.shape != (2,):\n        raise TypeError('shift must be an array of shape (2,).')\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.ShiftedMFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.ShiftedMFT.__call__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.ShiftedMFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#farfieldfresnelnpixels-pixel_scale-focal_length-focal_shift-shift-pixeltrue","title":"<code>FarFieldFresnel(npixels, pixel_scale, focal_length, focal_shift, shift, pixel=True)</code>","text":"<p>Performs a Fresnel propagation on the wavefront, propagating from Pupil to Focal plane. The <code>focal_shift</code> parameter represents the distance from the focal plane at which the PSF is modelled. The <code>shift</code> parameter is used to shift the center of the output plane, which is treated in units of pixels by default, otherwise it is treated in the units of <code>pixel_scale</code>.</p> Far Field Fresnel API <p>         Bases: <code>ShiftedMFT</code></p> <p>A propagator class to for Far-Field fresnel propagations. This classes implements algorithms that use quadratic phase factors to better represent out-of-plane behaviour of wavefronts, close to the focal plane. This class is designed to work on Cartesian wavefronts, i.e. pixel units are in metres/pixel in the output plane.</p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>Array, metres/pixel</code> <p>The pixel scale in the output plane, measured in metres per pixel.</p> <code>focal_length</code> <code>Array, metres</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>focal_shift</code> <code>Array, metres</code> <p>The shift in the propagation distance of the wavefront.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or metres, radians). True interprets the shift value in pixel units.</p> <code>inverse</code> <code>bool</code> <p>Should the propagation be performed in the inverse direction.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class FarFieldFresnel(ShiftedMFT):\n\"\"\"\n    A propagator class to for Far-Field fresnel propagations. This classes\n    implements algorithms that use quadratic phase factors to better represent\n    out-of-plane behaviour of wavefronts, close to the focal plane. This class\n    is designed to work on Cartesian wavefronts, i.e. pixel units are in\n    metres/pixel in the output plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The focal_length of the lens/mirror this propagator represents.\n    focal_shift : Array, metres\n        The shift in the propagation distance of the wavefront.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or metres, radians). True\n        interprets the shift value in pixel units.\n    inverse : bool\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    focal_shift: Array\n\n    def __init__(self: Propagator,\n                 npixels: Array,\n                 pixel_scale: Array,\n                 focal_length: Array,\n                 focal_shift: Array,\n                 shift: Array = np.zeros(2),\n                 pixel: bool = False,\n                 inverse: bool = False):\n\"\"\"\n        Constructor for the CartesianFresnel propagator\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The pixel scale in the output plane, measured in metres per pixel.\n        focal_length : Array, metres\n            The focal_length of the lens/mirror this propagator represents.\n        focal_shift : Array, metres\n            The shift in the propagation distance of the wavefront.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or metres, radians).\n        inverse : bool = False\n            Should the propagation be performed in the inverse direction.\n        \"\"\"\n        if inverse:\n            raise NotImplementedError('Inverse propagation not implemented '\n                                      'for CartesianFresnel.')\n\n        self.focal_shift = np.asarray(focal_shift, dtype=float)\n        if self.focal_shift.ndim != 0:\n            raise TypeError('focal_shift must be a scalar.')\n\n        super().__init__(shift=shift, pixel=pixel, focal_length=focal_length,\n                         pixel_scale=pixel_scale, npixels=npixels, inverse=inverse)\n\n    def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.shifted_fresnel_prop(self.npixels, self.pixel_scale,\n                                              self.shift, self.focal_length, self.focal_shift, self.pixel)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.FarFieldFresnel.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def __call__(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.shifted_fresnel_prop(self.npixels, self.pixel_scale,\n                                          self.shift, self.focal_length, self.focal_shift, self.pixel)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.FarFieldFresnel.__init__","title":"<code>__init__(npixels, pixel_scale, focal_length, focal_shift, shift=np.zeros(2), pixel=False, inverse=False)</code>","text":"<p>Constructor for the CartesianFresnel propagator</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>Array, metres/pixel</code> <p>The pixel scale in the output plane, measured in metres per pixel.</p> required <code>focal_length</code> <code>Array, metres</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>focal_shift</code> <code>Array, metres</code> <p>The shift in the propagation distance of the wavefront.</p> required <code>shift</code> <code>Array = np.array([0., 0.])</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.zeros(2)</code> <code>pixel</code> <code>bool = False</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or metres, radians).</p> <code>False</code> <code>inverse</code> <code>bool = False</code> <p>Should the propagation be performed in the inverse direction.</p> <code>False</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self: Propagator,\n             npixels: Array,\n             pixel_scale: Array,\n             focal_length: Array,\n             focal_shift: Array,\n             shift: Array = np.zeros(2),\n             pixel: bool = False,\n             inverse: bool = False):\n\"\"\"\n    Constructor for the CartesianFresnel propagator\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel\n        The pixel scale in the output plane, measured in metres per pixel.\n    focal_length : Array, metres\n        The focal_length of the lens/mirror this propagator represents.\n    focal_shift : Array, metres\n        The shift in the propagation distance of the wavefront.\n    shift : Array = np.array([0., 0.])\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool = False\n        Should the shift value be considered in units of pixel, or in the\n        physical units of the output plane (ie pixels or metres, radians).\n    inverse : bool = False\n        Should the propagation be performed in the inverse direction.\n    \"\"\"\n    if inverse:\n        raise NotImplementedError('Inverse propagation not implemented '\n                                  'for CartesianFresnel.')\n\n    self.focal_shift = np.asarray(focal_shift, dtype=float)\n    if self.focal_shift.ndim != 0:\n        raise TypeError('focal_shift must be a scalar.')\n\n    super().__init__(shift=shift, pixel=pixel, focal_length=focal_length,\n                     pixel_scale=pixel_scale, npixels=npixels, inverse=inverse)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.FarFieldFresnel","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.FarFieldFresnel.__call__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.FarFieldFresnel.__init__","title":"Propagators","text":""},{"location":"docs/API/sources/","title":"Source: <code>source.py</code>","text":"<p>This module contains the classes that define the behaviour of sources in \u2202Lux.</p> <p>There are five public classes:</p> <ul> <li><code>PointSource</code></li> <li><code>PointSources</code></li> <li><code>BinarySource</code></li> <li><code>ResolvedSource</code></li> <li><code>PointResolvedSource</code></li> </ul> <p>Source classes store <code>Spectrum</code> objects that define the spectral properties of the source. They also store the position of the source on the sky, and the flux of the source.</p> <p>All public classes have two main methods:</p> <ol> <li><code>normalise()</code> Returns a new source object with the relevant attributes normalised.</li> <li><code>model(optics)</code> Models the source through the optics.</li> </ol> PointSource <p>         Bases: <code>Source</code></p> <p>Concrete Class for unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointSource(Source):\n\"\"\"\n    Concrete Class for unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n</code></pre> PointSources <p>         Bases: <code>Source</code></p> <p>Concrete Class for multiple unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky positions of these sources.</p> <code>flux</code> <code>Array, photons</code> <p>The fluxes of the sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointSources(Source):\n\"\"\"\n    Concrete Class for multiple unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky positions of these sources.\n    flux : Array, photons\n        The fluxes of the sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array,\n                 position: Array = np.zeros(2),\n                 flux: Array = None,\n                 weights: Array = None,\n                 spectrum: Spectrum = None):\n\"\"\"\n        Constructor for the PointSources class.\n\n        Parameters\n        ----------\n        position : Array, radians\n            The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.\n        flux : Array, photons = None\n            The fluxes of the sources.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n            Every source in this class will have an identical spectrum.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        super().__init__(spectrum=spectrum, wavelengths=wavelengths,\n                         weights=weights)\n\n        # More complex parameter checks here because of extra dims\n        self.position = np.asarray(position, dtype=float)\n        if self.position.ndim != 2:\n            raise ValueError(\"position must be a 2d array.\")\n\n        if flux is None:\n            self.flux = np.ones(len(self.position))\n        else:\n            self.flux = np.asarray(flux, dtype=float)\n\n            if self.flux.ndim != 1:\n                raise ValueError(\"flux must be a 1d array.\")\n\n            if len(self.flux) != len(self.position):\n                raise ValueError(\"Length of flux must be equal to length of \"\n                                 \"position.\")\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the source modelled through the optics.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights[None, :] * self.flux[:, None]\n        propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n        return propagator(self.wavelengths, self.position, weights).sum(0)\n</code></pre> BinarySource <p>         Bases: <code>RelativePositionSource</code>, <code>RelativeFluxSource</code></p> <p>A parameterised binary source.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the sources.</p> <code>separation</code> <code>Array, radians</code> <p>The separation of the two sources in radians.</p> <code>position_angle</code> <code>Array, radians</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the two sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class BinarySource(RelativePositionSource, RelativeFluxSource):\n\"\"\"\n    A parameterised binary source.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the sources.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a CombinedSpectrum object.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array = None,\n                 position: Array = np.array([0., 0.]),\n                 flux: Array = np.array(1.),\n                 separation: Array = None,\n                 position_angle: Array = np.pi / 2,\n                 contrast: Array = np.array(1.),\n                 spectrum: Spectrum = None,\n                 weights: Array = None):\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the sources.\n        separation : Array, radians = None\n            The separation of the two sources in radians.\n        position_angle : Array, radians = np.pi/2\n            The position angle between the two sources measured clockwise from\n            the vertical axis.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the two sources.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        wavelengths = np.asarray(wavelengths, dtype=float)\n        if weights is None:\n            weights = np.ones((2, len(wavelengths)))\n\n        super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                         separation=separation, position_angle=position_angle,\n                         contrast=contrast, spectrum=spectrum, weights=weights)\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the source modelled through the optics.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights * self.fluxes[:, None]\n        propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n        return propagator(self.wavelengths, self.positions, weights).sum(0)\n</code></pre> ResolvedSource <p>         Bases: <code>Source</code></p> <p>A class for modelling resolved sources that parametrise their resolved component using an array of intensities.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities representing the resolved source.</p> Source code in <code>dLux/sources.py</code> <pre><code>class ResolvedSource(Source):\n\"\"\"\n    A class for modelling resolved sources that parametrise their resolved\n    component using an array of intensities.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    \"\"\"\n    distribution: Array\n\n    def __init__(self: Source,\n                 wavelengths: Array,\n                 position: Array = np.zeros(2),\n                 flux: Array = np.array(1.),\n                 distribution: Array = np.ones((3, 3)),\n                 weights: Array = None,\n                 spectrum: Spectrum = None):\n\"\"\"\n        Constructor for the ResolvedSource class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        distribution = np.asarray(distribution, dtype=float)\n        self.distribution = distribution / distribution.sum()\n\n        if self.distribution.ndim != 2:\n            raise ValueError(\"distribution must be a 2d array.\")\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum,\n                         wavelengths=wavelengths, weights=weights)\n\n    def normalise(self: Source) -&gt; Source:\n\"\"\"\n        Method for returning a new source object with a normalised total\n        spectrum and source distribution.\n\n        Returns\n        -------\n        source : Source\n            The source object with the normalised spectrum and distribution.\n        \"\"\"\n        spectrum = self.spectrum.normalise()\n        distribution_floor = np.maximum(self.distribution, 0.)\n        distribution = distribution_floor / distribution_floor.sum()\n        return self.set(['spectrum', 'distribution'], [spectrum, distribution])\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self = self.normalise()\n        psf = optics.propagate(self.wavelengths, self.position, self.weights)\n        convolved = convolve(psf, self.distribution, mode='same')\n        return self.flux * convolved\n</code></pre> PointResolvedSource <p>         Bases: <code>RelativeFluxSource</code>, <code>ResolvedSource</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source. An example would be an unresolved star with a resolved dust shell or debris disk. These two objects share the same spectra but have their fluxes defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array (ie this class inherits from ResolvedSource).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolved source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities representing the resolved source.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointResolvedSource(RelativeFluxSource, ResolvedSource):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source. An example would be an unresolved star with\n    a resolved dust shell or debris disk. These two objects share the same\n    spectra but have their fluxes defined by flux (the mean flux) and the flux\n    ratio (contrast) between the point source and resolved distribution. The\n    resolved component is defined by an array (ie this class inherits from\n    ResolvedSource).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolved source.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    def __init__(self: Source,\n                 wavelengths: Array = None,\n                 position: Array = np.zeros(2),\n                 flux: Array = np.array(1.),\n                 distribution: Array = np.ones((3, 3)),\n                 contrast: Array = np.array(1.),\n                 spectrum: Spectrum = None,\n                 weights: Array = None) -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the point and resolved source.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                         distribution=distribution, spectrum=spectrum, weights=weights,\n                         contrast=contrast)\n\n    def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self = self.normalise()\n        psf = optics.propagate(self.wavelengths, self.position, self.weights)\n        convolved = convolve(psf, self.distribution, mode='same')\n        return self.fluxes[0] * psf + self.fluxes[1] * convolved\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointSources.__init__","title":"<code>__init__(wavelengths, position=np.zeros(2), flux=None, weights=None, spectrum=None)</code>","text":"<p>Constructor for the PointSources class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.</p> <code>np.zeros(2)</code> <code>flux</code> <code>Array, photons = None</code> <p>The fluxes of the sources.</p> <code>None</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> required Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self: Source,\n             wavelengths: Array,\n             position: Array = np.zeros(2),\n             flux: Array = None,\n             weights: Array = None,\n             spectrum: Spectrum = None):\n\"\"\"\n    Constructor for the PointSources class.\n\n    Parameters\n    ----------\n    position : Array, radians\n        The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.\n    flux : Array, photons = None\n        The fluxes of the sources.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    \"\"\"\n    super().__init__(spectrum=spectrum, wavelengths=wavelengths,\n                     weights=weights)\n\n    # More complex parameter checks here because of extra dims\n    self.position = np.asarray(position, dtype=float)\n    if self.position.ndim != 2:\n        raise ValueError(\"position must be a 2d array.\")\n\n    if flux is None:\n        self.flux = np.ones(len(self.position))\n    else:\n        self.flux = np.asarray(flux, dtype=float)\n\n        if self.flux.ndim != 1:\n            raise ValueError(\"flux must be a 1d array.\")\n\n        if len(self.flux) != len(self.position):\n            raise ValueError(\"Length of flux must be equal to length of \"\n                             \"position.\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSources.model","title":"<code>model(optics)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n    Method to model the psf of the point source through the optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n\n    Returns\n    -------\n    psf : Array\n        The PSF of the source modelled through the optics.\n    \"\"\"\n    self = self.normalise()\n    weights = self.weights[None, :] * self.flux[:, None]\n    propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n    return propagator(self.wavelengths, self.position, weights).sum(0)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSources","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointSources.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointSources.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.__init__","title":"<code>__init__(wavelengths=None, position=np.array([0.0, 0.0]), flux=np.array(1.0), separation=None, position_angle=np.pi / 2, contrast=np.array(1.0), spectrum=None, weights=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians = np.array([0., 0.])</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons = np.array(1.)</code> <p>The mean flux of the sources.</p> <code>np.array(1.0)</code> <code>separation</code> <code>Array, radians = None</code> <p>The separation of the two sources in radians.</p> <code>None</code> <code>position_angle</code> <code>Array, radians = np.pi/2</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>np.pi / 2</code> <code>contrast</code> <code>Array = np.array(1.)</code> <p>The contrast ratio between the two sources.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>CombinedSpectrum = None</code> <p>The spectrum of this object, represented by a CombinedSpectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self: Source,\n             wavelengths: Array = None,\n             position: Array = np.array([0., 0.]),\n             flux: Array = np.array(1.),\n             separation: Array = None,\n             position_angle: Array = np.pi / 2,\n             contrast: Array = np.array(1.),\n             spectrum: Spectrum = None,\n             weights: Array = None):\n\"\"\"\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The mean flux of the sources.\n    separation : Array, radians = None\n        The separation of the two sources in radians.\n    position_angle : Array, radians = np.pi/2\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array = np.array(1.)\n        The contrast ratio between the two sources.\n    spectrum : CombinedSpectrum = None\n        The spectrum of this object, represented by a CombinedSpectrum.\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    \"\"\"\n    wavelengths = np.asarray(wavelengths, dtype=float)\n    if weights is None:\n        weights = np.ones((2, len(wavelengths)))\n\n    super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                     separation=separation, position_angle=position_angle,\n                     contrast=contrast, spectrum=spectrum, weights=weights)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource.model","title":"<code>model(optics)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n    Method to model the psf of the point source through the optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n\n    Returns\n    -------\n    psf : Array\n        The PSF of the source modelled through the optics.\n    \"\"\"\n    self = self.normalise()\n    weights = self.weights * self.fluxes[:, None]\n    propagator = vmap(optics.propagate, in_axes=(None, 0, 0))\n    return propagator(self.wavelengths, self.positions, weights).sum(0)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.__init__","title":"<code>__init__(wavelengths, position=np.zeros(2), flux=np.array(1.0), distribution=np.ones((3, 3)), weights=None, spectrum=None)</code>","text":"<p>Constructor for the ResolvedSource class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians = np.array([0., 0.])</code> <p>The (x, y) on-sky position of this object.</p> <code>np.zeros(2)</code> <code>flux</code> <code>Array, photons = np.array(1.)</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array = np.ones((3, 3))</code> <p>The array of intensities representing the resolved source.</p> <code>np.ones((3, 3))</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> required Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self: Source,\n             wavelengths: Array,\n             position: Array = np.zeros(2),\n             flux: Array = np.array(1.),\n             distribution: Array = np.ones((3, 3)),\n             weights: Array = None,\n             spectrum: Spectrum = None):\n\"\"\"\n    Constructor for the ResolvedSource class.\n\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The flux of the object.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities representing the resolved source.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    \"\"\"\n    distribution = np.asarray(distribution, dtype=float)\n    self.distribution = distribution / distribution.sum()\n\n    if self.distribution.ndim != 2:\n        raise ValueError(\"distribution must be a 2d array.\")\n\n    super().__init__(position=position, flux=flux, spectrum=spectrum,\n                     wavelengths=wavelengths, weights=weights)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.model","title":"<code>model(optics)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n    Method to model the psf of the source through the optics. Implements a\n    basic convolution with the psf and source distribution.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self = self.normalise()\n    psf = optics.propagate(self.wavelengths, self.position, self.weights)\n    convolved = convolve(psf, self.distribution, mode='same')\n    return self.flux * convolved\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new source object with a normalised total spectrum and source distribution.</p> <p>Returns:</p> Name Type Description <code>source</code> <code>Source</code> <p>The source object with the normalised spectrum and distribution.</p> Source code in <code>dLux/sources.py</code> <pre><code>def normalise(self: Source) -&gt; Source:\n\"\"\"\n    Method for returning a new source object with a normalised total\n    spectrum and source distribution.\n\n    Returns\n    -------\n    source : Source\n        The source object with the normalised spectrum and distribution.\n    \"\"\"\n    spectrum = self.spectrum.normalise()\n    distribution_floor = np.maximum(self.distribution, 0.)\n    distribution = distribution_floor / distribution_floor.sum()\n    return self.set(['spectrum', 'distribution'], [spectrum, distribution])\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ResolvedSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ResolvedSource.normalise","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointResolvedSource.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros(2), flux=np.array(1.0), distribution=np.ones((3, 3)), contrast=np.array(1.0), spectrum=None, weights=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians = np.array([0., 0.])</code> <p>The (x, y) on-sky position of this object.</p> <code>np.zeros(2)</code> <code>flux</code> <code>Array, photons = np.array(1.)</code> <p>The mean flux of the point and resolved source.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array = np.ones((3, 3))</code> <p>The array of intensities representing the resolved source.</p> <code>np.ones((3, 3))</code> <code>contrast</code> <code>Array = np.array(1.)</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self: Source,\n             wavelengths: Array = None,\n             position: Array = np.zeros(2),\n             flux: Array = np.array(1.),\n             distribution: Array = np.ones((3, 3)),\n             contrast: Array = np.array(1.),\n             spectrum: Spectrum = None,\n             weights: Array = None) -&gt; Source:\n\"\"\"\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The mean flux of the point and resolved source.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities representing the resolved source.\n    contrast : Array = np.array(1.)\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    \"\"\"\n    super().__init__(wavelengths=wavelengths, position=position, flux=flux,\n                     distribution=distribution, spectrum=spectrum, weights=weights,\n                     contrast=contrast)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointResolvedSource.model","title":"<code>model(optics)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution, while also modelling the single point source psf.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self: Source, optics: Optics) -&gt; Array:\n\"\"\"\n    Method to model the psf of the source through the optics. Implements a\n    basic convolution with the psf and source distribution, while also\n    modelling the single point source psf.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self = self.normalise()\n    psf = optics.propagate(self.wavelengths, self.position, self.weights)\n    convolved = convolve(psf, self.distribution, mode='same')\n    return self.fluxes[0] * psf + self.fluxes[1] * convolved\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointResolvedSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointResolvedSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointResolvedSource.model","title":"Sources","text":""},{"location":"docs/API/sources/#examples","title":"Examples","text":"<p>Let's look at how to construct all these different classes. First, we construct some optics to model the sources through.</p> <pre><code>import dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n</code></pre> <p>Now, we define the different source classes.</p> <pre><code># Define wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\n\n# Construct PointSource\nsources = [dl.PointSource(wavelengths)]\n\n# Construct PointSources\npositions = 3e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nsources.append(dl.PointSources(wavelengths, positions))\n\n# Construct BinarySource\nseparation = 2e-6 # radians\nsources.append(dl.BinarySource(wavelengths, separation=separation))\n\n# Construct ResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.ResolvedSource(wavelengths, distribution=distribution))\n\n# Construct PointResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.PointResolvedSource(wavelengths, distribution=distribution, \n    contrast=3))\n</code></pre> Plotting Code <pre><code>import matplotlib.pyplot as plt\ntitles = [\"PointSource\", \"PointSources\", \"BinarySource\", \"ResolvedSource\",\n    \"PointResolvedSource\"]\n\nplt.figure(figsize=(25, 4))\nfor i in range(5):\n    psf = sources[i].model(optics)\n    plt.subplot(1, 5, i+1)\n    plt.title(titles[i])\n    plt.imshow(psf**0.5)\n    plt.colorbar()\nplt.savefig('assets/sources.png')\n</code></pre> <p></p>"},{"location":"docs/API/spectra/","title":"Spectra: <code>spectra.py</code>","text":"<p>This module contains the classes that define the behaviour of spectra in \u2202Lux.</p> <p>There are two public classes:</p> <ul> <li><code>Spectrum</code></li> <li><code>PolySpectrum</code></li> </ul> <p>The <code>Spectrum</code> class is a generic class that allows for the definition of spectra by a simple wavelength and weights. The <code>PolySpectrum</code> class provides a generic polynomial spectrum.</p> Spectrum <p>         Bases: <code>BaseSpectrum</code></p> <p>A Spectrum class that internally parametrises the spectrum via arrays (i.e. wavelengths and weights)</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, metres</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p> Source code in <code>dLux/spectra.py</code> <pre><code>class Spectrum(BaseSpectrum):\n\"\"\"\n    A Spectrum class that internally parametrises the spectrum via arrays (i.e.\n    wavelengths and weights)\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array\n        The relative weights of each wavelength.\n    \"\"\"\n    weights: Array\n\n    def __init__(self: Spectrum,\n                 wavelengths: Array,\n                 weights: Array = None):\n\"\"\"\n        Constructor for the Spectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        weights : Array = None\n            The relative weights of each wavelength. Defaults to uniform\n            spectrum. Weights are automatically normalised to a sum of 1.\n        \"\"\"\n        super().__init__(wavelengths)\n        if weights is None:\n            in_shape = self.wavelengths.shape\n            weights = np.ones(in_shape) / in_shape[-1]\n\n        weights = np.asarray(weights, dtype=float)\n        if weights.ndim == 2:\n            self.weights = weights / weights.sum(-1)[:, None]\n        else:\n            self.weights = weights / weights.sum()\n\n        if self.weights.ndim == 1:\n            if self.wavelengths.shape != self.weights.shape:\n                raise ValueError(\"wavelengths and weights must have the same \"\n                                 \"shape.\")\n        else:\n            if self.wavelengths.shape != self.weights.shape[-1:]:\n                raise ValueError(\"wavelengths and weights must have the same \"\n                                 \"shape.\")\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum.\n\n        Returns\n        -------\n        spectrum : Spectrum\n            The spectrum object with the normalised spectrum.\n        \"\"\"\n        if self.weights.ndim == 2:\n            weight_sum = self.weights.sum(-1)[:, None]\n        else:\n            weight_sum = self.weights.sum()\n        return self.divide('weights', weight_sum)\n</code></pre> PolySpectrum <p>         Bases: <code>BaseSpectrum</code></p> <p>Implements a generic polynomial spectrum. This is likely not needed and will probably just be turned into LinearSpectrum in the future.</p> <p>This implements a polynomial as follows: f(x) = c0 + c1x + c2x^2 + ... + cn*x^n</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, metres</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> Source code in <code>dLux/spectra.py</code> <pre><code>class PolySpectrum(BaseSpectrum):\n\"\"\"\n    Implements a generic polynomial spectrum. This is likely not needed and\n    will probably just be turned into LinearSpectrum in the future.\n\n    This implements a polynomial as follows:\n    f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    \"\"\"\n    coefficients: Array\n\n    def __init__(self: Spectrum,\n                 wavelengths: Array,\n                 coefficients: Array):\n\"\"\"\n        Constructor for the PolySpectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        coefficients : Array\n            The array of polynomial coefficient values.\n        \"\"\"\n        super().__init__(wavelengths)\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n        if self.coefficients.ndim != 1:\n            raise ValueError(\"Coefficients must be a 1d array.\")\n\n    def _eval_weight(self, wavelength):\n        return np.array([self.coefficients[i] * wavelength ** i\n                         for i in range(len(self.coefficients))]).sum()\n\n    @property\n    def weights(self: Spectrum) -&gt; Array:\n\"\"\"\n        Gets the relative spectral weights by evaluating the polynomial\n        function at the internal wavelengths. This automatically normalises\n        the weights to have unitary amplitude.\n\n        Returns\n        -------\n        weights : Array\n            The normalised relative weights of each wavelength.\n        \"\"\"\n        weights = vmap(self._eval_weight)(self.wavelengths)\n        return weights / weights.sum()\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n        Calculated weights are automatically normalised, but could be\n        calculated from the shift term (ie b in y = mx + b) \n\n        Returns\n        --------\n        spectrum : Spectrum\n            The unmodified spectrum object\n        \"\"\"\n        return self\n</code></pre>"},{"location":"docs/API/spectra/#dLux.spectra.Spectrum.__init__","title":"<code>__init__(wavelengths, weights=None)</code>","text":"<p>Constructor for the Spectrum class.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, metres</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>weights</code> <code>Array = None</code> <p>The relative weights of each wavelength. Defaults to uniform spectrum. Weights are automatically normalised to a sum of 1.</p> <code>None</code> Source code in <code>dLux/spectra.py</code> <pre><code>def __init__(self: Spectrum,\n             wavelengths: Array,\n             weights: Array = None):\n\"\"\"\n    Constructor for the Spectrum class.\n\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array = None\n        The relative weights of each wavelength. Defaults to uniform\n        spectrum. Weights are automatically normalised to a sum of 1.\n    \"\"\"\n    super().__init__(wavelengths)\n    if weights is None:\n        in_shape = self.wavelengths.shape\n        weights = np.ones(in_shape) / in_shape[-1]\n\n    weights = np.asarray(weights, dtype=float)\n    if weights.ndim == 2:\n        self.weights = weights / weights.sum(-1)[:, None]\n    else:\n        self.weights = weights / weights.sum()\n\n    if self.weights.ndim == 1:\n        if self.wavelengths.shape != self.weights.shape:\n            raise ValueError(\"wavelengths and weights must have the same \"\n                             \"shape.\")\n    else:\n        if self.wavelengths.shape != self.weights.shape[-1:]:\n            raise ValueError(\"wavelengths and weights must have the same \"\n                             \"shape.\")\n</code></pre>"},{"location":"docs/API/spectra/#dLux.spectra.Spectrum.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new spectrum object with a normalised total spectrum.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Spectrum</code> <p>The spectrum object with the normalised spectrum.</p> Source code in <code>dLux/spectra.py</code> <pre><code>def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n    Method for returning a new spectrum object with a normalised total\n    spectrum.\n\n    Returns\n    -------\n    spectrum : Spectrum\n        The spectrum object with the normalised spectrum.\n    \"\"\"\n    if self.weights.ndim == 2:\n        weight_sum = self.weights.sum(-1)[:, None]\n    else:\n        weight_sum = self.weights.sum()\n    return self.divide('weights', weight_sum)\n</code></pre>"},{"location":"docs/API/spectra/#dLux.spectra.Spectrum","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.Spectrum.__init__","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.Spectrum.normalise","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.weights","title":"<code>weights: Array</code>  <code>property</code>","text":"<p>Gets the relative spectral weights by evaluating the polynomial function at the internal wavelengths. This automatically normalises the weights to have unitary amplitude.</p> <p>Returns:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The normalised relative weights of each wavelength.</p>"},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.__init__","title":"<code>__init__(wavelengths, coefficients)</code>","text":"<p>Constructor for the PolySpectrum class.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, metres</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> required Source code in <code>dLux/spectra.py</code> <pre><code>def __init__(self: Spectrum,\n             wavelengths: Array,\n             coefficients: Array):\n\"\"\"\n    Constructor for the PolySpectrum class.\n\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    \"\"\"\n    super().__init__(wavelengths)\n    self.coefficients = np.asarray(coefficients, dtype=float)\n\n    if self.coefficients.ndim != 1:\n        raise ValueError(\"Coefficients must be a 1d array.\")\n</code></pre>"},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Calculated weights are automatically normalised, but could be calculated from the shift term (ie b in y = mx + b) </p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Spectrum</code> <p>The unmodified spectrum object</p> Source code in <code>dLux/spectra.py</code> <pre><code>def normalise(self: Spectrum) -&gt; Spectrum:\n\"\"\"\n    Calculated weights are automatically normalised, but could be\n    calculated from the shift term (ie b in y = mx + b) \n\n    Returns\n    --------\n    spectrum : Spectrum\n        The unmodified spectrum object\n    \"\"\"\n    return self\n</code></pre>"},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.weights","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.__init__","title":"Spectra","text":""},{"location":"docs/API/spectra/#dLux.spectra.PolySpectrum.normalise","title":"Spectra","text":""},{"location":"docs/API/spectra/#examples","title":"Examples","text":"<p>Here is how to construct and plot a simple <code>Spectrum</code> object.</p> <pre><code>import dLux as dl\nimport jax.numpy as np\n\n# Array based spectrum\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nweights = np.linspace(.5, 1, 5)\nspectrum = dl.Spectrum(wavelengths, weights)\n</code></pre> Plotting Code <pre><code>plt.title(\"Spectrum\")\nplt.scatter(spectrum.wavelengths, spectrum.weights)\nplt.ylim(0)\nplt.xlabel(\"Wavelength (meters)\")\nplt.ylabel(\"Normalised Weight\")\nplt.savefig('assets/spectrum.png')\n</code></pre> <p></p>"},{"location":"docs/API/wavefronts/","title":"Wavefronts: <code>wavefronts.py</code>","text":"<p>This module contains the classes that define the behaviour of wavefronts in \u2202Lux.</p> <p>There are two public classes: <code>Wavefront</code> and <code>FresnelWavefront</code>.</p> <p>All <code>Wavefront</code> objects have the following attributes:</p> <ul> <li><code>wavelength</code></li> <li><code>amplitude</code></li> <li><code>phase</code></li> <li><code>pixel_scale</code></li> <li><code>plane</code></li> <li><code>units</code></li> </ul> <p>The <code>wavelength</code>, <code>amplitude</code> and <code>phase</code> attributes are the respective wavelength, amplitude and phase of the wavefront. The <code>pixel_scale</code> is the physical size of the pixels representing the wavefront. The <code>plane</code> is the current plane of the wavefront, which can be 'Pupil', 'Focal' or 'Intermediate'. The <code>units</code> attribute is the current units of the wavefront, which can be 'Cartesian' or 'Angular'.</p> <p>It is important to note here that <code>plane</code> and <code>units</code> do not actually determine the behaviour of the wavefront, but rather are used to track the current unit type. That is, if you set the units parameter from 'Cartesian' to 'Angular', the wavefront will not be converted to angular units, but rather the units will be treated as angular in propagations, which can lead to incorrect results.</p> Wavefront API <p>         Bases: <code>Base</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as two helper parameters, plane and units.</p> <p>All wavefronts currently only support square amplitude and phase arrays.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, metres</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, metres/pixel or radians/pixel</code> <p>The physical dimensions of the pixels representing the wavefront. This can be in units of either metres per pixel or radians per pixel depending on if 'unit' is 'Cartesian' or 'Angular'.</p> <code>plane</code> <code>str</code> <p>The current plane type of wavefront, can be 'Pupil', 'Focal' or 'Intermediate'.</p> <code>units</code> <code>str</code> <p>The current units of the wavefront, can be 'Cartesian' or 'Angular'.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>class Wavefront(Base):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    two helper parameters, plane and units.\n\n    All wavefronts currently only support square amplitude and phase arrays.\n\n    Attributes\n    ----------\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, metres/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        can be in units of either metres per pixel or radians per pixel\n        depending on if 'unit' is 'Cartesian' or 'Angular'.\n    plane : str\n        The current plane type of wavefront, can be 'Pupil', 'Focal' or\n        'Intermediate'.\n    units : str\n        The current units of the wavefront, can be 'Cartesian' or 'Angular'.\n    \"\"\"\n    wavelength: Array\n    pixel_scale: Array\n    amplitude: Array\n    phase: Array\n    plane: str\n    units: str\n\n    def __init__(self: Wavefront,\n                 npixels: int,\n                 diameter: Array,\n                 wavelength: Array):\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        diameter : float, metres\n            The physical dimensions of each square pixel.\n        wavelength : float, metres\n            The wavelength of the `Wavefront`.\n        \"\"\"\n        self.wavelength = np.asarray(wavelength, dtype=float)\n        self.pixel_scale = np.asarray(diameter / npixels, dtype=float)\n        self.amplitude = np.ones((npixels, npixels), dtype=float)\n        self.phase = np.zeros((npixels, npixels), dtype=float)\n\n        # Input checks\n        if self.wavelength.shape != ():\n            raise ValueError(\"wavelength must have shape ().\")\n        if self.diameter.shape != ():\n            raise ValueError(\"diameter must have shape ().\")\n\n        # Always initialised in Pupil plane with Cartesian Coords\n        self.plane = 'Pupil'\n        self.units = 'Cartesian'\n\n    ########################\n    ### Getter Functions ###\n    ########################\n    @property\n    def diameter(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the current wavefront diameter calculated using the pixel scale\n        and number of pixels.\n\n        Returns\n        -------\n        diameter : Array, metres or radians\n            The current diameter of the wavefront.\n        \"\"\"\n        return self.npixels * self.pixel_scale\n\n    @property\n    def npixels(self: Wavefront) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        wavefront. Taken from the last axis of the amplitude array.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[-1]\n\n    @property\n    def real(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the real component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The real component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.cos(self.phase)\n\n    @property\n    def imaginary(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the imaginary component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The imaginary component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.sin(self.phase)\n\n    @property\n    def phasor(self: Wavefront) -&gt; Array:\n\"\"\"\n        The electric field phasor described by this Wavefront in complex form.\n\n        Returns\n        -------\n        field : Array\n            The electric field phasor of the wavefront.\n        \"\"\"\n        return self.amplitude * np.exp(1j * self.phase)\n\n    @property\n    def psf(self: Wavefront) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), i.e. the squared modulus\n        of the complex wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return self.amplitude ** 2\n\n    @property\n    def coordinates(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the physical positions of the wavefront pixels in metres.\n\n        Returns\n        -------\n        coordinates : Array\n            The coordinates of the centers of each pixel representing the\n            wavefront.\n        \"\"\"\n        return dlu.pixel_coords(self.npixels, self.pixel_scale)\n\n    @property\n    def wavenumber(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the wavenumber of the wavefront (2 * pi / wavelength).\n\n        Returns\n        -------\n        wavenumber : Array, 1/meters\n            The wavenumber of the wavefront.\n        \"\"\"\n        return 2 * np.pi / self.wavelength\n\n    @property\n    def fringe_size(self: Wavefront) -&gt; Array:\n\"\"\"\n        Returns the size of the fringes in angular units.\n\n        # TODO Units check\n        # TODO Possibly output in unit based on units attribute\n        # TODO make methods use this\n        Returns\n        -------\n        fringe_size : Array, radians\n            The wavenumber of the wavefront.\n        \"\"\"\n        return self.wavelength / self.diameter\n\n    #####################\n    ### Magic Methods ###\n    #####################\n    def __add__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of OPD values and is added to the wavefront. If it is an\n        Aberration, the wavefront is passed to the layer and the output\n        wavefront is returned.\n\n        Parameters\n        ----------\n        other : Array or Aberration\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type\n        if other is None:\n            return self\n\n        # Some Optical Layer\n        if isinstance(other, OpticalLayer()):\n            return other(self)\n\n        # Array based inputs - Defaults to OPD\n        if isinstance(other, (Array, float, int)):\n            return self.add_opd(other)\n\n        # Other\n        else:\n            raise TypeError(\"Can only add an array or OpticalLayer to \"\n                            f\"Wavefront. Got: {type(other)}.\")\n\n    def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of OPD values and is added to the wavefront. If it is an\n        Aberration, the wavefront is passed to the layer and the output\n        wavefront is returned.\n\n        Parameters\n        ----------\n        other : Array or Aberration\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__add__(other)\n\n    def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of transmission values and is multiplied by the wavefront\n        amplitude. If it is an Aperture, Aberration, or Propagator, the\n        wavefront is passed to the layer and the output wavefront is returned.\n\n        Parameters\n        ----------\n        other : Array or Aberration or Aperture or Propagator\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type, return None\n        if other is None:\n            return self\n\n        # Some Optical Layer, apply it\n        if isinstance(other, OpticalLayer()):\n            return other(self)\n\n        # Array based inputs\n        if isinstance(other, (Array, float, int)):\n\n            # Complex array - Multiply the phasors\n            if isinstance(other, Array) and other.dtype.kind == 'c':\n                phasor = self.phasor * other\n                return self.set([\"amplitude\", \"phase\"],\n                                [np.abs(phasor), np.angle(phasor)])\n\n            # Scalar array - Multiply amplitude\n            else:\n                return self.multiply('amplitude', other)\n\n        # Other\n        else:\n            raise TypeError(\"Can only multiply Wavefront by array or \"\n                            f\"OpticalLayer. Got: {type(other)}.\")\n\n    def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n        Magic method used to give a simple API for interaction with different\n        layer types and arrays. If the input 'other' in an array it is treated\n        as an array of transmission values and is multiplied by the wavefront\n        amplitude. If it is an Aperture, Aberration, or Propagator, the\n        wavefront is passed to the layer and the output wavefront is returned.\n\n        Parameters\n        ----------\n        other : Array or Aberration or Aperture or Propagator\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__mul__(other)\n\n    #######################\n    ### Adder Functions ###\n    #######################\n    def add_opd(self: Wavefront, path_difference: Array) -&gt; Wavefront:\n\"\"\"\n        Applies the wavelength-dependent phase based on the supplied optical\n        path difference.\n\n        Parameters\n        ----------\n        path_difference : Array, metres\n            The physical optical path difference of either the entire wavefront\n            or each pixel individually.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phases updated according to the supplied\n            path_difference\n        \"\"\"\n        phase_difference = self.wavenumber * path_difference\n        return self.add('phase', phase_difference)\n\n    def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:\n\"\"\"\n        Applies input array to the phase of the wavefront.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            The phase to be added to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with updated phases.\n        \"\"\"\n        # Add this extra None check to allow PhaseOptics to have a None phase\n        # and still be able to be 'added' to it, making this the phase \n        # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`\n        if phase is not None:\n            return self.add('phase', phase)\n        return self\n\n    #######################\n    ### Other Functions ###\n    #######################\n    def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:\n\"\"\"\n        Tilts the wavefront by the angles in the (x, y) by modifying the \n        phase arrays.\n\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The tilted wavefront.\n        \"\"\"\n        if not isinstance(angles, Array) or angles.shape != (2,):\n            raise ValueError(\"angles must be an array of shape (2,).\")\n        opd = - (angles[:, None, None] * self.coordinates).sum(0)\n        return self.add_opd(opd)\n\n    def normalise(self: Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the total power of the wavefront to 1.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the normalised electric field amplitudes.\n        \"\"\"\n        return self.divide('amplitude', np.linalg.norm(self.amplitude))\n\n    def _to_field(self: Wavefront, complex: bool = False) -&gt; Array:\n\"\"\"\n        Returns the wavefront in either (amplitude, phase) or (real, imaginary)\n        form.\n\n        Parameters\n        ----------\n        complex : bool = False\n            Whether to return the wavefront in (real, imaginary) form.\n\n        Returns\n        -------\n        field : Array\n            The wavefront in either (amplitude, phase) or (real, imaginary) form.\n        \"\"\"\n        if complex:\n            return np.array([self.real, self.imaginary])\n        return np.array([self.amplitude, self.phase])\n\n    def _to_amplitude_phase(self: Wavefront, field: Array) -&gt; Array:\n\"\"\"\n        Returns the input field in (real, imaginary) (amplitude, phase) form.\n\n        Parameters\n        ----------\n        field : Array\n            The wavefront field in (amplitude, phase) form.\n\n        Returns\n        -------\n        field : Array\n            The wavefront field in (real, imaginary) form.\n        \"\"\"\n        amplitude = np.hypot(field[0], field[1])\n        phase = np.arctan2(field[1], field[0])\n        return np.array([amplitude, phase])\n\n    def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:\n\"\"\"\n        Flips the amplitude and phase of the wavefront along the specified axes.\n\n        Parameters\n        ----------\n        axis : tuple\n            The axes along which to flip the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the flipped amplitude and phase.\n        \"\"\"\n        field = self._to_field()\n        flipper = vmap(np.flip, (0, None))\n        amplitude, phase = flipper(field, axis)\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    def scale_to(self: Wavefront,\n                 npixels: int,\n                 pixel_scale: Array,\n                 complex: bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial interpolation on the wavefront, determined by the\n        pixel_scale_out and npixels parameters. The transformation is done\n        on the amplitude and phase arrays, but can be done on the real and\n        imaginary components by passing `complex=True`.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels representing the wavefront after the\n            interpolation.\n        pixel_scale: Array\n            The pixel scale of the array after the interpolation.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront interpolated to the size and shape determined by\n            npixels and pixel_scale_out, with the updated pixel_scale.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Scale the field\n        scaler = vmap(dlu.scale, (0, None, None))\n        field = scaler(field, npixels, pixel_scale / self.pixel_scale)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase'], [field[0], field[1]])\n\n    def rotate(self: Wavefront,\n               angle: Array,\n               order: int = 1,\n               complex: bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial rotation on the wavefront, determined by the\n        angle parameter, using interpolation. The transformation is done\n        on the amplitude and phase arrays, but can be done on the real and\n        imaginary components by passing `complex=True`.\n\n        Parameters\n        ----------\n        angle : Array, radians\n            The angle by which to rotate the wavefront in a clockwise direction.\n        order : int = 1\n            The interpolation order to use.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront rotated by angle in the clockwise direction.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Rotate the field\n        rotator = vmap(dlu.rotate, (0, None, None))\n        field = rotator(field, angle, order)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase'], [field[0], field[1]])\n\n    ############################\n    ### Padding and Cropping ###\n    ############################\n    def pad_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n        Paraxially zero-pads the `Wavefront` to the size determined by\n        npixels. Note this only supports padding arrays of even dimension\n        to even dimension, and odd dimension to odd dimension, i.e. 2 -&gt; 4 or\n        3 -&gt; 5.\n\n        Parameters\n        ----------\n        npixels : int\n            The size of the array to pad to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` zero-padded to the size npixels.\n        \"\"\"\n        npixels_in = self.npixels\n        if npixels_in % 2 != npixels % 2:\n            raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n        if npixels &lt; npixels_in:\n            raise ValueError(\"npixels must be larger than the current array \"\n                             \"size: {}\".format(npixels_in))\n\n        new_centre = npixels // 2\n        centre = npixels_in // 2\n        remainder = npixels_in % 2\n        padded = np.zeros([npixels, npixels])\n\n        amplitude = padded.at[\n                    new_centre - centre: centre + new_centre + remainder,\n                    new_centre - centre: centre + new_centre + remainder\n                    ].set(self.amplitude)\n        phase = padded.at[\n                new_centre - centre: centre + new_centre + remainder,\n                new_centre - centre: centre + new_centre + remainder\n                ].set(self.phase)\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    def crop_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n        Paraxially crops the `Wavefront` to the size determined by npixels.\n        Note this only supports padding arrays of even dimension to even\n        dimension, and odd dimension to odd dimension, i.e. 4 -&gt; 2 or 5 -&gt; 3.\n\n        Parameters\n        ----------\n        npixels : int\n            The size of the array to crop to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` cropped to the size npixels.\n        \"\"\"\n        npixels_in = self.npixels\n\n        if npixels_in % 2 != npixels % 2:\n            raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n        if npixels &gt; npixels_in:\n            raise ValueError(\"npixels must be smaller than the current array \"\n                             \"size: {}\".format(npixels_in))\n\n        new_centre = npixels_in // 2\n        centre = npixels // 2\n\n        amplitude = self.amplitude[\n                    new_centre - centre: new_centre + centre,\n                    new_centre - centre: new_centre + centre]\n        phase = self.phase[\n                new_centre - centre: new_centre + centre,\n                new_centre - centre: new_centre + centre]\n\n        return self.set(['amplitude', 'phase'], [amplitude, phase])\n\n    #############################\n    ### Propagation Functions ###\n    #############################\n    def _FFT_output(self         : Wavefront,\n                    pad_factor   : int = 1,\n                    focal_length : Array = None, \n                    inverse      : bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane, unit, and pixel scale.\n\n        Parameters\n        ----------\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            If True, the propagation is treated as an inverse FFT.\n\n        Returns\n        -------\n        plane : str\n            The output plane of the propagation.\n        units : str\n            The units of the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        \"\"\"\n        pixel_scale = self.fringe_size / pad_factor\n        if focal_length is None:\n            units = 'Angular'\n        else:\n            units = 'Cartesian'\n            pixel_scale *= focal_length\n\n            # Check for invalid propagation\n            if self.units == 'Angular':\n                raise ValueError(\"focal_length can not be specific when\"\n                                 \"propagating from a Focal plane with angular units.\")\n\n        # Check planes\n        if inverse:\n            if self.plane != 'Focal':\n                raise ValueError(\"Can only do an IFFT from a Focal plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Pupil'\n            units = 'Cartesian'\n        else:\n            if self.plane != 'Pupil':\n                raise ValueError(\"Can only do an FFT from a Pupil plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Focal'\n\n        return plane, units, pixel_scale\n\n    # TODO: focal_length not used?\n    def _FFT(self: Wavefront,\n             phasor: Array,\n             focal_length: Array = None,\n             inverse: bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane, unit, pixel scale, and returns the\n        appropriate propagation function\n\n        Parameters\n        ----------\n        inverse : bool = False\n            If True, the inverse FFT is used.\n\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        if inverse:\n            return np.fft.fft2(np.fft.ifftshift(phasor)) / phasor.shape[-1]\n        else:\n            return np.fft.fftshift(np.fft.ifft2(phasor)) * phasor.shape[-1]\n\n    def FFT(self: Wavefront,\n            pad: int = 2,\n            focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a Fast Fourier Transform.\n\n        Parameters\n        ----------\n        pad : int = 2\n            The padding factory to apply to the input wavefront before\n            performing the FFT.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units, pixel_scale = self._FFT_output(pad, focal_length)\n\n        # Pad must be int\n        npixels = (self.npixels * (pad - 1)) // 2\n        amplitude = np.pad(self.amplitude, npixels)\n        phase = np.pad(self.phase, npixels)\n        phasor = amplitude * np.exp(1j * phase)\n        phasor = self._FFT(phasor, focal_length)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def IFFT(self: Wavefront,\n             pad: int = 2,\n             focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing an Inverse Fast Fourier\n        Transform.\n\n        Parameters\n        ----------\n        pad : int = 2\n            The padding factory to apply to the input wavefront before\n            performing the FFT.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units, pixel_scale = self._FFT_output(pad, focal_length, \n            inverse=True)\n\n        # Pad must be int\n        npixels = (self.npixels * (pad - 1)) // 2\n        amplitude = np.pad(self.amplitude, npixels)\n        phase = np.pad(self.phase, npixels)\n        phasor = amplitude * np.exp(1j * phase)\n        phasor = self._FFT(phasor, focal_length, inverse=True)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def _MFT_output(self: Wavefront,\n                    focal_length: Array = None,\n                    inverse: bool = False) -&gt; tuple:\n\"\"\"\n        Calculates the output plane and unit for the MFT\n\n        Parameters\n        ----------\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            If True, the inverse MFT is used.\n\n        Returns\n        -------\n        plane : str\n            The output plane of the propagation.\n        units : str\n            The units of the output plane.\n        \"\"\"\n        # Get units\n        if focal_length is None:\n            units = 'Angular'\n        else:\n            units = 'Cartesian'\n\n            # Check for invalid propagation\n            if self.units == 'Angular':\n                raise ValueError(\"focal_length can not be specific when\"\n                                 \"propagating from a Focal plane with angular units.\")\n\n        # Check planes\n        if inverse:\n            if self.plane != 'Focal':\n                raise ValueError(\"Can only do an IMFT from a Focal plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Pupil'\n            units = 'Cartesian'\n        else:\n            if self.plane != 'Pupil':\n                raise ValueError(\"Can only do an MFT from a Pupil plane, \"\n                                 f\"current plane is {self.plane}.\")\n            plane = 'Focal'\n\n        return plane, units\n\n    def _nfringes(self: Wavefront,\n                  npixels: int,\n                  pixel_scale: Array,\n                  focal_length: Array = None) -&gt; Array:\n\"\"\"\n        Calculates the number of fringes in the output plane.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        nfringes : Array\n            The number of fringes in the output plane.\n        \"\"\"\n        output_size = npixels * pixel_scale\n\n        # Angular\n        if focal_length is None:\n            return output_size / self.fringe_size\n\n        # Cartesian\n        else:\n            return output_size / (self.fringe_size * focal_length)\n\n    def _transfer_matrix(self: Wavefront,\n                         npixels: int,\n                         pixel_scale: Array,\n                         shift: Array = 0.,\n                         focal_length: Array = None,\n                         inverse: bool = False) -&gt; Array:\n\"\"\"\n        Calculates the transfer matrix for the MFT.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array\n            The pixel scale of the output plane.\n        shift : Array = 0.\n            The shift to apply to the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        inverse : bool = False\n            Is this a forward or inverse MFT.\n\n        Returns\n        -------\n        transfer_matrix : Array\n            The transfer matrix for the MFT.\n        \"\"\"\n        scale_in = 1.0 / self.npixels\n        scale_out = self._nfringes(npixels, pixel_scale, focal_length) / npixels\n        in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)\n        out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)\n\n        if not inverse:\n            return np.exp(2j * np.pi * np.outer(in_vec, out_vec))\n        else:\n            return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))\n\n    def _MFT(self: Wavefront,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array = None,\n             shift: Array = np.zeros(2),\n             inverse: bool = False) -&gt; Array:\n\"\"\"\n        Performs the actual phasor propagation and normalises the output\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        shift : Array = np.zeros(2)\n            The shift in the center of the output plane.\n        inverse : bool = False\n            Is this a forward or inverse MFT.\n\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        # Transfer Matrices\n        x_matrix = self._transfer_matrix(npixels, pixel_scale, shift[0],\n                                         focal_length, inverse=inverse)\n        y_matrix = self._transfer_matrix(npixels, pixel_scale, shift[1],\n                                         focal_length, inverse=inverse).T\n\n        # Propagation\n        phasor = (y_matrix @ self.phasor) @ x_matrix\n        nfringes = self._nfringes(npixels, pixel_scale, focal_length)\n        phasor *= np.exp(np.log(nfringes) -\n                         (np.log(self.npixels) + np.log(npixels)))\n        return phasor\n\n    def MFT(self: Wavefront,\n            npixels: int,\n            pixel_scale: Array,\n            focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a 2-sided Matrix Fourier\n        Transform. TODO: Add link to Soumer et al. 2007(?).\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length)\n        phasor = self._MFT(npixels, pixel_scale, focal_length)\n\n        # Return new wavefront\n        pixel_scale = np.array(pixel_scale)  # Allow float input\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def IMFT(self: Wavefront,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a, inverse 2-sided Matrix Fourier\n        Transform. TODO: Add link to Soumer et al. 2007(?).\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length, inverse=True)\n        phasor = self._MFT(npixels, pixel_scale, focal_length, inverse=True)\n\n        # Return new wavefront\n        pixel_scale = np.array(pixel_scale)  # Allow float input\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def shifted_MFT(self: Wavefront,\n                    npixels: int,\n                    pixel_scale: Array,\n                    shift: Array,\n                    focal_length: Array = None,\n                    pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a 2-sided Matrix Fourier\n        Transform with a shift in the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        shift : Array\n            The shift in the center of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        pixel : bool = True\n            Whether the shift is in pixels or the units of pixel_scale.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length)\n        shift = shift if pixel else shift / pixel_scale\n        phasor = self._MFT(npixels, pixel_scale, focal_length, shift)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n\n    def shifted_IMFT(self: Wavefront,\n                     npixels: int,\n                     pixel_scale: Array,\n                     shift: Array,\n                     focal_length: Array = None,\n                     pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n        Propagates the wavefront by performing a, Inverse 2-sided Matrix Fourier\n        Transform with a shift in the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output wavefront.\n        pixel_scale : Array\n            The pixel scale of the output wavefront.\n        shift : Array\n            The shift in the center of the output plane.\n        focal_length : Array = None\n            The focal length of the propagation. If None, the propagation is\n            treated as an 'angular' propagation, else it is treated as a\n            'Cartesian' propagation.\n        pixel : bool = True\n            Whether the shift is in pixels or the units of pixel_scale.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate\n        plane, units = self._MFT_output(focal_length, inverse=True)\n        shift = shift if pixel else shift / pixel_scale\n        phasor = self._MFT(npixels, pixel_scale, focal_length, shift,\n                           inverse=True)\n\n        # Return new wavefront\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.coordinates","title":"<code>coordinates: Array</code>  <code>property</code>","text":"<p>Returns the physical positions of the wavefront pixels in metres.</p> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The coordinates of the centers of each pixel representing the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"<code>diameter: Array</code>  <code>property</code>","text":"<p>Returns the current wavefront diameter calculated using the pixel scale and number of pixels.</p> <p>Returns:</p> Name Type Description <code>diameter</code> <code>Array, metres or radians</code> <p>The current diameter of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size","title":"<code>fringe_size: Array</code>  <code>property</code>","text":"<p>Returns the size of the fringes in angular units.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-units-check","title":"TODO Units check","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-possibly-output-in-unit-based-on-units-attribute","title":"TODO Possibly output in unit based on units attribute","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-make-methods-use-this","title":"TODO make methods use this","text":"<p>Returns:</p> Name Type Description <code>fringe_size</code> <code>Array, radians</code> <p>The wavenumber of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"<code>imaginary: Array</code>  <code>property</code>","text":"<p>Returns the imaginary component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The imaginary component of the <code>Wavefront</code> phasor.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the wavefront. Taken from the last axis of the amplitude array.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"<code>phasor: Array</code>  <code>property</code>","text":"<p>The electric field phasor described by this Wavefront in complex form.</p> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The electric field phasor of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"<code>psf: Array</code>  <code>property</code>","text":"<p>Calculates the Point Spread Function (PSF), i.e. the squared modulus of the complex wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.real","title":"<code>real: Array</code>  <code>property</code>","text":"<p>Returns the real component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The real component of the <code>Wavefront</code> phasor.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"<code>wavenumber: Array</code>  <code>property</code>","text":"<p>Returns the wavenumber of the wavefront (2 * pi / wavelength).</p> <p>Returns:</p> Name Type Description <code>wavenumber</code> <code>Array, 1/meters</code> <p>The wavenumber of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.FFT","title":"<code>FFT(pad=2, focal_length=None)</code>","text":"<p>Propagates the wavefront by performing a Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int = 2</code> <p>The padding factory to apply to the input wavefront before performing the FFT.</p> <code>2</code> <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def FFT(self: Wavefront,\n        pad: int = 2,\n        focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing a Fast Fourier Transform.\n\n    Parameters\n    ----------\n    pad : int = 2\n        The padding factory to apply to the input wavefront before\n        performing the FFT.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units, pixel_scale = self._FFT_output(pad, focal_length)\n\n    # Pad must be int\n    npixels = (self.npixels * (pad - 1)) // 2\n    amplitude = np.pad(self.amplitude, npixels)\n    phase = np.pad(self.phase, npixels)\n    phasor = amplitude * np.exp(1j * phase)\n    phasor = self._FFT(phasor, focal_length)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.IFFT","title":"<code>IFFT(pad=2, focal_length=None)</code>","text":"<p>Propagates the wavefront by performing an Inverse Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int = 2</code> <p>The padding factory to apply to the input wavefront before performing the FFT.</p> <code>2</code> <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def IFFT(self: Wavefront,\n         pad: int = 2,\n         focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing an Inverse Fast Fourier\n    Transform.\n\n    Parameters\n    ----------\n    pad : int = 2\n        The padding factory to apply to the input wavefront before\n        performing the FFT.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units, pixel_scale = self._FFT_output(pad, focal_length, \n        inverse=True)\n\n    # Pad must be int\n    npixels = (self.npixels * (pad - 1)) // 2\n    amplitude = np.pad(self.amplitude, npixels)\n    phase = np.pad(self.phase, npixels)\n    phasor = amplitude * np.exp(1j * phase)\n    phasor = self._FFT(phasor, focal_length, inverse=True)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.IMFT","title":"<code>IMFT(npixels, pixel_scale, focal_length=None)</code>","text":"<p>Propagates the wavefront by performing a, inverse 2-sided Matrix Fourier Transform. TODO: Add link to Soumer et al. 2007(?).</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output wavefront.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the output wavefront.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def IMFT(self: Wavefront,\n         npixels: int,\n         pixel_scale: Array,\n         focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing a, inverse 2-sided Matrix Fourier\n    Transform. TODO: Add link to Soumer et al. 2007(?).\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output wavefront.\n    pixel_scale : Array\n        The pixel scale of the output wavefront.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units = self._MFT_output(focal_length, inverse=True)\n    phasor = self._MFT(npixels, pixel_scale, focal_length, inverse=True)\n\n    # Return new wavefront\n    pixel_scale = np.array(pixel_scale)  # Allow float input\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.MFT","title":"<code>MFT(npixels, pixel_scale, focal_length=None)</code>","text":"<p>Propagates the wavefront by performing a 2-sided Matrix Fourier Transform. TODO: Add link to Soumer et al. 2007(?).</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output wavefront.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the output wavefront.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def MFT(self: Wavefront,\n        npixels: int,\n        pixel_scale: Array,\n        focal_length: Array = None) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing a 2-sided Matrix Fourier\n    Transform. TODO: Add link to Soumer et al. 2007(?).\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output wavefront.\n    pixel_scale : Array\n        The pixel scale of the output wavefront.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units = self._MFT_output(focal_length)\n    phasor = self._MFT(npixels, pixel_scale, focal_length)\n\n    # Return new wavefront\n    pixel_scale = np.array(pixel_scale)  # Allow float input\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__add__","title":"<code>__add__(other)</code>","text":"<p>Magic method used to give a simple API for interaction with different layer types and arrays. If the input 'other' in an array it is treated as an array of OPD values and is added to the wavefront. If it is an Aberration, the wavefront is passed to the layer and the output wavefront is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array or Aberration</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def __add__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n    Magic method used to give a simple API for interaction with different\n    layer types and arrays. If the input 'other' in an array it is treated\n    as an array of OPD values and is added to the wavefront. If it is an\n    Aberration, the wavefront is passed to the layer and the output\n    wavefront is returned.\n\n    Parameters\n    ----------\n    other : Array or Aberration\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    # None Type\n    if other is None:\n        return self\n\n    # Some Optical Layer\n    if isinstance(other, OpticalLayer()):\n        return other(self)\n\n    # Array based inputs - Defaults to OPD\n    if isinstance(other, (Array, float, int)):\n        return self.add_opd(other)\n\n    # Other\n    else:\n        raise TypeError(\"Can only add an array or OpticalLayer to \"\n                        f\"Wavefront. Got: {type(other)}.\")\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Magic method used to give a simple API for interaction with different layer types and arrays. If the input 'other' in an array it is treated as an array of OPD values and is added to the wavefront. If it is an Aberration, the wavefront is passed to the layer and the output wavefront is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array or Aberration</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n    Magic method used to give a simple API for interaction with different\n    layer types and arrays. If the input 'other' in an array it is treated\n    as an array of OPD values and is added to the wavefront. If it is an\n    Aberration, the wavefront is passed to the layer and the output\n    wavefront is returned.\n\n    Parameters\n    ----------\n    other : Array or Aberration\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__imul__","title":"<code>__imul__(other)</code>","text":"<p>Magic method used to give a simple API for interaction with different layer types and arrays. If the input 'other' in an array it is treated as an array of transmission values and is multiplied by the wavefront amplitude. If it is an Aperture, Aberration, or Propagator, the wavefront is passed to the layer and the output wavefront is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array or Aberration or Aperture or Propagator</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n    Magic method used to give a simple API for interaction with different\n    layer types and arrays. If the input 'other' in an array it is treated\n    as an array of transmission values and is multiplied by the wavefront\n    amplitude. If it is an Aperture, Aberration, or Propagator, the\n    wavefront is passed to the layer and the output wavefront is returned.\n\n    Parameters\n    ----------\n    other : Array or Aberration or Aperture or Propagator\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"<code>__init__(npixels, diameter, wavelength)</code>","text":"<p>Constructor for the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p> required <code>diameter</code> <code>float, metres</code> <p>The physical dimensions of each square pixel.</p> required <code>wavelength</code> <code>float, metres</code> <p>The wavelength of the <code>Wavefront</code>.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self: Wavefront,\n             npixels: int,\n             diameter: Array,\n             wavelength: Array):\n\"\"\"\n    Constructor for the wavefront.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels that represent the `Wavefront`.\n    diameter : float, metres\n        The physical dimensions of each square pixel.\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    \"\"\"\n    self.wavelength = np.asarray(wavelength, dtype=float)\n    self.pixel_scale = np.asarray(diameter / npixels, dtype=float)\n    self.amplitude = np.ones((npixels, npixels), dtype=float)\n    self.phase = np.zeros((npixels, npixels), dtype=float)\n\n    # Input checks\n    if self.wavelength.shape != ():\n        raise ValueError(\"wavelength must have shape ().\")\n    if self.diameter.shape != ():\n        raise ValueError(\"diameter must have shape ().\")\n\n    # Always initialised in Pupil plane with Cartesian Coords\n    self.plane = 'Pupil'\n    self.units = 'Cartesian'\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Magic method used to give a simple API for interaction with different layer types and arrays. If the input 'other' in an array it is treated as an array of transmission values and is multiplied by the wavefront amplitude. If it is an Aperture, Aberration, or Propagator, the wavefront is passed to the layer and the output wavefront is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array or Aberration or Aperture or Propagator</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:\n\"\"\"\n    Magic method used to give a simple API for interaction with different\n    layer types and arrays. If the input 'other' in an array it is treated\n    as an array of transmission values and is multiplied by the wavefront\n    amplitude. If it is an Aperture, Aberration, or Propagator, the\n    wavefront is passed to the layer and the output wavefront is returned.\n\n    Parameters\n    ----------\n    other : Array or Aberration or Aperture or Propagator\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    # None Type, return None\n    if other is None:\n        return self\n\n    # Some Optical Layer, apply it\n    if isinstance(other, OpticalLayer()):\n        return other(self)\n\n    # Array based inputs\n    if isinstance(other, (Array, float, int)):\n\n        # Complex array - Multiply the phasors\n        if isinstance(other, Array) and other.dtype.kind == 'c':\n            phasor = self.phasor * other\n            return self.set([\"amplitude\", \"phase\"],\n                            [np.abs(phasor), np.angle(phasor)])\n\n        # Scalar array - Multiply amplitude\n        else:\n            return self.multiply('amplitude', other)\n\n    # Other\n    else:\n        raise TypeError(\"Can only multiply Wavefront by array or \"\n                        f\"OpticalLayer. Got: {type(other)}.\")\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"<code>add_opd(path_difference)</code>","text":"<p>Applies the wavelength-dependent phase based on the supplied optical path difference.</p> <p>Parameters:</p> Name Type Description Default <code>path_difference</code> <code>Array, metres</code> <p>The physical optical path difference of either the entire wavefront or each pixel individually.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phases updated according to the supplied path_difference</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def add_opd(self: Wavefront, path_difference: Array) -&gt; Wavefront:\n\"\"\"\n    Applies the wavelength-dependent phase based on the supplied optical\n    path difference.\n\n    Parameters\n    ----------\n    path_difference : Array, metres\n        The physical optical path difference of either the entire wavefront\n        or each pixel individually.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the phases updated according to the supplied\n        path_difference\n    \"\"\"\n    phase_difference = self.wavenumber * path_difference\n    return self.add('phase', phase_difference)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"<code>add_phase(phase)</code>","text":"<p>Applies input array to the phase of the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phase to be added to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with updated phases.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:\n\"\"\"\n    Applies input array to the phase of the wavefront.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be added to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with updated phases.\n    \"\"\"\n    # Add this extra None check to allow PhaseOptics to have a None phase\n    # and still be able to be 'added' to it, making this the phase \n    # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`\n    if phase is not None:\n        return self.add('phase', phase)\n    return self\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.crop_to","title":"<code>crop_to(npixels)</code>","text":"<p>Paraxially crops the <code>Wavefront</code> to the size determined by npixels. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to odd dimension, i.e. 4 -&gt; 2 or 5 -&gt; 3.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The size of the array to crop to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> cropped to the size npixels.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def crop_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n    Paraxially crops the `Wavefront` to the size determined by npixels.\n    Note this only supports padding arrays of even dimension to even\n    dimension, and odd dimension to odd dimension, i.e. 4 -&gt; 2 or 5 -&gt; 3.\n\n    Parameters\n    ----------\n    npixels : int\n        The size of the array to crop to the wavefront to.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` cropped to the size npixels.\n    \"\"\"\n    npixels_in = self.npixels\n\n    if npixels_in % 2 != npixels % 2:\n        raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n    if npixels &gt; npixels_in:\n        raise ValueError(\"npixels must be smaller than the current array \"\n                         \"size: {}\".format(npixels_in))\n\n    new_centre = npixels_in // 2\n    centre = npixels // 2\n\n    amplitude = self.amplitude[\n                new_centre - centre: new_centre + centre,\n                new_centre - centre: new_centre + centre]\n    phase = self.phase[\n            new_centre - centre: new_centre + centre,\n            new_centre - centre: new_centre + centre]\n\n    return self.set(['amplitude', 'phase'], [amplitude, phase])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.flip","title":"<code>flip(axis)</code>","text":"<p>Flips the amplitude and phase of the wavefront along the specified axes.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>tuple</code> <p>The axes along which to flip the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the flipped amplitude and phase.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:\n\"\"\"\n    Flips the amplitude and phase of the wavefront along the specified axes.\n\n    Parameters\n    ----------\n    axis : tuple\n        The axes along which to flip the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the flipped amplitude and phase.\n    \"\"\"\n    field = self._to_field()\n    flipper = vmap(np.flip, (0, None))\n    amplitude, phase = flipper(field, axis)\n    return self.set(['amplitude', 'phase'], [amplitude, phase])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the total power of the wavefront to 1.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the normalised electric field amplitudes.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def normalise(self: Wavefront) -&gt; Wavefront:\n\"\"\"\n    Normalises the total power of the wavefront to 1.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the normalised electric field amplitudes.\n    \"\"\"\n    return self.divide('amplitude', np.linalg.norm(self.amplitude))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pad_to","title":"<code>pad_to(npixels)</code>","text":"<p>Paraxially zero-pads the <code>Wavefront</code> to the size determined by npixels. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to odd dimension, i.e. 2 -&gt; 4 or 3 -&gt; 5.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The size of the array to pad to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> zero-padded to the size npixels.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def pad_to(self: Wavefront, npixels: int) -&gt; Wavefront:\n\"\"\"\n    Paraxially zero-pads the `Wavefront` to the size determined by\n    npixels. Note this only supports padding arrays of even dimension\n    to even dimension, and odd dimension to odd dimension, i.e. 2 -&gt; 4 or\n    3 -&gt; 5.\n\n    Parameters\n    ----------\n    npixels : int\n        The size of the array to pad to the wavefront to.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` zero-padded to the size npixels.\n    \"\"\"\n    npixels_in = self.npixels\n    if npixels_in % 2 != npixels % 2:\n        raise ValueError(\"Only supports even -&gt; even or odd -&gt; odd input.\")\n    if npixels &lt; npixels_in:\n        raise ValueError(\"npixels must be larger than the current array \"\n                         \"size: {}\".format(npixels_in))\n\n    new_centre = npixels // 2\n    centre = npixels_in // 2\n    remainder = npixels_in % 2\n    padded = np.zeros([npixels, npixels])\n\n    amplitude = padded.at[\n                new_centre - centre: centre + new_centre + remainder,\n                new_centre - centre: centre + new_centre + remainder\n                ].set(self.amplitude)\n    phase = padded.at[\n            new_centre - centre: centre + new_centre + remainder,\n            new_centre - centre: centre + new_centre + remainder\n            ].set(self.phase)\n    return self.set(['amplitude', 'phase'], [amplitude, phase])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"<code>rotate(angle, order=1, complex=False)</code>","text":"<p>Performs a paraxial rotation on the wavefront, determined by the angle parameter, using interpolation. The transformation is done on the amplitude and phase arrays, but can be done on the real and imaginary components by passing <code>complex=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in a clockwise direction.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use.</p> <code>1</code> <code>complex</code> <code>bool = False</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront rotated by angle in the clockwise direction.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def rotate(self: Wavefront,\n           angle: Array,\n           order: int = 1,\n           complex: bool = False) -&gt; Wavefront:\n\"\"\"\n    Performs a paraxial rotation on the wavefront, determined by the\n    angle parameter, using interpolation. The transformation is done\n    on the amplitude and phase arrays, but can be done on the real and\n    imaginary components by passing `complex=True`.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in a clockwise direction.\n    order : int = 1\n        The interpolation order to use.\n    complex : bool = False\n        Whether to rotate the real and imaginary representation of the\n        wavefront as opposed to the amplitude and phase representation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront rotated by angle in the clockwise direction.\n    \"\"\"\n    # Get field in either (amplitude, phase) or (real, imaginary)\n    field = self._to_field(complex=complex)\n\n    # Rotate the field\n    rotator = vmap(dlu.rotate, (0, None, None))\n    field = rotator(field, angle, order)\n\n    # Cast back to (amplitude, phase) if needed\n    if complex:\n        field = self._to_amplitude_phase(field)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase'], [field[0], field[1]])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.scale_to","title":"<code>scale_to(npixels, pixel_scale, complex=False)</code>","text":"<p>Performs a paraxial interpolation on the wavefront, determined by the pixel_scale_out and npixels parameters. The transformation is done on the amplitude and phase arrays, but can be done on the real and imaginary components by passing <code>complex=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels representing the wavefront after the interpolation.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the array after the interpolation.</p> required <code>complex</code> <code>bool = False</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront interpolated to the size and shape determined by npixels and pixel_scale_out, with the updated pixel_scale.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def scale_to(self: Wavefront,\n             npixels: int,\n             pixel_scale: Array,\n             complex: bool = False) -&gt; Wavefront:\n\"\"\"\n    Performs a paraxial interpolation on the wavefront, determined by the\n    pixel_scale_out and npixels parameters. The transformation is done\n    on the amplitude and phase arrays, but can be done on the real and\n    imaginary components by passing `complex=True`.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels representing the wavefront after the\n        interpolation.\n    pixel_scale: Array\n        The pixel scale of the array after the interpolation.\n    complex : bool = False\n        Whether to rotate the real and imaginary representation of the\n        wavefront as opposed to the amplitude and phase representation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront interpolated to the size and shape determined by\n        npixels and pixel_scale_out, with the updated pixel_scale.\n    \"\"\"\n    # Get field in either (amplitude, phase) or (real, imaginary)\n    field = self._to_field(complex=complex)\n\n    # Scale the field\n    scaler = vmap(dlu.scale, (0, None, None))\n    field = scaler(field, npixels, pixel_scale / self.pixel_scale)\n\n    # Cast back to (amplitude, phase) if needed\n    if complex:\n        field = self._to_amplitude_phase(field)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase'], [field[0], field[1]])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.shifted_IMFT","title":"<code>shifted_IMFT(npixels, pixel_scale, shift, focal_length=None, pixel=True)</code>","text":"<p>Propagates the wavefront by performing a, Inverse 2-sided Matrix Fourier Transform with a shift in the center of the output plane. TODO: Add link to Soumer et al. 2007(?), </p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output wavefront.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the output wavefront.</p> required <code>shift</code> <code>Array</code> <p>The shift in the center of the output plane.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <code>pixel</code> <code>bool = True</code> <p>Whether the shift is in pixels or the units of pixel_scale.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def shifted_IMFT(self: Wavefront,\n                 npixels: int,\n                 pixel_scale: Array,\n                 shift: Array,\n                 focal_length: Array = None,\n                 pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing a, Inverse 2-sided Matrix Fourier\n    Transform with a shift in the center of the output plane.\n    TODO: Add link to Soumer et al. 2007(?), \n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output wavefront.\n    pixel_scale : Array\n        The pixel scale of the output wavefront.\n    shift : Array\n        The shift in the center of the output plane.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n    pixel : bool = True\n        Whether the shift is in pixels or the units of pixel_scale.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units = self._MFT_output(focal_length, inverse=True)\n    shift = shift if pixel else shift / pixel_scale\n    phasor = self._MFT(npixels, pixel_scale, focal_length, shift,\n                       inverse=True)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.shifted_MFT","title":"<code>shifted_MFT(npixels, pixel_scale, shift, focal_length=None, pixel=True)</code>","text":"<p>Propagates the wavefront by performing a 2-sided Matrix Fourier Transform with a shift in the center of the output plane. TODO: Add link to Soumer et al. 2007(?), </p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output wavefront.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the output wavefront.</p> required <code>shift</code> <code>Array</code> <p>The shift in the center of the output plane.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the propagation. If None, the propagation is treated as an 'angular' propagation, else it is treated as a 'Cartesian' propagation.</p> <code>None</code> <code>pixel</code> <code>bool = True</code> <p>Whether the shift is in pixels or the units of pixel_scale.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def shifted_MFT(self: Wavefront,\n                npixels: int,\n                pixel_scale: Array,\n                shift: Array,\n                focal_length: Array = None,\n                pixel: bool = True) -&gt; Wavefront:\n\"\"\"\n    Propagates the wavefront by performing a 2-sided Matrix Fourier\n    Transform with a shift in the center of the output plane.\n    TODO: Add link to Soumer et al. 2007(?), \n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output wavefront.\n    pixel_scale : Array\n        The pixel scale of the output wavefront.\n    shift : Array\n        The shift in the center of the output plane.\n    focal_length : Array = None\n        The focal length of the propagation. If None, the propagation is\n        treated as an 'angular' propagation, else it is treated as a\n        'Cartesian' propagation.\n    pixel : bool = True\n        Whether the shift is in pixels or the units of pixel_scale.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate\n    plane, units = self._MFT_output(focal_length)\n    shift = shift if pixel else shift / pixel_scale\n    phasor = self._MFT(npixels, pixel_scale, focal_length, shift)\n\n    # Return new wavefront\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.tilt","title":"<code>tilt(angles)</code>","text":"<p>Tilts the wavefront by the angles in the (x, y) by modifying the  phase arrays.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The tilted wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:\n\"\"\"\n    Tilts the wavefront by the angles in the (x, y) by modifying the \n    phase arrays.\n\n    Parameters\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The tilted wavefront.\n    \"\"\"\n    if not isinstance(angles, Array) or angles.shape != (2,):\n        raise ValueError(\"angles must be an array of shape (2,).\")\n    opd = - (angles[:, None, None] * self.coordinates).sum(0)\n    return self.add_opd(opd)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.coordinates","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-units-check","title":"TODO Units check","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-possibly-output-in-unit-based-on-units-attribute","title":"TODO Possibly output in unit based on units attribute","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.fringe_size--todo-make-methods-use-this","title":"TODO make methods use this","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.real","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.FFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.IFFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.IMFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.MFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__add__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__iadd__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__imul__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__mul__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.crop_to","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.flip","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pad_to","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.scale_to","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.shifted_IMFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.shifted_MFT","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.tilt","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#operators","title":"Operators","text":"<p>The wavefront classes contain a series of methods that allow for the manipulation and propagation of the wavefront. It also has a series of operators that allow for the manipulation of the wavefront via standard arithmetic operators, i.e.:</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\nnpixels = 16\ndiameter = 1 # metres\nwavelength = 1e-6 # metres\n\nwf = dl.Wavefront(npixels, diameter, wavelength)\n\n# Multiply to modify the amplitude\nwf *= 0.5 # Halves the amplitude\n\n# Multiply by complex array to transform both amplitude and phase\nwf *= np.ones((npixels, npixels)) * np.exp(1j * np.zeros((npixels, npixels)))\n\n# Multiply or Add by OpticalLayer to apply it\naperture = dl.ApertureFactory(16)\nwf *= aperture\nwf += aperture\n\n# Add to modify the phase through OPD units\nwf += 1 # Adds 1m of OPD across full wavefront\n</code></pre>"},{"location":"docs/API/wavefronts/#property-methods","title":"Property Methods","text":"<p>The <code>Wavefront</code> classes also have a series of property methods for ease of use:</p> <p><code>diameter</code> Returns the current wavefront diameter calculated with the pixel scale and number of pixels.</p> <p><code>npixels</code> Returns the side length of the arrays currently representing the wavefront. Taken from the last axis of the amplitude array.</p> <p><code>real</code> Returns the real component of the <code>Wavefront</code>.</p> <p><code>imaginary</code> Returns the imaginary component of the <code>Wavefront</code>.</p> <p><code>phasor</code> Returns the electric field phasor described by the <code>Wavefront</code> in complex form.</p> <p><code>psf</code> Calculates the Point Spread Function (PSF), i.e. the squared modulus of the complex wavefront.</p> <p><code>coordinates</code> Returns the physical positions of the wavefront pixels in metres.</p> <p><code>wavenumber</code> Returns the wavenumber of the wavefront (\\(2\\pi/\\lambda\\)).</p> <p><code>fringe_size</code> Returns the size of the fringes in angular units, i.e \\(\\lambda/D\\).</p>"},{"location":"docs/API/wavefronts/#general-methods","title":"General Methods","text":"<p>On top of these, the wavefront classes implement a number of methods that allow for the manipulation of the image:</p> <p><code>add_opd(opd)</code> Applies the input array as an OPD to the wavefront.</p> <p><code>add_phase(phase)</code> Applies input array to the phase of the wavefront.</p> <p><code>tilt(angles)</code> Tilts the wavefront by the angles in \\((x, y)\\), by modifying the phase arrays.</p> <p><code>normalise()</code> Normalises the total wavefront power to unity.</p> <p><code>flip(axis)</code> Flips the amplitude and phase of the wavefront along the specified axes.</p> <p><code>scale_to(npixels, pixel_scale)</code> Performs a paraxial interpolation on the wavefront, determined by the <code>pixel_scale</code> and <code>npixels</code> parameters.</p> <p><code>rotate(angle)</code> Performs a paraxial rotation on the wavefront, determined by the <code>angle</code> parameter, using interpolation.</p> <p><code>pad_to(npixels)</code> Paraxially zero-pads the <code>Wavefront</code> to the size determined by <code>npixels</code>. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to odd dimension, e.g. \\(2 \\rightarrow 4\\) or \\(3 \\rightarrow 5\\).</p> <p><code>crop_to(npixels)</code> Paraxially crops the <code>Wavefront</code> to the size determined by <code>npixels</code>. Note this only supports cropping arrays of even dimension to even dimension, and odd dimension to odd dimension, e.g. \\(4 \\rightarrow 2\\) or \\(5 \\rightarrow 3\\).</p>"},{"location":"docs/API/wavefronts/#propagator-methods","title":"Propagator Methods","text":"<p><code>Wavefront</code> objects also have methods used to propagate them between planes. These methods are:</p> <p><code>FFT(pad, focal_length=None)</code> Performs a Fast Fourier Transform (FFT) on the wavefront, propagating from Pupil to Focal plane. If the <code>focal_length</code> is None, the output units will angular, otherwise Cartesian.</p> <p><code>IFFT(pad, focal_length=None)</code> Performs an Inverse Fast Fourier Transform (IFFT) on the wavefront, propagating from Focal to Pupil plane.</p> <p><code>MFT(npixels, pixel_scale, focal_length=None)</code> Performs a Matrix Fourier Transform (MFT) on the wavefront, propagating from Pupil to Focal plane. If the <code>focal_length</code> is None, the <code>pixel_scale</code> is assumed to be in angular units (radians), otherwise it is assumed to be in Cartesian units (metres).</p> <p><code>IMFT(npixels, pixel_scale, focal_length=None)</code> Performs an Inverse Matrix Fourier Transform (IMFT) on the wavefront, propagating from Focal to Pupil plane.</p> <p><code>shifted_MFT(npixels, pixel_scale, shift, focal_length=None, pixel=True)</code> Performs a Matrix Fourier Transform (MFT) on the wavefront, propagating from Pupil to Focal plane. If the <code>focal_length</code> is None, the <code>pixel_scale</code> is assumed to be in angular units (radians), otherwise it is assumed to be in Cartesian units (meters). The <code>shift</code> parameter is used to shift the center of the output plane, which is treated in units of pixels by default, otherwise it is treated in the units of the <code>pixel_scale</code>.</p> <p><code>shifted_IMFT(npixels, pixel_scale, shift, focal_length=None, pixel=True)</code> Performs an Inverse Matrix Fourier Transform (IMFT) on the wavefront, propagating from Focal to Pupil plane. The <code>shift</code> parameter is used to shift the center of the output plane, which is treated in units of pixels by default, otherwise it is treated in the units of the <code>pixel_scale</code>.</p>"},{"location":"docs/API/wavefronts/#fresnel-wavefront","title":"Fresnel Wavefront","text":"<p>The <code>FresnelWavefront</code> class is a subclass of the <code>Wavefront</code>, implementing the methods required to perform a FarFieldFresnel propagation (i.e., close to the focal plane). It implements two more methods that are essential extensions of the MFT methods. This class only implements Cartesian propagation and only propagates from the Pupil plane to the Focal plane.</p> Fresnel Wavefront API <p>         Bases: <code>Wavefront</code></p> <p>A class to represent a wavefront that can be propagated to a Far Field Fresnel plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, metres</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, metres/pixel</code> <p>The physical dimensions of each square pixel.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane</code> <code>str</code> <p>The current plane of wavefront, can be Pupil, Focal, or Intermediate.</p> required <code>units</code> <code>str</code> <p>The units of the wavefront, can be 'Cartesian' or 'Angular'.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>class FresnelWavefront(Wavefront):\n\"\"\"\n    A class to represent a wavefront that can be propagated to a Far Field\n    Fresnel plane.\n\n    Parameters\n    ----------\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, metres/pixel\n        The physical dimensions of each square pixel.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane : str\n        The current plane of wavefront, can be Pupil, Focal, or Intermediate.\n    units : str\n        The units of the wavefront, can be 'Cartesian' or 'Angular'.\n    \"\"\"\n\n    def __init__(self: Wavefront,\n                 npixels: int,\n                 diameter: Array,\n                 wavelength: Array) -&gt; Wavefront:\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : float, metres/pixel\n            The physical dimensions of each square pixel.\n        wavelength : float, metres\n            The wavelength of the `Wavefront`.\n        \"\"\"\n        super().__init__(\n            npixels=npixels,\n            wavelength=wavelength,\n            diameter=diameter,\n        )\n\n    def _nfringes(self: Wavefront,\n                  npixels: int,\n                  pixel_scale: Array,\n                  focal_shift: Array,\n                  focal_length: Array) -&gt; Array:\n\"\"\"\n        Calculates the number of fringes in the output plane.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        focal_length : Array, metres\n            The focal length of the lens.\n\n        Returns\n        -------\n        nfringes : Array\n            The number of fringes in the output plane.\n        \"\"\"\n        propagation_distance = focal_length + focal_shift\n        output_size = npixels * pixel_scale\n\n        # # Angular - Not Implemented\n        # if focal_length is None:\n        #     return output_size / self.fringe_size\n\n        # Cartesian\n        return output_size / (self.fringe_size * propagation_distance)\n\n    # Move to utils as thinlens?\n    def quadratic_phase(self: Wavefront,\n                        x_coordinates: Array,\n                        y_coordinates: Array,\n                        distance: Array) -&gt; Array:\n\"\"\"\n        A convenience function for calculating quadratic phase factors.\n\n        Parameters\n        ----------\n        x_coordinates : Array, metres\n            The x coordinates of the pixels. This will be different\n            in the plane of propagation and the initial plane.\n        y_coordinates : Array, metres\n            The y coordinates of the pixels. This will be different\n            in the plane of propagation and the initial plane.\n        distance : Array, metres\n            The distance that is to be propagated.\n\n        Returns\n        -------\n        quadratic_phase : Array\n            A set of phase factors that are useful in optical calculations.\n        \"\"\"\n        r_coordinates = np.hypot(x_coordinates, y_coordinates)\n        return np.exp(0.5j * self.wavenumber * r_coordinates ** 2 / distance)\n\n    def transfer_function(self: Wavefront,\n                          distance: Array) -&gt; Array:\n\"\"\"\n        The Optical Transfer Function defining the phase evolution of the\n        wavefront when propagating to a non-conjugate plane.\n\n        Parameters\n        ----------\n        distance : Array, metres\n            The distance that is being propagated in metres.\n\n        Returns\n        -------\n        field : Array\n            The field that represents the optical transfer.\n        \"\"\"\n        return np.exp(1.0j * self.wavenumber * distance)\n\n    def _transfer_matrix(self: Wavefront,\n                         npixels: int,\n                         pixel_scale: Array,\n                         focal_shift: Array,\n                         focal_length: Array,\n                         shift: Array = 0.) -&gt; Array:\n\"\"\"\n        Calculates the transfer matrix for the MFT.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        focal_length : Array, metres\n            The focal length of the lens.\n        shift : Array = 0., metres\n            The shift to apply to the output plane.\n\n        Returns\n        -------\n        transfer_matrix : Array\n            The transfer matrix for the MFT.\n        \"\"\"\n        scale_in = 1.0 / self.npixels\n        scale_out = self._nfringes(npixels, pixel_scale, focal_shift,\n                                   focal_length) / npixels\n        in_vec = dlu.pixel_coordinates(self.npixels, scale_in, shift * scale_in)\n        out_vec = dlu.pixel_coordinates(npixels, scale_out, shift * scale_out)\n\n        if self.plane == 'Pupil':\n            return np.exp(2j * np.pi * np.outer(in_vec, out_vec))\n        else:\n            raise ValueError(f\"plane must be 'Pupil' Got {self.plane}\")\n\n        # elif self.plane == 'Focal':\n        #     return np.exp(-2j * np.pi * np.outer(in_vec, out_vec))\n\n    def _MFT(self: Wavefront,\n             phasor: Array,\n             npixels: int,\n             pixel_scale: Array,\n             focal_length: Array,\n             focal_shift: Array,\n             shift: Array = np.zeros(2)) -&gt; Array:\n\"\"\"\n        Performs the MFT.\n\n        Parameters\n        ----------\n        phasor : Array\n            The phasor to be propagated.\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n        shift : Array = np.zeros(2), metres\n            The shift to apply to the output plane.\n\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        # Set up\n        nfringes = self._nfringes(npixels, pixel_scale, focal_shift,\n                                  focal_length)\n        x_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,\n                                         focal_length, shift[0])\n        y_matrix = self._transfer_matrix(npixels, pixel_scale, focal_shift,\n                                         focal_length, shift[1]).T\n\n        # Perform and normalise\n        phasor = (y_matrix @ phasor) @ x_matrix\n        phasor *= np.exp(np.log(nfringes) - \\\n                         (np.log(self.npixels) + np.log(npixels)))\n        return phasor\n\n    def _phase_factors(self: Wavefront,\n                       npixels: int,\n                       pixel_scale: Array,\n                       focal_length: Array,\n                       focal_shift: Array) -&gt; tuple:\n\"\"\"\n        Calculates the phase factors for the Fresnel propagation.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n\n        Returns\n        -------\n        first_factor : Array\n            The first factor in the Fresnel propagation.\n        second_factor : Array\n            The second factor in the Fresnel propagation.\n        third_factor : Array\n            The third factor in the Fresnel propagation.\n        fourth_factor : Array\n            The fourth factor in the Fresnel propagation.\n        \"\"\"\n        # Coordinates\n        prop_dist = focal_length + focal_shift\n        input_positions = self.coordinates\n        output_positions = dlu.pixel_coords(npixels, pixel_scale)\n\n        # Calculate phase values\n        first_factor = self.quadratic_phase(*input_positions, -focal_length)\n        second_factor = self.quadratic_phase(*input_positions, prop_dist)\n        third_factor = self.transfer_function(prop_dist)\n        fourth_factor = self.quadratic_phase(*output_positions, prop_dist)\n        return first_factor, second_factor, third_factor, fourth_factor\n\n    def fresnel_prop(self: Wavefront,\n                     npixels: int,\n                     pixel_scale: Array,\n                     focal_length: Array,\n                     focal_shift: Array) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Fresnel Transform using a Matrix Fourier Transform.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : Array, metres/pixel\n            The physical dimensions of each square pixel.\n        focal_length : Array, metres\n            The focal length of the lens.\n        focal_shift : Array, metres\n            The distance the focal plane is shifted from the focal length.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # Calculate phase values\n        first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                           focal_length, focal_shift)\n\n        # Apply phases\n        phasor = self.phasor\n        phasor *= first\n        phasor *= second\n\n        # Propagate\n        phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                           focal_shift)\n\n        # Apply phases\n        phasor *= third\n        phasor *= fourth\n\n        # Update\n        pixel_scale = np.array(pixel_scale)\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                         'Cartesian'])\n\n    def shifted_fresnel_prop(self: Wavefront,\n                             npixels: int,\n                             pixel_scale: Array,\n                             shift: Array,\n                             focal_length: Array,\n                             focal_shift: Array,\n                             pixel: bool = True) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Fresnel Transform using a Matrix Fourier Transform with a shift in\n        the center of the output plane.\n        TODO: Add link to Soumer et al. 2007(?), \n        \"\"\"\n        # Get shift\n        shift = shift if pixel else shift / pixel_scale\n\n        # Calculate phase values\n        first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                           focal_length, focal_shift)\n\n        # Apply phases\n        phasor = self.phasor\n        phasor *= first\n        phasor *= second\n\n        # Propagate\n        phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                           focal_shift, shift)\n\n        # Apply phases\n        phasor *= third\n        phasor *= fourth\n\n        # Update\n        pixel_scale = np.array(pixel_scale)\n        return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                        [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                         'Cartesian'])\n</code></pre> <p><code>fresnel_prop(npixels, pixel_scale, focal_length, focal_shift)</code> Performs a Fresnel propagation on the wavefront, propagating from Pupil to Focal plane. The <code>focal_shift</code> parameter represents the distance from the focal plane at which the PSF is modelled.</p> <p><code>shifted_fresnel_prop(npixels pixel_scale, shift, focal_length, focal_shift, pixel=True)</code> Performs a Fresnel propagation on the wavefront, propagating from Pupil to Focal plane. The <code>focal_shift</code> parameter represents the distance from the focal plane at which the PSF is modelled. The shift parameter is used to shift the center of the output plane, which is treated in units of pixels by default, otherwise it is treated in the units of the <code>pixel_scale</code>.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.__init__","title":"<code>__init__(npixels, diameter, wavelength)</code>","text":"<p>Constructor for the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, metres/pixel</code> <p>The physical dimensions of each square pixel.</p> required <code>wavelength</code> <code>float, metres</code> <p>The wavelength of the <code>Wavefront</code>.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self: Wavefront,\n             npixels: int,\n             diameter: Array,\n             wavelength: Array) -&gt; Wavefront:\n\"\"\"\n    Constructor for the wavefront.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels that represent the `Wavefront`.\n    pixel_scale : float, metres/pixel\n        The physical dimensions of each square pixel.\n    wavelength : float, metres\n        The wavelength of the `Wavefront`.\n    \"\"\"\n    super().__init__(\n        npixels=npixels,\n        wavelength=wavelength,\n        diameter=diameter,\n    )\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.fresnel_prop","title":"<code>fresnel_prop(npixels, pixel_scale, focal_length, focal_shift)</code>","text":"<p>Propagates the wavefront from the input plane to the output plane using a Fresnel Transform using a Matrix Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>Array, metres/pixel</code> <p>The physical dimensions of each square pixel.</p> required <code>focal_length</code> <code>Array, metres</code> <p>The focal length of the lens.</p> required <code>focal_shift</code> <code>Array, metres</code> <p>The distance the focal plane is shifted from the focal length.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def fresnel_prop(self: Wavefront,\n                 npixels: int,\n                 pixel_scale: Array,\n                 focal_length: Array,\n                 focal_shift: Array) -&gt; Array:\n\"\"\"\n    Propagates the wavefront from the input plane to the output plane using\n    a Fresnel Transform using a Matrix Fourier Transform.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : Array, metres/pixel\n        The physical dimensions of each square pixel.\n    focal_length : Array, metres\n        The focal length of the lens.\n    focal_shift : Array, metres\n        The distance the focal plane is shifted from the focal length.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # Calculate phase values\n    first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                       focal_length, focal_shift)\n\n    # Apply phases\n    phasor = self.phasor\n    phasor *= first\n    phasor *= second\n\n    # Propagate\n    phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                       focal_shift)\n\n    # Apply phases\n    phasor *= third\n    phasor *= fourth\n\n    # Update\n    pixel_scale = np.array(pixel_scale)\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                     'Cartesian'])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.quadratic_phase","title":"<code>quadratic_phase(x_coordinates, y_coordinates, distance)</code>","text":"<p>A convenience function for calculating quadratic phase factors.</p> <p>Parameters:</p> Name Type Description Default <code>x_coordinates</code> <code>Array, metres</code> <p>The x coordinates of the pixels. This will be different in the plane of propagation and the initial plane.</p> required <code>y_coordinates</code> <code>Array, metres</code> <p>The y coordinates of the pixels. This will be different in the plane of propagation and the initial plane.</p> required <code>distance</code> <code>Array, metres</code> <p>The distance that is to be propagated.</p> required <p>Returns:</p> Name Type Description <code>quadratic_phase</code> <code>Array</code> <p>A set of phase factors that are useful in optical calculations.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def quadratic_phase(self: Wavefront,\n                    x_coordinates: Array,\n                    y_coordinates: Array,\n                    distance: Array) -&gt; Array:\n\"\"\"\n    A convenience function for calculating quadratic phase factors.\n\n    Parameters\n    ----------\n    x_coordinates : Array, metres\n        The x coordinates of the pixels. This will be different\n        in the plane of propagation and the initial plane.\n    y_coordinates : Array, metres\n        The y coordinates of the pixels. This will be different\n        in the plane of propagation and the initial plane.\n    distance : Array, metres\n        The distance that is to be propagated.\n\n    Returns\n    -------\n    quadratic_phase : Array\n        A set of phase factors that are useful in optical calculations.\n    \"\"\"\n    r_coordinates = np.hypot(x_coordinates, y_coordinates)\n    return np.exp(0.5j * self.wavenumber * r_coordinates ** 2 / distance)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.shifted_fresnel_prop","title":"<code>shifted_fresnel_prop(npixels, pixel_scale, shift, focal_length, focal_shift, pixel=True)</code>","text":"<p>Propagates the wavefront from the input plane to the output plane using a Fresnel Transform using a Matrix Fourier Transform with a shift in the center of the output plane. TODO: Add link to Soumer et al. 2007(?),</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def shifted_fresnel_prop(self: Wavefront,\n                         npixels: int,\n                         pixel_scale: Array,\n                         shift: Array,\n                         focal_length: Array,\n                         focal_shift: Array,\n                         pixel: bool = True) -&gt; Array:\n\"\"\"\n    Propagates the wavefront from the input plane to the output plane using\n    a Fresnel Transform using a Matrix Fourier Transform with a shift in\n    the center of the output plane.\n    TODO: Add link to Soumer et al. 2007(?), \n    \"\"\"\n    # Get shift\n    shift = shift if pixel else shift / pixel_scale\n\n    # Calculate phase values\n    first, second, third, fourth = self._phase_factors(npixels, pixel_scale,\n                                                       focal_length, focal_shift)\n\n    # Apply phases\n    phasor = self.phasor\n    phasor *= first\n    phasor *= second\n\n    # Propagate\n    phasor = self._MFT(phasor, npixels, pixel_scale, focal_length,\n                       focal_shift, shift)\n\n    # Apply phases\n    phasor *= third\n    phasor *= fourth\n\n    # Update\n    pixel_scale = np.array(pixel_scale)\n    return self.set(['amplitude', 'phase', 'pixel_scale', 'plane', 'units'],\n                    [np.abs(phasor), np.angle(phasor), pixel_scale, 'Intermediate',\n                     'Cartesian'])\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.transfer_function","title":"<code>transfer_function(distance)</code>","text":"<p>The Optical Transfer Function defining the phase evolution of the wavefront when propagating to a non-conjugate plane.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>Array, metres</code> <p>The distance that is being propagated in metres.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The field that represents the optical transfer.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def transfer_function(self: Wavefront,\n                      distance: Array) -&gt; Array:\n\"\"\"\n    The Optical Transfer Function defining the phase evolution of the\n    wavefront when propagating to a non-conjugate plane.\n\n    Parameters\n    ----------\n    distance : Array, metres\n        The distance that is being propagated in metres.\n\n    Returns\n    -------\n    field : Array\n        The field that represents the optical transfer.\n    \"\"\"\n    return np.exp(1.0j * self.wavenumber * distance)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.fresnel_prop","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.quadratic_phase","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.shifted_fresnel_prop","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FresnelWavefront.transfer_function","title":"Wavefronts","text":""},{"location":"docs/API/utils/coordinates/","title":"Coordinates Utility Functions","text":"<p>This module contains a series of functions which are used to calculate coordinate arrays, apply transformations to coordinate arrays, and convert between Cartesian and polar coordinates.</p>"},{"location":"docs/API/utils/coordinates/#polar-to-cartesian","title":"Polar to Cartesian","text":"<p>Converts a polar coordinate array to Cartesian coordinates.</p> Polar to Cartesian API <p>Converts the input (r, phi) polar coordinates into (x, y) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (r, phi) polar coordinates to be converted into Cartesian coordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input polar coordinates converted into (x, y) Cartesian coordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def polar_to_cart(coordinates: Array) -&gt; Array:\n\"\"\"\n    Converts the input (r, phi) polar coordinates into (x, y) Cartesian\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (r, phi) polar coordinates to be converted into Cartesian\n        coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input polar coordinates converted into (x, y) Cartesian coordinates.\n    \"\"\"\n    r, phi = coordinates\n    return np.array([r * np.cos(phi), r * np.sin(phi)])\n</code></pre>"},{"location":"docs/API/utils/coordinates/#dLux.utils.coordinates.polar_to_cart","title":"Coordinates","text":""},{"location":"docs/API/utils/coordinates/#cartesian-to-polar","title":"Cartesian to Polar","text":"<p>Converts a Cartesian coordinate array to polar coordinates.</p> Cartesian to Polar API <p>Converts the input (x, y) Cartesian coordinates into (r, phi) polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (x, y) Cartesian coordinates to be converted into polar coordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input Cartesian coordinates converted into (r, phi) polar coordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def cart_to_polar(coordinates: Array) -&gt; Array:\n\"\"\"\n    Converts the input (x, y) Cartesian coordinates into (r, phi) polar\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (x, y) Cartesian coordinates to be converted into polar coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input Cartesian coordinates converted into (r, phi) polar\n        coordinates.\n    \"\"\"\n    x, y = coordinates\n    return np.array([np.hypot(x, y), np.arctan2(y, x)])\n</code></pre>"},{"location":"docs/API/utils/coordinates/#dLux.utils.coordinates.cart_to_polar","title":"Coordinates","text":""},{"location":"docs/API/utils/coordinates/#pixel-coords","title":"Pixel Coords","text":"<p>Calculates the coordinates of the pixel centers for the given input,     assuming an equal size and pixel scale in all dimensions. Similar to <code>pixel_coordinates()</code>, but with a simplified API.</p> Pixel Coords API <p>Calculates the coordinates of the pixel centers for the given input, assuming an equal size and pixel scale in all dimensions. All  coordinates are output in units of metres. This function is essentially a reduced version of the full <code>pixel_coordinates</code> function that gives flexibility to have different dimension sizes and scales.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in all dimensions.</p> required <code>pixel_scale</code> <code>float = 1</code> <p>The pixel scale in all dimensions.</p> <code>1</code> <code>ndims</code> <code>int = 2</code> <p>The number of output dimensions.</p> <code>2</code> <code>polar</code> <code>bool = False</code> <p>If True, the output is in polar coordinates. If False, the output is in Cartesian coordinates. ndims must be 2 if polar is True.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The array of pixel center coordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def pixel_coords(\n        npixels: int,\n        pixel_scale: float = 1,\n        ndims: int = 2,\n        polar=False,\n        ) -&gt; Array:\n\"\"\"\n    Calculates the coordinates of the pixel centers for the given input,\n    assuming an equal size and pixel scale in all dimensions. All \n    coordinates are output in units of metres. This function is essentially a\n    reduced version of the full `pixel_coordinates` function that gives\n    flexibility to have different dimension sizes and scales.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in all dimensions.\n    pixel_scale : float = 1\n        The pixel scale in all dimensions.\n    ndims : int = 2\n        The number of output dimensions.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        Cartesian coordinates. ndims must be 2 if polar is True.\n\n    Returns\n    -------\n    coordinates : Array\n        The array of pixel center coordinates.\n    \"\"\"\n    npixels = (npixels,) * ndims\n    pixel_scale = (pixel_scale,) * ndims\n    return pixel_coordinates(npixels, pixel_scale, polar=polar)\n</code></pre>"},{"location":"docs/API/utils/coordinates/#dLux.utils.coordinates.pixel_coords","title":"Coordinates","text":""},{"location":"docs/API/utils/coordinates/#pixel-coordinates","title":"Pixel Coordinates","text":"<p>Calculates the coordinates of the pixel centers for the given input, without the underlying assumptions of <code>pixel_coords()</code>.</p> Pixel Coordinates API <p>Calculates the coordinates of the pixel centers for the given input. All  coordinates are output in units of metres. </p> <p>The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordinates, indexing is set to 'xy' and the input must be 2d.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>Union[int, tuple]</code> <p>The number of pixels in each dimension.</p> required <code>pixel_scales</code> <code>Union[tuple, float] = 1.</code> <p>The pixel scales in each dimension. If a tuple, the length of the tuple must match the number of dimensions. If a float, the same scale is applied to all dimensions. If None, the scale is set to 1.</p> <code>1.0</code> <code>offsets</code> <code>Union[tuple, float] = 0.</code> <p>The offset of the pixel centers in each dimension. If a tuple, the  length of the tuple must match the number of dimensions. If a float,  the same offset is applied to all dimensions. If None, the offset is  set to 0.</p> <code>0.0</code> <code>polar</code> <code>bool = False</code> <p>If True, the output is in polar coordinates. If False, the output is in Cartesian coordinates. Default is False.</p> <code>False</code> <code>indexing</code> <code>str = 'xy'</code> <p>The indexing of the output. Default is 'xy'. See numpy.meshgrid for more details.</p> <code>'xy'</code> <p>Returns:</p> Name Type Description <code>positions</code> <code>Array</code> <p>The positions of the pixel centers in the given dimensions.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def pixel_coordinates(\n        npixels: Union[int, tuple],\n        pixel_scales: Union[tuple, float] = 1.,\n        offsets: Union[tuple, float] = 0.,\n        polar: bool = False,\n        indexing: str = 'xy'\n) -&gt; Array:\n\"\"\"\n    Calculates the coordinates of the pixel centers for the given input. All \n    coordinates are output in units of metres. \n\n    The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the\n    string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a\n    meshgrid with Cartesian indexing. In the 2-D case with inputs of length M\n    and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for\n    \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs\n    are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.\n    If the output is in polar coordinates, indexing is set to 'xy' and the\n    input must be 2d.\n\n    Parameters\n    ----------\n    npixels : Union[int, tuple]\n        The number of pixels in each dimension.\n    pixel_scales : Union[tuple, float] = 1.\n        The pixel scales in each dimension. If a tuple, the length\n        of the tuple must match the number of dimensions. If a float, the same\n        scale is applied to all dimensions. If None, the scale is set to 1.\n    offsets : Union[tuple, float] = 0.\n        The offset of the pixel centers in each dimension. If a tuple, the \n        length of the tuple must match the number of dimensions. If a float, \n        the same offset is applied to all dimensions. If None, the offset is \n        set to 0.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        Cartesian coordinates. Default is False.\n    indexing : str = 'xy'\n        The indexing of the output. Default is 'xy'. See numpy.meshgrid for more\n        details.\n\n    Returns\n    -------\n    positions : Array\n        The positions of the pixel centers in the given dimensions.\n    \"\"\"\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\"indexing must be either 'xy' or 'ij'.\")\n\n    if polar and indexing == 'ij':\n        indexing = 'xy'\n\n    if not isinstance(npixels, tuple):\n        npixels = (npixels,)\n\n    # Assume equal pixel scales if not given\n    if not isinstance(pixel_scales, tuple):\n        pixel_scales = (pixel_scales,) * len(npixels)\n\n    # Assume no offset if not given\n    if not isinstance(offsets, tuple):\n        offsets = (offsets,) * len(npixels)\n\n    def pixel_fn(n, offset, scale):\n        pix = np.arange(n) - (n - 1) / 2.\n        pix *= scale\n        pix -= offset\n        return pix\n\n    pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)\n\n    # output (x, y) for 2d, else in order\n    positions = np.array(np.meshgrid(*pixels, indexing=indexing))\n\n    if polar:\n        if len(npixels) != 2:\n            raise ValueError(\"polar coordinates are only defined for 2D arrays.\")\n        return cart_to_polar(positions)\n\n    # Squeeze for empty axis removal with 1d\n    return np.squeeze(positions)\n</code></pre>"},{"location":"docs/API/utils/coordinates/#dLux.utils.coordinates.pixel_coordinates","title":"Coordinates","text":""},{"location":"docs/API/utils/helpers/","title":"Helper Utility Functions","text":"<p>This module contains the leftover functions that don't fit anywhere else in the <code>utils</code> module!</p>"},{"location":"docs/API/utils/helpers/#list-to-dictionary","title":"List to Dictionary","text":"<p>Converts a list of \u2202Lux objects into a regular ordered dictionary. This shouldn't need to be used by the user, but is used internally in many of the constructors.</p> List to Dictionary API <p>Converts some input list of dLux layers and converts them into an OrderedDict with the correct structure, ensuring that all keys are unique.</p> <p>Parameters:</p> Name Type Description Default <code>list_in</code> <code>list</code> <p>The list of dLux Layers to be converted into a dictionary.</p> required <code>ordered</code> <code>bool</code> <p>Whether to return an ordered or regular dictionary.</p> required <code>allowed_types</code> <code>tuple</code> <p>The allowed types of layers to be included in the dictionary.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>dictionary</code> <code>dict</code> <p>The equivalent dictionary or ordered dictionary.</p> Source code in <code>dLux/utils/helpers.py</code> <pre><code>def list_to_dictionary(\n        list_in: list,\n        ordered: bool,\n        allowed_types: tuple = ()) -&gt; dict:\n\"\"\"\n    Converts some input list of dLux layers and converts them into an\n    OrderedDict with the correct structure, ensuring that all keys are unique.\n\n    Parameters\n    ----------\n    list_in : list\n        The list of dLux Layers to be converted into a dictionary.\n    ordered : bool\n        Whether to return an ordered or regular dictionary.\n    allowed_types : tuple\n        The allowed types of layers to be included in the dictionary.\n\n    Returns\n    -------\n    dictionary : dict\n        The equivalent dictionary or ordered dictionary.\n    \"\"\"\n    # Construct names list and identify repeats\n    names, repeats = [], []\n    for item in list_in:\n\n        # Check for specified names\n        if isinstance(item, tuple):\n            item, name = item\n        else:\n            name = item.__class__.__name__\n\n        # Check input types\n        if allowed_types != () and not isinstance(item, allowed_types):\n            raise TypeError(f\"Item {name} is not an allowed type, got \"\n                            f\"{type(item)}\")\n\n        # Check for Repeats\n        if name in names:\n            repeats.append(name)\n        names.append(name)\n\n    # Get list of unique repeats\n    repeats = list(set(repeats))\n\n    # Iterate over repeat names\n    for i in range(len(repeats)):\n\n        # Iterate over names list and append index value to name\n        idx = 0\n        for j in range(len(names)):\n            if repeats[i] == names[j]:\n                names[j] = names[j] + '_{}'.format(idx)\n                idx += 1\n\n    # Turn list into Dictionary\n    dict_out = OrderedDict() if ordered else {}\n    for i in range(len(names)):\n\n        # Check for spaces in names\n        if ' ' in names[i]:\n            raise ValueError(f\"Names can not contain spaces, got {names[i]}\")\n\n        # Add to dict\n        if isinstance(list_in[i], tuple):\n            item = list_in[i][0]\n        else:\n            item = list_in[i]\n        dict_out[names[i]] = item\n    return dict_out\n</code></pre>"},{"location":"docs/API/utils/helpers/#dLux.utils.helpers.list_to_dictionary","title":"Helpers","text":""},{"location":"docs/API/utils/interpolation/","title":"Interpolation Utility Functions","text":"<p>This module contains some basic interpolation functions that can be used on arrays and wavefronts.</p>"},{"location":"docs/API/utils/interpolation/#scale-array","title":"Scale Array","text":"<p>Scales an array to some number of output pixels.</p> Scale Array API <p>Scales some input array to size_out using interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to scale.</p> required <code>size_out</code> <code>int</code> <p>The output size of the mask</p> required <code>order</code> <code>int</code> <p>The interpolation order. Supports 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array scaled to size_out</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def scale_array(array: Array,\n                size_out: int,\n                order: int) -&gt; Array:\n\"\"\"\n    Scales some input array to size_out using interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to scale.\n    size_out : int\n        The output size of the mask\n    order : int\n        The interpolation order. Supports 0 and 1.\n\n    Returns\n    -------\n    array : Array\n        The array scaled to size_out\n    \"\"\"\n    xs = np.linspace(0, array.shape[0], size_out)\n    xs, ys = np.meshgrid(xs, xs)\n    return map_coordinates(array, np.array([ys, xs]), order=order)\n</code></pre>"},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.scale_array","title":"Interpolation","text":""},{"location":"docs/API/utils/interpolation/#downsample","title":"Downsample","text":"<p>Downsamples an array, taking either the mean or sum.</p> Downsample API <p>Downsamples the input array by n.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to downsample.</p> required <code>n</code> <code>int</code> <p>The factor by which to downsample the array.</p> required <code>method</code> <code>str = 'mean'</code> <p>The method by which to downsample the array. Can be 'mean' or 'sum'.</p> <code>'mean'</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The downsampled array.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def downsample(array: Array, n: int, method='mean') -&gt; Array:\n\"\"\"\n    Downsamples the input array by n.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to downsample.\n    n : int\n        The factor by which to downsample the array.\n    method : str = 'mean'\n        The method by which to downsample the array. Can be 'mean' or 'sum'.\n\n    Returns\n    -------\n    array : Array\n        The downsampled array.\n    \"\"\"\n    if method == 'sum':\n        method = np.sum\n    elif method == 'mean':\n        method = np.mean\n    else:\n        raise ValueError('Invalid method. Choose \"mean\" or \"sum\".')\n\n    size_in = array.shape[0]\n    size_out = size_in // n\n\n    # Downsample first dimension\n    array = method(array.reshape((size_in * size_out, n)), 1)\n    array = array.reshape(size_in, size_out).T\n\n    # Downsample second dimension\n    array = method(array.reshape((size_out * size_out, n)), 1)\n    array = array.reshape(size_out, size_out).T\n    return array\n</code></pre>"},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.downsample","title":"Interpolation","text":""},{"location":"docs/API/utils/interpolation/#scale","title":"Scale","text":"<p>Scales an array by some sampling ratio.</p> Scale API <p>Paraxially interpolates a wavefront field (either in amplitude and phase, or real and imaginary) based on the sampling ratio, and npixels_out.</p>"},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.scale--todo-check-if-a-half-pixel-offset-is-produced","title":"TODO: Check if a half-pixel offset is produced","text":"<p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input field to interpolate, either in amplitude and phase, or real and imaginary.</p> required <code>npixels</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>ratio</code> <code>float</code> <p>The relative input to output scales, TODO: does 2 make it bigger or  smaller? i.e. input scale/output scale. &lt;- get this right.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The interpolated output amplitude and phase arrays.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def scale(array: Array,\n          npixels: int,\n          ratio: float,\n          order: int = 1) -&gt; Array:\n\"\"\"\n    Paraxially interpolates a wavefront field (either in amplitude and phase, or\n    real and imaginary) based on the sampling ratio, and npixels_out.\n\n    # TODO: Check if a half-pixel offset is produced\n\n    Parameters\n    ----------\n    array : Array\n        The input field to interpolate, either in amplitude and phase, or real\n        and imaginary.\n    npixels : int\n        The number of pixel in the output array.\n    ratio : float\n        The relative input to output scales, TODO: does 2 make it bigger or \n        smaller? i.e. input scale/output scale. &lt;- get this right.\n    order : int = 1\n        The interpolation order to use.\n\n    Returns\n    -------\n    field : Array\n        The interpolated output amplitude and phase arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = array.shape[-1]\n    # TODO: Update with utils.pixel_coordinates\n    coordinates = generate_coordinates(npixels_in, npixels, ratio)\n    return map_coordinates(array, coordinates, order=order)\n</code></pre>"},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.scale","title":"Interpolation","text":""},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.scale--todo-check-if-a-half-pixel-offset-is-produced","title":"TODO: Check if a half-pixel offset is produced","text":""},{"location":"docs/API/utils/interpolation/#rotate","title":"Rotate","text":"<p>Rotates an array by some angle in radians.</p> Rotate API <p>Rotates an array by the angle, using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle to rotate the array by.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def rotate(array: Array, angle: Array, order: int = 1) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using linear interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    order : int = 1\n        The interpolation order to use.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n\n    def _rotate(coordinates: Array, rotation: Array) -&gt; Array:\n        x, y = coordinates[0], coordinates[1]\n        new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n        new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n        return np.array([new_x, new_y])\n\n    # Get coordinates\n    npixels = array.shape[0]\n    centre = (npixels - 1) / 2\n    coordinates = dlu.pixel_coordinates((npixels, npixels), indexing='ij')\n    coordinates_rotated = _rotate(coordinates, angle) + centre\n\n    # Interpolate\n    return map_coordinates(array, coordinates_rotated, order=order)\n</code></pre>"},{"location":"docs/API/utils/interpolation/#dLux.utils.interpolation.rotate","title":"Interpolation","text":""},{"location":"docs/API/utils/math/","title":"Math Utility Functions","text":"<p>This module contains functions used to</p>"},{"location":"docs/API/utils/math/#factorial","title":"Factorial","text":"<p>Differentiably calculates the factorial of a number. Jax-friendly!</p> Factorial API <p>Calculate n! in a jax friendly way. Note that n == 0 is not a  safe case.  </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The value to calculate the factorial of.</p> required <p>Returns:</p> Type Description <code>n! : float</code> <p>The factorial of the value.</p> Source code in <code>dLux/utils/math.py</code> <pre><code>def factorial(n: float) -&gt; float:\n\"\"\"\n    Calculate n! in a jax friendly way. Note that n == 0 is not a \n    safe case.  \n\n    Parameters\n    ----------\n    n : float\n        The value to calculate the factorial of.\n\n    Returns\n    -------\n    n! : float\n        The factorial of the value.\n    \"\"\"\n    return lax.exp(lax.lgamma(n + 1.))\n</code></pre>"},{"location":"docs/API/utils/math/#dLux.utils.math.factorial","title":"Math","text":""},{"location":"docs/API/utils/math/#triangular-number","title":"Triangular Number","text":"<p>Calculates the nth triangular number.</p> Triangular Number API <p>Calculate the nth triangular number.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The nth triangular number to calculate.</p> required <p>Returns:</p> Name Type Description <code>n</code> <code>int</code> <p>The nth triangular number.</p> Source code in <code>dLux/utils/math.py</code> <pre><code>def triangular_number(n: int) -&gt; int:\n\"\"\"\n    Calculate the nth triangular number.\n\n    Parameters\n    ----------\n    n : int\n        The nth triangular number to calculate.\n\n    Returns\n    -------\n    n : int\n        The nth triangular number.\n    \"\"\"\n    return n * (n + 1) / 2\n</code></pre>"},{"location":"docs/API/utils/math/#dLux.utils.math.triangular_number","title":"Math","text":""},{"location":"docs/API/utils/optics/","title":"Optics Utility Functions","text":"<p>This module contains a number of common equations used in optics, such as converting between Optical Path Difference (OPD) and phase, and a few functions used to calculate sampling rates in focal planes.</p>"},{"location":"docs/API/utils/optics/#opd-to-phase","title":"OPD to Phase","text":"<p>Converts an input OPD and wavelength (metres) to phase (radians).</p> OPD to Phase API <p>Converts the input Optical Path Difference (opd) in units of metres to phases in units of radians for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>Array, metres</code> <p>The Optical Path Difference (opd) to be converted into phase.</p> required <code>wavelength</code> <code>Array, metres</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The equivalent phase value for the given opd and wavelength.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def opd_to_phase(opd: Array, wavelength: Array) -&gt; Array:\n\"\"\"\n    Converts the input Optical Path Difference (opd) in units of metres to\n    phases in units of radians for the given wavelength.\n\n    Parameters\n    ----------\n    opd : Array, metres\n        The Optical Path Difference (opd) to be converted into phase.\n    wavelength : Array, metres\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    phase : Array, radians\n        The equivalent phase value for the given opd and wavelength.\n    \"\"\"\n    return 2 * np.pi * opd / wavelength\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.opd_to_phase","title":"Optics","text":""},{"location":"docs/API/utils/optics/#phase-to-opd","title":"Phase to OPD","text":"<p>Converts an input phase (radians) and wavelength (metres) to OPD (metres).</p> Phase to OPD API <p>Converts the input phase in units of radians to the equivalent Optical Path Difference (opd) in metres for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phase to be converted into Optical Path Difference (opd)</p> required <code>wavelength</code> <code>Array, metres</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>opd</code> <code>Array, metres</code> <p>The equivalent opd value for the given phase and wavelength.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def phase_to_opd(phase: Array, wavelength: Array) -&gt; Array:\n\"\"\"\n    Converts the input phase in units of radians to the equivalent Optical Path\n    Difference (opd) in metres for the given wavelength.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be converted into Optical Path Difference (opd)\n    wavelength : Array, metres\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    opd : Array, metres\n        The equivalent opd value for the given phase and wavelength.\n    \"\"\"\n    return phase * wavelength / (2 * np.pi)\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.phase_to_opd","title":"Optics","text":""},{"location":"docs/API/utils/optics/#get-fringe-size","title":"Get Fringe Size","text":"<p>Calculates the angular size of the diffraction fringes (radians) in a focal plane based on the wavelength and aperture (metres).</p> Get Fringe Size API <p>Calculates the angular size of the diffraction fringes.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, metres</code> <p>The size of the aperture.</p> required <p>Returns:</p> Name Type Description <code>fringe_size</code> <code>Array, radians</code> <p>The angular fringe size in units of radians.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_fringe_size(wavelength: Array, aperture: Array) -&gt; Array:\n\"\"\"\n    Calculates the angular size of the diffraction fringes.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, metres\n        The size of the aperture.\n\n    Returns\n    -------\n    fringe_size : Array, radians\n        The angular fringe size in units of radians.\n    \"\"\"\n    return wavelength / aperture\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.get_fringe_size","title":"Optics","text":""},{"location":"docs/API/utils/optics/#get-pixels-per-fringe","title":"Get Pixels Per Fringe","text":"<p>Calculates the number of pixels per diffraction fringe in a focal plane based on the wavelength and aperture in metres. A Nyquist-sampled system will have 2 pixels per fringe.</p> Get Pixels Per Fringe API <p>Calculates the number of pixels per diffraction fringe, i.e. the fringe sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, metres</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, metres</code> <p>The size of the aperture.</p> required <code>pixel_scale</code> <code>Array, metres/pixel or radians/pixel</code> <p>The size of each pixel. This is taken in units of radians per pixel if no focal length is provided, else it is taken in size of metres per pixel.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the optical system. If none is provided, the pixel scale is taken in units of radians per pixel, else it is taken in metres per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sampling</code> <code>Array</code> <p>The sampling rate of the fringes in units of pixels.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_pixels_per_fringe(wavelength: Array,\n                          aperture: Array,\n                          pixel_scale: Array,\n                          focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the number of pixels per diffraction fringe, i.e. the fringe\n    sampling rate.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, metres\n        The size of the aperture.\n    pixel_scale : Array, metres/pixel or radians/pixel\n        The size of each pixel. This is taken in units of radians per pixel if\n        no focal length is provided, else it is taken in size of metres per\n        pixel.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is taken in units of radians per pixel, else it is taken in\n        metres per pixel.\n\n    Returns\n    -------\n    sampling : Array\n        The sampling rate of the fringes in units of pixels.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to metres if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Return sampling\n    return fringe_size / pixel_scale\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.get_pixels_per_fringe","title":"Optics","text":""},{"location":"docs/API/utils/optics/#get-pixel-scale","title":"Get Pixel Scale","text":"<p>Calculates the required pixel scale (radians/pixel or metres/pixel) in a focal plane based on the wavelength and aperture (metres) in order to sample the diffraction fringes by some sampling rate. A sampling rate of 2 will give a Nyquist-sampled system. If a focal length is provided, the output will be in metres per pixel, otherwise it will be in radians per pixel.</p> Get Pixel Scale API <p>Calculates the pixel_size needed in order to sample the diffraction fringes at the given sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>wavelength</code> <code>Array, metres</code> <p>The observation wavelength.</p> required <code>aperture</code> <code>Array, metres</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in metres per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or metres per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radians per pixel if no focal length is provided, else in units of metres per pixel.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_pixel_scale(sampling_rate: Array,\n                    wavelength: Array,\n                    aperture: Array,\n                    focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, metres\n        The observation wavelength.\n    aperture : Array, metres\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        metres per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or metres per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radians per pixel if no focal length is\n        provided, else in units of metres per pixel.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to metres if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Get sampling rate\n    return fringe_size / sampling_rate\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.get_pixel_scale","title":"Optics","text":""},{"location":"docs/API/utils/optics/#get-airy-pixel-scale","title":"Get Airy Pixel Scale","text":"<p>Calculates the required pixel scale (radians/pixel or metres/pixel) in a focal plane based on the wavelength and aperture (metres) in order to sample the diffraction fringes by some sampling rate, based on the slightly larger diffraction fringes given by an Airy disk PSF. A sampling rate of 2 will give a Nyquist-sampled system. If a focal length is provided the output will be in metres per pixel, otherwise it will be in radians per pixel.</p> Get Airy Pixel Scale API <p>Calculates the pixel_size needed to sample the diffraction fringes at the given sampling rate. Applies the 1.22 multiplier for Airy disk diffraction fringes given by a circular aperture.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>wavelength</code> <code>Array, metres</code> <p>The observation wavelength.</p> required <code>aperture</code> <code>Array, metres</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array = None</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in metres per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or metres per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radians per pixel if no focal length is provided, else in units of metres per pixel.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_airy_pixel_scale(sampling_rate: Array,\n                         wavelength: Array,\n                         aperture: Array,\n                         focal_length: Array = None) -&gt; Array:\n\"\"\"\n    Calculates the pixel_size needed to sample the diffraction fringes\n    at the given sampling rate. Applies the 1.22 multiplier for Airy disk\n    diffraction fringes given by a circular aperture.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, metres\n        The observation wavelength.\n    aperture : Array, metres\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        metres per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or metres per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radians per pixel if no focal length is\n        provided, else in units of metres per pixel.\n    \"\"\"\n    return get_pixel_scale(sampling_rate, 1.22 * wavelength, aperture,\n                           focal_length)\n</code></pre>"},{"location":"docs/API/utils/optics/#dLux.utils.optics.get_airy_pixel_scale","title":"Optics","text":""},{"location":"docs/API/utils/units/","title":"Units Utility Functions","text":"<p>This module contains functions for converting between different angular units.</p>"},{"location":"docs/API/utils/units/#radians-to-degrees","title":"Radians to Degrees","text":"<p>Converts radians to degrees.</p> Radians to Degrees API <p>Converts the inputs values from radians to degrees.</p> <p>Can also be imported as r2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def rad_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to degrees.\n\n    Can also be imported as r2d.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values * 180 / np.pi\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.rad_to_deg","title":"Units","text":""},{"location":"docs/API/utils/units/#radians-to-arcminutes","title":"Radians to Arcminutes","text":"<p>Converts radians to arcminutes.</p> Radians to Arcminutes API <p>Converts the inputs values from radians to arcminutes.</p> <p>Can also be imported as r2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def rad_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcminutes.\n\n    Can also be imported as r2m.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60 * 180 / np.pi\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.rad_to_arcmin","title":"Units","text":""},{"location":"docs/API/utils/units/#radians-to-arcseconds","title":"Radians to Arcseconds","text":"<p>Converts radians to arcseconds.</p> Radians to Arcseconds API <p>Converts the inputs values from radians to arcseconds.</p> <p>Can also be imported as r2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def rad_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcseconds.\n\n    Can also be imported as r2s.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600 * 180 / np.pi\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.rad_to_arcsec","title":"Units","text":""},{"location":"docs/API/utils/units/#degrees-to-radians","title":"Degrees to Radians","text":"<p>Converts degrees to radians.</p> Degrees to Radians API <p>Converts the inputs values from degrees to radians.</p> <p>Can also be imported as d2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def deg_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to radians.\n\n    Can also be imported as d2r.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / 180\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.deg_to_rad","title":"Units","text":""},{"location":"docs/API/utils/units/#degrees-to-arcminutes","title":"Degrees to Arcminutes","text":"<p>Converts degrees to arcminutes.</p> Degrees to Arcminutes API <p>Converts the inputs values from degrees to arcminutes.</p> <p>Can also be imported as d2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def deg_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcminutes.\n\n    Can also be imported as d2m.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.deg_to_arcmin","title":"Units","text":""},{"location":"docs/API/utils/units/#degrees-to-arcseconds","title":"Degrees to Arcseconds","text":"<p>Converts degrees to arcseconds.</p> Degrees to Arcseconds API <p>Converts the inputs values from degrees to arcseconds.</p> <p>Can also be imported as d2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def deg_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcseconds.\n\n    Can also be imported as d2s.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.deg_to_arcsec","title":"Units","text":""},{"location":"docs/API/utils/units/#arcminutes-to-radians","title":"Arcminutes to Radians","text":"<p>Converts arcminutes to radians.</p> Arcminutes to Radians API <p>Converts the inputs values from arcminutes to radians.</p> <p>Can also be imported as m2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcmin_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to radians.\n\n    Can also be imported as m2r.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (60 * 180)\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcmin_to_rad","title":"Units","text":""},{"location":"docs/API/utils/units/#arcminutes-to-degrees","title":"Arcminutes to Degrees","text":"<p>Converts arcminutes to degrees.</p> Arcminutes to Degrees API <p>Converts the inputs values from arcminutes to degrees.</p> <p>Can also be imported as m2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcmin_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to degrees.\n\n    Can also be imported as m2d.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 60\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcmin_to_deg","title":"Units","text":""},{"location":"docs/API/utils/units/#arcminutes-to-arcseconds","title":"Arcminutes to Arcseconds","text":"<p>Converts arcminutes to arcseconds.</p> Arcminutes to Arcseconds API <p>Converts the inputs values from arcminutes to arcseconds.</p> <p>Can also be imported as m2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcmin_to_arcsec(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to arcseconds.\n\n    Can also be imported as m2s.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 60\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcmin_to_arcsec","title":"Units","text":""},{"location":"docs/API/utils/units/#arcseconds-to-radians","title":"Arcseconds to Radians","text":"<p>Converts arcseconds to radians.</p> Arcseconds to Radians API <p>Converts the inputs values from arcseconds to radians.</p> <p>Can also be imported as s2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcsec_to_rad(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to radians.\n\n    Can also be imported as s2r.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (3600 * 180)\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcsec_to_rad","title":"Units","text":""},{"location":"docs/API/utils/units/#arcseconds-to-degrees","title":"Arcseconds to Degrees","text":"<p>Converts arcseconds to degrees.</p> Arcseconds to Degrees API <p>Converts the inputs values from arcseconds to degrees.</p> <p>Can also be imported as s2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcsec_to_deg(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to degrees.\n\n    Can also be imported as s2d.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 3600\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcsec_to_deg","title":"Units","text":""},{"location":"docs/API/utils/units/#arcseconds-to-arcminutes","title":"Arcseconds to Arcminutes","text":"<p>Converts arcseconds to arcminutes.</p> Arcseconds to Arcminutes API <p>Converts the inputs values from arcseconds to arcminutes.</p> <p>Can also be imported as s2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcsec_to_arcmin(values: Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to arcminutes.\n\n    Can also be imported as s2m.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values / 60\n</code></pre>"},{"location":"docs/API/utils/units/#dLux.utils.units.arcsec_to_arcmin","title":"Units","text":""},{"location":"docs/notebooks/HMC/","title":"NumPyro and Hamiltonian Monte Carlo","text":"In\u00a0[1]: Copied! <pre># Set CPU count for numpyro multi-chain multi-thread\nimport os\nos.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'\n\nimport jax.random as jr\nimport dLux as dl\nimport matplotlib.pyplot as plt\n\n# Set global plotting parameters\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = 'serif'\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Set CPU count for numpyro multi-chain multi-thread import os os.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'  import jax.random as jr import dLux as dl import matplotlib.pyplot as plt  # Set global plotting parameters %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = 'serif' plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>Let's construct the source and optics. In this case, we will use the <code>AlphaCen</code> source from the <code>dLuxToliman</code> package as it gives separation in arcseconds and flux in log units. This will make our NumPyro sampling functions simpler.</p> In\u00a0[2]: Copied! <pre>from dLuxToliman import AlphaCen\n\n# Use the AlphaCen object for separation in units of arcseconds, and flux in log\nsource = AlphaCen()\nsource = source.set(['log_flux', 'separation'], [3.5, 0.1])\n\n# Aperture properties\nwf_npix = 128\nradial_terms = [2, 3]\ntrue_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (7,))\naperture = dl.ApertureFactory(wf_npix, radial_orders=radial_terms, coefficients=true_coeffs)\n\n# Psf properties\npsf_npixels = 16\npsf_pixel_scale = 0.03\n\n# Construct\ndiameter = 1\noptics = dl.AngularOptics(wf_npix, diameter, aperture, psf_npixels, psf_pixel_scale)\n\n# Construct Telescope\ntelescope = dl.Instrument(optics, (source,'source'))\n</pre> from dLuxToliman import AlphaCen  # Use the AlphaCen object for separation in units of arcseconds, and flux in log source = AlphaCen() source = source.set(['log_flux', 'separation'], [3.5, 0.1])  # Aperture properties wf_npix = 128 radial_terms = [2, 3] true_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (7,)) aperture = dl.ApertureFactory(wf_npix, radial_orders=radial_terms, coefficients=true_coeffs)  # Psf properties psf_npixels = 16 psf_pixel_scale = 0.03  # Construct diameter = 1 optics = dl.AngularOptics(wf_npix, diameter, aperture, psf_npixels, psf_pixel_scale)  # Construct Telescope telescope = dl.Instrument(optics, (source,'source')) <p>Now, let's create simulated data and examine them.</p> In\u00a0[3]: Copied! <pre>## Generate psf\npsf = telescope.model()\npsf_photon = jr.poisson(jr.PRNGKey(0), psf)\nbg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape)\ndata = psf_photon + bg_noise\n\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 2)\nplt.title(\"PSF with photon noise\")\nplt.imshow(psf_photon)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\nplt.show()\n</pre> ## Generate psf psf = telescope.model() psf_photon = jr.poisson(jr.PRNGKey(0), psf) bg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape) data = psf_photon + bg_noise  plt.figure(figsize=(15, 4)) plt.subplot(1, 3, 1) plt.title(\"PSF\") plt.imshow(psf) plt.colorbar()  plt.subplot(1, 3, 2) plt.title(\"PSF with photon noise\") plt.imshow(psf_photon) plt.colorbar()  plt.subplot(1, 3, 3) plt.title(\"Data\") plt.imshow(data) plt.colorbar() plt.show() <p>Next, we construct our NumPyro sampling function. In this function we need to define prior distribution variables for our parameters, along with the corresponding parameter path. This allows for NumPyro to simultaneously sample the posterior of all parameters by taking advantage of the differentiable nature of these models.</p> <p>With these parameters, we create a <code>plate</code> which defines our data. We use a Poisson likelihood since photon noise is our dominant noise source.</p> In\u00a0[4]: Copied! <pre># PPL\nimport numpyro as npy\nimport numpyro.distributions as dist\n\nparameters = ['x_position', 'y_position', 'separation', 'position_angle', \n    'log_flux', 'contrast']\n\ndef psf_model(data, model):\n\"\"\"\n    Define the numpyro function\n    \"\"\"\n    values = [\n        npy.sample(\"x\",        dist.Uniform(-0.1, 0.1)),\n        npy.sample(\"y\",        dist.Uniform(-0.1, 0.1)),\n        npy.sample(\"r\",        dist.Uniform(0.01, 0.5)),\n        npy.sample(\"theta\",    dist.Uniform(80, 100)),\n        npy.sample(\"log_flux\", dist.Uniform(3, 4)),\n        npy.sample(\"contrast\", dist.Uniform(1, 5)),\n    ]\n\n    with npy.plate(\"data\", len(data.flatten())):\n        poisson_model = dist.Poisson(\n            model.set(parameters, values).model().flatten())\n        return npy.sample(\"psf\", poisson_model, obs=data.flatten())\n</pre> # PPL import numpyro as npy import numpyro.distributions as dist  parameters = ['x_position', 'y_position', 'separation', 'position_angle',      'log_flux', 'contrast']  def psf_model(data, model):     \"\"\"     Define the numpyro function     \"\"\"     values = [         npy.sample(\"x\",        dist.Uniform(-0.1, 0.1)),         npy.sample(\"y\",        dist.Uniform(-0.1, 0.1)),         npy.sample(\"r\",        dist.Uniform(0.01, 0.5)),         npy.sample(\"theta\",    dist.Uniform(80, 100)),         npy.sample(\"log_flux\", dist.Uniform(3, 4)),         npy.sample(\"contrast\", dist.Uniform(1, 5)),     ]      with npy.plate(\"data\", len(data.flatten())):         poisson_model = dist.Poisson(             model.set(parameters, values).model().flatten())         return npy.sample(\"psf\", poisson_model, obs=data.flatten()) <p>Using the model above, we can now sample from the posterior distribution using the No U-Turn Sampler (NUTS).</p> In\u00a0[5]: Copied! <pre>from jax import device_count\nsampler = npy.infer.MCMC(\n    npy.infer.NUTS(psf_model),    \n    num_warmup=2000,\n    num_samples=2000,\n    num_chains=device_count(),\n    progress_bar=True,\n)\n%time sampler.run(jr.PRNGKey(0), data, telescope)\n</pre> from jax import device_count sampler = npy.infer.MCMC(     npy.infer.NUTS(psf_model),         num_warmup=2000,     num_samples=2000,     num_chains=device_count(),     progress_bar=True, ) %time sampler.run(jr.PRNGKey(0), data, telescope) <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 8min 13s, sys: 30.2 s, total: 8min 43s\nWall time: 2min 12s\n</pre> <p>Let's examine the summary. Note: here we want to make sure that all the <code>r_hat</code> values are $\\sim1$.</p> In\u00a0[6]: Copied! <pre>sampler.print_summary()\nvalues_out = sampler.get_samples()\n</pre> sampler.print_summary() values_out = sampler.get_samples() <pre>\n                mean       std    median      5.0%     95.0%     n_eff     r_hat\n  contrast      2.57      0.24      2.56      2.16      2.95   3977.78      1.00\n  log_flux      3.51      0.01      3.51      3.50      3.52   6194.75      1.00\n         r      0.10      0.00      0.10      0.09      0.10   3822.17      1.00\n     theta     88.46      1.63     88.47     85.81     91.14   4543.61      1.00\n         x      0.01      0.00      0.01      0.00      0.01   3447.85      1.00\n         y     -0.00      0.00     -0.00     -0.00      0.00   4949.93      1.00\n\nNumber of divergences: 0\n</pre> In\u00a0[7]: Copied! <pre>import chainconsumer as cc\n\nchain = cc.ChainConsumer()\nchain.add_chain(values_out)\nchain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\nfig = chain.plotter.plot()\nfig.set_size_inches((15,15));\n</pre> import chainconsumer as cc  chain = cc.ChainConsumer() chain.add_chain(values_out) chain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  fig = chain.plotter.plot() fig.set_size_inches((15,15)); <p>Excellent! All the parameters are well constrained.</p>"},{"location":"docs/notebooks/HMC/#numpyro-and-hamiltonian-monte-carlo","title":"NumPyro and Hamiltonian Monte Carlo\u00b6","text":"<p>In this tutorial we will see how we to integrate our \u2202Lux optical models with the Probabilistic Programming Language (PPL) NumPyro. This allows us to run a subset of MCMC algorithms known as Hamiltonian Monte Carlo (HMC), which take advantage of autodiff to infer the relationship between a large number of parameters.</p> <p>In this example we will simulate a binary star through a simple optical system, and simultaneously infer the stellar and optical parameters.</p>"},{"location":"docs/notebooks/HMC/#inference-with-numpyro","title":"Inference with NumPyro\u00b6","text":"<p>Awesome, now we are going to try and infer these parameters using HMC. There are quite a few different parameters we want to infer:</p>"},{"location":"docs/notebooks/HMC/#source-parameters","title":"Source Parameters\u00b6","text":"<ul> <li>The $(x,y)$ mean position (2 parameters)</li> <li>The separation (1 parameter)</li> <li>The position angle (1 parameter)</li> <li>The mean flux (1 parameter)</li> <li>The contrast ratio (1 parameter)</li> </ul>"},{"location":"docs/notebooks/HMC/#optical-parameters","title":"Optical Parameters\u00b6","text":"<ul> <li>The Zernike aberration coefficients (7 parameters)</li> </ul> <p>This gives us a total of 13 parameters, which is quite high dimensional for regular MCMC algorithms.</p>"},{"location":"docs/notebooks/designing_a_mask/","title":"Phase Mask Design","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax.numpy as np\nimport jax.random as jr\nfrom jax import vmap\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax.numpy as np import jax.random as jr from jax import vmap  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>We will first generate an orthonormal basis for the pupil phases, then threshold this to {0, 1} while preserving soft-edges using the Continuous Latent-Image Mask Binarization (CLIMB) algorithm from the Wong et al. paper.</p> <p>Generate basis vectors however you like -- in this case we are using logarithmic radial harmonics and sines/cosines in $\\theta$ -- but you can do whatever you want here. This code is not important; just generate your favourite not-necessarily-orthonormal basis, and we will use Principal Component Analysis (PCA) to orthonormalise it later on.</p> In\u00a0[2]: Copied! <pre># Define arrays sizes, samplings, symmetries\nwf_npix = 256\noversample = 3\nnslice = 3\n\n# Define basis hyper parameters\na = 10\nb = 8\nith = 10\n\n# Define coordinate grids\nnpix = wf_npix * oversample\nc = (npix - 1) / 2.\nxs = (np.arange(npix) - c) / c\nXX, YY = np.meshgrid(xs, xs)\nRR = np.sqrt(XX ** 2 + YY ** 2)\nPHI = np.arctan2(YY, XX)\n\n# Generate basis vectors to map over\nAs = np.arange(-a, a+1)\nBs = nslice * np.arange(0, b+1)\nCs = np.array([-np.pi/2, np.pi/2])\nIs = np.arange(-ith, ith+1)\n\n# Define basis functions\nLRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C)\nsine_fn = lambda i, RR: np.sin(i * np.pi * RR)\ncose_fn = lambda i, RR: np.cos(i * np.pi * RR)\n\n# Map over basis functions\ngen_LRHF_basis = vmap(vmap(vmap( \\\n                            LRHF_fn, (None, 0, None, None, None)), \n                                     (0, None, None, None, None)), \n                                     (None, None, 0, None, None))\ngen_sine_basis = vmap(sine_fn, in_axes=(0, None))\ngen_cose_basis = vmap(cose_fn, in_axes=(0, None))\n\n# Generate basis\nLRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\\n            .reshape([len(As)*len(Bs)*len(Cs), npix, npix])\nsine_basis = gen_sine_basis(Is, RR)\ncose_basis = gen_cose_basis(Is, RR)\n\n# Format shapes and combine\nLRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix])\nsine_flat = sine_basis.reshape([len(sine_basis), npix*npix])\ncose_flat = cose_basis.reshape([len(cose_basis), npix*npix])\nfull_basis = np.concatenate([\n    LRHF_flat,\n    sine_flat,\n    cose_flat\n])\n</pre> # Define arrays sizes, samplings, symmetries wf_npix = 256 oversample = 3 nslice = 3  # Define basis hyper parameters a = 10 b = 8 ith = 10  # Define coordinate grids npix = wf_npix * oversample c = (npix - 1) / 2. xs = (np.arange(npix) - c) / c XX, YY = np.meshgrid(xs, xs) RR = np.sqrt(XX ** 2 + YY ** 2) PHI = np.arctan2(YY, XX)  # Generate basis vectors to map over As = np.arange(-a, a+1) Bs = nslice * np.arange(0, b+1) Cs = np.array([-np.pi/2, np.pi/2]) Is = np.arange(-ith, ith+1)  # Define basis functions LRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C) sine_fn = lambda i, RR: np.sin(i * np.pi * RR) cose_fn = lambda i, RR: np.cos(i * np.pi * RR)  # Map over basis functions gen_LRHF_basis = vmap(vmap(vmap( \\                             LRHF_fn, (None, 0, None, None, None)),                                       (0, None, None, None, None)),                                       (None, None, 0, None, None)) gen_sine_basis = vmap(sine_fn, in_axes=(0, None)) gen_cose_basis = vmap(cose_fn, in_axes=(0, None))  # Generate basis LRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\             .reshape([len(As)*len(Bs)*len(Cs), npix, npix]) sine_basis = gen_sine_basis(Is, RR) cose_basis = gen_cose_basis(Is, RR)  # Format shapes and combine LRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix]) sine_flat = sine_basis.reshape([len(sine_basis), npix*npix]) cose_flat = cose_basis.reshape([len(cose_basis), npix*npix]) full_basis = np.concatenate([     LRHF_flat,     sine_flat,     cose_flat ]) <p>Orthonormalise with PCA -- you could also use Gram-Schmidt if you prefer.</p> In\u00a0[3]: Copied! <pre>%%time\nfrom sklearn.decomposition import PCA\npca = PCA().fit(full_basis)\n\ncomponents = pca.components_.reshape([len(full_basis), npix, npix])\ncomponents = np.copy(components[:99,:,:])\nbasis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])\n\n# save for use later\nnp.save('files/basis', basis)\n\n# # Load if already generated\n# basis = np.load('files/basis.npy')\n</pre> %%time from sklearn.decomposition import PCA pca = PCA().fit(full_basis)  components = pca.components_.reshape([len(full_basis), npix, npix]) components = np.copy(components[:99,:,:]) basis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])  # save for use later np.save('files/basis', basis)  # # Load if already generated # basis = np.load('files/basis.npy') <pre>CPU times: user 6min 2s, sys: 47.5 s, total: 6min 50s\nWall time: 59.7 s\n</pre> <p>Visualising the pretty basis vectors:</p> In\u00a0[4]: Copied! <pre>nfigs = 60\nncols = 10\nnrows = 1 + nfigs//ncols\n\nplt.figure(figsize=(4*ncols, 4*nrows))\nfor i in range(nfigs):\n    plt.subplot(nrows, ncols, i+1)\n    plt.imshow(basis[i], cmap='seismic')\n    plt.xticks([])\n    plt.yticks([])\nplt.tight_layout()\nplt.show()\n</pre> nfigs = 60 ncols = 10 nrows = 1 + nfigs//ncols  plt.figure(figsize=(4*ncols, 4*nrows)) for i in range(nfigs):     plt.subplot(nrows, ncols, i+1)     plt.imshow(basis[i], cmap='seismic')     plt.xticks([])     plt.yticks([]) plt.tight_layout() plt.show() <p>First we want to construct a \u2202Lux layer that we can use to design a binary mask; for this, we will use <code>ApplyBasisCLIMB</code> which soft-thresholds the edges (see Wong et al., 2021, sec. 3.2.2). In brief, this creates an optical path difference (OPD) map as a weighted sum of modes; we set it to \u03c0 phase where it is positive, we set it to zero phase where it is negative, and we soft-edge it on the edges to propagate gradients.</p> <p>These models reside in the external <code>dLuxToliman</code> package, which you can install with <code>pip install dLuxToliman</code>.</p> In\u00a0[6]: Copied! <pre>from dLuxToliman import TolimanOptics, ApplyBasisCLIMB\n\n# Define our mask layer, here we use ApplyBasisCLIMB\nwavels = 1e-9 * np.linspace(595, 695, 3)\ncoeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)])\nCLIMB = ApplyBasisCLIMB(basis, np.mean(wavels), coeffs)\noptics = TolimanOptics(psf_npixels=128, mask=CLIMB)\n</pre> from dLuxToliman import TolimanOptics, ApplyBasisCLIMB  # Define our mask layer, here we use ApplyBasisCLIMB wavels = 1e-9 * np.linspace(595, 695, 3) coeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)]) CLIMB = ApplyBasisCLIMB(basis, np.mean(wavels), coeffs) optics = TolimanOptics(psf_npixels=128, mask=CLIMB) <p>We also add a small amount of Gaussian jitter to assist in engineering the PSF shape, then define a simple point source. We then combine all of these together into an <code>Instrument</code> object.</p> In\u00a0[7]: Copied! <pre># Add some detector jitter\ndetector = dl.LayeredDetector([dl.ApplyJitter(1)])\n\n# Define a source\nsource = dl.PointSource(wavelengths=wavels)\n\n# Create our instrument\ntel = dl.Instrument(optics, source, detector)\n</pre> # Add some detector jitter detector = dl.LayeredDetector([dl.ApplyJitter(1)])  # Define a source source = dl.PointSource(wavelengths=wavels)  # Create our instrument tel = dl.Instrument(optics, source, detector) <p>We also define a maximum radius which we want light to be confined within. Now, let's examine all this together.</p> In\u00a0[8]: Copied! <pre>lamd = wavels.max() / optics.diameter\nsampling_rate = lamd / optics.true_pixel_scale\nrmax = 8*sampling_rate # 8 lam/D\n</pre> lamd = wavels.max() / optics.diameter sampling_rate = lamd / optics.true_pixel_scale rmax = 8*sampling_rate # 8 lam/D In\u00a0[9]: Copied! <pre>aperture = tel.aperture.transmission\nmask = tel.mask.get_binary_phase()\nouter = plt.Circle((64, 64), rmax, fill=False, color='w')\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture*mask, cmap='hot')\nplt.title('Input OPD')\n\nax = plt.subplot(1, 2, 2)\nax.imshow(tel.model())\nax.set_title('Input PSF')\nax.add_patch(outer)\nplt.show()\n</pre> aperture = tel.aperture.transmission mask = tel.mask.get_binary_phase() outer = plt.Circle((64, 64), rmax, fill=False, color='w')  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture*mask, cmap='hot') plt.title('Input OPD')  ax = plt.subplot(1, 2, 2) ax.imshow(tel.model()) ax.set_title('Input PSF') ax.add_patch(outer) plt.show() <p>Now, let's define our loss function. We can pass the string path to our mask coefficients to the <code>zdx.filter_value_and_grad</code> function in order to generate gradients for only those terms!</p> In\u00a0[10]: Copied! <pre>from dLuxToliman import get_radial_mask, get_GE, get_RGE, get_RWGE\nparam = 'mask.coefficients'\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef loss_func(tel, rmax=150, power=0.5):\n    # Get PSF, Gradients and Mask\n    psf = tel.model()\n\n    Rmask = get_radial_mask(psf.shape[0], 0, rmax)\n\n    # Calculate loss\n    loss1 = - np.power(Rmask*get_GE(psf),  power).sum()\n    loss2 = - np.power(Rmask*get_RGE(psf), power).sum()\n    return loss1 + loss2\n</pre> from dLuxToliman import get_radial_mask, get_GE, get_RGE, get_RWGE param = 'mask.coefficients'  @zdx.filter_jit @zdx.filter_value_and_grad(param) def loss_func(tel, rmax=150, power=0.5):     # Get PSF, Gradients and Mask     psf = tel.model()      Rmask = get_radial_mask(psf.shape[0], 0, rmax)      # Calculate loss     loss1 = - np.power(Rmask*get_GE(psf),  power).sum()     loss2 = - np.power(Rmask*get_RGE(psf), power).sum()     return loss1 + loss2 <p>Evaluate once to <code>jit</code> compile:</p> In\u00a0[11]: Copied! <pre>%%time\nloss, grads = loss_func(tel, rmax=rmax) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = loss_func(tel, rmax=rmax) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -36.050437927246094\nCPU times: user 3.56 s, sys: 119 ms, total: 3.68 s\nWall time: 3.06 s\n</pre> <p>Gradient descent time!</p> In\u00a0[12]: Copied! <pre>model = tel\noptim, opt_state = zdx.get_optimiser(model, param, optax.adam(8e1))\n\nlosses, models_out = [], []\nwith tqdm(range(100),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_func(model, rmax=rmax)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> model = tel optim, opt_state = zdx.get_optimiser(model, param, optax.adam(8e1))  losses, models_out = [], [] with tqdm(range(100),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_func(model, rmax=rmax)         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)          t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Visualising the results:</p> In\u00a0[13]: Copied! <pre>coeffs_out = np.array([model.get(param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\naxes['C'].imshow(aperture*mask,cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = tel.set('detector.layers', {}).model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nfinal = models_out[-1]\naxes['E'].imshow(aperture*final.mask.get_binary_phase(),cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = final.model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\nplt.show()\n</pre> coeffs_out = np.array([model.get(param) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  axes['C'].imshow(aperture*mask,cmap='hot') axes['C'].set_title('Input OPD')  psf_in = tel.set('detector.layers', {}).model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  final = models_out[-1] axes['E'].imshow(aperture*final.mask.get_binary_phase(),cmap='hot') axes['E'].set_title('Final OPD')  psf_out = final.model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF') plt.show() In\u00a0[14]: Copied! <pre># Visualise GE Metrics\noversample = 2\nfinal_optics = models_out[-1].optics\nparams = ['psf_pixel_scale', 'psf_npixels']\noversampled = final_optics.multiply(params, [1/oversample, oversample*npix])\noversampled_psf = final_optics.model(source)\n\n# Plot\nplt.figure(figsize=(20, 4))\nplt.subplot(1, 4, 1)\nplt.title(\"PSF\")\nplt.imshow(psf_out)\nplt.colorbar()\n\nplt.subplot(1, 4, 2)\nplt.title(\"Gradient Energy\")\nplt.imshow(get_GE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 3)\nplt.title(\"Radial GE\")\nplt.imshow(get_RGE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 4)\nplt.title(\"Radial Weighted GE\")\nplt.imshow(get_RWGE(psf_out))\nplt.colorbar()\nplt.show()\n</pre> # Visualise GE Metrics oversample = 2 final_optics = models_out[-1].optics params = ['psf_pixel_scale', 'psf_npixels'] oversampled = final_optics.multiply(params, [1/oversample, oversample*npix]) oversampled_psf = final_optics.model(source)  # Plot plt.figure(figsize=(20, 4)) plt.subplot(1, 4, 1) plt.title(\"PSF\") plt.imshow(psf_out) plt.colorbar()  plt.subplot(1, 4, 2) plt.title(\"Gradient Energy\") plt.imshow(get_GE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 3) plt.title(\"Radial GE\") plt.imshow(get_RGE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 4) plt.title(\"Radial Weighted GE\") plt.imshow(get_RWGE(psf_out)) plt.colorbar() plt.show() In\u00a0[17]: Copied! <pre># Save mask for use in flatfield_calibration notebook\nmask_out = models_out[-1].mask.get_binary_phase()\nnp.save(\"files/test_mask\", mask_out)\n</pre> # Save mask for use in flatfield_calibration notebook mask_out = models_out[-1].mask.get_binary_phase() np.save(\"files/test_mask\", mask_out)"},{"location":"docs/notebooks/designing_a_mask/#phase-mask-design","title":"Phase Mask Design\u00b6","text":"<p>In this notebook we will illustrate the inverse design of a phase mask, choosing the example from Wong et al., 2021: designing a diffractive pupil phase mask for the Toliman telescope.</p> <p>In order to get high precision centroids, we need to maximise the gradient energy of the pupil; in order to satisfy fabrication constraints, we need a binary mask with phases of only 0 or \u03c0.</p>"},{"location":"docs/notebooks/designing_a_mask/#optimising-the-pupil","title":"Optimising the Pupil\u00b6","text":""},{"location":"docs/notebooks/fisher_information/","title":"Fisher Information","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nfrom jax.config import config\n\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax from jax.config import config  import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl import dLux.utils as dlu  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"text.usetex\"] = 'true' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>Using models from the <code>dLuxToliman</code> package, we need to construct the components of our model:</p> <ul> <li>the optimisable mask</li> <li>the source</li> <li>the optics</li> </ul> In\u00a0[2]: Copied! <pre>from dLuxToliman import AlphaCen, TolimanOptics, ApplyBasisCLIMB\n\n# Construct source\nsource = AlphaCen()\n\n# Optimisable binary mask\nclimb_basis = np.load(\"files/basis.npy\")\ncoefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)])\nmean_wl = source.wavelengths.mean()\nmask_layer = ApplyBasisCLIMB(climb_basis, mean_wl, coefficients)\n\n# Construct instrument\noptics = TolimanOptics(psf_npixels=200, mask=mask_layer, radial_orders=[2, 3])\nmodel = dl.Instrument(optics, source)\n</pre> from dLuxToliman import AlphaCen, TolimanOptics, ApplyBasisCLIMB  # Construct source source = AlphaCen()  # Optimisable binary mask climb_basis = np.load(\"files/basis.npy\") coefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)]) mean_wl = source.wavelengths.mean() mask_layer = ApplyBasisCLIMB(climb_basis, mean_wl, coefficients)  # Construct instrument optics = TolimanOptics(psf_npixels=200, mask=mask_layer, radial_orders=[2, 3]) model = dl.Instrument(optics, source) <p>Visualising the mask and PSF:</p> In\u00a0[3]: Copied! <pre>aperture = model.aperture.transmission\nmask = model.mask.get_binary_phase()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture * mask, cmap='hot')\nplt.title('Input OPD')\n\nplt.subplot(1, 2, 2)\npsf = model.model()\nplt.imshow(psf)\nplt.colorbar()\nplt.title('Input PSF')\nplt.show()\n</pre> aperture = model.aperture.transmission mask = model.mask.get_binary_phase()  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture * mask, cmap='hot') plt.title('Input OPD')  plt.subplot(1, 2, 2) psf = model.model() plt.imshow(psf) plt.colorbar() plt.title('Input PSF') plt.show() <p>Next, we need to define our loss function. We want to maximize the Fisher information; conveniently, <code>zodiax</code> has a Bayesian module that can calculate the covariance matrix and its entropy. This means we only need to define the likelihood function, the parameters we want to marginalise over, and the parameters we wish to optimise.</p> <p>We will optimise the mask coefficients and marginalise over the binary source parameters and optical aberrations.</p> <p>Note we define the <code>shape_dict</code> here to cast the wavelength to a single value, resulting in a marginalisation over the mean wavelength.</p> In\u00a0[4]: Copied! <pre># Marginal params\nshape_dict = {'wavelengths': (1,)}\nmarginal_params = ['separation', 'contrast', 'position_angle', 'wavelengths', \n    'psf_pixel_scale', 'aperture.coefficients']\n\n# Loss function\nopt_param = 'mask.coefficients'\n@zdx.filter_jit\n@zdx.filter_value_and_grad(opt_param)\ndef fim_loss_func(model, parameters):\n    cov = zdx.self_covariance_matrix(model, parameters, zdx.bayes.poiss_loglike, \n        shape_dict=shape_dict)\n    return zdx.covaraince_entropy(cov)\n</pre> # Marginal params shape_dict = {'wavelengths': (1,)} marginal_params = ['separation', 'contrast', 'position_angle', 'wavelengths',      'psf_pixel_scale', 'aperture.coefficients']  # Loss function opt_param = 'mask.coefficients' @zdx.filter_jit @zdx.filter_value_and_grad(opt_param) def fim_loss_func(model, parameters):     cov = zdx.self_covariance_matrix(model, parameters, zdx.bayes.poiss_loglike,          shape_dict=shape_dict)     return zdx.covaraince_entropy(cov) <p>Call the loss function once to compile:</p> In\u00a0[5]: Copied! <pre>%%time\nloss, grads = fim_loss_func(model, marginal_params)\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = fim_loss_func(model, marginal_params) print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -191.1194305419922\nCPU times: user 18.4 s, sys: 612 ms, total: 19 s\nWall time: 10.4 s\n</pre> <p>Now run gradient descent!</p> In\u00a0[6]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, opt_param, optax.adam(2e1))\n\nlosses, models_out = [], [model]\nwith tqdm(range(50),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = fim_loss_func(model, marginal_params)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> optim, opt_state = zdx.get_optimiser(model, opt_param, optax.adam(2e1))  losses, models_out = [], [model] with tqdm(range(50),desc='Gradient Descent') as t:     for i in t:          loss, grads = fim_loss_func(model, marginal_params)         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)         t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> In\u00a0[7]: Copied! <pre>coeffs_out = np.array([model.get(opt_param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\nmask = models_out[0].mask.get_binary_phase()\naxes['C'].imshow(aperture * mask, cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = models_out[0].model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nmask = models_out[-1].mask.get_binary_phase()\naxes['E'].imshow(aperture * mask, cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = models_out[-1].model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n\nplt.show()\n</pre> coeffs_out = np.array([model.get(opt_param) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])   axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  mask = models_out[0].mask.get_binary_phase() axes['C'].imshow(aperture * mask, cmap='hot') axes['C'].set_title('Input OPD')  psf_in = models_out[0].model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  mask = models_out[-1].mask.get_binary_phase() axes['E'].imshow(aperture * mask, cmap='hot') axes['E'].set_title('Final OPD')  psf_out = models_out[-1].model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF')  plt.show() <p>Let's calculate the elements of the covariance matrix:</p> In\u00a0[10]: Copied! <pre>%%time\ncovs = [zdx.self_covariance_matrix(model, marginal_params, zdx.bayes.poiss_loglike, \n        shape_dict=shape_dict) for model in [models_out[0], models_out[-1]]]\n</pre> %%time covs = [zdx.self_covariance_matrix(model, marginal_params, zdx.bayes.poiss_loglike,          shape_dict=shape_dict) for model in [models_out[0], models_out[-1]]] <pre>CPU times: user 14.2 s, sys: 1.02 s, total: 15.2 s\nWall time: 6.65 s\n</pre> <p>And using ChainConsumer we can easily visualise this covariance:</p> In\u00a0[11]: Copied! <pre>from chainconsumer import ChainConsumer\n\nparam_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",\n               \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",\n               \"TfoilX\", \"TfoilY\"]\nX = np.zeros(len(param_names))\nc = ChainConsumer()\nc.add_covariance(X, covs[0], parameters=param_names, name='Initial')\nc.add_covariance(X, covs[1], parameters=param_names, name='Final')\nc.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\n# fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised\nfig = c.plotter.plot()\n</pre> from chainconsumer import ChainConsumer  param_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",                \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",                \"TfoilX\", \"TfoilY\"] X = np.zeros(len(param_names)) c = ChainConsumer() c.add_covariance(X, covs[0], parameters=param_names, name='Initial') c.add_covariance(X, covs[1], parameters=param_names, name='Final') c.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  # fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised fig = c.plotter.plot() <p>It looks like the optimisation worked - marginal posterior bounds for all optical parameters are much tighter after the optimisation.</p> <p>We see that in this narrowband simulation, most parameters are not tightly correlated; but separation, plate scale and wavelength are almost indistinguishable. This makes sense, as they affect the PSF in the same way! Only independent constraints on wavelength can save us here. If you want to do precise astrometry, you have to nail down your plate scale and spectrum; we see that the marginal posterior for separation is unchanged, but dominated entirely by this degeneracy with plate scale and wavelength, which is much tighter for the optimised pupil.</p> <p>This is why we superimpose a grating over our pupil in the Toliman telescope design (design paper, Fig 6) -- we can measure a stellar spectrum and separate this from the astrometry.</p> <p>If we were doing this properly for a telescope design, we would want to take this into account -- our real goal is precisely measuring separation, and everything else is something we can marginalise over. If we incorporate our prior constraints on plate scale and wavelength, I am sure we will do even better.</p>"},{"location":"docs/notebooks/fisher_information/#fisher-information","title":"Fisher Information\u00b6","text":"<p>Autodiff doesn't just make it faster to solve optimisation and inference problems -- it also allows you to use powerful ideas in statistics requiring second derivatives that are intractable analytically or with finite differences.</p> <p>The Fisher Information Matrix, or the inverse of the Hessian of the likelihood, can be used for</p> <ul> <li>the Laplace approximation to a posterior for variational inference, giving you the Gaussian covariance of the posterior near the maximum likelihood point;</li> <li>Fisher forecasting, where you calculate this for an instrument or experiment at expected parameters to predict how well it will constrain them; and</li> <li>optimal design, as the Cram\u00e9r-Rao lower bound on the precision of an experiment is the inverse of the Fisher information matrix - so you want to make this as tight as possible!</li> </ul> <p>Because <code>jax</code> lets us compute the Hessian of our loss function, we can use the Fisher matrix for variational inference without MCMC, and also more powerfully as an objective function to optimise a telescope design; why bother engineering a PSF for a particular goal, when you could model the system end to end and optimise the Fisher forecast precision of the parameter of interest? *</p> <p>* This is the topic of another Desdoigts et al. paper in prep.</p> <p>This notebook follows on from Phase Mask Design and will reuse some code without repeating explanations.</p>"},{"location":"docs/notebooks/flatfield_calibration/","title":"Pixel Level Calibration","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl import dLux.utils as dlu  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>Now we need to construct our model. There are three components that we need:</p> <ol> <li><p>Optics: Here we will use the pre-built Toliman optics model from the <code>dLuxToliman</code> package, ensuring we add some aberration to recover.</p> </li> <li><p>Detector: Here we create a simple detector that applies a simple flat field.</p> </li> <li><p>Sources: This will be a set of point sources with different positions and fluxes.</p> </li> </ol> <p>Let's put all this together and see how it looks.</p> In\u00a0[2]: Copied! <pre>from dLuxToliman import TolimanOptics\n\n# Construct optics\ncoeffs = 2e-8 * jr.normal(jr.PRNGKey(0), (7,))\noptics = TolimanOptics(radial_orders=[2, 3], coefficients=coeffs)\n\n# Create Detector\ndet_npix = optics.psf_npixels\npix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])\ndetector = dl.LayeredDetector([dl.ApplyPixelResponse(pix_response)])\n\n# Create Sources\nNstars = 15\ntrue_positions = dlu.arcsec_to_rad(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-20, maxval=20))\ntrue_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(1), (Nstars,))\nwavels = 1e-9 * np.linspace(545, 645, 3)\nsource = dl.PointSources(wavels, true_positions, true_fluxes)\n</pre> from dLuxToliman import TolimanOptics  # Construct optics coeffs = 2e-8 * jr.normal(jr.PRNGKey(0), (7,)) optics = TolimanOptics(radial_orders=[2, 3], coefficients=coeffs)  # Create Detector det_npix = optics.psf_npixels pix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix]) detector = dl.LayeredDetector([dl.ApplyPixelResponse(pix_response)])  # Create Sources Nstars = 15 true_positions = dlu.arcsec_to_rad(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-20, maxval=20)) true_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(1), (Nstars,)) wavels = 1e-9 * np.linspace(545, 645, 3) source = dl.PointSources(wavels, true_positions, true_fluxes) <p>Now we need to introduce the dithers. We can utilise the built-in <code>Dither</code> observation class:</p> In\u00a0[3]: Copied! <pre># Observation strategy, define dithers\ndet_pixsize = optics.true_pixel_scale\ndithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]])\nobservation = dl.Dither(dithers)\n</pre> # Observation strategy, define dithers det_pixsize = optics.true_pixel_scale dithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]]) observation = dl.Dither(dithers) In\u00a0[4]: Copied! <pre># Combine into instrument and observe!\ntel = dl.Instrument(optics, source, detector, observation)\npsfs = tel.observe()\n</pre> # Combine into instrument and observe! tel = dl.Instrument(optics, source, detector, observation) psfs = tel.observe() In\u00a0[5]: Copied! <pre># Apply some noise to the PSF Background noise\ndata = jr.poisson(jr.PRNGKey(0), psfs)\n\nplt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(data[i])\n    plt.colorbar()\nplt.show()\n</pre> # Apply some noise to the PSF Background noise data = jr.poisson(jr.PRNGKey(0), psfs)  plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(data[i])     plt.colorbar() plt.show() <p>There are four sets of parameters we are going to learn:</p> <ul> <li>Positions</li> <li>Fluxes</li> <li>Zernike aberrations</li> <li>Pixel responses</li> </ul> <p>We start by defining the paths to those parameters; we will define them individually so that we can refer to them easily later.</p> In\u00a0[6]: Copied! <pre>positions = 'PointSources.position'\nfluxes    = 'PointSources.flux'\nzernikes  = 'aperture.coefficients'\nflatfield = 'ApplyPixelResponse.pixel_response'\n\nparameters = [positions, fluxes, zernikes, flatfield]\n</pre> positions = 'PointSources.position' fluxes    = 'PointSources.flux' zernikes  = 'aperture.coefficients' flatfield = 'ApplyPixelResponse.pixel_response'  parameters = [positions, fluxes, zernikes, flatfield] <p>Each of these parameters needs a different initialisation:</p> <ul> <li>Positions need to be shifted by some random value</li> <li>Fluxes need to be multiplied by some random value</li> <li>Zernike coefficients need to be set to zero</li> <li>Pixel response values need to be set to one</li> </ul> <p>We perturb the values to initialise the model.</p> In\u00a0[7]: Copied! <pre># Add small random values to the positions\nmodel = tel.add(positions, 2.*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))\n\n# Multiply the fluxes by small random values\nmodel = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))\n\n# Set the zernike coefficients to zero\nmodel = model.set(zernikes, np.zeros(model.get(zernikes).shape))\n\n# Set the flat field to uniform\nmodel = model.set(flatfield, np.ones((det_npix, det_npix)))\n\n# Generate psfs\npsfs = model.observe()\n</pre> # Add small random values to the positions model = tel.add(positions, 2.*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))  # Multiply the fluxes by small random values model = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))  # Set the zernike coefficients to zero model = model.set(zernikes, np.zeros(model.get(zernikes).shape))  # Set the flat field to uniform model = model.set(flatfield, np.ones((det_npix, det_npix)))  # Generate psfs psfs = model.observe() <p>We can see the residuals are not optimal:</p> In\u00a0[8]: Copied! <pre>plt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(psfs[i] - data[i])\n    plt.colorbar()\nplt.show()\n</pre> plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(psfs[i] - data[i])     plt.colorbar() plt.show() <p>Now we want to generate an <code>optax</code> optimiser object that we can use to train each parameter individually. Because of the various scales and effects on the loss function that each parameter has, we need to set individual learning rates and optimisation schedules for every parameter. Luckily, we have built some functions to help specifically with that!</p> In\u00a0[9]: Copied! <pre># So first we simply set the simple parameters to use an adam optimiser \n# algorithm, with individual learning rates\npos_optimiser   = optax.adam(1e-7)\nflux_optimiser  = optax.adam(1e6)\ncoeff_optimiser = optax.adam(2e-9)\n\n# Now the flat-field, because it is highly covariant with the mean flux level\n# we don't start learning its parameters until the 100th epoch.\nFF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8, \n                             boundaries_and_scales={100 : int(1e8)})\nFF_optimiser = optax.adam(FF_sched)\n\n# Combine the optimisers into a list\noptimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]\n\n# Generate out optax optimiser, and also get our args\noptim, opt_state = zdx.get_optimiser(model, parameters, optimisers)\n</pre> # So first we simply set the simple parameters to use an adam optimiser  # algorithm, with individual learning rates pos_optimiser   = optax.adam(1e-7) flux_optimiser  = optax.adam(1e6) coeff_optimiser = optax.adam(2e-9)  # Now the flat-field, because it is highly covariant with the mean flux level # we don't start learning its parameters until the 100th epoch. FF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8,                               boundaries_and_scales={100 : int(1e8)}) FF_optimiser = optax.adam(FF_sched)  # Combine the optimisers into a list optimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]  # Generate out optax optimiser, and also get our args optim, opt_state = zdx.get_optimiser(model, parameters, optimisers) <p>Poisson log-likelihood:</p> In\u00a0[10]: Copied! <pre>@zdx.filter_jit\n@zdx.filter_value_and_grad(parameters)\ndef loss_fn(model, data):\n    out = model.observe()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</pre> @zdx.filter_jit @zdx.filter_value_and_grad(parameters) def loss_fn(model, data):     out = model.observe()     return -np.sum(jax.scipy.stats.poisson.logpmf(data, out)) <p>Call once to jit compile:</p> In\u00a0[11]: Copied! <pre>%%time\nloss, grads = loss_fn(model, data) # Compile\nprint(\"Initial Loss: {}\".format(int(loss)))\n</pre> %%time loss, grads = loss_fn(model, data) # Compile print(\"Initial Loss: {}\".format(int(loss))) <pre>Initial Loss: 1369240320\nCPU times: user 3.69 s, sys: 141 ms, total: 3.83 s\nWall time: 960 ms\n</pre> <p>Run gradient descent:</p> In\u00a0[12]: Copied! <pre>losses, models_out = [], []\nwith tqdm(range(200),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_fn(model, data)    \n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        losses.append(loss)\n        models_out.append(model)\n        t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar\n</pre> losses, models_out = [], [] with tqdm(range(200),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_fn(model, data)             updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         losses.append(loss)         models_out.append(model)         t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar <pre>Gradient Descent:   0%|          | 0/200 [00:00&lt;?, ?it/s]</pre> <p>Format the output into arrays:</p> In\u00a0[13]: Copied! <pre>nepochs = len(models_out)\npsfs_out = models_out[-1].observe()\n\npositions_found  = np.array([model.get(positions) for model in models_out])\nfluxes_found     = np.array([model.get(fluxes)    for model in models_out])\nzernikes_found   = np.array([model.get(zernikes)  for model in models_out])\nflatfields_found = np.array([model.get(flatfield) for model in models_out])\n</pre> nepochs = len(models_out) psfs_out = models_out[-1].observe()  positions_found  = np.array([model.get(positions) for model in models_out]) fluxes_found     = np.array([model.get(fluxes)    for model in models_out]) zernikes_found   = np.array([model.get(zernikes)  for model in models_out]) flatfields_found = np.array([model.get(flatfield) for model in models_out]) <p>Pull out the quantities to be plotted (e.g. final model and residuals):</p> In\u00a0[14]: Copied! <pre>coeff_residuals = coeffs - zernikes_found\nflux_residuals = true_fluxes - fluxes_found\n\nscaler = 1e3\npositions_residuals = true_positions - positions_found\nr_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1])\nr_residuals = dlu.rad_to_arcsec(r_residuals_rads)\n</pre> coeff_residuals = coeffs - zernikes_found flux_residuals = true_fluxes - fluxes_found  scaler = 1e3 positions_residuals = true_positions - positions_found r_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1]) r_residuals = dlu.rad_to_arcsec(r_residuals_rads) In\u00a0[15]: Copied! <pre>j = len(models_out)\nplt.figure(figsize=(16, 13))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Log10 Loss\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Log10 ADU\")\nplt.plot(np.log10(np.array(losses)[:j]))\n\nplt.subplot(3, 2, 2)\nplt.title(\"Stellar Positions\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Positional Error (arcseconds)\")\nplt.plot(r_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 3)\nplt.title(\"Stellar Fluxes\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Flux Error (Photons)\")\nplt.plot(flux_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Zernike Coeff Residuals\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Residual Amplitude\")\nplt.plot(coeff_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> j = len(models_out) plt.figure(figsize=(16, 13))  plt.subplot(3, 2, 1) plt.title(\"Log10 Loss\") plt.xlabel(\"Epochs\") plt.ylabel(\"Log10 ADU\") plt.plot(np.log10(np.array(losses)[:j]))  plt.subplot(3, 2, 2) plt.title(\"Stellar Positions\") plt.xlabel(\"Epochs\") plt.ylabel(\"Positional Error (arcseconds)\") plt.plot(r_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 3) plt.title(\"Stellar Fluxes\") plt.xlabel(\"Epochs\") plt.ylabel(\"Flux Error (Photons)\") plt.plot(flux_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 4) plt.title(\"Zernike Coeff Residuals\") plt.xlabel(\"Epochs\") plt.ylabel(\"Residual Amplitude\") plt.plot(coeff_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.tight_layout() plt.show() <p>How did the phase retrieval go? Really well, as it happens!</p> In\u00a0[16]: Copied! <pre># OPDs\ntrue_opd = tel.aperture.opd\nopds_found = np.array([model.aperture.opd for model in models_out])\nfound_opd = opds_found[-1]\nopd_residuls = true_opd - opds_found\nopd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5\n\nvmin = np.min(np.array([true_opd, found_opd]))\nvmax = np.max(np.array([true_opd, found_opd]))\n\n# Coefficients\ntrue_coeff = tel.get(zernikes)\nfound_coeff = models_out[-1].get(zernikes)\nindex = np.arange(len(true_coeff))+4\n\nplt.figure(figsize=(20, 10))\nplt.suptitle(\"Optical Aberrations\")\n\nplt.subplot(2, 2, 1)\nplt.title(\"RMS OPD residual\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"RMS OPD (nm)\")\nplt.plot(opd_rmse_nm)\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Zernike Coefficient Amplitude\")\nplt.xlabel(\"Index\")\nplt.ylabel(\"Amplitude\")\nplt.scatter(index, true_coeff, label=\"True Value\")\nplt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x')\nplt.bar(index, true_coeff - found_coeff, label='Residual')\nplt.axhline(0, c='k', alpha=0.5)\nplt.legend()\n\nplt.subplot(2, 3, 4)\nplt.title(\"True OPD\")\nplt.imshow(true_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found OPD\")\nplt.imshow(found_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"OPD Residual\")\nplt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax)\nplt.colorbar()\nplt.show()\n</pre> # OPDs true_opd = tel.aperture.opd opds_found = np.array([model.aperture.opd for model in models_out]) found_opd = opds_found[-1] opd_residuls = true_opd - opds_found opd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5  vmin = np.min(np.array([true_opd, found_opd])) vmax = np.max(np.array([true_opd, found_opd]))  # Coefficients true_coeff = tel.get(zernikes) found_coeff = models_out[-1].get(zernikes) index = np.arange(len(true_coeff))+4  plt.figure(figsize=(20, 10)) plt.suptitle(\"Optical Aberrations\")  plt.subplot(2, 2, 1) plt.title(\"RMS OPD residual\") plt.xlabel(\"Epochs\") plt.ylabel(\"RMS OPD (nm)\") plt.plot(opd_rmse_nm) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(2, 2, 2) plt.title(\"Zernike Coefficient Amplitude\") plt.xlabel(\"Index\") plt.ylabel(\"Amplitude\") plt.scatter(index, true_coeff, label=\"True Value\") plt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x') plt.bar(index, true_coeff - found_coeff, label='Residual') plt.axhline(0, c='k', alpha=0.5) plt.legend()  plt.subplot(2, 3, 4) plt.title(\"True OPD\") plt.imshow(true_opd) plt.colorbar()  plt.subplot(2, 3, 5) plt.title(\"Found OPD\") plt.imshow(found_opd) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"OPD Residual\") plt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax) plt.colorbar() plt.show() <p>Most impressively, we are recovering the thousands of flat field parameters pretty well too!</p> In\u00a0[17]: Copied! <pre># calculate the mask where there was enough flux to infer the flat field\nthresh = 2500\nfmask = data.mean(0) &gt;= thresh\n\nout_mask = np.where(data.mean(0) &lt; thresh)\nin_mask = np.where(data.mean(0) &gt;= thresh)\n\ndata_tile = np.tile(data.mean(0), [len(models_out), 1, 1])\nin_mask_tiled = np.where(data_tile &gt;= thresh)\n\n# calculate residuals\npr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]\n\n# for correlation plot\ntrue_pr_masked = pix_response.at[out_mask].set(1)\nfound_pr_masked = flatfields_found[-1].at[out_mask].set(1)\n\n# FF Scatter Plot\ndata_sum = data.sum(0) # [flux_mask]\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\n# Errors\npfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])])\nptrue = pix_response[in_mask]\npr_res = ptrue - pfound\nmasked_error = np.abs(pr_res).mean(-1)\n\nplt.figure(figsize=(20, 10))\nplt.subplot(2, 3, (1,2))\nplt.title(\"Pixel Response\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Mean Sensitivity Error\")\nplt.plot(masked_error)\nplt.axhline(0, c='k', alpha=0.5)\n\n# FF Scatter Plot\ndata_sum = data.sum(0)\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\nplt.subplot(2, 3, 3)\nplt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75)\nplt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5)\nplt.colorbar()\nplt.title(\"Sensitivity Residual\")\nplt.ylabel(\"Recovered Sensitivity\")\nplt.xlabel(\"True Sensitivity\")\n\nplt.subplot(2, 3, 4)\nplt.title(\"True Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked)\nplt.colorbar()\n\nvmin = np.min(pix_response)\nvmax = np.max(pix_response)\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(found_pr_masked, vmin=vmin, vmax=vmax)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"Pixel Response Residual\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2)\nplt.colorbar()\n\nplt.show()\n</pre> # calculate the mask where there was enough flux to infer the flat field thresh = 2500 fmask = data.mean(0) &gt;= thresh  out_mask = np.where(data.mean(0) &lt; thresh) in_mask = np.where(data.mean(0) &gt;= thresh)  data_tile = np.tile(data.mean(0), [len(models_out), 1, 1]) in_mask_tiled = np.where(data_tile &gt;= thresh)  # calculate residuals pr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]  # for correlation plot true_pr_masked = pix_response.at[out_mask].set(1) found_pr_masked = flatfields_found[-1].at[out_mask].set(1)  # FF Scatter Plot data_sum = data.sum(0) # [flux_mask] colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  # Errors pfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])]) ptrue = pix_response[in_mask] pr_res = ptrue - pfound masked_error = np.abs(pr_res).mean(-1)  plt.figure(figsize=(20, 10)) plt.subplot(2, 3, (1,2)) plt.title(\"Pixel Response\") plt.xlabel(\"Epochs\") plt.ylabel(\"Mean Sensitivity Error\") plt.plot(masked_error) plt.axhline(0, c='k', alpha=0.5)  # FF Scatter Plot data_sum = data.sum(0) colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  plt.subplot(2, 3, 3) plt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75) plt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5) plt.colorbar() plt.title(\"Sensitivity Residual\") plt.ylabel(\"Recovered Sensitivity\") plt.xlabel(\"True Sensitivity\")  plt.subplot(2, 3, 4) plt.title(\"True Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked) plt.colorbar()  vmin = np.min(pix_response) vmax = np.max(pix_response)  plt.subplot(2, 3, 5) plt.title(\"Found Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(found_pr_masked, vmin=vmin, vmax=vmax) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"Pixel Response Residual\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2) plt.colorbar()  plt.show()"},{"location":"docs/notebooks/flatfield_calibration/#pixel-level-calibration","title":"Pixel Level Calibration\u00b6","text":"<p>There are a lot of existing frameworks for phase retrieval, but it is not necessarily straightforward to simultaneously retrieve:</p> <ul> <li>aberrations (the optical distortions, maybe tens of parameters)</li> <li>astrometry (the positions of stars, tens of parameters)</li> <li>inter-pixel sensitivity (aka the 'flat field', on a large pixel grid!)</li> </ul> <p>The dimensionality of the pixel grid can be so high that it is hard to retrieve without automatic differentiation (autodiff). With \u2202Lux, it's easy*!</p> <p>* This is the topic of a Desdoigts et al. paper in prep. It was not easy to build, and we're pretty happy about it.</p>"},{"location":"docs/notebooks/phase_retrieval_demo/","title":"Phase Retrieval in \u2202Lux","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom matplotlib import colormaps\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl import dLux.utils as dlu  # Plotting/visualisation import matplotlib.pyplot as plt from matplotlib import colormaps from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>We want to construct a basic optical system with a $2.4\\, \\text{m}$ aperture, along with some Zernike aberrations and a bar mask.</p> <p>We also create a simple <code>PointSource</code> object that we want to model.</p> <p>Let's see how we can do this in \u2202Lux.</p> In\u00a0[2]: Copied! <pre># Wavefront properties\ndiameter = 2.4\nwf_npixels = 256\n\n# Zernike aberration properties\nradial_terms = [2, 3]\ncoeffs = 1e-7*jr.normal(jr.PRNGKey(0), (7,))\n\n# Construct an aperture\naperture = dl.ApertureFactory(wf_npixels, radial_terms, coeffs)\n\n# Generate an asymmetry\nc, s = wf_npixels//2, 20\nmask = np.ones((wf_npixels, wf_npixels)).at[c-s:c+s, :c].set(0)\n\n# psf params\npsf_npixels = 256 \npsf_pixel_scale = 1e-2 # arcseconds\n\n# Construct Optics\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, psf_npixels, \n    psf_pixel_scale, mask=mask)\n\n# Create a point source\nsource = dl.PointSource(flux=1e5, wavelengths=np.linspace(1e-6, 1.5e-6, 5))\n</pre> # Wavefront properties diameter = 2.4 wf_npixels = 256  # Zernike aberration properties radial_terms = [2, 3] coeffs = 1e-7*jr.normal(jr.PRNGKey(0), (7,))  # Construct an aperture aperture = dl.ApertureFactory(wf_npixels, radial_terms, coeffs)  # Generate an asymmetry c, s = wf_npixels//2, 20 mask = np.ones((wf_npixels, wf_npixels)).at[c-s:c+s, :c].set(0)  # psf params psf_npixels = 256  psf_pixel_scale = 1e-2 # arcseconds  # Construct Optics optics = dl.AngularOptics(wf_npixels, diameter, aperture, psf_npixels,      psf_pixel_scale, mask=mask)  # Create a point source source = dl.PointSource(flux=1e5, wavelengths=np.linspace(1e-6, 1.5e-6, 5)) <p>Let's examine the resulting optical system and generate some data.</p> In\u00a0[3]: Copied! <pre># Model the psf and add some photon noise\npsf = optics.model(source)\ndata = jr.poisson(jr.PRNGKey(1), psf)\n\n# Get mask, setting nan values for visualisation\nsupport = optics.aperture.transmission * optics.mask\nsupport_mask = support.at[support==0.].set(np.nan)\n\n# Get aberrations\nopd = optics.aperture.opd\n\n# Plot\ncmap = colormaps['inferno']\ncmap.set_bad('k',1.)\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(support_mask * opd * 1e6, cmap=cmap)\nplt.title(\"Aberrations\")\nplt.colorbar(label='um')\n\nplt.subplot(1, 2, 2)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar(label='Photons')\nplt.show()\n</pre> # Model the psf and add some photon noise psf = optics.model(source) data = jr.poisson(jr.PRNGKey(1), psf)  # Get mask, setting nan values for visualisation support = optics.aperture.transmission * optics.mask support_mask = support.at[support==0.].set(np.nan)  # Get aberrations opd = optics.aperture.opd  # Plot cmap = colormaps['inferno'] cmap.set_bad('k',1.) plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(support_mask * opd * 1e6, cmap=cmap) plt.title(\"Aberrations\") plt.colorbar(label='um')  plt.subplot(1, 2, 2) plt.title(\"Data\") plt.imshow(data) plt.colorbar(label='Photons') plt.show() <p>Excellent! Now we want to try and recover these aberrations. To do this, we create a new optical system with a different set of Zernike aberrations. If we define the path to the optical aberration coefficients, we can use the <code>.set()</code> method to assign newly randomised coefficient values. With this new optical system we will try to recover the original aberration coefficients using gradient descent methods.</p> In\u00a0[4]: Copied! <pre># Define path to the zernikes\nparam = 'aperture.coefficients'\ncoeffs_init = 1e-7*jr.normal(jr.PRNGKey(2), (len(coeffs),))\nmodel = optics.multiply(param, 0)\n</pre> # Define path to the zernikes param = 'aperture.coefficients' coeffs_init = 1e-7*jr.normal(jr.PRNGKey(2), (len(coeffs),)) model = optics.multiply(param, 0) <p>Now we need to define our loss function, and specify that we want to optimise the Zernike coefficients. To do this, we pass the string path to the Zernike coefficients into the <code>zdx.filter_value_and_grad()</code> function. Note that we also use the <code>zdx.filter_jit()</code> function in order to compile this function into XLA so that future evaluations will be much faster!</p> In\u00a0[5]: Copied! <pre># Define loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef loss_func(model, source, data):\n    psf = model.model(source)\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, psf))\n</pre> # Define loss function @zdx.filter_jit @zdx.filter_value_and_grad(param) def loss_func(model, source, data):     psf = model.model(source)     return -np.sum(jax.scipy.stats.poisson.logpmf(data, psf)) <p>Compiling the function into XLA:</p> In\u00a0[6]: Copied! <pre>%%time\nloss, initial_grads = loss_func(model, source, data) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, initial_grads = loss_func(model, source, data) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: 144743.921875\nCPU times: user 324 ms, sys: 15.3 ms, total: 339 ms\nWall time: 274 ms\n</pre> <p>Now, we begin the optimisation loop using <code>optax</code> with a low learning rate.</p> In\u00a0[7]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, param, optax.adam(1e-8))\n\nlosses, models_out = [], []\nwith tqdm(range(100), desc='Gradient Descent') as t:\n    for i in t: \n        # calculate the loss and gradient\n        loss, grads = loss_func(model, source, data) \n        \n        # apply the update\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        \n        # save results\n        models_out.append(model) \n        losses.append(loss)\n        \n        t.set_description('Loss %.5f' % (loss)) # update the progress bar\n</pre> optim, opt_state = zdx.get_optimiser(model, param, optax.adam(1e-8))  losses, models_out = [], [] with tqdm(range(100), desc='Gradient Descent') as t:     for i in t:          # calculate the loss and gradient         loss, grads = loss_func(model, source, data)                   # apply the update         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)                  # save results         models_out.append(model)          losses.append(loss)                  t.set_description('Loss %.5f' % (loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Now, we visualise this: we have great performance, recovering the input Zernike coefficients and PSF accurately.</p> In\u00a0[8]: Copied! <pre>psf = model.model(source)\ncoeffs_found = np.array([model_out.get(param) for model_out in models_out])\n\nmosaic = \"\"\"\n    AABB\n    CDEF\n    \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['B','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Training History\")\naxes['A'].set_xlabel('Training Epoch')\naxes['A'].set_ylabel('Poisson Log-Likelihood')\n\naxes['B'].plot(coeffs*1e9, coeffs_found[-1]*1e9,'.', markersize=12,color='C0',label='Recovered')\naxes['B'].plot(coeffs*1e9, coeffs_init*1e9,'.', markersize=12,color='C1',label='Initial')\n\naxes['B'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               '-',color='C2',label='1:1')\naxes['B'].legend()\naxes['B'].set_title('Correlation Plot ')\naxes['B'].set_xlabel('True Zernike Coefficients (nm)')\naxes['B'].set_ylabel('Model Zernike Coefficients (nm)')\n\naxes['C'].imshow(data)\naxes['C'].set_title('Data')\n\naxes['D'].imshow(psf)\naxes['D'].set_title('Recovered PSF')\n\naxes['E'].imshow(support_mask*opd, cmap=cmap)\naxes['E'].set_title('Input Aberrations')\n\naxes['F'].imshow(support_mask*model.aperture.opd, cmap=cmap)\naxes['F'].set_title('Recovered Aberrations')\nplt.show()\n</pre> psf = model.model(source) coeffs_found = np.array([model_out.get(param) for model_out in models_out])  mosaic = \"\"\"     AABB     CDEF     \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['B','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Training History\") axes['A'].set_xlabel('Training Epoch') axes['A'].set_ylabel('Poisson Log-Likelihood')  axes['B'].plot(coeffs*1e9, coeffs_found[-1]*1e9,'.', markersize=12,color='C0',label='Recovered') axes['B'].plot(coeffs*1e9, coeffs_init*1e9,'.', markersize=12,color='C1',label='Initial')  axes['B'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,                np.array([np.min(coeffs),np.max(coeffs)])*1e9,                '-',color='C2',label='1:1') axes['B'].legend() axes['B'].set_title('Correlation Plot ') axes['B'].set_xlabel('True Zernike Coefficients (nm)') axes['B'].set_ylabel('Model Zernike Coefficients (nm)')  axes['C'].imshow(data) axes['C'].set_title('Data')  axes['D'].imshow(psf) axes['D'].set_title('Recovered PSF')  axes['E'].imshow(support_mask*opd, cmap=cmap) axes['E'].set_title('Input Aberrations')  axes['F'].imshow(support_mask*model.aperture.opd, cmap=cmap) axes['F'].set_title('Recovered Aberrations') plt.show()"},{"location":"docs/notebooks/phase_retrieval_demo/#phase-retrieval-in-lux","title":"Phase Retrieval in \u2202Lux\u00b6","text":"<p>In this notebook, we will go through a simple example of phase retrieval in \u2202Lux: recovering Zernike coefficients for an aberrated circular aperture by gradient descent. As noted by Martinache et al. 2013, you can only detect the sign of even-order aberrations if your pupil is not inversion-symmetric.</p> <p>We will follow the example in the paper and recover Zernike aberrations using a circular pupil with an additional bar asymmetry.</p>"},{"location":"tests/conftest/","title":"Conftest","text":"In\u00a0[\u00a0]: Copied! <pre>import pytest\nimport jax.numpy as np\nfrom jax import Array\nimport dLux\n</pre> import pytest import jax.numpy as np from jax import Array import dLux In\u00a0[\u00a0]: Copied! <pre>from dLux import (\n    wavefronts,\n    optical_layers,\n    propagators,\n    apertures,\n    aberrations,\n    optics,\n    images,\n    detectors,\n    detector_layers,\n    instruments,\n    observations,\n    sources,\n    spectra,\n    utils,\n    )\n</pre> from dLux import (     wavefronts,     optical_layers,     propagators,     apertures,     aberrations,     optics,     images,     detectors,     detector_layers,     instruments,     observations,     sources,     spectra,     utils,     ) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nThere are Four main parts of dLux:\n\nClasses that operate on/interact with wavefronts\n    wavefronts.py     : 2 Classes\n    aberrations.py    : 2 Classes\n    optics.py         : 4 Classes\n    propagators.py    : 4 Classes\n    optical_layers.py : 8 Classes\n    apertures.py      : 9 Classes\n\nClasses that operate on/interact with images\n    images.py          : 1 Classes\n    detectors.py       : 1 Classes\n    detector_layers.py : 6 Classes\n\nSource objects the operate on optics classes\n    sources.py      : 5 Classes\n    spectra.py      : 2 Classes\n\nOther main class types\n    instruments.py  : 1 Classes\n    observations.py : 1 Classes\n\nSub Modules\n    utils.py\n\"\"\"\n</pre> \"\"\" There are Four main parts of dLux:  Classes that operate on/interact with wavefronts     wavefronts.py     : 2 Classes     aberrations.py    : 2 Classes     optics.py         : 4 Classes     propagators.py    : 4 Classes     optical_layers.py : 8 Classes     apertures.py      : 9 Classes  Classes that operate on/interact with images     images.py          : 1 Classes     detectors.py       : 1 Classes     detector_layers.py : 6 Classes  Source objects the operate on optics classes     sources.py      : 5 Classes     spectra.py      : 2 Classes  Other main class types     instruments.py  : 1 Classes     observations.py : 1 Classes  Sub Modules     utils.py \"\"\" In\u00a0[\u00a0]: Copied! <pre>'''=============================================================================\n================================================================================\n# Wavefronts\n------------\n\nwavefronts.py classes:\n    Wavefront\n    FresnelWavefront\n\n'''\n@pytest.fixture\ndef create_wavefront():\n    def _create_wavefront(\n        npixels : int = 16,\n        diameter : Array = np.array(1.),\n        wavelength : Array = np.array(1e-6)):\n        return wavefronts.Wavefront(\n            npixels=npixels, \n            diameter=diameter, \n            wavelength=wavelength)\n    return _create_wavefront\n</pre> '''============================================================================= ================================================================================ # Wavefronts ------------  wavefronts.py classes:     Wavefront     FresnelWavefront  ''' @pytest.fixture def create_wavefront():     def _create_wavefront(         npixels : int = 16,         diameter : Array = np.array(1.),         wavelength : Array = np.array(1e-6)):         return wavefronts.Wavefront(             npixels=npixels,              diameter=diameter,              wavelength=wavelength)     return _create_wavefront In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_fresnel_wavefront():\n    def _create_fresnel_wavefront(\n        npixels : int = 16,\n        diameter : Array = np.array(1.),\n        wavelength : Array = np.array(1e-6)):\n        return wavefronts.FresnelWavefront(\n            npixels=npixels, \n            diameter=diameter, \n            wavelength=wavelength)\n    return _create_fresnel_wavefront\n</pre> @pytest.fixture def create_fresnel_wavefront():     def _create_fresnel_wavefront(         npixels : int = 16,         diameter : Array = np.array(1.),         wavelength : Array = np.array(1e-6)):         return wavefronts.FresnelWavefront(             npixels=npixels,              diameter=diameter,              wavelength=wavelength)     return _create_fresnel_wavefront In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\n# Aberrations\n-------------\n\naberrations.py classes:\n    Zernike\n    ZernikeBasis\n\n'''\n@pytest.fixture\ndef create_zernike():\n\"\"\"Constructs the Zernike class for testing.\"\"\"\n    def _create_zernike(j : int = 1):\n        return aberrations.Zernike(j=j)\n    return _create_zernike\n</pre> ''' ================================================================================ ================================================================================ # Aberrations -------------  aberrations.py classes:     Zernike     ZernikeBasis  ''' @pytest.fixture def create_zernike():     \"\"\"Constructs the Zernike class for testing.\"\"\"     def _create_zernike(j : int = 1):         return aberrations.Zernike(j=j)     return _create_zernike In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_zernike_basis():\n\"\"\"Constructs the ZernikeBasis class for testing.\"\"\"\n    def _create_zernike_basis(\n            js : Array = np.arange(1, 4)):\n        return aberrations.ZernikeBasis(js=js)\n    return _create_zernike_basis\n</pre> @pytest.fixture def create_zernike_basis():     \"\"\"Constructs the ZernikeBasis class for testing.\"\"\"     def _create_zernike_basis(             js : Array = np.arange(1, 4)):         return aberrations.ZernikeBasis(js=js)     return _create_zernike_basis In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\n# Optics\n--------\n\noptics.py classes:\n    LayeredOptics\n    AngularOptics\n    CartesianOptics\n    FlexibleOptics\n\n'''\naperture = apertures.ApertureFactory(16)\npropagator = propagators.MFT(16, 1)\nmask = np.ones((16, 16))\n</pre> ''' ================================================================================ ================================================================================ # Optics --------  optics.py classes:     LayeredOptics     AngularOptics     CartesianOptics     FlexibleOptics  ''' aperture = apertures.ApertureFactory(16) propagator = propagators.MFT(16, 1) mask = np.ones((16, 16)) In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_angular_optics():\n\"\"\"Constructs the AngularOptics class for testing.\"\"\"\n    def _create_angular_optics(\n        wf_npixels      : int   = 16,\n        diameter        : float = 1.,\n        aperture        : Array = aperture,\n        psf_npixels     : int   = 16,\n        psf_pixel_scale : float = 1.,\n        psf_oversample  : int   = 1,\n        mask            : Array = mask):\n        return optics.AngularOptics(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n            mask=mask)\n    return _create_angular_optics\n</pre> @pytest.fixture def create_angular_optics():     \"\"\"Constructs the AngularOptics class for testing.\"\"\"     def _create_angular_optics(         wf_npixels      : int   = 16,         diameter        : float = 1.,         aperture        : Array = aperture,         psf_npixels     : int   = 16,         psf_pixel_scale : float = 1.,         psf_oversample  : int   = 1,         mask            : Array = mask):         return optics.AngularOptics(             wf_npixels=wf_npixels,             diameter=diameter,             aperture=aperture,             psf_npixels=psf_npixels,             psf_pixel_scale=psf_pixel_scale,             psf_oversample=psf_oversample,             mask=mask)     return _create_angular_optics In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_cartesian_optics():\n\"\"\"Constructs the CartesianOptics class for testing.\"\"\"\n    def _create_cartesian_optics(\n        wf_npixels      : int   = 16,\n        diameter        : float = 1.,\n        aperture        : Array = aperture,\n        focal_length    : float = 10.,\n        psf_npixels     : int = 16,\n        psf_pixel_scale : float = 1.,\n        psf_oversample  : int = 1,\n        mask            : Array = mask):\n        return optics.CartesianOptics(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            focal_length=focal_length,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            psf_oversample=psf_oversample,\n            mask=mask)\n    return _create_cartesian_optics\n</pre> @pytest.fixture def create_cartesian_optics():     \"\"\"Constructs the CartesianOptics class for testing.\"\"\"     def _create_cartesian_optics(         wf_npixels      : int   = 16,         diameter        : float = 1.,         aperture        : Array = aperture,         focal_length    : float = 10.,         psf_npixels     : int = 16,         psf_pixel_scale : float = 1.,         psf_oversample  : int = 1,         mask            : Array = mask):         return optics.CartesianOptics(             wf_npixels=wf_npixels,             diameter=diameter,             aperture=aperture,             focal_length=focal_length,             psf_npixels=psf_npixels,             psf_pixel_scale=psf_pixel_scale,             psf_oversample=psf_oversample,             mask=mask)     return _create_cartesian_optics In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_flexible_optics():\n\"\"\"Constructs the FlexibleOptics class for testing.\"\"\"\n    def _create_flexible_optics(\n        wf_npixels  : int   = 16,\n        diameter    : float = 1.,\n        aperture    : Array = aperture,\n        propagator  : Array = propagator,\n        mask        : Array = mask):\n        return optics.FlexibleOptics(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            aperture=aperture,\n            propagator=propagator,\n            mask=mask)\n    return _create_flexible_optics\n</pre> @pytest.fixture def create_flexible_optics():     \"\"\"Constructs the FlexibleOptics class for testing.\"\"\"     def _create_flexible_optics(         wf_npixels  : int   = 16,         diameter    : float = 1.,         aperture    : Array = aperture,         propagator  : Array = propagator,         mask        : Array = mask):         return optics.FlexibleOptics(             wf_npixels=wf_npixels,             diameter=diameter,             aperture=aperture,             propagator=propagator,             mask=mask)     return _create_flexible_optics In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_layered_optics():\n\"\"\"Constructs the LayeredOptics class for testing.\"\"\"\n    def _create_layered_optics(\n        wf_npixels : int   = 16,\n        diameter   : float = 1,\n        layers     : list  = [aperture, propagator]):\n        return optics.LayeredOptics(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            layers=layers)\n    return _create_layered_optics\n</pre> @pytest.fixture def create_layered_optics():     \"\"\"Constructs the LayeredOptics class for testing.\"\"\"     def _create_layered_optics(         wf_npixels : int   = 16,         diameter   : float = 1,         layers     : list  = [aperture, propagator]):         return optics.LayeredOptics(             wf_npixels=wf_npixels,             diameter=diameter,             layers=layers)     return _create_layered_optics In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\n# Propagators\n-------------\n\npropagators.py classes:\n    MFT\n    FFT\n    ShiftedMFT\n    FarFieldFresnel\n\n'''\n@pytest.fixture\ndef create_fft():\n    def _create_fft(\n        focal_length : Array = 1.,\n        pad          : int = 2,\n        inverse      : bool = False):\n        return propagators.FFT(focal_length=focal_length, pad=pad, \n            inverse=inverse)\n    return _create_fft\n</pre> ''' ================================================================================ ================================================================================ # Propagators -------------  propagators.py classes:     MFT     FFT     ShiftedMFT     FarFieldFresnel  ''' @pytest.fixture def create_fft():     def _create_fft(         focal_length : Array = 1.,         pad          : int = 2,         inverse      : bool = False):         return propagators.FFT(focal_length=focal_length, pad=pad,              inverse=inverse)     return _create_fft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_mft():\n    def _create_mft(\n        pixel_scale  : Array = 1.,\n        npixels      : int   = 16,\n        focal_length : Array = 1.,\n        inverse      : bool = False):\n        return propagators.MFT(npixels=npixels, pixel_scale=pixel_scale,\n            focal_length=focal_length, inverse=inverse)\n    return _create_mft\n</pre> @pytest.fixture def create_mft():     def _create_mft(         pixel_scale  : Array = 1.,         npixels      : int   = 16,         focal_length : Array = 1.,         inverse      : bool = False):         return propagators.MFT(npixels=npixels, pixel_scale=pixel_scale,             focal_length=focal_length, inverse=inverse)     return _create_mft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_shifted_mft():\n    def _create_shifted_mft(\n        pixel_scale  : Array = 1.,\n        npixels      : int   = 16,\n        shift        : Array = np.zeros(2),\n        focal_length : Array = None,\n        pixel        : bool = False,\n        inverse      : bool = False):\n        return propagators.ShiftedMFT(npixels=npixels, pixel_scale=pixel_scale,\n            shift=shift, focal_length=focal_length, inverse=inverse)\n    return _create_shifted_mft\n</pre> @pytest.fixture def create_shifted_mft():     def _create_shifted_mft(         pixel_scale  : Array = 1.,         npixels      : int   = 16,         shift        : Array = np.zeros(2),         focal_length : Array = None,         pixel        : bool = False,         inverse      : bool = False):         return propagators.ShiftedMFT(npixels=npixels, pixel_scale=pixel_scale,             shift=shift, focal_length=focal_length, inverse=inverse)     return _create_shifted_mft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_far_field_fresnel():\n    def _create_far_field_fresnel(\n        npixels      : int   = 16,\n        pixel_scale  : float = np.array(1.),\n        focal_length : Array = np.array(1.),\n        focal_shift  : Array = np.array(1e-3),\n        shift        : Array = np.zeros(2),\n        pixel        : bool  = False,\n        inverse      : bool  = False):\n        return propagators.FarFieldFresnel(npixels=npixels, \n            pixel_scale=pixel_scale, focal_length=focal_length,\n            inverse=inverse, focal_shift=focal_shift,pixel=pixel)\n    return _create_far_field_fresnel\n</pre> @pytest.fixture def create_far_field_fresnel():     def _create_far_field_fresnel(         npixels      : int   = 16,         pixel_scale  : float = np.array(1.),         focal_length : Array = np.array(1.),         focal_shift  : Array = np.array(1e-3),         shift        : Array = np.zeros(2),         pixel        : bool  = False,         inverse      : bool  = False):         return propagators.FarFieldFresnel(npixels=npixels,              pixel_scale=pixel_scale, focal_length=focal_length,             inverse=inverse, focal_shift=focal_shift,pixel=pixel)     return _create_far_field_fresnel In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\n# Optical Layers\n----------------\n\noptical_layers.py classes:\n    Tilt\n    Normalise\n    Rotate\n    Optic\n    BasisOptic\n    PhaseOptic\n    PhaseBasisOptic\n\n'''\n@pytest.fixture\ndef create_tilt():\n\"\"\"Constructs the Tilt class for testing.\"\"\"\n    def _create_tilt(angles : Array = np.ones(2)):\n        return optical_layers.Tilt(angles=angles)\n    return _create_tilt\n</pre> ''' ================================================================================ ================================================================================ # Optical Layers ----------------  optical_layers.py classes:     Tilt     Normalise     Rotate     Optic     BasisOptic     PhaseOptic     PhaseBasisOptic  ''' @pytest.fixture def create_tilt():     \"\"\"Constructs the Tilt class for testing.\"\"\"     def _create_tilt(angles : Array = np.ones(2)):         return optical_layers.Tilt(angles=angles)     return _create_tilt In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_normalise():\n\"\"\"Constructs the Normalise class for testing.\"\"\"\n    def _create_normalise():\n        return optical_layers.Normalise()\n    return _create_normalise\n</pre> @pytest.fixture def create_normalise():     \"\"\"Constructs the Normalise class for testing.\"\"\"     def _create_normalise():         return optical_layers.Normalise()     return _create_normalise In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rotate():\n\"\"\"Constructs the Rotate class for testing.\"\"\"\n    def _create_rotate(\n        angle   : Array = np.array(np.pi), \n        order   : int   = 1, \n        complex : bool  = False):\n        return optical_layers.Rotate(angle=angle, order=order, complex=complex)\n    return _create_rotate\n</pre> @pytest.fixture def create_rotate():     \"\"\"Constructs the Rotate class for testing.\"\"\"     def _create_rotate(         angle   : Array = np.array(np.pi),          order   : int   = 1,          complex : bool  = False):         return optical_layers.Rotate(angle=angle, order=order, complex=complex)     return _create_rotate In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_optic():\n\"\"\"Constructs the Optic class for testing.\"\"\"\n    def _create_optic(\n        transmission : Array = np.ones((16, 16)),\n        opd          : Array = np.zeros((16, 16)),\n        normalise    : bool = True):\n        return optical_layers.Optic(transmission=transmission, opd=opd, \n            normalise=normalise)\n    return _create_optic\n</pre> @pytest.fixture def create_optic():     \"\"\"Constructs the Optic class for testing.\"\"\"     def _create_optic(         transmission : Array = np.ones((16, 16)),         opd          : Array = np.zeros((16, 16)),         normalise    : bool = True):         return optical_layers.Optic(transmission=transmission, opd=opd,              normalise=normalise)     return _create_optic  In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_basis_optic():\n\"\"\"Constructs the BasisOptic class for testing.\"\"\"\n    def _create_basis_optic(\n        transmission : Array = np.ones((16, 16)),\n        basis        : Array = np.ones((3, 16, 16)),\n        coefficients : Array = np.zeros(3),\n        normalise    : bool = True):\n        return optical_layers.BasisOptic(transmission=transmission, basis=basis, \n            coefficients=coefficients, normalise=normalise)\n    return _create_basis_optic\n</pre> @pytest.fixture def create_basis_optic():     \"\"\"Constructs the BasisOptic class for testing.\"\"\"     def _create_basis_optic(         transmission : Array = np.ones((16, 16)),         basis        : Array = np.ones((3, 16, 16)),         coefficients : Array = np.zeros(3),         normalise    : bool = True):         return optical_layers.BasisOptic(transmission=transmission, basis=basis,              coefficients=coefficients, normalise=normalise)     return _create_basis_optic  In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_phase_optic():\n\"\"\"Constructs the PhaseOptic class for testing.\"\"\"\n    def _create_phase_optic(\n        transmission : Array = np.ones((16, 16)),\n        phase        : Array = np.zeros((16, 16)),\n        normalise    : bool = True):\n        return optical_layers.PhaseOptic(transmission=transmission, phase=phase, \n            normalise=normalise)\n    return _create_phase_optic\n</pre> @pytest.fixture def create_phase_optic():     \"\"\"Constructs the PhaseOptic class for testing.\"\"\"     def _create_phase_optic(         transmission : Array = np.ones((16, 16)),         phase        : Array = np.zeros((16, 16)),         normalise    : bool = True):         return optical_layers.PhaseOptic(transmission=transmission, phase=phase,              normalise=normalise)     return _create_phase_optic  In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_phase_basis_optic():\n\"\"\"Constructs the PhaseBasisOptic class for testing.\"\"\"\n    def _create_phase_basis_optic(\n        transmission : Array = np.ones((16, 16)),\n        basis        : Array = np.ones((3, 16, 16)),\n        coefficients : Array = np.zeros(3),\n        normalise    : bool = True):\n        return optical_layers.PhaseBasisOptic(transmission=transmission, basis=basis, \n            coefficients=coefficients, normalise=normalise)\n    return _create_phase_basis_optic\n</pre> @pytest.fixture def create_phase_basis_optic():     \"\"\"Constructs the PhaseBasisOptic class for testing.\"\"\"     def _create_phase_basis_optic(         transmission : Array = np.ones((16, 16)),         basis        : Array = np.ones((3, 16, 16)),         coefficients : Array = np.zeros(3),         normalise    : bool = True):         return optical_layers.PhaseBasisOptic(transmission=transmission, basis=basis,              coefficients=coefficients, normalise=normalise)     return _create_phase_basis_optic In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\n# Apertures\n-----------\n\naperture.py classes:\n    CircularAperture\n    RectangularAperture\n    RegPolyAperture\n    IrregPolyAperture\n    AberratedAperture\n    UniformSpider\n    CompoundAperture\n    MultiAperture\n    ApertureFactory\n\n'''\n@pytest.fixture\ndef create_circular_aperture():\n    def _create_circular_aperture( \n        radius      : Array = 1., \n        centre      : Array = [0., 0.],\n        shear       : Array = [0., 0.],\n        compression : Array = [1., 1.],\n        occulting   : bool = False, \n        softening   : Array = 0.,\n        normalise   : bool = True):\n        return apertures.CircularAperture(\n            radius=radius,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise)\n    return _create_circular_aperture\n</pre> ''' ================================================================================ ================================================================================ # Apertures -----------  aperture.py classes:     CircularAperture     RectangularAperture     RegPolyAperture     IrregPolyAperture     AberratedAperture     UniformSpider     CompoundAperture     MultiAperture     ApertureFactory  ''' @pytest.fixture def create_circular_aperture():     def _create_circular_aperture(          radius      : Array = 1.,          centre      : Array = [0., 0.],         shear       : Array = [0., 0.],         compression : Array = [1., 1.],         occulting   : bool = False,          softening   : Array = 0.,         normalise   : bool = True):         return apertures.CircularAperture(             radius=radius,             centre=centre,             shear=shear,             compression=compression,             occulting=occulting,             softening=softening,             normalise=normalise)     return _create_circular_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rectangular_aperture():\n    def _create_rectangular_aperture(\n        height      : Array = 0.5, \n        width       : Array = 1., \n        centre      : Array = [0., 0.],\n        shear       : Array = [0., 0.],\n        compression : Array = [1., 1.],\n        rotation    : Array = 0.,\n        occulting   : bool = False, \n        softening   : Array = 0.,\n        normalise   : bool = True):\n        return apertures.RectangularAperture(\n            height=height,\n            width=width,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise)\n    return _create_rectangular_aperture\n</pre> @pytest.fixture def create_rectangular_aperture():     def _create_rectangular_aperture(         height      : Array = 0.5,          width       : Array = 1.,          centre      : Array = [0., 0.],         shear       : Array = [0., 0.],         compression : Array = [1., 1.],         rotation    : Array = 0.,         occulting   : bool = False,          softening   : Array = 0.,         normalise   : bool = True):         return apertures.RectangularAperture(             height=height,             width=width,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise)     return _create_rectangular_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_reg_poly_aperture():\n    def _create_reg_poly_aperture( \n        nsides      : int = 4,\n        rmax        : float = 0.5,\n        centre      : Array = [0., 0.],\n        shear       : Array = [0., 0.],\n        compression : Array = [1., 1.],\n        rotation    : Array = 0.,\n        occulting   : bool = False, \n        softening   : Array = 0.,\n        normalise   : bool = True):\n        return apertures.RegPolyAperture(\n            nsides=nsides,\n            rmax=rmax,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise)\n    return _create_reg_poly_aperture\n</pre> @pytest.fixture def create_reg_poly_aperture():     def _create_reg_poly_aperture(          nsides      : int = 4,         rmax        : float = 0.5,         centre      : Array = [0., 0.],         shear       : Array = [0., 0.],         compression : Array = [1., 1.],         rotation    : Array = 0.,         occulting   : bool = False,          softening   : Array = 0.,         normalise   : bool = True):         return apertures.RegPolyAperture(             nsides=nsides,             rmax=rmax,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise)     return _create_reg_poly_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_irreg_poly_aperture():\n    def _create_irreg_poly_aperture( \n        vertices    : Array = np.array([[0.5,   0.5], [0.5, -0.5], \n                                        [-0.5, -0.5], [-0.5, 0.5]]),\n        centre      : Array = [0., 0.],\n        shear       : Array = [0., 0.],\n        compression : Array = [1., 1.],\n        rotation    : Array = 0.,\n        occulting   : bool = False, \n        softening   : Array = 0.,\n        normalise   : bool = True):\n        return apertures.IrregPolyAperture(\n            vertices=vertices,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise)\n    return _create_irreg_poly_aperture\n</pre> @pytest.fixture def create_irreg_poly_aperture():     def _create_irreg_poly_aperture(          vertices    : Array = np.array([[0.5,   0.5], [0.5, -0.5],                                          [-0.5, -0.5], [-0.5, 0.5]]),         centre      : Array = [0., 0.],         shear       : Array = [0., 0.],         compression : Array = [1., 1.],         rotation    : Array = 0.,         occulting   : bool = False,          softening   : Array = 0.,         normalise   : bool = True):         return apertures.IrregPolyAperture(             vertices=vertices,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             occulting=occulting,             softening=softening,             normalise=normalise)     return _create_irreg_poly_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_aberrated_aperture(create_circular_aperture):\n    nterms = 6\n    def _create_aberrated_aperture(\n        aperture: object = create_circular_aperture(),\n        noll_inds: list = np.arange(1, nterms+1, dtype=int),\n        coefficients: Array = np.zeros(nterms, dtype=float)):\n        return apertures.AberratedAperture(\n            aperture=aperture,\n            noll_inds=noll_inds,\n            coefficients=coefficients)\n    return _create_aberrated_aperture\n</pre> @pytest.fixture def create_aberrated_aperture(create_circular_aperture):     nterms = 6     def _create_aberrated_aperture(         aperture: object = create_circular_aperture(),         noll_inds: list = np.arange(1, nterms+1, dtype=int),         coefficients: Array = np.zeros(nterms, dtype=float)):         return apertures.AberratedAperture(             aperture=aperture,             noll_inds=noll_inds,             coefficients=coefficients)     return _create_aberrated_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_uniform_spider():\n    def _create_uniform_spider(\n        nstruts     : int = 4,\n        strut_width : float = .05,\n        centre      : Array = [0., 0.], \n        shear       : Array = [0., 0.],\n        compression : Array = [1., 1.],\n        rotation    : Array = 0., \n        softening   : bool = False,\n        normalise   : bool = True):\n        return apertures.UniformSpider(\n            nstruts=nstruts, \n            strut_width=strut_width,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            softening=softening,\n            normalise=normalise)\n    return _create_uniform_spider\n</pre> @pytest.fixture def create_uniform_spider():     def _create_uniform_spider(         nstruts     : int = 4,         strut_width : float = .05,         centre      : Array = [0., 0.],          shear       : Array = [0., 0.],         compression : Array = [1., 1.],         rotation    : Array = 0.,          softening   : bool = False,         normalise   : bool = True):         return apertures.UniformSpider(             nstruts=nstruts,              strut_width=strut_width,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             softening=softening,             normalise=normalise)     return _create_uniform_spider In\u00a0[\u00a0]: Copied! <pre># Note the apertures input is mapped to 'apers' since apertures is already\n# taken in the namespcae for the aperture module\n@pytest.fixture\ndef create_compound_aperture(create_circular_aperture):\n    def _create_compound_aperture(\n        apers       : list = [create_circular_aperture()],\n        centre      : Array = np.array([0., 0.]), \n        shear       : Array = np.array([0., 0.]),\n        compression : Array = np.array([1., 1.]),\n        rotation    : Array = np.array(0.),\n        normalise: bool = True):\n        return apertures.CompoundAperture(apertures=apers, normalise=normalise)\n    return _create_compound_aperture\n</pre> # Note the apertures input is mapped to 'apers' since apertures is already # taken in the namespcae for the aperture module @pytest.fixture def create_compound_aperture(create_circular_aperture):     def _create_compound_aperture(         apers       : list = [create_circular_aperture()],         centre      : Array = np.array([0., 0.]),          shear       : Array = np.array([0., 0.]),         compression : Array = np.array([1., 1.]),         rotation    : Array = np.array(0.),         normalise: bool = True):         return apertures.CompoundAperture(apertures=apers, normalise=normalise)     return _create_compound_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_multi_aperture(create_circular_aperture):\n    def _create_multi_aperture(\n        apers       : list = [create_circular_aperture()],\n        centre      : Array = np.array([0., 0.]), \n        shear       : Array = np.array([0., 0.]),\n        compression : Array = np.array([1., 1.]),\n        rotation    : Array = np.array(0.),\n        normalise: bool = True):\n        return apertures.MultiAperture(apertures=apers, normalise=normalise)\n    return _create_multi_aperture\n</pre> @pytest.fixture def create_multi_aperture(create_circular_aperture):     def _create_multi_aperture(         apers       : list = [create_circular_aperture()],         centre      : Array = np.array([0., 0.]),          shear       : Array = np.array([0., 0.]),         compression : Array = np.array([1., 1.]),         rotation    : Array = np.array(0.),         normalise: bool = True):         return apertures.MultiAperture(apertures=apers, normalise=normalise)     return _create_multi_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_aperture_factory(create_circular_aperture):\n    def _create_aperture_factory(\n        npixels          : int   = 16,\n        radial_orders    : Array = [0, 1, 2],\n        coefficients     : Array = None, \n        noll_indices     : Array = None,\n        aperture_ratio   : float = 1.0,\n        secondary_ratio  : float = 0.,\n        nsides           : int   = 0,\n        secondary_nsides : int   = 0,\n        rotation         : float = 0., \n        nstruts          : int   = 0,\n        strut_ratio      : float = 0.,\n        strut_rotation   : float = 0.,\n        normalise        : bool  = True):\n        return apertures.ApertureFactory(\n            npixels=npixels,\n            radial_orders=radial_orders,\n            coefficients=coefficients,\n            noll_indices=noll_indices,\n            aperture_ratio=aperture_ratio,\n            secondary_ratio=secondary_ratio,\n            nsides=nsides,\n            secondary_nsides=secondary_nsides,\n            rotation=rotation,\n            nstruts=nstruts,\n            strut_ratio=strut_ratio,\n            strut_rotation=strut_rotation,\n            normalise=normalise)\n    return _create_aperture_factory\n</pre> @pytest.fixture def create_aperture_factory(create_circular_aperture):     def _create_aperture_factory(         npixels          : int   = 16,         radial_orders    : Array = [0, 1, 2],         coefficients     : Array = None,          noll_indices     : Array = None,         aperture_ratio   : float = 1.0,         secondary_ratio  : float = 0.,         nsides           : int   = 0,         secondary_nsides : int   = 0,         rotation         : float = 0.,          nstruts          : int   = 0,         strut_ratio      : float = 0.,         strut_rotation   : float = 0.,         normalise        : bool  = True):         return apertures.ApertureFactory(             npixels=npixels,             radial_orders=radial_orders,             coefficients=coefficients,             noll_indices=noll_indices,             aperture_ratio=aperture_ratio,             secondary_ratio=secondary_ratio,             nsides=nsides,             secondary_nsides=secondary_nsides,             rotation=rotation,             nstruts=nstruts,             strut_ratio=strut_ratio,             strut_rotation=strut_rotation,             normalise=normalise)     return _create_aperture_factory In\u00a0[\u00a0]: Copied! <pre>'''=============================================================================\n================================================================================\n# Images\n--------\n\nimages.py classes:\n    Image\n\n'''\n@pytest.fixture\ndef create_image():\n    def _create_image(\n        image : Array = np.ones((16, 16)), \n        pixel_scale : float = 1/16):\n        return images.Image(image=image, pixel_scale=pixel_scale)\n    return _create_image\n</pre> '''============================================================================= ================================================================================ # Images --------  images.py classes:     Image  ''' @pytest.fixture def create_image():     def _create_image(         image : Array = np.ones((16, 16)),          pixel_scale : float = 1/16):         return images.Image(image=image, pixel_scale=pixel_scale)     return _create_image In\u00a0[\u00a0]: Copied! <pre>'''=============================================================================\n================================================================================\n# Detectors\n-----------\n\nDetectors.py classes:\n    LayeredDetector\n\n'''\n@pytest.fixture\ndef create_layered_detector(create_constant):\n    def _create_layered_detector(layers = [create_constant()]):\n        return detectors.LayeredDetector(layers=layers)\n    return _create_layered_detector\n</pre> '''============================================================================= ================================================================================ # Detectors -----------  Detectors.py classes:     LayeredDetector  ''' @pytest.fixture def create_layered_detector(create_constant):     def _create_layered_detector(layers = [create_constant()]):         return detectors.LayeredDetector(layers=layers)     return _create_layered_detector In\u00a0[\u00a0]: Copied! <pre>'''=============================================================================\n================================================================================\n# Image Layers\n--------------\n\nimage_layers.py classes:\n    ApplyPixelResponse\n    ApplyJitter\n    ApplySaturation\n    AddConstant\n    IntegerDownsample\n    Rotate\n\n'''\n@pytest.fixture\ndef create_pixel_response():\n    def _create_pixel_response(pixel_response: Array = np.ones((16, 16))):\n        return detector_layers.ApplyPixelResponse(pixel_response=pixel_response)\n    return _create_pixel_response\n</pre> '''============================================================================= ================================================================================ # Image Layers --------------  image_layers.py classes:     ApplyPixelResponse     ApplyJitter     ApplySaturation     AddConstant     IntegerDownsample     Rotate  ''' @pytest.fixture def create_pixel_response():     def _create_pixel_response(pixel_response: Array = np.ones((16, 16))):         return detector_layers.ApplyPixelResponse(pixel_response=pixel_response)     return _create_pixel_response In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_jitter():\n    def _create_jitter(sigma: float = 1., kernel_size: int = 10):\n        return detector_layers.ApplyJitter(sigma=sigma, kernel_size=kernel_size)\n    return _create_jitter\n</pre> @pytest.fixture def create_jitter():     def _create_jitter(sigma: float = 1., kernel_size: int = 10):         return detector_layers.ApplyJitter(sigma=sigma, kernel_size=kernel_size)     return _create_jitter In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_saturation():\n    def _create_saturation(saturation: float = 1.):\n        return detector_layers.ApplySaturation(saturation=saturation)\n    return _create_saturation\n</pre> @pytest.fixture def create_saturation():     def _create_saturation(saturation: float = 1.):         return detector_layers.ApplySaturation(saturation=saturation)     return _create_saturation In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_constant():\n    def _create_constant(value: Array = np.array(1.)):\n        return detector_layers.AddConstant(value=value)\n    return _create_constant\n</pre> @pytest.fixture def create_constant():     def _create_constant(value: Array = np.array(1.)):         return detector_layers.AddConstant(value=value)     return _create_constant In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_integer_downsample():\n    def _create_integer_downsample(kernel_size: int = 2):\n        return detector_layers.IntegerDownsample(kernel_size=kernel_size)\n    return _create_integer_downsample\n</pre> @pytest.fixture def create_integer_downsample():     def _create_integer_downsample(kernel_size: int = 2):         return detector_layers.IntegerDownsample(kernel_size=kernel_size)     return _create_integer_downsample     In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rotate_detector():\n    def _create_rotate_detector(angle: Array = np.array(np.pi), order: int = 1):\n        return detector_layers.Rotate(angle=angle, order=order)\n    return _create_rotate_detector\n</pre> @pytest.fixture def create_rotate_detector():     def _create_rotate_detector(angle: Array = np.array(np.pi), order: int = 1):         return detector_layers.Rotate(angle=angle, order=order)     return _create_rotate_detector In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\nSources\n-------\n\nsources.py classes:\n    Source\n    PointSources\n    BinarySource\n    ResolvedSource\n    PointResolvedSource\n\n'''\n@pytest.fixture\ndef create_point_source():\n    def _create_point_source(\n        wavelengths : Array = np.array([1e-6]),\n        position    : Array = np.zeros(2),\n        flux        : Array = np.array(1.),\n        weights     : Array = None,\n        spectrum    : spectra.Spectrum = None):\n        return sources.PointSource(wavelengths=wavelengths, position=position,\n            flux=flux, spectrum=spectrum, weights=weights)\n    return _create_point_source\n</pre> ''' ================================================================================ ================================================================================ Sources -------  sources.py classes:     Source     PointSources     BinarySource     ResolvedSource     PointResolvedSource  ''' @pytest.fixture def create_point_source():     def _create_point_source(         wavelengths : Array = np.array([1e-6]),         position    : Array = np.zeros(2),         flux        : Array = np.array(1.),         weights     : Array = None,         spectrum    : spectra.Spectrum = None):         return sources.PointSource(wavelengths=wavelengths, position=position,             flux=flux, spectrum=spectrum, weights=weights)     return _create_point_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_point_sources():\n    def _create_point_sources(\n        wavelengths : Array = np.array([1e-6]),\n        position    : Array = np.zeros((3, 2)),\n        flux        : Array = np.ones(3),\n        weights     : Array = None,\n        spectrum    : spectra.Spectrum = None):\n        return sources.PointSources(wavelengths=wavelengths, position=position,\n            flux=flux, spectrum=spectrum, weights=weights)\n    return _create_point_sources\n</pre> @pytest.fixture def create_point_sources():     def _create_point_sources(         wavelengths : Array = np.array([1e-6]),         position    : Array = np.zeros((3, 2)),         flux        : Array = np.ones(3),         weights     : Array = None,         spectrum    : spectra.Spectrum = None):         return sources.PointSources(wavelengths=wavelengths, position=position,             flux=flux, spectrum=spectrum, weights=weights)     return _create_point_sources In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_resolved_source():\n    def _create_resolved_source(\n            wavelengths  : Array = np.array([1e-6]),\n            position     : Array = np.zeros(2),\n            flux         : Array = np.array(1.),\n            distribution : Array = np.ones((5, 5)),\n            weights      : Array = None,\n            spectrum     : spectra.Spectrum = None):\n        return sources.ResolvedSource(wavelengths=wavelengths, \n            position=position, flux=flux, distribution=distribution, \n            spectrum=spectrum, weights=weights)\n    return _create_resolved_source\n</pre> @pytest.fixture def create_resolved_source():     def _create_resolved_source(             wavelengths  : Array = np.array([1e-6]),             position     : Array = np.zeros(2),             flux         : Array = np.array(1.),             distribution : Array = np.ones((5, 5)),             weights      : Array = None,             spectrum     : spectra.Spectrum = None):         return sources.ResolvedSource(wavelengths=wavelengths,              position=position, flux=flux, distribution=distribution,              spectrum=spectrum, weights=weights)     return _create_resolved_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_binary_source():\n    def _create_binary_source(\n        wavelengths    : Array = np.array([1e-6]),\n        position       : Array = np.array([0., 0.]),\n        flux           : Array = np.array(1.),\n        separation     : Array = np.array(1.),\n        position_angle : Array = np.array(0.),\n        contrast       : Array = np.array(2.),\n        spectrum       : spectra.Spectrum = None,\n        weights        : Array = None):\n        return sources.BinarySource(position=position, flux=flux,\n            separation=separation, position_angle=position_angle,\n            contrast=contrast, spectrum=spectrum, wavelengths=wavelengths,\n            weights=weights)\n    return _create_binary_source\n</pre> @pytest.fixture def create_binary_source():     def _create_binary_source(         wavelengths    : Array = np.array([1e-6]),         position       : Array = np.array([0., 0.]),         flux           : Array = np.array(1.),         separation     : Array = np.array(1.),         position_angle : Array = np.array(0.),         contrast       : Array = np.array(2.),         spectrum       : spectra.Spectrum = None,         weights        : Array = None):         return sources.BinarySource(position=position, flux=flux,             separation=separation, position_angle=position_angle,             contrast=contrast, spectrum=spectrum, wavelengths=wavelengths,             weights=weights)     return _create_binary_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_point_resolved_source():\n    def _create_point_resolved_source(\n        wavelengths  : Array = np.array([1e-6]),\n        position     : Array = np.array([0., 0.]),\n        flux         : Array = np.array(1.),\n        distribution : Array = np.ones((5, 5)),\n        contrast     : Array = np.array(2.),\n        spectrum     : spectra.Spectrum = None,\n        weights      : Array = None):\n        return sources.PointResolvedSource(position=position, flux=flux,\n            distribution=distribution, contrast=contrast, spectrum=spectrum,\n            wavelengths=wavelengths)\n    return _create_point_resolved_source\n</pre> @pytest.fixture def create_point_resolved_source():     def _create_point_resolved_source(         wavelengths  : Array = np.array([1e-6]),         position     : Array = np.array([0., 0.]),         flux         : Array = np.array(1.),         distribution : Array = np.ones((5, 5)),         contrast     : Array = np.array(2.),         spectrum     : spectra.Spectrum = None,         weights      : Array = None):         return sources.PointResolvedSource(position=position, flux=flux,             distribution=distribution, contrast=contrast, spectrum=spectrum,             wavelengths=wavelengths)     return _create_point_resolved_source In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\nSpectra\n-------\n\nspectra.py classes:\n    Spectrum\n    PolySpectrum\n\n'''\n@pytest.fixture\ndef create_spectrum():\n    def _create_spectrum(\n        wavelengths : Array = np.linspace(1e-6, 1.2e-6, 5),\n        weights     : Array = np.arange(5)):\n        return spectra.Spectrum(wavelengths, weights)\n    return _create_spectrum\n</pre> ''' ================================================================================ ================================================================================ Spectra -------  spectra.py classes:     Spectrum     PolySpectrum  ''' @pytest.fixture def create_spectrum():     def _create_spectrum(         wavelengths : Array = np.linspace(1e-6, 1.2e-6, 5),         weights     : Array = np.arange(5)):         return spectra.Spectrum(wavelengths, weights)     return _create_spectrum In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_poly_spectrum():\n    def _create_poly_spectrum(\n        wavelengths  : Array = np.linspace(1e-6, 1.2e-6, 5),\n        coefficients : Array = np.arange(3)):\n        return spectra.PolySpectrum(wavelengths, coefficients)\n    return _create_poly_spectrum\n</pre> @pytest.fixture def create_poly_spectrum():     def _create_poly_spectrum(         wavelengths  : Array = np.linspace(1e-6, 1.2e-6, 5),         coefficients : Array = np.arange(3)):         return spectra.PolySpectrum(wavelengths, coefficients)     return _create_poly_spectrum In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\nInstruments\n-----------\n\ninstruments.py classes:\n    Instrument\n\n'''\n@pytest.fixture\ndef create_instrument(create_angular_optics, create_point_source, \n    create_layered_detector, create_dither):\n    def _create_instrument(\n            optics      = create_angular_optics(),\n            sources     = create_point_source(),\n            detector    = create_layered_detector(),\n            observation = create_dither()):\n        return instruments.Instrument(optics=optics, detector=detector,\n            sources=sources, observation=observation)\n    return _create_instrument\n</pre> ''' ================================================================================ ================================================================================ Instruments -----------  instruments.py classes:     Instrument  ''' @pytest.fixture def create_instrument(create_angular_optics, create_point_source,      create_layered_detector, create_dither):     def _create_instrument(             optics      = create_angular_optics(),             sources     = create_point_source(),             detector    = create_layered_detector(),             observation = create_dither()):         return instruments.Instrument(optics=optics, detector=detector,             sources=sources, observation=observation)     return _create_instrument In\u00a0[\u00a0]: Copied! <pre>'''\n================================================================================\n================================================================================\nObservations\n------------\n\nobservations.py classes:\n    Dither\n\n'''\n@pytest.fixture\ndef create_dither():\n    def _create_dither(dithers: Array = np.ones((5, 2))):\n        return observations.Dither(dithers=dithers)\n    return _create_dither\n</pre> ''' ================================================================================ ================================================================================ Observations ------------  observations.py classes:     Dither  ''' @pytest.fixture def create_dither():     def _create_dither(dithers: Array = np.ones((5, 2))):         return observations.Dither(dithers=dithers)     return _create_dither <p>Possibly for models later on @pytest.fixture def create_basis_climb(): def _create_basis_climb( basis: Array = np.ones((3, 768, 768)), coefficients: Array = np.ones(3), ideal_wavelength: Array = np.array(5e-7)): return optical_layers.ApplyBasisCLIMB( basis, ideal_wavelength, coefficients) return _create_basis_climb</p>"},{"location":"tests/test_aberrations/","title":"Test aberrations","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import config, Array\nimport pytest\nimport dLux.utils as dlu\n</pre> import jax.numpy as np from jax import config, Array import pytest import dLux.utils as dlu In\u00a0[\u00a0]: Copied! <pre>config.update(\"jax_debug_nans\", True)\n</pre> config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestZernike(object):\n\"\"\"\n    Tests the Zernike class.\n    \"\"\"\n\n\n    def test_constructor(self, create_zernike):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test inputs &lt;= 0\n        with pytest.raises(ValueError):\n            create_zernike(0)\n\n        # Test constructor\n        zernike = create_zernike()\n\n\n    def test_calculate(self, create_zernike):\n\"\"\"\n        Tests the calculate method.\n        \"\"\"\n        zernike = create_zernike()\n        coords = dlu.pixel_coords(16, 1/16)\n\n        # Test calculate\n        z = zernike.calculate(coords)\n        p = zernike.calculate(coords, nsides=3)\n\n        with pytest.raises(ValueError):\n            zernike.calculate(coords, nsides=1)\n</pre> class TestZernike(object):     \"\"\"     Tests the Zernike class.     \"\"\"       def test_constructor(self, create_zernike):         \"\"\"         Tests the constructor.         \"\"\"         # Test inputs &lt;= 0         with pytest.raises(ValueError):             create_zernike(0)          # Test constructor         zernike = create_zernike()       def test_calculate(self, create_zernike):         \"\"\"         Tests the calculate method.         \"\"\"         zernike = create_zernike()         coords = dlu.pixel_coords(16, 1/16)          # Test calculate         z = zernike.calculate(coords)         p = zernike.calculate(coords, nsides=3)          with pytest.raises(ValueError):             zernike.calculate(coords, nsides=1) In\u00a0[\u00a0]: Copied! <pre>class TestZernikeBasis(object):\n\"\"\"\n    Tests the ZernikeBasis class.\n    \"\"\"\n\n\n    def test_constructor(self, create_zernike_basis):\n        zernike_basis = create_zernike_basis()\n\n\n    def test_calculate_basis(self, create_zernike_basis):\n        zernike_basis = create_zernike_basis()\n        coords = dlu.pixel_coords(16, 1/16)\n\n        # Test calculate\n        z = zernike_basis.calculate_basis(coords)\n</pre> class TestZernikeBasis(object):     \"\"\"     Tests the ZernikeBasis class.     \"\"\"       def test_constructor(self, create_zernike_basis):         zernike_basis = create_zernike_basis()       def test_calculate_basis(self, create_zernike_basis):         zernike_basis = create_zernike_basis()         coords = dlu.pixel_coords(16, 1/16)          # Test calculate         z = zernike_basis.calculate_basis(coords)"},{"location":"tests/test_apertures/","title":"Test apertures","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import Array, config\nimport pytest\nimport dLux\nfrom inspect import signature\nimport dLux.utils as dlu\n</pre> import jax.numpy as np from jax import Array, config import pytest import dLux from inspect import signature import dLux.utils as dlu In\u00a0[\u00a0]: Copied! <pre>config.update(\"jax_debug_nans\", True)\n</pre> config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_transmission(constructor):\n\"\"\"Tests the transmission function of some input aperture\"\"\"\n    constructor().transmission(16, 1)\n    if 'occulting' in signature(constructor).parameters.keys():\n        constructor(occulting=True).transmission(16, 1)\n</pre> def _test_transmission(constructor):     \"\"\"Tests the transmission function of some input aperture\"\"\"     constructor().transmission(16, 1)     if 'occulting' in signature(constructor).parameters.keys():         constructor(occulting=True).transmission(16, 1) In\u00a0[\u00a0]: Copied! <pre>def _test_extent(constructor):\n\"\"\"Tests the extent function of some input aperture\"\"\"\n    constructor()._extent()\n</pre> def _test_extent(constructor):     \"\"\"Tests the extent function of some input aperture\"\"\"     constructor()._extent() In\u00a0[\u00a0]: Copied! <pre>def _test_base_dynamic_aperture_constructor(constructor):\n\"\"\"Tests the constructor of some input aperture\"\"\"\n    constructor()\n    with pytest.raises(ValueError):\n        constructor(centre=[0])\n    with pytest.raises(ValueError):\n        constructor(shear=[0])\n    with pytest.raises(ValueError):\n        constructor(compression=[0])\n    \n    # Have to add this here since CircularAperture is a special case\n    if 'rotation' in signature(constructor).parameters.keys():\n        with pytest.raises(ValueError):\n            constructor(rotation=[0])\n</pre> def _test_base_dynamic_aperture_constructor(constructor):     \"\"\"Tests the constructor of some input aperture\"\"\"     constructor()     with pytest.raises(ValueError):         constructor(centre=[0])     with pytest.raises(ValueError):         constructor(shear=[0])     with pytest.raises(ValueError):         constructor(compression=[0])          # Have to add this here since CircularAperture is a special case     if 'rotation' in signature(constructor).parameters.keys():         with pytest.raises(ValueError):             constructor(rotation=[0]) In\u00a0[\u00a0]: Copied! <pre>def _test_call(constructor, wf_constructor):\n\"\"\"Tests the __call__ function of some input aperture\"\"\"\n    constructor()(wf_constructor())\n</pre> def _test_call(constructor, wf_constructor):     \"\"\"Tests the __call__ function of some input aperture\"\"\"     constructor()(wf_constructor()) In\u00a0[\u00a0]: Copied! <pre>def _test_dyanmic_aperture_constructor(constructor):\n\"\"\"Tests the constructor of some input aperture\"\"\"\n    constructor()\n    with pytest.raises(ValueError):\n        constructor(softening=[0, 0])\n</pre> def _test_dyanmic_aperture_constructor(constructor):     \"\"\"Tests the constructor of some input aperture\"\"\"     constructor()     with pytest.raises(ValueError):         constructor(softening=[0, 0]) In\u00a0[\u00a0]: Copied! <pre>def _test_make_static(constructor):\n\"\"\"Tests the make_static function of some input aperture\"\"\"\n    constructor().make_static(16, 1)\n</pre> def _test_make_static(constructor):     \"\"\"Tests the make_static function of some input aperture\"\"\"     constructor().make_static(16, 1) In\u00a0[\u00a0]: Copied! <pre>def _test_basis(constructor, aperture_constructor=None):\n\"\"\"Tests the basis function of some input aperture\"\"\"\n    # constructor()._basis(dlu.pixel_coords(16, 1/16))\n    if aperture_constructor is not None:\n        aperture = aperture_constructor()\n        constructor(aperture=aperture)._basis(dlu.pixel_coords(16, 1/16))\n</pre> def _test_basis(constructor, aperture_constructor=None):     \"\"\"Tests the basis function of some input aperture\"\"\"     # constructor()._basis(dlu.pixel_coords(16, 1/16))     if aperture_constructor is not None:         aperture = aperture_constructor()         constructor(aperture=aperture)._basis(dlu.pixel_coords(16, 1/16)) In\u00a0[\u00a0]: Copied! <pre>def _test_opd(constructor):\n\"\"\"Tests the opd function of some input aperture\"\"\"\n    constructor()._opd(dlu.pixel_coords(16, 1/16))\n</pre> def _test_opd(constructor):     \"\"\"Tests the opd function of some input aperture\"\"\"     constructor()._opd(dlu.pixel_coords(16, 1/16)) In\u00a0[\u00a0]: Copied! <pre>class TestCircularAperture():\n\"\"\"Tests the CircularAperture class.\"\"\"\n\n    def test_constructor(self, create_circular_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_dynamic_aperture_constructor(create_circular_aperture)\n        _test_dyanmic_aperture_constructor(create_circular_aperture)\n        with pytest.raises(ValueError):\n            create_circular_aperture(radius=[0])\n\n    def test_call(self, create_circular_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_circular_aperture, create_wavefront)\n    \n    def test_transmission(self, create_circular_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_circular_aperture)\n    \n    def test_make_static(self, create_circular_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_circular_aperture)\n    \n    def test_extent(self, create_circular_aperture):\n\"\"\"Tests the extent method.\"\"\"\n        _test_extent(create_circular_aperture)\n</pre> class TestCircularAperture():     \"\"\"Tests the CircularAperture class.\"\"\"      def test_constructor(self, create_circular_aperture):         \"\"\"Tests the constructor.\"\"\"         _test_base_dynamic_aperture_constructor(create_circular_aperture)         _test_dyanmic_aperture_constructor(create_circular_aperture)         with pytest.raises(ValueError):             create_circular_aperture(radius=[0])      def test_call(self, create_circular_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_circular_aperture, create_wavefront)          def test_transmission(self, create_circular_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_circular_aperture)          def test_make_static(self, create_circular_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_circular_aperture)          def test_extent(self, create_circular_aperture):         \"\"\"Tests the extent method.\"\"\"         _test_extent(create_circular_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestRectangularAperture():\n\"\"\"Tests the RectangularAperture class.\"\"\"\n\n    def test_constructor(self, create_rectangular_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_dynamic_aperture_constructor(create_rectangular_aperture)\n        _test_dyanmic_aperture_constructor(create_rectangular_aperture)\n        with pytest.raises(ValueError):\n            create_rectangular_aperture(height=[0])\n        with pytest.raises(ValueError):\n            create_rectangular_aperture(width=[0])\n\n    def test_call(self, create_rectangular_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_rectangular_aperture, create_wavefront)\n    \n    def test_transmission(self, create_rectangular_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_rectangular_aperture)\n    \n    def test_make_static(self, create_rectangular_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_rectangular_aperture)\n    \n    def test_extent(self, create_rectangular_aperture):\n\"\"\"Tests the extent method.\"\"\"\n        _test_extent(create_rectangular_aperture)\n</pre> class TestRectangularAperture():     \"\"\"Tests the RectangularAperture class.\"\"\"      def test_constructor(self, create_rectangular_aperture):         \"\"\"Tests the constructor.\"\"\"         _test_base_dynamic_aperture_constructor(create_rectangular_aperture)         _test_dyanmic_aperture_constructor(create_rectangular_aperture)         with pytest.raises(ValueError):             create_rectangular_aperture(height=[0])         with pytest.raises(ValueError):             create_rectangular_aperture(width=[0])      def test_call(self, create_rectangular_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_rectangular_aperture, create_wavefront)          def test_transmission(self, create_rectangular_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_rectangular_aperture)          def test_make_static(self, create_rectangular_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_rectangular_aperture)          def test_extent(self, create_rectangular_aperture):         \"\"\"Tests the extent method.\"\"\"         _test_extent(create_rectangular_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestRegPolyAperture():\n\"\"\"Tests the RegPolyAperture class.\"\"\"\n\n    def test_constructor(self, create_reg_poly_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_dynamic_aperture_constructor(create_reg_poly_aperture)\n        _test_dyanmic_aperture_constructor(create_reg_poly_aperture)\n        with pytest.raises(ValueError):\n            create_reg_poly_aperture(rmax=[0])\n    \n    def test_call(self, create_reg_poly_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_reg_poly_aperture, create_wavefront)\n    \n    def test_transmission(self, create_reg_poly_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_reg_poly_aperture)\n    \n    def test_make_static(self, create_reg_poly_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_reg_poly_aperture)\n    \n    def test_extent(self, create_reg_poly_aperture):\n\"\"\"Tests the extent method.\"\"\"\n        _test_extent(create_reg_poly_aperture)\n</pre> class TestRegPolyAperture():     \"\"\"Tests the RegPolyAperture class.\"\"\"      def test_constructor(self, create_reg_poly_aperture):         \"\"\"Tests the constructor.\"\"\"         _test_base_dynamic_aperture_constructor(create_reg_poly_aperture)         _test_dyanmic_aperture_constructor(create_reg_poly_aperture)         with pytest.raises(ValueError):             create_reg_poly_aperture(rmax=[0])          def test_call(self, create_reg_poly_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_reg_poly_aperture, create_wavefront)          def test_transmission(self, create_reg_poly_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_reg_poly_aperture)          def test_make_static(self, create_reg_poly_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_reg_poly_aperture)          def test_extent(self, create_reg_poly_aperture):         \"\"\"Tests the extent method.\"\"\"         _test_extent(create_reg_poly_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestIrregPolyAperture():\n\"\"\"Tests the IrregPolyAperture class.\"\"\"\n\n    def test_constructor(self, create_irreg_poly_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_dynamic_aperture_constructor(create_irreg_poly_aperture)\n        _test_dyanmic_aperture_constructor(create_irreg_poly_aperture)\n        with pytest.raises(ValueError):\n            create_irreg_poly_aperture(vertices=[0])\n    \n    def test_call(self, create_irreg_poly_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_irreg_poly_aperture, create_wavefront)\n    \n    def test_transmission(self, create_irreg_poly_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_irreg_poly_aperture)\n\n    def test_make_static(self, create_irreg_poly_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_irreg_poly_aperture)\n    \n    def test_extent(self, create_irreg_poly_aperture):\n\"\"\"Tests the extent method.\"\"\"\n        _test_extent(create_irreg_poly_aperture)\n</pre> class TestIrregPolyAperture():     \"\"\"Tests the IrregPolyAperture class.\"\"\"      def test_constructor(self, create_irreg_poly_aperture):         \"\"\"Tests the constructor.\"\"\"         _test_base_dynamic_aperture_constructor(create_irreg_poly_aperture)         _test_dyanmic_aperture_constructor(create_irreg_poly_aperture)         with pytest.raises(ValueError):             create_irreg_poly_aperture(vertices=[0])          def test_call(self, create_irreg_poly_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_irreg_poly_aperture, create_wavefront)          def test_transmission(self, create_irreg_poly_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_irreg_poly_aperture)      def test_make_static(self, create_irreg_poly_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_irreg_poly_aperture)          def test_extent(self, create_irreg_poly_aperture):         \"\"\"Tests the extent method.\"\"\"         _test_extent(create_irreg_poly_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestAberratedAperture():\n\"\"\"Tests the AberratedAperture class.\"\"\"\n\n    def test_constructor(self, create_aberrated_aperture, \n        create_circular_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        create_aberrated_aperture()\n        create_aberrated_aperture(coefficients=None)\n        with pytest.raises(TypeError):\n            create_aberrated_aperture(aperture='Not an aperture')\n        with pytest.raises(ValueError):\n            ap = create_circular_aperture(occulting=True)\n            create_aberrated_aperture(aperture=ap)\n    \n    def test_call(self, create_aberrated_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_aberrated_aperture, create_wavefront)\n    \n    def test_transmission(self, create_aberrated_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_aberrated_aperture)\n    \n    def test_make_static(self, create_aberrated_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_aberrated_aperture)\n    \n    def test_basis(self, create_aberrated_aperture, create_reg_poly_aperture, \n        create_irreg_poly_aperture):\n\"\"\"Tests the basis method.\"\"\"\n        _test_basis(create_aberrated_aperture)\n        _test_basis(create_aberrated_aperture, create_reg_poly_aperture)\n        _test_basis(create_aberrated_aperture, create_irreg_poly_aperture)\n    \n    def test_opd(self, create_aberrated_aperture):\n\"\"\"Tests the _opd method.\"\"\"\n        _test_opd(create_aberrated_aperture)\n</pre> class TestAberratedAperture():     \"\"\"Tests the AberratedAperture class.\"\"\"      def test_constructor(self, create_aberrated_aperture,          create_circular_aperture):         \"\"\"Tests the constructor.\"\"\"         create_aberrated_aperture()         create_aberrated_aperture(coefficients=None)         with pytest.raises(TypeError):             create_aberrated_aperture(aperture='Not an aperture')         with pytest.raises(ValueError):             ap = create_circular_aperture(occulting=True)             create_aberrated_aperture(aperture=ap)          def test_call(self, create_aberrated_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_aberrated_aperture, create_wavefront)          def test_transmission(self, create_aberrated_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_aberrated_aperture)          def test_make_static(self, create_aberrated_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_aberrated_aperture)          def test_basis(self, create_aberrated_aperture, create_reg_poly_aperture,          create_irreg_poly_aperture):         \"\"\"Tests the basis method.\"\"\"         _test_basis(create_aberrated_aperture)         _test_basis(create_aberrated_aperture, create_reg_poly_aperture)         _test_basis(create_aberrated_aperture, create_irreg_poly_aperture)          def test_opd(self, create_aberrated_aperture):         \"\"\"Tests the _opd method.\"\"\"         _test_opd(create_aberrated_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestUniformSpider():\n\"\"\"Tests the UniformSpider class.\"\"\"\n\n    def test_constructor(self, create_uniform_spider):\n\"\"\"Tests the constructor.\"\"\"\n        create_uniform_spider()\n        with pytest.raises(ValueError):\n            create_uniform_spider(strut_width=[0])\n    \n    def test_call(self, create_uniform_spider, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_uniform_spider, create_wavefront)\n    \n    def test_transmission(self, create_uniform_spider):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_uniform_spider)\n    \n    def test_make_static(self, create_uniform_spider):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_uniform_spider)\n    \n    def test_extent(self, create_uniform_spider):\n\"\"\"Tests the extent method.\"\"\"\n        _test_extent(create_uniform_spider)\n</pre> class TestUniformSpider():     \"\"\"Tests the UniformSpider class.\"\"\"      def test_constructor(self, create_uniform_spider):         \"\"\"Tests the constructor.\"\"\"         create_uniform_spider()         with pytest.raises(ValueError):             create_uniform_spider(strut_width=[0])          def test_call(self, create_uniform_spider, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_uniform_spider, create_wavefront)          def test_transmission(self, create_uniform_spider):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_uniform_spider)          def test_make_static(self, create_uniform_spider):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_uniform_spider)          def test_extent(self, create_uniform_spider):         \"\"\"Tests the extent method.\"\"\"         _test_extent(create_uniform_spider) In\u00a0[\u00a0]: Copied! <pre>class TestCompoundAperture():\n\"\"\"Tests the CompoundAperture class.\"\"\"\n\n    def test_constructor(self, create_compound_aperture, \n        create_aberrated_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        create_compound_aperture()\n        aber_ap = create_aberrated_aperture()\n        with pytest.raises(TypeError):\n            create_compound_aperture(apers=[aber_ap, aber_ap])\n    \n    def test_call(self, create_compound_aperture, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_compound_aperture, create_wavefront)\n    \n    def test_transmission(self, create_compound_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_compound_aperture)\n    \n    def test_make_static(self, create_compound_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_compound_aperture)\n\n    def test_basis(self, create_compound_aperture):\n\"\"\"Tests the basis method.\"\"\"\n        _test_basis(create_compound_aperture)\n    \n    def test_opd(self, create_compound_aperture):\n\"\"\"Tests the _opd method.\"\"\"\n        _test_opd(create_compound_aperture)\n</pre> class TestCompoundAperture():     \"\"\"Tests the CompoundAperture class.\"\"\"      def test_constructor(self, create_compound_aperture,          create_aberrated_aperture):         \"\"\"Tests the constructor.\"\"\"         create_compound_aperture()         aber_ap = create_aberrated_aperture()         with pytest.raises(TypeError):             create_compound_aperture(apers=[aber_ap, aber_ap])          def test_call(self, create_compound_aperture, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_compound_aperture, create_wavefront)          def test_transmission(self, create_compound_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_compound_aperture)          def test_make_static(self, create_compound_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_compound_aperture)      def test_basis(self, create_compound_aperture):         \"\"\"Tests the basis method.\"\"\"         _test_basis(create_compound_aperture)          def test_opd(self, create_compound_aperture):         \"\"\"Tests the _opd method.\"\"\"         _test_opd(create_compound_aperture) In\u00a0[\u00a0]: Copied! <pre>class TestMultiAperture():\n\"\"\"Tests the MultiAperture class.\"\"\"\n\n    def test_constructor(self, create_multi_aperture):\n\"\"\"Tests the constructor.\"\"\"\n        create_multi_aperture()\n    \n    def test_call(self, create_multi_aperture, create_wavefront, \n        create_aberrated_aperture, create_compound_aperture):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_multi_aperture, create_wavefront)\n        aber_ap = create_aberrated_aperture()\n        comp_ap = create_compound_aperture(apers=[aber_ap])\n        create_multi_aperture(apers=[comp_ap])(create_wavefront())\n    \n    def test_transmission(self, create_multi_aperture):\n\"\"\"Tests the transmission method.\"\"\"\n        _test_transmission(create_multi_aperture)\n    \n    def test_make_static(self, create_multi_aperture, create_aberrated_aperture,\n        create_compound_aperture):\n\"\"\"Tests the make_static method.\"\"\"\n        _test_make_static(create_multi_aperture)\n        aber_ap = create_aberrated_aperture()\n        comp_ap = create_compound_aperture(apers=[aber_ap])\n        create_multi_aperture(apers=[comp_ap]).make_static(16, 1)\n\n    def test_basis(self, create_multi_aperture):\n\"\"\"Tests the basis method.\"\"\"\n        _test_basis(create_multi_aperture)\n    \n    def test_opd(self, create_multi_aperture):\n\"\"\"Tests the _opd method.\"\"\"\n        _test_opd(create_multi_aperture)\n    \n    def test_aberrated_apertures(self, create_multi_aperture, \n        create_aberrated_aperture, create_compound_aperture):\n\"\"\"Tests the _aberrated_aperture method.\"\"\"\n        create_multi_aperture()._aberrated_apertures()\n        aber_ap = create_aberrated_aperture()\n        comp_ap = create_compound_aperture(apers=[aber_ap])\n        create_multi_aperture(apers=[comp_ap])._aberrated_apertures()\n    \n    def test_getattr(self, create_multi_aperture):\n\"\"\"Tests the __getattr__ method.\"\"\"\n        create_multi_aperture().CircularAperture\n        with pytest.raises(AttributeError):\n            create_multi_aperture().not_an_aperture\n</pre> class TestMultiAperture():     \"\"\"Tests the MultiAperture class.\"\"\"      def test_constructor(self, create_multi_aperture):         \"\"\"Tests the constructor.\"\"\"         create_multi_aperture()          def test_call(self, create_multi_aperture, create_wavefront,          create_aberrated_aperture, create_compound_aperture):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_multi_aperture, create_wavefront)         aber_ap = create_aberrated_aperture()         comp_ap = create_compound_aperture(apers=[aber_ap])         create_multi_aperture(apers=[comp_ap])(create_wavefront())          def test_transmission(self, create_multi_aperture):         \"\"\"Tests the transmission method.\"\"\"         _test_transmission(create_multi_aperture)          def test_make_static(self, create_multi_aperture, create_aberrated_aperture,         create_compound_aperture):         \"\"\"Tests the make_static method.\"\"\"         _test_make_static(create_multi_aperture)         aber_ap = create_aberrated_aperture()         comp_ap = create_compound_aperture(apers=[aber_ap])         create_multi_aperture(apers=[comp_ap]).make_static(16, 1)      def test_basis(self, create_multi_aperture):         \"\"\"Tests the basis method.\"\"\"         _test_basis(create_multi_aperture)          def test_opd(self, create_multi_aperture):         \"\"\"Tests the _opd method.\"\"\"         _test_opd(create_multi_aperture)          def test_aberrated_apertures(self, create_multi_aperture,          create_aberrated_aperture, create_compound_aperture):         \"\"\"Tests the _aberrated_aperture method.\"\"\"         create_multi_aperture()._aberrated_apertures()         aber_ap = create_aberrated_aperture()         comp_ap = create_compound_aperture(apers=[aber_ap])         create_multi_aperture(apers=[comp_ap])._aberrated_apertures()          def test_getattr(self, create_multi_aperture):         \"\"\"Tests the __getattr__ method.\"\"\"         create_multi_aperture().CircularAperture         with pytest.raises(AttributeError):             create_multi_aperture().not_an_aperture In\u00a0[\u00a0]: Copied! <pre>def test_aperture_factory():\n\"\"\"Tests the ApertureFactory method\"\"\"\n    npix = 16\n\n    dLux.ApertureFactory(npix)\n    dLux.ApertureFactory(npix, nsides=3)\n    dLux.ApertureFactory(npix, radial_orders=[2, 3])\n    dLux.ApertureFactory(npix, noll_indices=[1, 2, 3])\n    dLux.ApertureFactory(npix, secondary_ratio=0.1)\n    dLux.ApertureFactory(npix, secondary_ratio=0.1, secondary_nsides=3)\n    dLux.ApertureFactory(npix, nstruts=3, strut_ratio=0.01)\n    dLux.ApertureFactory(npix, static=False)\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, nstruts=3, secondary_ratio=0)\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, radial_orders=[-1, 0])\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, nsides=1)\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, secondary_nsides=1)\n    \n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, aperture_ratio=-1)\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, secondary_ratio=-1)\n\n    with pytest.raises(ValueError):\n        dLux.ApertureFactory(npix, strut_ratio=-1)\n</pre> def test_aperture_factory():     \"\"\"Tests the ApertureFactory method\"\"\"     npix = 16      dLux.ApertureFactory(npix)     dLux.ApertureFactory(npix, nsides=3)     dLux.ApertureFactory(npix, radial_orders=[2, 3])     dLux.ApertureFactory(npix, noll_indices=[1, 2, 3])     dLux.ApertureFactory(npix, secondary_ratio=0.1)     dLux.ApertureFactory(npix, secondary_ratio=0.1, secondary_nsides=3)     dLux.ApertureFactory(npix, nstruts=3, strut_ratio=0.01)     dLux.ApertureFactory(npix, static=False)      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, nstruts=3, secondary_ratio=0)      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, radial_orders=[-1, 0])      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, nsides=1)      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, secondary_nsides=1)          with pytest.raises(ValueError):         dLux.ApertureFactory(npix, aperture_ratio=-1)      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, secondary_ratio=-1)      with pytest.raises(ValueError):         dLux.ApertureFactory(npix, strut_ratio=-1)"},{"location":"tests/test_detector_layers/","title":"Test detector layers","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_call(constructor, image_constructor):\n\"\"\"Tests the __call__ method.\"\"\"\n    constructor()(image_constructor())\n</pre> def _test_call(constructor, image_constructor):     \"\"\"Tests the __call__ method.\"\"\"     constructor()(image_constructor()) In\u00a0[\u00a0]: Copied! <pre>class TestApplyPixelResponse():\n\"\"\"Tests the ApplyPixelResponse class.\"\"\"\n\n    def test_constructor(self, create_pixel_response):\n\"\"\"Tests the constructor.\"\"\"\n        create_pixel_response()\n        with pytest.raises(ValueError):\n            create_pixel_response(pixel_response=np.ones(1))\n\n    def test_call(self, create_pixel_response, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_pixel_response, create_image)\n</pre> class TestApplyPixelResponse():     \"\"\"Tests the ApplyPixelResponse class.\"\"\"      def test_constructor(self, create_pixel_response):         \"\"\"Tests the constructor.\"\"\"         create_pixel_response()         with pytest.raises(ValueError):             create_pixel_response(pixel_response=np.ones(1))      def test_call(self, create_pixel_response, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_pixel_response, create_image) In\u00a0[\u00a0]: Copied! <pre>class TestApplyJitter():\n\"\"\"Tests the ApplyJitter class.\"\"\"\n\n    def test_constructor(self, create_jitter):\n\"\"\"Tests the constructor.\"\"\"\n        create_jitter()\n        with pytest.raises(ValueError):\n            create_jitter(sigma=np.array([1.]))\n\n    def test_call(self, create_jitter, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_jitter, create_image)\n</pre> class TestApplyJitter():     \"\"\"Tests the ApplyJitter class.\"\"\"      def test_constructor(self, create_jitter):         \"\"\"Tests the constructor.\"\"\"         create_jitter()         with pytest.raises(ValueError):             create_jitter(sigma=np.array([1.]))      def test_call(self, create_jitter, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_jitter, create_image) In\u00a0[\u00a0]: Copied! <pre>class TestApplySaturation():\n\"\"\"Tests the ApplySaturation class.\"\"\"\n\n    def test_constructor(self, create_saturation):\n\"\"\"Tests the constructor.\"\"\"\n        create_saturation()\n        with pytest.raises(ValueError):\n            create_saturation(saturation=np.array([1.]))\n\n    def test_call(self, create_saturation, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_saturation, create_image)\n</pre> class TestApplySaturation():     \"\"\"Tests the ApplySaturation class.\"\"\"      def test_constructor(self, create_saturation):         \"\"\"Tests the constructor.\"\"\"         create_saturation()         with pytest.raises(ValueError):             create_saturation(saturation=np.array([1.]))      def test_call(self, create_saturation, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_saturation, create_image) In\u00a0[\u00a0]: Copied! <pre>class TestAddConstant():\n\"\"\"Tests the AddConstant class.\"\"\"\n\n    def test_constructor(self, create_constant):\n\"\"\"Tests the constructor.\"\"\"\n        create_constant()\n        with pytest.raises(ValueError):\n            create_constant(value=np.array([1.]))\n\n    def test_call(self, create_constant, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_constant, create_image)\n</pre> class TestAddConstant():     \"\"\"Tests the AddConstant class.\"\"\"      def test_constructor(self, create_constant):         \"\"\"Tests the constructor.\"\"\"         create_constant()         with pytest.raises(ValueError):             create_constant(value=np.array([1.]))      def test_call(self, create_constant, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_constant, create_image) In\u00a0[\u00a0]: Copied! <pre>class TestIntegerDownsample():\n\"\"\"Tests the IntegerDownsample class.\"\"\"\n\n    def test_constructor(self, create_integer_downsample):\n\"\"\"Tests the constructor.\"\"\"\n        create_integer_downsample()\n\n    def test_call(self, create_integer_downsample, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_integer_downsample, create_image)\n</pre> class TestIntegerDownsample():     \"\"\"Tests the IntegerDownsample class.\"\"\"      def test_constructor(self, create_integer_downsample):         \"\"\"Tests the constructor.\"\"\"         create_integer_downsample()      def test_call(self, create_integer_downsample, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_integer_downsample, create_image) In\u00a0[\u00a0]: Copied! <pre>class TestRotate():\n\"\"\"Tests the Rotate class.\"\"\"\n\n    def test_constructor(self, create_rotate_detector):\n\"\"\"Tests the constructor.\"\"\"\n        create_rotate_detector()\n        with pytest.raises(ValueError):\n            create_rotate_detector(angle=np.array([1.]))\n\n    def test_call(self, create_rotate_detector, create_image):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_rotate_detector, create_image)\n</pre> class TestRotate():     \"\"\"Tests the Rotate class.\"\"\"      def test_constructor(self, create_rotate_detector):         \"\"\"Tests the constructor.\"\"\"         create_rotate_detector()         with pytest.raises(ValueError):             create_rotate_detector(angle=np.array([1.]))      def test_call(self, create_rotate_detector, create_image):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_rotate_detector, create_image)"},{"location":"tests/test_detectors/","title":"Test detectors","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestLayeredDetector():\n\"\"\"Tests the LayeredDetector class.\"\"\"\n\n    def test_constructor(self, create_layered_detector):\n\"\"\"Tests the constructor.\"\"\"\n        create_layered_detector()\n        with pytest.raises(TypeError):\n            create_layered_detector(layers=[np.ones(1)])\n\n    def test_model(self, create_layered_detector, create_image):\n\"\"\"Tests the model method.\"\"\"\n        create_layered_detector().model(create_image())\n    \n    def test_getattr(self, create_layered_detector):\n\"\"\"Tests the __getattr__ method.\"\"\"\n        create_layered_detector().AddConstant\n        with pytest.raises(AttributeError):\n            create_layered_detector().nonexistent_attribute\n</pre> class TestLayeredDetector():     \"\"\"Tests the LayeredDetector class.\"\"\"      def test_constructor(self, create_layered_detector):         \"\"\"Tests the constructor.\"\"\"         create_layered_detector()         with pytest.raises(TypeError):             create_layered_detector(layers=[np.ones(1)])      def test_model(self, create_layered_detector, create_image):         \"\"\"Tests the model method.\"\"\"         create_layered_detector().model(create_image())          def test_getattr(self, create_layered_detector):         \"\"\"Tests the __getattr__ method.\"\"\"         create_layered_detector().AddConstant         with pytest.raises(AttributeError):             create_layered_detector().nonexistent_attribute"},{"location":"tests/test_images/","title":"Test images","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import config, Array\nimport pytest\nimport dLux\n</pre> import jax.numpy as np from jax import config, Array import pytest import dLux In\u00a0[\u00a0]: Copied! <pre>config.update(\"jax_debug_nans\", True)\n</pre> config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestImage():\n\"\"\"Test the Image class.\"\"\"\n\n    def test_constructor(self, create_image):\n\"\"\"Tests the constructor.\"\"\"\n        create_image()\n\n    def test_npixels(self, create_image):\n\"\"\"Tests the npixels property.\"\"\"\n        create_image().npixels\n    \n    def test_downsample(self, create_image):\n\"\"\"Tests the downsample method.\"\"\"\n        create_image().downsample(2)\n    \n    def test_convolve(self, create_image):\n\"\"\"Tests the convolve method.\"\"\"\n        create_image().convolve(np.ones((2, 2)))\n    \n    def test_rotate(self, create_image):\n\"\"\"Tests the rotate method.\"\"\"\n        create_image().rotate(np.pi, order=1)\n\n    def test_magic(self, create_image):\n\"\"\"Tests the magic methods.\"\"\"\n        im = create_image()\n        im *= np.array(1)\n        im /= np.array(1)\n        im += np.array(1)\n        im -= np.array(1)\n</pre> class TestImage():     \"\"\"Test the Image class.\"\"\"      def test_constructor(self, create_image):         \"\"\"Tests the constructor.\"\"\"         create_image()      def test_npixels(self, create_image):         \"\"\"Tests the npixels property.\"\"\"         create_image().npixels          def test_downsample(self, create_image):         \"\"\"Tests the downsample method.\"\"\"         create_image().downsample(2)          def test_convolve(self, create_image):         \"\"\"Tests the convolve method.\"\"\"         create_image().convolve(np.ones((2, 2)))          def test_rotate(self, create_image):         \"\"\"Tests the rotate method.\"\"\"         create_image().rotate(np.pi, order=1)      def test_magic(self, create_image):         \"\"\"Tests the magic methods.\"\"\"         im = create_image()         im *= np.array(1)         im /= np.array(1)         im += np.array(1)         im -= np.array(1)"},{"location":"tests/test_installation/","title":"Test installation","text":"In\u00a0[\u00a0]: Copied! <pre>import pytest\nimport sys\nimport os\n</pre> import pytest import sys import os In\u00a0[\u00a0]: Copied! <pre>platform: str = sys.platform\nnot_lin_err: str = \"\"\"\n    The installation test is designed to run on\n    a linux machine. In particular, this test\n    is designed to be run by github actions.\n    If you are using windows dispare.\n\"\"\"\n</pre> platform: str = sys.platform not_lin_err: str = \"\"\"     The installation test is designed to run on     a linux machine. In particular, this test     is designed to be run by github actions.     If you are using windows dispare. \"\"\" In\u00a0[\u00a0]: Copied! <pre>if platform not in [\"linux\", \"linux2\"]:\n    print(f\"Error: {not_lin_err}\")\n</pre> if platform not in [\"linux\", \"linux2\"]:     print(f\"Error: {not_lin_err}\") In\u00a0[\u00a0]: Copied! <pre>def test_install_dLux():\n    install_ok: int = os.system(\"pip install --quiet .\")\n\n    assert install_ok == 0\n\n    os.system(\"rm -r dLux.egg-info\")\n    os.system(\"rm -r build\")\n</pre> def test_install_dLux():     install_ok: int = os.system(\"pip install --quiet .\")      assert install_ok == 0      os.system(\"rm -r dLux.egg-info\")     os.system(\"rm -r build\") In\u00a0[\u00a0]: Copied! <pre>def test_import_dLux():\n    import dLux\n    assert True\n</pre> def test_import_dLux():     import dLux     assert True In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tests/test_instruments/","title":"Test instruments","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestInstrument(object):\n\"\"\"Tests the Instrument class.\"\"\"\n\n    def test_constructor(self, create_instrument):\n\"\"\"Tests the constructor.\"\"\"\n        create_instrument()\n        with pytest.raises(TypeError):\n            create_instrument(sources=[\"Not a source\"])\n        with pytest.raises(TypeError):\n            create_instrument(optics='Not an optics')\n        with pytest.raises(TypeError):\n            create_instrument(observation='Not an observation')\n        with pytest.raises(TypeError):\n            create_instrument(detector='Not a detector')\n\n    def test_observe(self, create_instrument):\n\"\"\"Tests the normalise method.\"\"\"\n        create_instrument().observe()\n\n    def test_normalise(self, create_instrument):\n\"\"\"Tests the normalise method.\"\"\"\n        create_instrument().normalise()\n    \n    def test_model(self, create_instrument):\n\"\"\"Tests the model method.\"\"\"\n        create_instrument().model()\n    \n    def test_getattr(self, create_instrument):\n\"\"\"Tests the __getattr__ method.\"\"\"\n        create_instrument().diameter\n        create_instrument().PointSource\n        create_instrument().flux\n        with pytest.raises(AttributeError):\n            create_instrument().nonexistent_attribute\n</pre> class TestInstrument(object):     \"\"\"Tests the Instrument class.\"\"\"      def test_constructor(self, create_instrument):         \"\"\"Tests the constructor.\"\"\"         create_instrument()         with pytest.raises(TypeError):             create_instrument(sources=[\"Not a source\"])         with pytest.raises(TypeError):             create_instrument(optics='Not an optics')         with pytest.raises(TypeError):             create_instrument(observation='Not an observation')         with pytest.raises(TypeError):             create_instrument(detector='Not a detector')      def test_observe(self, create_instrument):         \"\"\"Tests the normalise method.\"\"\"         create_instrument().observe()      def test_normalise(self, create_instrument):         \"\"\"Tests the normalise method.\"\"\"         create_instrument().normalise()          def test_model(self, create_instrument):         \"\"\"Tests the model method.\"\"\"         create_instrument().model()          def test_getattr(self, create_instrument):         \"\"\"Tests the __getattr__ method.\"\"\"         create_instrument().diameter         create_instrument().PointSource         create_instrument().flux         with pytest.raises(AttributeError):             create_instrument().nonexistent_attribute"},{"location":"tests/test_observations/","title":"Test observations","text":"In\u00a0[\u00a0]: Copied! <pre>import dLux \nimport jax.numpy as np\nimport pytest\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import dLux  import jax.numpy as np import pytest from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class TestDither(object):\n\"\"\"Tests the Dither class.\"\"\"\n\n    def test_constructor(self, create_dither):\n\"\"\"Tests the constructor.\"\"\"\n        create_dither()\n        with pytest.raises(ValueError):\n            dither = create_dither(np.array([1., 1., 1.]))\n    \n    def test_model(self, create_dither, create_instrument):\n\"\"\"Tests the model method.\"\"\"\n        create_dither().model(create_instrument())\n</pre> class TestDither(object):     \"\"\"Tests the Dither class.\"\"\"      def test_constructor(self, create_dither):         \"\"\"Tests the constructor.\"\"\"         create_dither()         with pytest.raises(ValueError):             dither = create_dither(np.array([1., 1., 1.]))          def test_model(self, create_dither, create_instrument):         \"\"\"Tests the model method.\"\"\"         create_dither().model(create_instrument())"},{"location":"tests/test_optical_layers/","title":"Test optical layers","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_transmissive_layer(constructor):\n\"\"\"Tests the constructor of a transmissive layer.\"\"\"\n    constructor()\n</pre> def _test_transmissive_layer(constructor):     \"\"\"Tests the constructor of a transmissive layer.\"\"\"     constructor() In\u00a0[\u00a0]: Copied! <pre>def _test_call_transmissive_layer(constructor, create_wavefront):\n\"\"\"Tests the __call__ method of a transmissive layer.\"\"\"\n    wf = create_wavefront()\n    constructor(normalise=True)(wf)\n    constructor(normalise=False)(wf)\n</pre> def _test_call_transmissive_layer(constructor, create_wavefront):     \"\"\"Tests the __call__ method of a transmissive layer.\"\"\"     wf = create_wavefront()     constructor(normalise=True)(wf)     constructor(normalise=False)(wf) In\u00a0[\u00a0]: Copied! <pre>def _test_applied_shape(constructor):\n\"\"\"Tests the applied_shape method of a shaped layer.\"\"\"\n    constructor().applied_shape\n</pre> def _test_applied_shape(constructor):     \"\"\"Tests the applied_shape method of a shaped layer.\"\"\"     constructor().applied_shape In\u00a0[\u00a0]: Copied! <pre>def _test_basis_layer_constructor(constructor):\n\"\"\"Tests the constructor of a basis layer.\"\"\"\n    constructor()\n    constructor(basis=None)\n    constructor(coefficients=None)\n    with pytest.raises(ValueError):\n        constructor(basis=np.ones((2, 1, 1)), coefficients=np.ones(1))\n    with pytest.raises(ValueError):\n        constructor(basis=[(2, 1, 1)], coefficients=np.ones(1))\n</pre> def _test_basis_layer_constructor(constructor):     \"\"\"Tests the constructor of a basis layer.\"\"\"     constructor()     constructor(basis=None)     constructor(coefficients=None)     with pytest.raises(ValueError):         constructor(basis=np.ones((2, 1, 1)), coefficients=np.ones(1))     with pytest.raises(ValueError):         constructor(basis=[(2, 1, 1)], coefficients=np.ones(1)) In\u00a0[\u00a0]: Copied! <pre>def _test_base_transmissive_optic_constructor(constructor):\n\"\"\"Tests the constructor of a base transmissive optic.\"\"\"\n    constructor()\n    constructor(transmission=None)\n</pre> def _test_base_transmissive_optic_constructor(constructor):     \"\"\"Tests the constructor of a base transmissive optic.\"\"\"     constructor()     constructor(transmission=None) In\u00a0[\u00a0]: Copied! <pre>def _test_base_opd_optic_constructor(constructor):\n\"\"\"Tests the constructor of a base opd optic.\"\"\"\n    constructor()\n    constructor(opd=None)\n</pre> def _test_base_opd_optic_constructor(constructor):     \"\"\"Tests the constructor of a base opd optic.\"\"\"     constructor()     constructor(opd=None) In\u00a0[\u00a0]: Copied! <pre>def _test_base_phase_optic_constructor(constructor):\n\"\"\"Tests the constructor of a base phase optic.\"\"\"\n    constructor()\n    constructor(phase=None)\n</pre> def _test_base_phase_optic_constructor(constructor):     \"\"\"Tests the constructor of a base phase optic.\"\"\"     constructor()     constructor(phase=None) In\u00a0[\u00a0]: Copied! <pre>def _test_base_basis_optic_constructor(constructor):\n\"\"\"Tests the constructor of a base basis optic.\"\"\"\n    constructor()\n    with pytest.raises(ValueError):\n        constructor(basis=np.ones((2, 1, 1)), coefficients=np.ones(1))\n</pre> def _test_base_basis_optic_constructor(constructor):     \"\"\"Tests the constructor of a base basis optic.\"\"\"     constructor()     with pytest.raises(ValueError):         constructor(basis=np.ones((2, 1, 1)), coefficients=np.ones(1)) In\u00a0[\u00a0]: Copied! <pre>class TestOptic():\n\"\"\"Tests the Optic class.\"\"\"\n\n    def test_constructor(self, create_optic):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_transmissive_optic_constructor(create_optic)\n        _test_base_opd_optic_constructor(create_optic)\n        with pytest.raises(ValueError):\n            create_optic(transmission=np.ones(1), opd=np.ones(2))\n    \n    def test_call(self, create_optic, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call_transmissive_layer(create_optic, create_wavefront)\n    \n    def test_applied_shape(self, create_optic):\n\"\"\"Tests the applied_shape method.\"\"\"\n        _test_applied_shape(create_optic)\n</pre> class TestOptic():     \"\"\"Tests the Optic class.\"\"\"      def test_constructor(self, create_optic):         \"\"\"Tests the constructor.\"\"\"         _test_base_transmissive_optic_constructor(create_optic)         _test_base_opd_optic_constructor(create_optic)         with pytest.raises(ValueError):             create_optic(transmission=np.ones(1), opd=np.ones(2))          def test_call(self, create_optic, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call_transmissive_layer(create_optic, create_wavefront)          def test_applied_shape(self, create_optic):         \"\"\"Tests the applied_shape method.\"\"\"         _test_applied_shape(create_optic) In\u00a0[\u00a0]: Copied! <pre>class TestPhaseOptic():\n\"\"\"Tests the Optic class.\"\"\"\n\n    def test_constructor(self, create_phase_optic):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_transmissive_optic_constructor(create_phase_optic)\n        _test_base_phase_optic_constructor(create_phase_optic)\n        with pytest.raises(ValueError):\n            create_phase_optic(transmission=np.ones(1), phase=np.ones(2))\n    \n    def test_call(self, create_phase_optic, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call_transmissive_layer(create_phase_optic, create_wavefront)\n\n    def test_applied_shape(self, create_phase_optic):\n\"\"\"Tests the applied_shape method.\"\"\"\n        _test_applied_shape(create_phase_optic)\n</pre> class TestPhaseOptic():     \"\"\"Tests the Optic class.\"\"\"      def test_constructor(self, create_phase_optic):         \"\"\"Tests the constructor.\"\"\"         _test_base_transmissive_optic_constructor(create_phase_optic)         _test_base_phase_optic_constructor(create_phase_optic)         with pytest.raises(ValueError):             create_phase_optic(transmission=np.ones(1), phase=np.ones(2))          def test_call(self, create_phase_optic, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call_transmissive_layer(create_phase_optic, create_wavefront)      def test_applied_shape(self, create_phase_optic):         \"\"\"Tests the applied_shape method.\"\"\"         _test_applied_shape(create_phase_optic) In\u00a0[\u00a0]: Copied! <pre>class TestBasisOptic():\n\"\"\"Tests the BasisOptics class.\"\"\"\n\n    def test_constructor(self, create_basis_optic):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_transmissive_optic_constructor(create_basis_optic)\n        _test_base_basis_optic_constructor(create_basis_optic)\n    \n    def test_call(self, create_basis_optic, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call_transmissive_layer(create_basis_optic, create_wavefront)\n\n    def test_applied_shape(self, create_basis_optic):\n\"\"\"Tests the applied_shape method.\"\"\"\n        _test_applied_shape(create_basis_optic)\n</pre> class TestBasisOptic():     \"\"\"Tests the BasisOptics class.\"\"\"      def test_constructor(self, create_basis_optic):         \"\"\"Tests the constructor.\"\"\"         _test_base_transmissive_optic_constructor(create_basis_optic)         _test_base_basis_optic_constructor(create_basis_optic)          def test_call(self, create_basis_optic, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call_transmissive_layer(create_basis_optic, create_wavefront)      def test_applied_shape(self, create_basis_optic):         \"\"\"Tests the applied_shape method.\"\"\"         _test_applied_shape(create_basis_optic) In\u00a0[\u00a0]: Copied! <pre>class TestPhaseBasisOptic():\n\"\"\"Tests the PhaseBasisOptics class.\"\"\"\n\n    def test_constructor(self, create_phase_basis_optic):\n\"\"\"Tests the constructor.\"\"\"\n        _test_base_transmissive_optic_constructor(create_phase_basis_optic)\n        _test_base_basis_optic_constructor(create_phase_basis_optic)\n    \n    def test_call(self, create_phase_basis_optic, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call_transmissive_layer(create_phase_basis_optic, \n            create_wavefront)\n\n    def test_applied_shape(self, create_phase_basis_optic):\n\"\"\"Tests the applied_shape method.\"\"\"\n        _test_applied_shape(create_phase_basis_optic)\n</pre> class TestPhaseBasisOptic():     \"\"\"Tests the PhaseBasisOptics class.\"\"\"      def test_constructor(self, create_phase_basis_optic):         \"\"\"Tests the constructor.\"\"\"         _test_base_transmissive_optic_constructor(create_phase_basis_optic)         _test_base_basis_optic_constructor(create_phase_basis_optic)          def test_call(self, create_phase_basis_optic, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call_transmissive_layer(create_phase_basis_optic,              create_wavefront)      def test_applied_shape(self, create_phase_basis_optic):         \"\"\"Tests the applied_shape method.\"\"\"         _test_applied_shape(create_phase_basis_optic) In\u00a0[\u00a0]: Copied! <pre>class TestTilt():\n\"\"\"Tests the Tilt class.\"\"\"\n\n    def test_constructor(self, create_tilt):\n\"\"\"Tests the constructor.\"\"\"\n        create_tilt()\n        with pytest.raises(ValueError):\n            create_tilt(angles=np.ones(1))\n\n    def test_call(self, create_tilt, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        create_tilt()(create_wavefront())\n</pre> class TestTilt():     \"\"\"Tests the Tilt class.\"\"\"      def test_constructor(self, create_tilt):         \"\"\"Tests the constructor.\"\"\"         create_tilt()         with pytest.raises(ValueError):             create_tilt(angles=np.ones(1))      def test_call(self, create_tilt, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         create_tilt()(create_wavefront()) In\u00a0[\u00a0]: Copied! <pre>class TestNormalise():\n\"\"\"Tests the Normalise class.\"\"\"\n\n    def test_call(self, create_normalise, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        wf = create_normalise()(create_wavefront())\n</pre> class TestNormalise():     \"\"\"Tests the Normalise class.\"\"\"      def test_call(self, create_normalise, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         wf = create_normalise()(create_wavefront()) In\u00a0[\u00a0]: Copied! <pre>class TestRotate():\n\"\"\"Tests the Rotate class.\"\"\"\n\n    def test_constructor(self, create_rotate):\n\"\"\"Tests the constructor.\"\"\"\n        create_rotate()\n        with pytest.raises(ValueError):\n            create_rotate(angle=np.ones(1))\n        with pytest.raises(ValueError):\n            create_rotate(order=2)\n\n    def test_call(self, create_rotate, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        wf = create_wavefront()\n        create_rotate()(wf)\n        create_rotate(complex=True)(wf)\n</pre> class TestRotate():     \"\"\"Tests the Rotate class.\"\"\"      def test_constructor(self, create_rotate):         \"\"\"Tests the constructor.\"\"\"         create_rotate()         with pytest.raises(ValueError):             create_rotate(angle=np.ones(1))         with pytest.raises(ValueError):             create_rotate(order=2)      def test_call(self, create_rotate, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         wf = create_wavefront()         create_rotate()(wf)         create_rotate(complex=True)(wf)"},{"location":"tests/test_optics/","title":"Test optics","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_apertured_optics_constructor(constructor):\n\"\"\"Tests the constructor of the AperturedOptics class\"\"\"\n    constructor()\n    with pytest.raises(TypeError):\n        constructor(aperture=\"1\")\n    with pytest.raises(TypeError):\n        constructor(mask=\"1\")\n</pre> def _test_apertured_optics_constructor(constructor):     \"\"\"Tests the constructor of the AperturedOptics class\"\"\"     constructor()     with pytest.raises(TypeError):         constructor(aperture=\"1\")     with pytest.raises(TypeError):         constructor(mask=\"1\") In\u00a0[\u00a0]: Copied! <pre>def _test_propagate(optics):\n\"\"\"Tests the propagate method and its sub function\"\"\"\n    # Test wavelengths\n    optics.propagate(1e-6)\n    optics.propagate(np.array(1e-6))\n    optics.propagate([1e-6, 2e-6])\n\n    # Test weights\n    optics.propagate(1e-6, weights=1e-6)\n    optics.propagate(1e-6, weights=np.array(1e-6))\n    with pytest.raises(ValueError):\n        optics.propagate(1e-6, weights=np.array([1e-6, 2e-6]))\n\n    # Test offset\n    optics.propagate(wavelengths=1e-6, offset=[0, 0])\n    with pytest.raises(ValueError):\n        optics.propagate(1e-6, offset=np.array([0, 0, 0]))\n</pre> def _test_propagate(optics):     \"\"\"Tests the propagate method and its sub function\"\"\"     # Test wavelengths     optics.propagate(1e-6)     optics.propagate(np.array(1e-6))     optics.propagate([1e-6, 2e-6])      # Test weights     optics.propagate(1e-6, weights=1e-6)     optics.propagate(1e-6, weights=np.array(1e-6))     with pytest.raises(ValueError):         optics.propagate(1e-6, weights=np.array([1e-6, 2e-6]))      # Test offset     optics.propagate(wavelengths=1e-6, offset=[0, 0])     with pytest.raises(ValueError):         optics.propagate(1e-6, offset=np.array([0, 0, 0])) In\u00a0[\u00a0]: Copied! <pre>def _test_propagate_mono(optics):\n\"\"\"Tests the propagate method and its sub function\"\"\"\n    # Test wavelengths\n    optics.propagate_mono(1e-6)\n    optics.propagate_mono(1e-6, return_wf=True)\n</pre> def _test_propagate_mono(optics):     \"\"\"Tests the propagate method and its sub function\"\"\"     # Test wavelengths     optics.propagate_mono(1e-6)     optics.propagate_mono(1e-6, return_wf=True) In\u00a0[\u00a0]: Copied! <pre>def _test_model(optics, source):\n\"\"\"Tests the source input type checking of the BaseOptics.model method\"\"\"\n    optics.model(sources=source)\n    optics.model(sources=[source])\n    with pytest.raises(TypeError):\n        optics.model(sources=1)\n</pre> def _test_model(optics, source):     \"\"\"Tests the source input type checking of the BaseOptics.model method\"\"\"     optics.model(sources=source)     optics.model(sources=[source])     with pytest.raises(TypeError):         optics.model(sources=1) In\u00a0[\u00a0]: Copied! <pre>def _test_getattr(optics):\n\"\"\"Tests the __getattr__ method\"\"\"\n    optics.transmission\n    with pytest.raises(AttributeError):\n        optics.not_an_attribute\n</pre> def _test_getattr(optics):     \"\"\"Tests the __getattr__ method\"\"\"     optics.transmission     with pytest.raises(AttributeError):         optics.not_an_attribute In\u00a0[\u00a0]: Copied! <pre>def _test_true_pixel_scale(optics):\n\"\"\"Tests the true_pixel_scale property\"\"\"\n    optics.true_pixel_scale\n</pre> def _test_true_pixel_scale(optics):     \"\"\"Tests the true_pixel_scale property\"\"\"     optics.true_pixel_scale In\u00a0[\u00a0]: Copied! <pre>class TestAngularOptics():\n\"\"\"Tests the AngularOptics class.\"\"\"\n\n    def test_constructor(self, create_angular_optics):\n\"\"\"Tests the constructor\"\"\"\n        _test_apertured_optics_constructor(create_angular_optics)\n\n    def test_propagate(self, create_angular_optics):\n\"\"\"Tests the propagate method\"\"\"\n        _test_propagate(create_angular_optics())\n\n    def test_model(self, create_angular_optics, create_point_source):\n\"\"\"Tests the model method\"\"\"\n        _test_model(create_angular_optics(), create_point_source())\n    \n    def test_propagate_mono(self, create_angular_optics):\n\"\"\"Tests the propagate_mono method\"\"\"\n        _test_propagate_mono(create_angular_optics())\n\n    def test_getattr(self, create_angular_optics):\n\"\"\"Tests the __getattr__ method\"\"\"\n        _test_getattr(create_angular_optics())\n    \n    def test_true_pixel_scale(self, create_angular_optics):\n\"\"\"Tests the true_pixel_scale property\"\"\"\n        _test_true_pixel_scale(create_angular_optics())\n</pre> class TestAngularOptics():     \"\"\"Tests the AngularOptics class.\"\"\"      def test_constructor(self, create_angular_optics):         \"\"\"Tests the constructor\"\"\"         _test_apertured_optics_constructor(create_angular_optics)      def test_propagate(self, create_angular_optics):         \"\"\"Tests the propagate method\"\"\"         _test_propagate(create_angular_optics())      def test_model(self, create_angular_optics, create_point_source):         \"\"\"Tests the model method\"\"\"         _test_model(create_angular_optics(), create_point_source())          def test_propagate_mono(self, create_angular_optics):         \"\"\"Tests the propagate_mono method\"\"\"         _test_propagate_mono(create_angular_optics())      def test_getattr(self, create_angular_optics):         \"\"\"Tests the __getattr__ method\"\"\"         _test_getattr(create_angular_optics())          def test_true_pixel_scale(self, create_angular_optics):         \"\"\"Tests the true_pixel_scale property\"\"\"         _test_true_pixel_scale(create_angular_optics()) In\u00a0[\u00a0]: Copied! <pre>class TestCartesianOptics():\n\"\"\"Tests the CartesianOptics class.\"\"\"\n\n    def test_constructor(self, create_cartesian_optics):\n\"\"\"Tests the constructor\"\"\"\n        _test_apertured_optics_constructor(create_cartesian_optics)\n        with pytest.raises(TypeError):\n            create_cartesian_optics(focal_length=[1.])\n\n    def test_propagate(self, create_angular_optics):\n\"\"\"Tests the propagate method\"\"\"\n        _test_propagate(create_angular_optics())\n\n    def test_model(self, create_cartesian_optics, create_point_source):\n\"\"\"Tests the model method\"\"\"\n        _test_model(create_cartesian_optics(), create_point_source())\n    \n    def test_propagate_mono(self, create_cartesian_optics):\n\"\"\"Tests the propagate_mono method\"\"\"\n        _test_propagate_mono(create_cartesian_optics())\n\n    def test_getattr(self, create_cartesian_optics):\n\"\"\"Tests the __getattr__ method\"\"\"\n        _test_getattr(create_cartesian_optics())\n    \n    def test_true_pixel_scale(self, create_cartesian_optics):\n\"\"\"Tests the true_pixel_scale property\"\"\"\n        _test_true_pixel_scale(create_cartesian_optics())\n</pre> class TestCartesianOptics():     \"\"\"Tests the CartesianOptics class.\"\"\"      def test_constructor(self, create_cartesian_optics):         \"\"\"Tests the constructor\"\"\"         _test_apertured_optics_constructor(create_cartesian_optics)         with pytest.raises(TypeError):             create_cartesian_optics(focal_length=[1.])      def test_propagate(self, create_angular_optics):         \"\"\"Tests the propagate method\"\"\"         _test_propagate(create_angular_optics())      def test_model(self, create_cartesian_optics, create_point_source):         \"\"\"Tests the model method\"\"\"         _test_model(create_cartesian_optics(), create_point_source())          def test_propagate_mono(self, create_cartesian_optics):         \"\"\"Tests the propagate_mono method\"\"\"         _test_propagate_mono(create_cartesian_optics())      def test_getattr(self, create_cartesian_optics):         \"\"\"Tests the __getattr__ method\"\"\"         _test_getattr(create_cartesian_optics())          def test_true_pixel_scale(self, create_cartesian_optics):         \"\"\"Tests the true_pixel_scale property\"\"\"         _test_true_pixel_scale(create_cartesian_optics()) In\u00a0[\u00a0]: Copied! <pre>class TestFlexibleOptics():\n\"\"\"Tests the FlexibleOptics class.\"\"\"\n\n    def test_constructor(self, create_flexible_optics, create_mft, \n        create_far_field_fresnel):\n\"\"\"Tests the constructor\"\"\"\n        _test_apertured_optics_constructor(create_flexible_optics)\n        with pytest.raises(TypeError):\n            create_flexible_optics(propagator=1.)\n\n        # Test Fresnel propagation\n        optics = create_flexible_optics(propagator=create_far_field_fresnel())\n        optics.propagate(1e-6)\n\n    def test_propagate(self, create_flexible_optics):\n\"\"\"Tests the propagate method\"\"\"\n        _test_propagate(create_flexible_optics())\n\n    def test_model(self, create_flexible_optics, create_point_source):\n\"\"\"Tests the model method\"\"\"\n        _test_model(create_flexible_optics(), create_point_source())\n    \n    def test_propagate_mono(self, create_flexible_optics):\n\"\"\"Tests the propagate_mono method\"\"\"\n        _test_propagate_mono(create_flexible_optics())\n\n    def test_getattr(self, create_flexible_optics):\n\"\"\"Tests the __getattr__ method\"\"\"\n        _test_getattr(create_flexible_optics())\n    \n    def test_true_pixel_scale(self, create_flexible_optics):\n\"\"\"Tests the true_pixel_scale property\"\"\"\n        _test_true_pixel_scale(create_flexible_optics())\n</pre> class TestFlexibleOptics():     \"\"\"Tests the FlexibleOptics class.\"\"\"      def test_constructor(self, create_flexible_optics, create_mft,          create_far_field_fresnel):         \"\"\"Tests the constructor\"\"\"         _test_apertured_optics_constructor(create_flexible_optics)         with pytest.raises(TypeError):             create_flexible_optics(propagator=1.)          # Test Fresnel propagation         optics = create_flexible_optics(propagator=create_far_field_fresnel())         optics.propagate(1e-6)      def test_propagate(self, create_flexible_optics):         \"\"\"Tests the propagate method\"\"\"         _test_propagate(create_flexible_optics())      def test_model(self, create_flexible_optics, create_point_source):         \"\"\"Tests the model method\"\"\"         _test_model(create_flexible_optics(), create_point_source())          def test_propagate_mono(self, create_flexible_optics):         \"\"\"Tests the propagate_mono method\"\"\"         _test_propagate_mono(create_flexible_optics())      def test_getattr(self, create_flexible_optics):         \"\"\"Tests the __getattr__ method\"\"\"         _test_getattr(create_flexible_optics())          def test_true_pixel_scale(self, create_flexible_optics):         \"\"\"Tests the true_pixel_scale property\"\"\"         _test_true_pixel_scale(create_flexible_optics()) In\u00a0[\u00a0]: Copied! <pre>class TestLayeredOptics():\n\"\"\"Tests the LayeredOptics class.\"\"\"\n\n    def test_constructor(self, create_layered_optics, create_mft):\n\"\"\"Tests the constructor\"\"\"\n        _test_apertured_optics_constructor(create_layered_optics)\n\n    def test_propagate(self, create_layered_optics):\n\"\"\"Tests the propagate method\"\"\"\n        _test_propagate(create_layered_optics())\n\n    def test_model(self, create_layered_optics, create_point_source):\n\"\"\"Tests the model method\"\"\"\n        _test_model(create_layered_optics(), create_point_source())\n    \n    def test_propagate_mono(self, create_layered_optics):\n\"\"\"Tests the propagate_mono method\"\"\"\n        _test_propagate_mono(create_layered_optics())\n\n    def test_getattr(self, create_layered_optics):\n\"\"\"Tests the __getattr__ method\"\"\"\n        create_layered_optics().Optic\n        with pytest.raises(AttributeError):\n            create_layered_optics().not_an_attribute\n    \n    def test_true_pixel_scale(self, create_layered_optics):\n\"\"\"Tests the true_pixel_scale property\"\"\"\n        _test_true_pixel_scale(create_layered_optics())\n</pre> class TestLayeredOptics():     \"\"\"Tests the LayeredOptics class.\"\"\"      def test_constructor(self, create_layered_optics, create_mft):         \"\"\"Tests the constructor\"\"\"         _test_apertured_optics_constructor(create_layered_optics)      def test_propagate(self, create_layered_optics):         \"\"\"Tests the propagate method\"\"\"         _test_propagate(create_layered_optics())      def test_model(self, create_layered_optics, create_point_source):         \"\"\"Tests the model method\"\"\"         _test_model(create_layered_optics(), create_point_source())          def test_propagate_mono(self, create_layered_optics):         \"\"\"Tests the propagate_mono method\"\"\"         _test_propagate_mono(create_layered_optics())      def test_getattr(self, create_layered_optics):         \"\"\"Tests the __getattr__ method\"\"\"         create_layered_optics().Optic         with pytest.raises(AttributeError):             create_layered_optics().not_an_attribute          def test_true_pixel_scale(self, create_layered_optics):         \"\"\"Tests the true_pixel_scale property\"\"\"         _test_true_pixel_scale(create_layered_optics())"},{"location":"tests/test_propagators/","title":"Test propagators","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>def _test_propagator_constructor(constructor):\n\"\"\"Tests the constructor of a propagator.\"\"\"\n    constructor()\n    with pytest.raises(TypeError):\n        constructor(focal_length = np.array([1]))\n</pre> def _test_propagator_constructor(constructor):     \"\"\"Tests the constructor of a propagator.\"\"\"     constructor()     with pytest.raises(TypeError):         constructor(focal_length = np.array([1])) In\u00a0[\u00a0]: Copied! <pre>def _test_call(constructor, wf_constructor):\n\"\"\"Tests the __call__ method of a propagator.\"\"\"\n    wf = wf_constructor()\n    wf = constructor(focal_length=None)(wf)\n    wf = constructor(focal_length=None, inverse=True)(wf)\n    wf = constructor(focal_length=5)(wf)\n    wf = constructor(focal_length=5, inverse=True)(wf)\n</pre> def _test_call(constructor, wf_constructor):     \"\"\"Tests the __call__ method of a propagator.\"\"\"     wf = wf_constructor()     wf = constructor(focal_length=None)(wf)     wf = constructor(focal_length=None, inverse=True)(wf)     wf = constructor(focal_length=5)(wf)     wf = constructor(focal_length=5, inverse=True)(wf) In\u00a0[\u00a0]: Copied! <pre>class TestFFT():\n\"\"\"Test the CartesianFFT class.\"\"\"\n\n    def test_constructor(self, create_fft):\n\"\"\"Tests the constructor.\"\"\"\n        _test_propagator_constructor(create_fft)\n    \n    def test_call(self, create_fft, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_fft, create_wavefront)\n</pre> class TestFFT():     \"\"\"Test the CartesianFFT class.\"\"\"      def test_constructor(self, create_fft):         \"\"\"Tests the constructor.\"\"\"         _test_propagator_constructor(create_fft)          def test_call(self, create_fft, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_fft, create_wavefront) In\u00a0[\u00a0]: Copied! <pre>class TestMFT():\n\"\"\"Test the CartesianMFT class.\"\"\"\n\n    def test_constructor(self, create_mft):\n\"\"\"Tests the constructor.\"\"\"\n        _test_propagator_constructor(create_mft)\n        with pytest.raises(TypeError):\n            create_mft(pixel_scale = np.array([1]))\n\n    def test_call(self, create_mft, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_mft, create_wavefront)\n</pre> class TestMFT():     \"\"\"Test the CartesianMFT class.\"\"\"      def test_constructor(self, create_mft):         \"\"\"Tests the constructor.\"\"\"         _test_propagator_constructor(create_mft)         with pytest.raises(TypeError):             create_mft(pixel_scale = np.array([1]))      def test_call(self, create_mft, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_mft, create_wavefront) In\u00a0[\u00a0]: Copied! <pre>class TestShiftedMFT():\n\"\"\"Test the ShiftedCartesianMFT class.\"\"\"\n\n    def test_constructor(self, create_shifted_mft):\n\"\"\"Tests the constructor.\"\"\"\n        _test_propagator_constructor(create_shifted_mft)\n        with pytest.raises(TypeError):\n            create_shifted_mft(shift = np.array([1]))\n\n    def test_call(self, create_shifted_mft, create_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        _test_call(create_shifted_mft, create_wavefront)\n</pre> class TestShiftedMFT():     \"\"\"Test the ShiftedCartesianMFT class.\"\"\"      def test_constructor(self, create_shifted_mft):         \"\"\"Tests the constructor.\"\"\"         _test_propagator_constructor(create_shifted_mft)         with pytest.raises(TypeError):             create_shifted_mft(shift = np.array([1]))      def test_call(self, create_shifted_mft, create_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         _test_call(create_shifted_mft, create_wavefront) In\u00a0[\u00a0]: Copied! <pre>class TestFarFieldFresnel():\n\"\"\"Test the FarFieldFresnel class.\"\"\"\n\n    def test_constructor(self, create_far_field_fresnel):\n\"\"\"Tests the constructor.\"\"\"\n        # Manully test here since inverse is not implemented\n        create_far_field_fresnel()\n        with pytest.raises(TypeError):\n            create_far_field_fresnel(focal_length = np.array([1]))\n        with pytest.raises(TypeError):\n            create_far_field_fresnel(focal_shift = np.array([1]))\n        with pytest.raises(NotImplementedError):\n            create_far_field_fresnel(inverse=True)\n    \n    def test_call(self, create_far_field_fresnel, create_fresnel_wavefront):\n\"\"\"Tests the __call__ method.\"\"\"\n        create_far_field_fresnel()(create_fresnel_wavefront())\n</pre> class TestFarFieldFresnel():     \"\"\"Test the FarFieldFresnel class.\"\"\"      def test_constructor(self, create_far_field_fresnel):         \"\"\"Tests the constructor.\"\"\"         # Manully test here since inverse is not implemented         create_far_field_fresnel()         with pytest.raises(TypeError):             create_far_field_fresnel(focal_length = np.array([1]))         with pytest.raises(TypeError):             create_far_field_fresnel(focal_shift = np.array([1]))         with pytest.raises(NotImplementedError):             create_far_field_fresnel(inverse=True)          def test_call(self, create_far_field_fresnel, create_fresnel_wavefront):         \"\"\"Tests the __call__ method.\"\"\"         create_far_field_fresnel()(create_fresnel_wavefront())"},{"location":"tests/test_sources/","title":"Test sources","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_source_constructor(constructor, spectrum_constructor):\n\"\"\"Tests the consturctor for source classes\"\"\"\n    constructor()\n    constructor(spectrum=spectrum_constructor())\n    with pytest.raises(ValueError):\n        constructor(position=[1, 2, 3])\n    with pytest.raises(ValueError):\n        constructor(flux=[1])\n    with pytest.raises(ValueError):\n        constructor(spectrum=\"spectrum\")\n</pre> def _test_source_constructor(constructor, spectrum_constructor):     \"\"\"Tests the consturctor for source classes\"\"\"     constructor()     constructor(spectrum=spectrum_constructor())     with pytest.raises(ValueError):         constructor(position=[1, 2, 3])     with pytest.raises(ValueError):         constructor(flux=[1])     with pytest.raises(ValueError):         constructor(spectrum=\"spectrum\") In\u00a0[\u00a0]: Copied! <pre>def _test_resolved_source_constructor(constructor):\n\"\"\"tests the constructor for resolved source classes\"\"\"\n    with pytest.raises(ValueError):\n        constructor(distribution=[1])\n</pre> def _test_resolved_source_constructor(constructor):     \"\"\"tests the constructor for resolved source classes\"\"\"     with pytest.raises(ValueError):         constructor(distribution=[1]) In\u00a0[\u00a0]: Copied! <pre>def _test_normalise(constructor):\n\"\"\"Tests the normalise method for source classes\"\"\"\n    source = constructor().normalise()\n</pre> def _test_normalise(constructor):     \"\"\"Tests the normalise method for source classes\"\"\"     source = constructor().normalise() In\u00a0[\u00a0]: Copied! <pre>def _test_model(constructor, optics_constructor):\n\"\"\"Tests the model method for source classes\"\"\"\n    constructor().model(optics_constructor())\n</pre> def _test_model(constructor, optics_constructor):     \"\"\"Tests the model method for source classes\"\"\"     constructor().model(optics_constructor()) In\u00a0[\u00a0]: Copied! <pre>def _test_rel_pos_constructor(constructor):\n\"\"\"Tests the constructor for relative position classes\"\"\"\n    with pytest.raises(ValueError):\n        constructor(separation=[1])\n    with pytest.raises(ValueError):\n        constructor(position_angle=[1])\n</pre> def _test_rel_pos_constructor(constructor):     \"\"\"Tests the constructor for relative position classes\"\"\"     with pytest.raises(ValueError):         constructor(separation=[1])     with pytest.raises(ValueError):         constructor(position_angle=[1]) In\u00a0[\u00a0]: Copied! <pre>def _test_rel_flux_constructor(constructor):\n\"\"\"Tests the constructor for relative flux classes\"\"\"\n    with pytest.raises(ValueError):\n        constructor(contrast=[1])\n</pre> def _test_rel_flux_constructor(constructor):     \"\"\"Tests the constructor for relative flux classes\"\"\"     with pytest.raises(ValueError):         constructor(contrast=[1]) In\u00a0[\u00a0]: Copied! <pre>class TestPointSource():\n\"\"\"Tests the Source class.\"\"\"\n\n    def test_constructor(self, create_point_source, create_spectrum):\n\"\"\"Test the constructor class.\"\"\"\n        create_point_source()\n        _test_source_constructor(create_point_source, create_spectrum)\n        \n    def test_normalise(self, create_point_source):\n\"\"\"Test the normalise method.\"\"\"\n        _test_normalise(create_point_source)\n    \n    def test_model(self, create_point_source, create_angular_optics):\n\"\"\"Test the model method.\"\"\"\n        _test_model(create_point_source, create_angular_optics)\n</pre> class TestPointSource():     \"\"\"Tests the Source class.\"\"\"      def test_constructor(self, create_point_source, create_spectrum):         \"\"\"Test the constructor class.\"\"\"         create_point_source()         _test_source_constructor(create_point_source, create_spectrum)              def test_normalise(self, create_point_source):         \"\"\"Test the normalise method.\"\"\"         _test_normalise(create_point_source)          def test_model(self, create_point_source, create_angular_optics):         \"\"\"Test the model method.\"\"\"         _test_model(create_point_source, create_angular_optics) In\u00a0[\u00a0]: Copied! <pre>class TestPointSources():\n\"\"\"Tests the Sources class.\"\"\"\n\n    def test_constructor(self, create_point_sources, create_spectrum):\n\"\"\"Test the constructor class.\"\"\"\n        create_point_sources()\n        _test_source_constructor(create_point_sources, create_spectrum)\n        create_point_sources(flux=None)\n        with pytest.raises(ValueError):\n            create_point_sources(flux=np.ones((2, 2)))\n        \n    def test_normalise(self, create_point_sources):\n\"\"\"Test the normalise method.\"\"\"\n        _test_normalise(create_point_sources)\n    \n    def test_model(self, create_point_sources, create_angular_optics):\n\"\"\"Test the model method.\"\"\"\n        _test_model(create_point_sources, create_angular_optics)\n</pre> class TestPointSources():     \"\"\"Tests the Sources class.\"\"\"      def test_constructor(self, create_point_sources, create_spectrum):         \"\"\"Test the constructor class.\"\"\"         create_point_sources()         _test_source_constructor(create_point_sources, create_spectrum)         create_point_sources(flux=None)         with pytest.raises(ValueError):             create_point_sources(flux=np.ones((2, 2)))              def test_normalise(self, create_point_sources):         \"\"\"Test the normalise method.\"\"\"         _test_normalise(create_point_sources)          def test_model(self, create_point_sources, create_angular_optics):         \"\"\"Test the model method.\"\"\"         _test_model(create_point_sources, create_angular_optics) In\u00a0[\u00a0]: Copied! <pre>class TestResolvedSource():\n\"\"\"Tests the ResolvedSource class.\"\"\"\n\n    def test_constructor(self, create_resolved_source, create_spectrum):\n\"\"\"Test the constructor class.\"\"\"\n        create_resolved_source()\n        _test_source_constructor(create_resolved_source, create_spectrum)\n        _test_resolved_source_constructor(create_resolved_source)\n        \n    def test_normalise(self, create_resolved_source):\n\"\"\"Test the normalise method.\"\"\"\n        _test_normalise(create_resolved_source)\n    \n    def test_model(self, create_resolved_source, create_angular_optics):\n\"\"\"Test the model method.\"\"\"\n        _test_model(create_resolved_source, create_angular_optics)\n</pre> class TestResolvedSource():     \"\"\"Tests the ResolvedSource class.\"\"\"      def test_constructor(self, create_resolved_source, create_spectrum):         \"\"\"Test the constructor class.\"\"\"         create_resolved_source()         _test_source_constructor(create_resolved_source, create_spectrum)         _test_resolved_source_constructor(create_resolved_source)              def test_normalise(self, create_resolved_source):         \"\"\"Test the normalise method.\"\"\"         _test_normalise(create_resolved_source)          def test_model(self, create_resolved_source, create_angular_optics):         \"\"\"Test the model method.\"\"\"         _test_model(create_resolved_source, create_angular_optics) In\u00a0[\u00a0]: Copied! <pre>class TestBinarySource():\n\"\"\"Tests the BinarySource class.\"\"\"\n\n    def test_constructor(self, create_binary_source, create_spectrum):\n\"\"\"Test the constructor class.\"\"\"\n        create_binary_source()\n        _test_source_constructor(create_binary_source, create_spectrum)\n        _test_rel_pos_constructor(create_binary_source)\n        _test_rel_flux_constructor(create_binary_source)\n        \n    def test_normalise(self, create_binary_source):\n\"\"\"Test the normalise method.\"\"\"\n        _test_normalise(create_binary_source)\n    \n    def test_model(self, create_binary_source, create_angular_optics):\n\"\"\"Test the model method.\"\"\"\n        _test_model(create_binary_source, create_angular_optics)\n</pre> class TestBinarySource():     \"\"\"Tests the BinarySource class.\"\"\"      def test_constructor(self, create_binary_source, create_spectrum):         \"\"\"Test the constructor class.\"\"\"         create_binary_source()         _test_source_constructor(create_binary_source, create_spectrum)         _test_rel_pos_constructor(create_binary_source)         _test_rel_flux_constructor(create_binary_source)              def test_normalise(self, create_binary_source):         \"\"\"Test the normalise method.\"\"\"         _test_normalise(create_binary_source)          def test_model(self, create_binary_source, create_angular_optics):         \"\"\"Test the model method.\"\"\"         _test_model(create_binary_source, create_angular_optics) In\u00a0[\u00a0]: Copied! <pre>class TestPointResolvedSource():\n\"\"\"Tests the PointResolvedSource class.\"\"\"\n\n    def test_constructor(self, create_point_resolved_source, create_spectrum):\n\"\"\"Test the constructor class.\"\"\"\n        create_point_resolved_source()\n        _test_source_constructor(create_point_resolved_source, create_spectrum)\n        _test_rel_flux_constructor(create_point_resolved_source)\n        _test_resolved_source_constructor(create_point_resolved_source)\n    \n    def test_normalise(self, create_point_resolved_source):\n\"\"\"Test the normalise method.\"\"\"\n        _test_normalise(create_point_resolved_source)\n    \n    def test_model(self, create_point_resolved_source, create_angular_optics):\n\"\"\"Test the model method.\"\"\"\n        _test_model(create_point_resolved_source, create_angular_optics)\n</pre> class TestPointResolvedSource():     \"\"\"Tests the PointResolvedSource class.\"\"\"      def test_constructor(self, create_point_resolved_source, create_spectrum):         \"\"\"Test the constructor class.\"\"\"         create_point_resolved_source()         _test_source_constructor(create_point_resolved_source, create_spectrum)         _test_rel_flux_constructor(create_point_resolved_source)         _test_resolved_source_constructor(create_point_resolved_source)          def test_normalise(self, create_point_resolved_source):         \"\"\"Test the normalise method.\"\"\"         _test_normalise(create_point_resolved_source)          def test_model(self, create_point_resolved_source, create_angular_optics):         \"\"\"Test the model method.\"\"\"         _test_model(create_point_resolved_source, create_angular_optics)"},{"location":"tests/test_spectra/","title":"Test spectra","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config, Array\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config, Array config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>def _test_normalise(constructor):\n\"\"\"Tests the normalise method.\"\"\"\n    constructor().normalise()\n</pre> def _test_normalise(constructor):     \"\"\"Tests the normalise method.\"\"\"     constructor().normalise() In\u00a0[\u00a0]: Copied! <pre>class TestSpectrum():\n\"\"\"Tests the Spectrum class.\"\"\"\n\n    def test_constructor(self, create_spectrum):\n\"\"\"Tests the constructor.\"\"\"\n        create_spectrum()\n        create_spectrum(weights=None)\n        create_spectrum(wavelengths=[1, 2, 3], weights=[[1, 2, 3], [1, 2, 3]])\n        with pytest.raises(ValueError):\n            create_spectrum(wavelengths=[1], weights=[[1, 2], [1, 2]])\n        with pytest.raises(ValueError):\n            create_spectrum(wavelengths=[1], weights=[1, 2])\n\n    def test_normalise(self, create_spectrum):\n\"\"\"Tests the normalise method.\"\"\"\n        _test_normalise(create_spectrum)\n</pre> class TestSpectrum():     \"\"\"Tests the Spectrum class.\"\"\"      def test_constructor(self, create_spectrum):         \"\"\"Tests the constructor.\"\"\"         create_spectrum()         create_spectrum(weights=None)         create_spectrum(wavelengths=[1, 2, 3], weights=[[1, 2, 3], [1, 2, 3]])         with pytest.raises(ValueError):             create_spectrum(wavelengths=[1], weights=[[1, 2], [1, 2]])         with pytest.raises(ValueError):             create_spectrum(wavelengths=[1], weights=[1, 2])      def test_normalise(self, create_spectrum):         \"\"\"Tests the normalise method.\"\"\"         _test_normalise(create_spectrum) In\u00a0[\u00a0]: Copied! <pre>class TestPolySpectrum():\n\"\"\"Tests the PolySpectrum class.\"\"\"\n\n    def test_constructor(self, create_poly_spectrum):\n\"\"\"Tests the constructor.\"\"\"\n        create_poly_spectrum()\n        with pytest.raises(ValueError):\n            create_poly_spectrum(coefficients=1)\n    \n    def test_normalise(self, create_poly_spectrum):\n\"\"\"Tests the normalise method.\"\"\"\n        _test_normalise(create_poly_spectrum)\n    \n    def test_weights(self, create_poly_spectrum):\n\"\"\"Tests the weights property.\"\"\"\n        create_poly_spectrum().weights\n</pre> class TestPolySpectrum():     \"\"\"Tests the PolySpectrum class.\"\"\"      def test_constructor(self, create_poly_spectrum):         \"\"\"Tests the constructor.\"\"\"         create_poly_spectrum()         with pytest.raises(ValueError):             create_poly_spectrum(coefficients=1)          def test_normalise(self, create_poly_spectrum):         \"\"\"Tests the normalise method.\"\"\"         _test_normalise(create_poly_spectrum)          def test_weights(self, create_poly_spectrum):         \"\"\"Tests the weights property.\"\"\"         create_poly_spectrum().weights"},{"location":"tests/test_utils/","title":"Test utils","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import config\nimport pytest\nfrom dLux.utils import (\n    coordinates,\n    helpers,\n    interpolation,\n    math,\n    optics,\n    units,\n)\n</pre> import jax.numpy as np from jax import config import pytest from dLux.utils import (     coordinates,     helpers,     interpolation,     math,     optics,     units, ) In\u00a0[\u00a0]: Copied! <pre>config.update(\"jax_debug_nans\", True)\n</pre> config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\ncoordinates.py\n\"\"\"\ndef test_polar_to_cart():\n\"\"\"Tests the polar_to_cart function.\"\"\"\n    assert (coordinates.polar_to_cart([1, 0]) == np.array([1, 0])).all()\n</pre> \"\"\" coordinates.py \"\"\" def test_polar_to_cart():     \"\"\"Tests the polar_to_cart function.\"\"\"     assert (coordinates.polar_to_cart([1, 0]) == np.array([1, 0])).all() In\u00a0[\u00a0]: Copied! <pre>def test_cart_to_polar():\n\"\"\"Tests the cart_to_polar function.\"\"\"\n    assert (coordinates.cart_to_polar([1, 0]) == np.array([1, 0])).all()\n</pre> def test_cart_to_polar():     \"\"\"Tests the cart_to_polar function.\"\"\"     assert (coordinates.cart_to_polar([1, 0]) == np.array([1, 0])).all() In\u00a0[\u00a0]: Copied! <pre>def test_pixel_coordinates():\n\"\"\"Tests the pixel_coordinates function.\"\"\"\n\n    # 1d tests\n    coordinates.pixel_coordinates(16, 1, 0.)\n\n    with pytest.raises(TypeError):\n        coordinates.pixel_coordinates(16, 1, 'Not an offset')\n\n    with pytest.raises(TypeError):\n        coordinates.pixel_coordinates(16, 'not a pixel scale')\n\n    coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0))\n\n    # 2d tests\n    coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0))\n    coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0), polar=True)\n\n    with pytest.raises(TypeError):\n        coordinates.pixel_coordinates((16, 16), (1, 1), 'Not an offset')\n    \n    with pytest.raises(TypeError):\n        coordinates.pixel_coordinates((16, 16), 'not a pixel scale', (0, 0))\n\n    # Others\n    coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0), indexing='ij', \n        polar=True)\n    with pytest.raises(ValueError):\n        coordinates.pixel_coordinates(16, 1, 0., indexing='ab')\n    with pytest.raises(ValueError):\n        coordinates.pixel_coordinates(16, 1, 0., polar=True)\n</pre> def test_pixel_coordinates():     \"\"\"Tests the pixel_coordinates function.\"\"\"      # 1d tests     coordinates.pixel_coordinates(16, 1, 0.)      with pytest.raises(TypeError):         coordinates.pixel_coordinates(16, 1, 'Not an offset')      with pytest.raises(TypeError):         coordinates.pixel_coordinates(16, 'not a pixel scale')      coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0))      # 2d tests     coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0))     coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0), polar=True)      with pytest.raises(TypeError):         coordinates.pixel_coordinates((16, 16), (1, 1), 'Not an offset')          with pytest.raises(TypeError):         coordinates.pixel_coordinates((16, 16), 'not a pixel scale', (0, 0))      # Others     coordinates.pixel_coordinates((16, 16), (1, 1), (0, 0), indexing='ij',          polar=True)     with pytest.raises(ValueError):         coordinates.pixel_coordinates(16, 1, 0., indexing='ab')     with pytest.raises(ValueError):         coordinates.pixel_coordinates(16, 1, 0., polar=True) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nhelpers.py\n\"\"\"\ndef test_list_to_dict():\n\"\"\"Tests the list_to_dict function.\"\"\"\n    inputs = [1, 2, (3, \"name\")]\n    helpers.list_to_dictionary(inputs, ordered=True)\n\n    with pytest.raises(ValueError):\n        inputs = [1, 2, (3, \"name with spaces\")]\n        helpers.list_to_dictionary(inputs, ordered=True)\n</pre> \"\"\" helpers.py \"\"\" def test_list_to_dict():     \"\"\"Tests the list_to_dict function.\"\"\"     inputs = [1, 2, (3, \"name\")]     helpers.list_to_dictionary(inputs, ordered=True)      with pytest.raises(ValueError):         inputs = [1, 2, (3, \"name with spaces\")]         helpers.list_to_dictionary(inputs, ordered=True) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\noptics.py\n\"\"\"\ndef test_phase_to_opd():\n\"\"\"Tests the phase_to_opd function.\"\"\"\n    optics.phase_to_opd(1, 1e-6)\n</pre> \"\"\" optics.py \"\"\" def test_phase_to_opd():     \"\"\"Tests the phase_to_opd function.\"\"\"     optics.phase_to_opd(1, 1e-6) In\u00a0[\u00a0]: Copied! <pre>def test_opd_to_phase():\n\"\"\"Tests the opd_to_phase function.\"\"\"\n    optics.opd_to_phase(1, 1e-6)\n</pre> def test_opd_to_phase():     \"\"\"Tests the opd_to_phase function.\"\"\"     optics.opd_to_phase(1, 1e-6) In\u00a0[\u00a0]: Copied! <pre>def test_get_fringe_size():\n\"\"\"Tests the get_fringe_size function.\"\"\"\n    optics.get_fringe_size(1e-6, 1)\n</pre> def test_get_fringe_size():     \"\"\"Tests the get_fringe_size function.\"\"\"     optics.get_fringe_size(1e-6, 1) In\u00a0[\u00a0]: Copied! <pre>def test_get_pixels_per_fringe():\n\"\"\"Tests the get_pixels_per_fringe function.\"\"\"\n    optics.get_pixels_per_fringe(1e-6, 1, 1)\n    optics.get_pixels_per_fringe(1e-6, 1, 1, 1)\n</pre> def test_get_pixels_per_fringe():     \"\"\"Tests the get_pixels_per_fringe function.\"\"\"     optics.get_pixels_per_fringe(1e-6, 1, 1)     optics.get_pixels_per_fringe(1e-6, 1, 1, 1) In\u00a0[\u00a0]: Copied! <pre>def test_get_pixel_scale():\n\"\"\"Tests the get_pixel_scale function.\"\"\"\n    optics.get_pixel_scale(1e-6, 1, 1)\n    optics.get_pixel_scale(1e-6, 1, 1, 1)\n</pre> def test_get_pixel_scale():     \"\"\"Tests the get_pixel_scale function.\"\"\"     optics.get_pixel_scale(1e-6, 1, 1)     optics.get_pixel_scale(1e-6, 1, 1, 1) In\u00a0[\u00a0]: Copied! <pre>def test_get_airy_pixel_scale():\n\"\"\"Tests the get_airy_pixel_scale function.\"\"\"\n    optics.get_airy_pixel_scale(1e-6, 1, 1)\n    optics.get_airy_pixel_scale(1e-6, 1, 1, 1)\n</pre> def test_get_airy_pixel_scale():     \"\"\"Tests the get_airy_pixel_scale function.\"\"\"     optics.get_airy_pixel_scale(1e-6, 1, 1)     optics.get_airy_pixel_scale(1e-6, 1, 1, 1) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nunits.py\n\"\"\"\ndef test_rad_to_deg():\n\"\"\"Tests the rad_to_deg function.\"\"\"\n    units.rad_to_deg(1)\n</pre> \"\"\" units.py \"\"\" def test_rad_to_deg():     \"\"\"Tests the rad_to_deg function.\"\"\"     units.rad_to_deg(1) In\u00a0[\u00a0]: Copied! <pre>def test_rad_to_arcmin():\n\"\"\"Tests the rad_to_arcmin function.\"\"\"\n    units.rad_to_arcmin(1)\n</pre> def test_rad_to_arcmin():     \"\"\"Tests the rad_to_arcmin function.\"\"\"     units.rad_to_arcmin(1) In\u00a0[\u00a0]: Copied! <pre>def test_rad_to_arcsec():\n\"\"\"Tests the rad_to_arcsec function.\"\"\"\n    units.rad_to_arcsec(1)\n</pre> def test_rad_to_arcsec():     \"\"\"Tests the rad_to_arcsec function.\"\"\"     units.rad_to_arcsec(1) In\u00a0[\u00a0]: Copied! <pre>def test_deg_to_rad():\n\"\"\"Tests the deg_to_rad function.\"\"\"\n    units.deg_to_rad(1)\n</pre> def test_deg_to_rad():     \"\"\"Tests the deg_to_rad function.\"\"\"     units.deg_to_rad(1) In\u00a0[\u00a0]: Copied! <pre>def test_deg_to_arcsec():\n\"\"\"Tests the deg_to_arcsec function.\"\"\"\n    units.deg_to_arcsec(1)\n</pre> def test_deg_to_arcsec():     \"\"\"Tests the deg_to_arcsec function.\"\"\"     units.deg_to_arcsec(1) In\u00a0[\u00a0]: Copied! <pre>def test_deg_to_arcmin():\n\"\"\"Tests the deg_to_arcmin function.\"\"\"\n    units.deg_to_arcmin(1)\n</pre> def test_deg_to_arcmin():     \"\"\"Tests the deg_to_arcmin function.\"\"\"     units.deg_to_arcmin(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcmin_to_rad():\n\"\"\"Tests the arcmin_to_rad function.\"\"\"\n    units.arcmin_to_rad(1)\n</pre> def test_arcmin_to_rad():     \"\"\"Tests the arcmin_to_rad function.\"\"\"     units.arcmin_to_rad(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcmin_to_deg():\n\"\"\"Tests the arcmin_to_deg function.\"\"\"\n    units.arcmin_to_deg(1)\n</pre> def test_arcmin_to_deg():     \"\"\"Tests the arcmin_to_deg function.\"\"\"     units.arcmin_to_deg(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcmin_to_arcsec():\n\"\"\"Tests the arcmin_to_arcsec function.\"\"\"\n    units.arcmin_to_arcsec(1)\n</pre> def test_arcmin_to_arcsec():     \"\"\"Tests the arcmin_to_arcsec function.\"\"\"     units.arcmin_to_arcsec(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcsec_to_rad():\n\"\"\"Tests the arcsec_to_rad function.\"\"\"\n    units.arcsec_to_rad(1)\n</pre> def test_arcsec_to_rad():     \"\"\"Tests the arcsec_to_rad function.\"\"\"     units.arcsec_to_rad(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcsec_to_deg():\n\"\"\"Tests the arcsec_to_deg function.\"\"\"\n    units.arcsec_to_deg(1)\n</pre> def test_arcsec_to_deg():     \"\"\"Tests the arcsec_to_deg function.\"\"\"     units.arcsec_to_deg(1) In\u00a0[\u00a0]: Copied! <pre>def test_arcsec_to_arcmin():\n\"\"\"Tests the arcsec_to_arcmin function.\"\"\"\n    units.arcsec_to_arcmin(1)\n</pre> def test_arcsec_to_arcmin():     \"\"\"Tests the arcsec_to_arcmin function.\"\"\"     units.arcsec_to_arcmin(1) In\u00a0[\u00a0]: Copied! <pre>\"\"\"\ninterpolation.py\n\"\"\"\ndef test_scale_array():\n\"\"\"Tests the scale_array function.\"\"\"\n    interpolation.scale_array(np.ones((16, 16)), 8, 1)\n</pre> \"\"\" interpolation.py \"\"\" def test_scale_array():     \"\"\"Tests the scale_array function.\"\"\"     interpolation.scale_array(np.ones((16, 16)), 8, 1) In\u00a0[\u00a0]: Copied! <pre>def test_downsample():\n\"\"\"Tests the downsample function.\"\"\"\n    interpolation.downsample(np.ones((16, 16)), 2)\n    interpolation.downsample(np.ones((16, 16)), 2, 'sum')\n    with pytest.raises(ValueError):\n        interpolation.downsample(np.ones((16, 16)), 2, 'other')\n</pre> def test_downsample():     \"\"\"Tests the downsample function.\"\"\"     interpolation.downsample(np.ones((16, 16)), 2)     interpolation.downsample(np.ones((16, 16)), 2, 'sum')     with pytest.raises(ValueError):         interpolation.downsample(np.ones((16, 16)), 2, 'other')"},{"location":"tests/test_wavefronts/","title":"Test wavefronts","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import config, Array\nimport pytest\nimport dLux\n</pre> import jax.numpy as np from jax import config, Array import pytest import dLux In\u00a0[\u00a0]: Copied! <pre>config.update(\"jax_debug_nans\", True)\n</pre> config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestWavefront():\n\"\"\"Test the Wavefront class.\"\"\"\n\n    def test_constructor(self, create_wavefront):\n\"\"\"Tests the constructor.\"\"\"\n        # Test constructor\n        create_wavefront()\n\n        # Test 1d array\n        with pytest.raises(ValueError):\n            create_wavefront(wavelength=[1e3])\n        \n        with pytest.raises(ValueError):\n            create_wavefront(diameter=np.ones(2))\n\n    def test_npixels(self, create_wavefront):\n\"\"\"Tests the npixels property.\"\"\"\n        wf = create_wavefront()\n        assert wf.npixels == wf.amplitude.shape[-1]\n\n    def test_diameter(self, create_wavefront):\n\"\"\"Tests the diameter property.\"\"\"\n        wf = create_wavefront()\n        assert wf.diameter == wf.npixels * wf.pixel_scale\n\n    def test_real(self, create_wavefront):\n\"\"\"Tests the real property.\"\"\"\n        wf = create_wavefront()\n        assert (wf.real == wf.amplitude * np.cos(wf.phase)).all()\n\n    def test_imaginary(self, create_wavefront):\n\"\"\"Tests the imaginary property.\"\"\"\n        wf = create_wavefront()\n        assert (wf.imaginary == wf.amplitude * np.sin(wf.phase)).all()\n\n    def test_phasor(self, create_wavefront):\n\"\"\"Tests the phasor property.\"\"\"\n        wf = create_wavefront()\n        assert (wf.phasor == wf.amplitude * np.exp(1j*wf.phase)).all()\n\n    def test_psf(self, create_wavefront):\n\"\"\"Tests the psf property.\"\"\"\n        wf = create_wavefront()\n        assert (wf.psf == wf.amplitude**2).all()\n\n    def test_coordinates(self, create_wavefront):\n\"\"\"Tests the coordinates property.\"\"\"\n        wf = create_wavefront()\n        wf.coordinates\n    \n    def test_add_phase(self, create_wavefront):\n\"\"\"Tests the add_phase method.\"\"\"\n        wf = create_wavefront()\n        wf.add_phase(np.ones(wf.npixels))\n        wf.add_phase(None)\n\n    def test_tilt(self, create_wavefront):\n\"\"\"Tests the tilt method.\"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(ValueError):\n            wf.tilt(\"some string\")\n\n        # Test wrong shapes\n        with pytest.raises(ValueError):\n            wf.tilt(np.ones(1))\n\n        # Test wrong shapes\n        with pytest.raises(ValueError):\n            wf.tilt(np.ones(3))\n\n        # Test basic behaviour\n        wf.tilt(np.ones(2))\n\n    def test_normalise(self, create_wavefront):\n\"\"\"Tests the normalise method.\"\"\"\n        wf = create_wavefront()\n        new_wf = wf.normalise()\n        assert np.sum(new_wf.amplitude**2) == 1.\n\n    def test_flip(self, create_wavefront):\n\"\"\"Tests the flip method.\"\"\"\n        wf = create_wavefront()\n        wf = wf.flip(0)\n        wf = wf.flip(1)\n        wf = wf.flip((0, 1))\n\n    def test_interpolate(self, create_wavefront):\n\"\"\"Tests the interpolate method.\"\"\"\n        k = 2\n        wf = create_wavefront()\n        wf = wf.scale_to(wf.npixels//k, k * wf.pixel_scale)\n        wf = wf.scale_to(wf.npixels//k, k * wf.pixel_scale, complex=True)\n\n    def test_rotate(self, create_wavefront):\n\"\"\"Tests the rotate method.\"\"\"\n        wf = create_wavefront()\n        wf = dLux.CircularAperture(1.)(wf)\n        flipped_amplitude = np.flip(wf.amplitude, axis=(-1, -2))\n        flipped_phase = np.flip(wf.phase, axis=(-1, -2))\n\n        new_wf = wf.rotate(np.pi, order=1)\n        assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)\n        assert np.allclose(new_wf.phase, flipped_phase)\n\n        new_wf = wf.rotate(np.pi, complex=True, order=1)\n\n        assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)\n        # Add small remainer to fix 0-pi instability\n        assert np.allclose((new_wf.phase+1e-6)%np.pi, flipped_phase, atol=1e-5)\n\n    def test_pad_to(self, create_wavefront):\n\"\"\"Tests the pad_to method.\"\"\"\n        even_wf = create_wavefront(npixels=16)\n        odd_wf = create_wavefront(npixels=15)\n        \n        # Smaller value\n        with pytest.raises(ValueError):\n            even_wf.pad_to(14)\n\n        # even -&gt; odd\n        with pytest.raises(ValueError):\n            even_wf.pad_to(17)\n\n        # odd -&gt; even\n        with pytest.raises(ValueError):\n            odd_wf.pad_to(16)\n\n        assert even_wf.pad_to(20).npixels == 20\n\n    def test_crop_to(self, create_wavefront):\n\"\"\"Tests the crop_to method.\"\"\"\n        even_wf = create_wavefront(npixels=16)\n        odd_wf = create_wavefront(npixels=15)\n\n        # Smaller value\n        with pytest.raises(ValueError):\n            even_wf.crop_to(18)\n\n        # even -&gt; odd\n        with pytest.raises(ValueError):\n            even_wf.crop_to(15)\n\n        # odd -&gt; even\n        with pytest.raises(ValueError):\n            odd_wf.crop_to(14)\n\n        assert even_wf.crop_to(12).npixels == 12\n\n    def test_magic(self, create_wavefront, create_optic):\n\"\"\"Tests the magic methods.\"\"\"\n        wf = create_wavefront()\n        wf += create_optic()\n        \n        wf *= None\n        wf *= wf.phasor\n\n        with pytest.raises(TypeError):\n            create_wavefront() + \"a string\"\n        \n        with pytest.raises(TypeError):\n            create_wavefront() * 'a string'\n\n    def test_FFT(self, create_wavefront):\n\"\"\"Tests the FFT method.\"\"\"\n        wf = create_wavefront()\n\n        with pytest.raises(ValueError):\n            wf = wf.set(\"units\", \"Angular\")\n            wf.FFT(focal_length=1.)\n\n        with pytest.raises(ValueError):\n            wf.IFFT()\n        \n        with pytest.raises(ValueError):\n            wf = wf.set(\"plane\", \"Focal\")\n            wf.FFT()\n    \n    def test_MFT(self, create_wavefront):\n\"\"\"Tests the MFT method.\"\"\"\n        wf = create_wavefront()\n\n        with pytest.raises(ValueError):\n            wf = wf.set(\"units\", \"Angular\")\n            wf.MFT(16, 1/16, focal_length=1.)\n\n        with pytest.raises(ValueError):\n            wf.IMFT(16, 1/16, )\n        \n        with pytest.raises(ValueError):\n            wf = wf.set(\"plane\", \"Focal\")\n            wf.MFT(16, 1/16)\n</pre> class TestWavefront():     \"\"\"Test the Wavefront class.\"\"\"      def test_constructor(self, create_wavefront):         \"\"\"Tests the constructor.\"\"\"         # Test constructor         create_wavefront()          # Test 1d array         with pytest.raises(ValueError):             create_wavefront(wavelength=[1e3])                  with pytest.raises(ValueError):             create_wavefront(diameter=np.ones(2))      def test_npixels(self, create_wavefront):         \"\"\"Tests the npixels property.\"\"\"         wf = create_wavefront()         assert wf.npixels == wf.amplitude.shape[-1]      def test_diameter(self, create_wavefront):         \"\"\"Tests the diameter property.\"\"\"         wf = create_wavefront()         assert wf.diameter == wf.npixels * wf.pixel_scale      def test_real(self, create_wavefront):         \"\"\"Tests the real property.\"\"\"         wf = create_wavefront()         assert (wf.real == wf.amplitude * np.cos(wf.phase)).all()      def test_imaginary(self, create_wavefront):         \"\"\"Tests the imaginary property.\"\"\"         wf = create_wavefront()         assert (wf.imaginary == wf.amplitude * np.sin(wf.phase)).all()      def test_phasor(self, create_wavefront):         \"\"\"Tests the phasor property.\"\"\"         wf = create_wavefront()         assert (wf.phasor == wf.amplitude * np.exp(1j*wf.phase)).all()      def test_psf(self, create_wavefront):         \"\"\"Tests the psf property.\"\"\"         wf = create_wavefront()         assert (wf.psf == wf.amplitude**2).all()      def test_coordinates(self, create_wavefront):         \"\"\"Tests the coordinates property.\"\"\"         wf = create_wavefront()         wf.coordinates          def test_add_phase(self, create_wavefront):         \"\"\"Tests the add_phase method.\"\"\"         wf = create_wavefront()         wf.add_phase(np.ones(wf.npixels))         wf.add_phase(None)      def test_tilt(self, create_wavefront):         \"\"\"Tests the tilt method.\"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(ValueError):             wf.tilt(\"some string\")          # Test wrong shapes         with pytest.raises(ValueError):             wf.tilt(np.ones(1))          # Test wrong shapes         with pytest.raises(ValueError):             wf.tilt(np.ones(3))          # Test basic behaviour         wf.tilt(np.ones(2))      def test_normalise(self, create_wavefront):         \"\"\"Tests the normalise method.\"\"\"         wf = create_wavefront()         new_wf = wf.normalise()         assert np.sum(new_wf.amplitude**2) == 1.      def test_flip(self, create_wavefront):         \"\"\"Tests the flip method.\"\"\"         wf = create_wavefront()         wf = wf.flip(0)         wf = wf.flip(1)         wf = wf.flip((0, 1))      def test_interpolate(self, create_wavefront):         \"\"\"Tests the interpolate method.\"\"\"         k = 2         wf = create_wavefront()         wf = wf.scale_to(wf.npixels//k, k * wf.pixel_scale)         wf = wf.scale_to(wf.npixels//k, k * wf.pixel_scale, complex=True)      def test_rotate(self, create_wavefront):         \"\"\"Tests the rotate method.\"\"\"         wf = create_wavefront()         wf = dLux.CircularAperture(1.)(wf)         flipped_amplitude = np.flip(wf.amplitude, axis=(-1, -2))         flipped_phase = np.flip(wf.phase, axis=(-1, -2))          new_wf = wf.rotate(np.pi, order=1)         assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)         assert np.allclose(new_wf.phase, flipped_phase)          new_wf = wf.rotate(np.pi, complex=True, order=1)          assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)         # Add small remainer to fix 0-pi instability         assert np.allclose((new_wf.phase+1e-6)%np.pi, flipped_phase, atol=1e-5)      def test_pad_to(self, create_wavefront):         \"\"\"Tests the pad_to method.\"\"\"         even_wf = create_wavefront(npixels=16)         odd_wf = create_wavefront(npixels=15)                  # Smaller value         with pytest.raises(ValueError):             even_wf.pad_to(14)          # even -&gt; odd         with pytest.raises(ValueError):             even_wf.pad_to(17)          # odd -&gt; even         with pytest.raises(ValueError):             odd_wf.pad_to(16)          assert even_wf.pad_to(20).npixels == 20      def test_crop_to(self, create_wavefront):         \"\"\"Tests the crop_to method.\"\"\"         even_wf = create_wavefront(npixels=16)         odd_wf = create_wavefront(npixels=15)          # Smaller value         with pytest.raises(ValueError):             even_wf.crop_to(18)          # even -&gt; odd         with pytest.raises(ValueError):             even_wf.crop_to(15)          # odd -&gt; even         with pytest.raises(ValueError):             odd_wf.crop_to(14)          assert even_wf.crop_to(12).npixels == 12      def test_magic(self, create_wavefront, create_optic):         \"\"\"Tests the magic methods.\"\"\"         wf = create_wavefront()         wf += create_optic()                  wf *= None         wf *= wf.phasor          with pytest.raises(TypeError):             create_wavefront() + \"a string\"                  with pytest.raises(TypeError):             create_wavefront() * 'a string'      def test_FFT(self, create_wavefront):         \"\"\"Tests the FFT method.\"\"\"         wf = create_wavefront()          with pytest.raises(ValueError):             wf = wf.set(\"units\", \"Angular\")             wf.FFT(focal_length=1.)          with pytest.raises(ValueError):             wf.IFFT()                  with pytest.raises(ValueError):             wf = wf.set(\"plane\", \"Focal\")             wf.FFT()          def test_MFT(self, create_wavefront):         \"\"\"Tests the MFT method.\"\"\"         wf = create_wavefront()          with pytest.raises(ValueError):             wf = wf.set(\"units\", \"Angular\")             wf.MFT(16, 1/16, focal_length=1.)          with pytest.raises(ValueError):             wf.IMFT(16, 1/16, )                  with pytest.raises(ValueError):             wf = wf.set(\"plane\", \"Focal\")             wf.MFT(16, 1/16) In\u00a0[\u00a0]: Copied! <pre>class TestFresnelWavefront():\n\"\"\"Test the FresnelWavefront class.\"\"\"\n\n    def test_constructor(self, create_wavefront):\n\"\"\"Tests the constructor.\"\"\"\n        # Test constructor\n        create_wavefront()\n\n        # Test 1d array\n        with pytest.raises(ValueError):\n            create_wavefront(wavelength=[1e3])\n        \n        with pytest.raises(ValueError):\n            create_wavefront(diameter=np.ones(2))\n\n    def test_fresnel_prop(self, create_fresnel_wavefront):\n\"\"\"Tests the fresnel_prop method.\"\"\"\n        wf = create_fresnel_wavefront()\n        wf.fresnel_prop(16, 1/16, 1e2, 1e-2)\n\n        with pytest.raises(ValueError):\n            wf = wf.set('plane', 'not Pupil')\n            wf.fresnel_prop(16, 1/16, 1e2, 1e-2)\n</pre> class TestFresnelWavefront():     \"\"\"Test the FresnelWavefront class.\"\"\"      def test_constructor(self, create_wavefront):         \"\"\"Tests the constructor.\"\"\"         # Test constructor         create_wavefront()          # Test 1d array         with pytest.raises(ValueError):             create_wavefront(wavelength=[1e3])                  with pytest.raises(ValueError):             create_wavefront(diameter=np.ones(2))      def test_fresnel_prop(self, create_fresnel_wavefront):         \"\"\"Tests the fresnel_prop method.\"\"\"         wf = create_fresnel_wavefront()         wf.fresnel_prop(16, 1/16, 1e2, 1e-2)          with pytest.raises(ValueError):             wf = wf.set('plane', 'not Pupil')             wf.fresnel_prop(16, 1/16, 1e2, 1e-2)"}]}