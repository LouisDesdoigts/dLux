{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"FAQ & Troubleshooting","text":"<p>We are yet to receive enough feedback to create a FAQ -- \u2202Lux must be flawless!</p> <p>If you do have any questions that aren't addressed in the documentation, please don't hesitate to email me!</p>"},{"location":"generate_mds/","title":"Generate mds","text":"In\u00a0[\u00a0]: Copied! <pre>import os\n</pre> import os In\u00a0[\u00a0]: Copied! <pre># Set the directory containing the .ipynb files\nnotebook_dir = \"tutorials/\"\n</pre> # Set the directory containing the .ipynb files notebook_dir = \"tutorials/\" In\u00a0[\u00a0]: Copied! <pre># Recursively find all .ipynb files in the directory\nnotebooks = []\nfor root, dirs, files in os.walk(notebook_dir):\n    for file in files:\n        if file.endswith(\".ipynb\"):\n            notebooks.append(os.path.join(root, file))\n</pre> # Recursively find all .ipynb files in the directory notebooks = [] for root, dirs, files in os.walk(notebook_dir):     for file in files:         if file.endswith(\".ipynb\"):             notebooks.append(os.path.join(root, file)) In\u00a0[\u00a0]: Copied! <pre># Convert each notebook to .md using jupyter nbconvert\nfor notebook in notebooks:\n    md_path = os.path.join(\n        os.path.dirname(os.path.dirname(notebook)),\n        os.path.splitext(os.path.basename(notebook))[0] + \".md\",\n    )\n    output_dir = os.path.dirname(os.path.dirname(notebook))\n    os.system(\n        (\n            f\"jupyter nbconvert --to Markdown {notebook} --output-dir {output_dir}\"\n            f\" --output {os.path.basename(md_path)}\"\n        )\n    )\n</pre> # Convert each notebook to .md using jupyter nbconvert for notebook in notebooks:     md_path = os.path.join(         os.path.dirname(os.path.dirname(notebook)),         os.path.splitext(os.path.basename(notebook))[0] + \".md\",     )     output_dir = os.path.dirname(os.path.dirname(notebook))     os.system(         (             f\"jupyter nbconvert --to Markdown {notebook} --output-dir {output_dir}\"             f\" --output {os.path.basename(md_path)}\"         )     )"},{"location":"generate_umls/","title":"Generate for whole package","text":"In\u00a0[\u00a0]: Copied! <pre>import subprocess\nimport dLux as dl\nfrom jax.tree_util import tree_flatten\nfrom selenium import webdriver\nimport os\n</pre> import subprocess import dLux as dl from jax.tree_util import tree_flatten from selenium import webdriver import os In\u00a0[\u00a0]: Copied! <pre>def get_parent_depth(cls):\n    if cls.__bases__:\n        return max(get_parent_depth(base) for base in cls.__bases__) + 1\n    else:\n        return 0\n</pre> def get_parent_depth(cls):     if cls.__bases__:         return max(get_parent_depth(base) for base in cls.__bases__) + 1     else:         return 0 In\u00a0[\u00a0]: Copied! <pre>def save_to_png(html_file, image_file):\n    # Set the options for the conversion\n    options = webdriver.ChromeOptions()\n    options.add_argument(\"headless\")\n    options.add_argument(\"disable-gpu\")\n    options.add_argument(\"no-sandbox\")\n\n    # Create a new Chrome driver\n    driver = webdriver.Chrome(options=options)\n\n    # Load the HTML file in the driver\n    driver.get(f\"file://{html_file}\")\n\n    # # Scroll to the bottom of the page\n    height = driver.execute_script(\n        \"return Math.max( document.body.scrollHeight, document.body.offsetHeight, \"\n        \"document.documentElement.clientHeight, document.documentElement.scrollHeight, \"\n        \"document.documentElement.offsetHeight );\"\n    )\n\n    # Set the size of the window to the height of the page\n    driver.set_window_size(height, height)\n\n    # Take a screenshot of the driver and save it to an image file\n    driver.save_screenshot(image_file)\n\n    # Quit the driver\n    driver.quit()\n</pre> def save_to_png(html_file, image_file):     # Set the options for the conversion     options = webdriver.ChromeOptions()     options.add_argument(\"headless\")     options.add_argument(\"disable-gpu\")     options.add_argument(\"no-sandbox\")      # Create a new Chrome driver     driver = webdriver.Chrome(options=options)      # Load the HTML file in the driver     driver.get(f\"file://{html_file}\")      # # Scroll to the bottom of the page     height = driver.execute_script(         \"return Math.max( document.body.scrollHeight, document.body.offsetHeight, \"         \"document.documentElement.clientHeight, document.documentElement.scrollHeight, \"         \"document.documentElement.offsetHeight );\"     )      # Set the size of the window to the height of the page     driver.set_window_size(height, height)      # Take a screenshot of the driver and save it to an image file     driver.save_screenshot(image_file)      # Quit the driver     driver.quit() In\u00a0[\u00a0]: Copied! <pre>classes = tree_flatten(dl.__all__)[0]\ndl_dict = dl.__dict__\npaths = [str(dl_dict[c]).split(\"'\")[1] for c in classes]\ndepths = [get_parent_depth(dl_dict[c]) for c in classes]\ncwd = os.getcwd()\n</pre> classes = tree_flatten(dl.__all__)[0] dl_dict = dl.__dict__ paths = [str(dl_dict[c]).split(\"'\")[1] for c in classes] depths = [get_parent_depth(dl_dict[c]) for c in classes] cwd = os.getcwd() In\u00a0[\u00a0]: Copied! <pre># Generate UMLS for each class\nfor path, depth in zip(paths, depths):\n    # print(depth, path)\n\n    # Generate UML\n    subprocess.run(\n        [\n            \"pyreverse\",\n            \"-c\",\n            f\"{path}\",\n            \"--output\",\n            \"html\",\n            \"-s0\",\n            f\"-a{depth-3}\",\n            \"--colorized\",\n            \"dLux\",\n            \"--output-directory\",\n            \"assets/uml\",\n        ],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n\n    # Save to png\n    file_name = path.split(\".\")[-1]\n    save_to_png(\n        f\"{cwd}/assets/uml/{path}.html\", f\"{cwd}/assets/uml/{file_name}.png\"\n    )\n\n    # Remove html file\n    os.remove(f\"{cwd}/assets/uml/{path}.html\")\n</pre> # Generate UMLS for each class for path, depth in zip(paths, depths):     # print(depth, path)      # Generate UML     subprocess.run(         [             \"pyreverse\",             \"-c\",             f\"{path}\",             \"--output\",             \"html\",             \"-s0\",             f\"-a{depth-3}\",             \"--colorized\",             \"dLux\",             \"--output-directory\",             \"assets/uml\",         ],         stdout=subprocess.PIPE,         stderr=subprocess.PIPE,     )      # Save to png     file_name = path.split(\".\")[-1]     save_to_png(         f\"{cwd}/assets/uml/{path}.html\", f\"{cwd}/assets/uml/{file_name}.png\"     )      # Remove html file     os.remove(f\"{cwd}/assets/uml/{path}.html\") In\u00a0[\u00a0]: Copied! <pre>\"\"\"\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Optic.png)\n\"\"\"\n</pre> \"\"\"     ??? abstract \"UML\"         ![UML](../../assets/uml/Optic.png) \"\"\""},{"location":"generate_umls/#generate-for-whole-package","title":"Generate for whole package\u00b6","text":"<p>subprocess.run( [ \"pyreverse\", \"-o\", \"html\", \"--colorized\", \"dLux\", \"--output-directory\", \"uml_files\", ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, )</p>"},{"location":"installation/","title":"Installation","text":"<p>\u2202Lux is hosted on PyPI, so simply pip install!</p> <pre><code>pip install dLux\n</code></pre> <p>You can also build from source. To do so, clone the git repo, enter the directory, and run.</p> <pre><code>pip install .\n</code></pre> <p>We encourage the creation of a virtual environment to run \u2202Lux to prevent software conflicts as we keep the software up to date with the latest version of the core packages.</p>"},{"location":"installation/#windowsgoogle-colab-quickstart","title":"Windows/Google Colab Quickstart","text":"<p><code>jaxlib</code> is currently not supported by the Jax team on windows, however there are two work-arounds!</p> <p>Firstly here is some community built software to install jax on windows! We do not use this ourselves so have limited knowledge, but some users seems to have got everyting working fine!</p> <p>Secondly, users can also run our software on Google Colab. If you want to instal from source in colab, run this at the start of your notebook!</p> <pre><code>!git clone https://github.com/LouisDesdoigts/dLux.git # Download latest version\n!cd dLux; pip install . -q # Navigate to \u2202Lux and install from source\n</code></pre> <p>From here everything should work! You can also run the code on GPU to take full advantage of Jax, simply by switch to a GPU runtime environment, no extra steps necessary!</p>"},{"location":"populate_docs/","title":"Usage","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> import matplotlib.pyplot as plt plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 In\u00a0[2]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\nprint(optics)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  print(optics) <pre>AngularOptics(\n  wf_npixels=256,\n  diameter=1.0,\n  aperture=Optic(opd=None, normalise=True, transmission=f32[256,256]),\n  mask=None,\n  psf_npixels=128,\n  psf_oversample=4.0,\n  psf_pixel_scale=0.1\n)\n</pre> In\u00a0[3]: Copied! <pre># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/simple_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/simple_optics.png') In\u00a0[5]: Copied! <pre>import jax.numpy as np\nimport dLux.utils as dlu\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = dlu.arcsec_to_rad(0.1 / 4)\n\n# Construct the list of layers\nlayers = [\n    dl.ApertureFactory(wf_npixels),\n    dl.MFT(psf_npixels, psf_pixel_scale)\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n</pre> import jax.numpy as np import dLux.utils as dlu import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = dlu.arcsec_to_rad(0.1 / 4)  # Construct the list of layers layers = [     dl.ApertureFactory(wf_npixels),     dl.MFT(psf_npixels, psf_pixel_scale) ]  # Construct the optics class optics = dl.LayeredOptics(wf_npixels, diameter, layers) In\u00a0[6]: Copied! <pre>print(optics)\n</pre> print(optics) <pre>LayeredOptics(\n  wf_npixels=256,\n  diameter=1.0,\n  layers={\n    'Optic':\n    Optic(opd=None, normalise=True, transmission=f32[256,256]),\n    'MFT':\n    MFT(focal_length=None, inverse=False, npixels=128, pixel_scale=f32[])\n  }\n)\n</pre> In\u00a0[7]: Copied! <pre># Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[8]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.Optic.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/layered_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.Optic.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/layered_optics.png') In\u00a0[9]: Copied! <pre>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Aberrations Parameters\nzernikes = np.arange(4, 10)\ncoefficients = 1e-7 * jr.normal(jr.PRNGKey(0), zernikes.shape)\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels, noll_indices=zernikes, \n    coefficients=coefficients)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths, flux=5e4)\ndata = jr.poisson(jr.PRNGKey(1), optics.model(source))\n</pre> import jax.numpy as np import jax.random as jr import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Aberrations Parameters zernikes = np.arange(4, 10) coefficients = 1e-7 * jr.normal(jr.PRNGKey(0), zernikes.shape)  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels, noll_indices=zernikes,      coefficients=coefficients)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths, flux=5e4) data = jr.poisson(jr.PRNGKey(1), optics.model(source)) In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.opd)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/aberrated_optics.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.opd) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"Data\") plt.imshow(data) plt.colorbar() plt.tight_layout() plt.savefig('assets/aberrated_optics.png') In\u00a0[11]: Copied! <pre>import jax.scipy as jsp\nimport zodiax as zdx\nimport optax\n\n# Set aberration coefficents to zero\nparameter = 'aperture.coefficients'\nmodel = optics.multiply(parameter, 0.1)\n\n# Define the loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(parameter)\ndef loss_fn(model, source, data):\n    psf = model.model(source)\n    return -np.sum(jsp.stats.poisson.logpmf(data, psf))\n\n# Compile the loss function\nloss, grads = loss_fn(model, source, data)\n</pre> import jax.scipy as jsp import zodiax as zdx import optax  # Set aberration coefficents to zero parameter = 'aperture.coefficients' model = optics.multiply(parameter, 0.1)  # Define the loss function @zdx.filter_jit @zdx.filter_value_and_grad(parameter) def loss_fn(model, source, data):     psf = model.model(source)     return -np.sum(jsp.stats.poisson.logpmf(data, psf))  # Compile the loss function loss, grads = loss_fn(model, source, data) In\u00a0[12]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, parameter, optax.adam(2e-9))\n\nlosses, models_out = [], []\nfor i in range(100):\n    # calculate the loss and gradient\n    loss, grads = loss_fn(model, source, data) \n    \n    # apply the update\n    updates, opt_state = optim.update(grads, opt_state)\n    model = zdx.apply_updates(model, updates)\n    \n    # save results\n    models_out.append(model) \n    losses.append(loss)\n</pre> optim, opt_state = zdx.get_optimiser(model, parameter, optax.adam(2e-9))  losses, models_out = [], [] for i in range(100):     # calculate the loss and gradient     loss, grads = loss_fn(model, source, data)           # apply the update     updates, opt_state = optim.update(grads, opt_state)     model = zdx.apply_updates(model, updates)          # save results     models_out.append(model)      losses.append(loss) In\u00a0[13]: Copied! <pre>plt.figure(figsize=(12, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Loss\")\nplt.plot(losses)\nplt.xlabel(\"Epoch\")\n\nfound_coeffs = models_out[-1].aperture.coefficients\nplt.subplot(1, 2, 2)\nplt.title(\"Coefficients\")\nplt.scatter(coefficients, found_coeffs)\nplt.xlabel(\"True Coefficients\")\nplt.ylabel(\"Found Coefficients\")\n\n# Add y=x line\nv = np.max(np.abs(np.concatenate([coefficients, found_coeffs])))\nplt.plot([-v, v], [-v, v], color='k', linestyle='--')\n\nplt.tight_layout()\nplt.savefig('assets/loss_curve.png')\n\n# Plot data. model and residual\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\n\npsf = models_out[-1].model(source)\nplt.subplot(1, 3, 2)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Residual\")\nplt.imshow(data - psf)\nplt.colorbar()\n\nplt.tight_layout()\nplt.savefig('assets/recovered_model.png')\n</pre> plt.figure(figsize=(12, 4)) plt.subplot(1, 2, 1) plt.title(\"Loss\") plt.plot(losses) plt.xlabel(\"Epoch\")  found_coeffs = models_out[-1].aperture.coefficients plt.subplot(1, 2, 2) plt.title(\"Coefficients\") plt.scatter(coefficients, found_coeffs) plt.xlabel(\"True Coefficients\") plt.ylabel(\"Found Coefficients\")  # Add y=x line v = np.max(np.abs(np.concatenate([coefficients, found_coeffs]))) plt.plot([-v, v], [-v, v], color='k', linestyle='--')  plt.tight_layout() plt.savefig('assets/loss_curve.png')  # Plot data. model and residual plt.figure(figsize=(15, 4)) plt.subplot(1, 3, 1) plt.title(\"Data\") plt.imshow(data) plt.colorbar()  psf = models_out[-1].model(source) plt.subplot(1, 3, 2) plt.title(\"PSF\") plt.imshow(psf) plt.colorbar()  plt.subplot(1, 3, 3) plt.title(\"Residual\") plt.imshow(data - psf) plt.colorbar()  plt.tight_layout() plt.savefig('assets/recovered_model.png') In\u00a0[14]: Copied! <pre># Construct Detector Object\ndetector_layers = [dl.ApplyJitter(3), dl.IntegerDownsample(4)]\ndetector = dl.LayeredDetector(detector_layers)\n\n# Construct Dithered Observation\ndithers = 2.5e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Combine all into instrument and model\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</pre> # Construct Detector Object detector_layers = [dl.ApplyJitter(3), dl.IntegerDownsample(4)] detector = dl.LayeredDetector(detector_layers)  # Construct Dithered Observation dithers = 2.5e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) observation = dl.Dither(dithers)  # Combine all into instrument and model instrument = dl.Instrument(optics, source, detector, observation) psfs = instrument.observe() In\u00a0[15]: Copied! <pre>plt.figure(figsize=(20, 4))\nfor i, psf in enumerate(psfs):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"PSF {}\".format(i))\n    plt.imshow(psf)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/full_instrument.png')\n</pre> plt.figure(figsize=(20, 4)) for i, psf in enumerate(psfs):     plt.subplot(1, 4, i+1)     plt.title(\"PSF {}\".format(i))     plt.imshow(psf)     plt.colorbar() plt.tight_layout() plt.savefig('assets/full_instrument.png') In\u00a0[16]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[17]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/angular_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/angular_psf.png') In\u00a0[18]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 1 # microns\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.CartesianOptics(wf_npixels, diameter, aperture, focal_length,\n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 1 # microns psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.CartesianOptics(wf_npixels, diameter, aperture, focal_length,     psf_npixels, psf_pixel_scale, psf_oversample)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[19]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/cartesian_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/cartesian_psf.png') In\u00a0[20]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\nfocal_shift = 2e-5 # metres\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct a Fresnel Propagator\npropagator = dl.FarFieldFresnel(psf_npixels, psf_pixel_scale, focal_length,\n    focal_shift)\n\n# Construct the optics class\noptics = dl.FlexibleOptics(wf_npixels, diameter, aperture, propagator)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 0.25e-6 # metres focal_shift = 2e-5 # metres  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct a Fresnel Propagator propagator = dl.FarFieldFresnel(psf_npixels, psf_pixel_scale, focal_length,     focal_shift)  # Construct the optics class optics = dl.FlexibleOptics(wf_npixels, diameter, aperture, propagator)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[21]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/fresnel_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/fresnel_psf.png') In\u00a0[22]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 256\ndiameter = 1 # metres\nfocal_length = 2 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.25e-6 # metres\n\n# Construct the list of optical layers\nlayers = [\n    (dl.ApertureFactory(wf_npixels), 'aperture'),\n    dl.MFT(psf_npixels, psf_pixel_scale, focal_length),\n]\n\n# Construct the optics class\noptics = dl.LayeredOptics(wf_npixels, diameter, layers)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import dLux as dl  # Define the parameters wf_npixels = 256 diameter = 1 # metres focal_length = 2 # metres psf_npixels = 128 psf_pixel_scale = 0.25e-6 # metres  # Construct the list of optical layers layers = [     (dl.ApertureFactory(wf_npixels), 'aperture'),     dl.MFT(psf_npixels, psf_pixel_scale, focal_length), ]  # Construct the optics class optics = dl.LayeredOptics(wf_npixels, diameter, layers)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[23]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/layered_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/layered_psf.png') In\u00a0[24]: Copied! <pre>import jax.numpy as np\nfrom jax import Array\nimport dLux.utils as dlu\nimport dLux\n\n# We must inherit from the base optics class, `BaseOptics`. This will integrate\n# our class with the rest of the dLux code.\nclass MyOptics(dLux.optics.BaseOptics):\n    wf_npixels      : int\n    diameter        : float\n    aperture        : Array\n    mask            : Array\n    psf_pixel_scale : float\n    psf_npixels     : int\n\n    def __init__(self, wf_npixes, diameter, aperture, mask, psf_npixels, \n        psf_pixel_scale):\n        '''Constructs the class'''\n        self.wf_npixels = wf_npixels\n        self.diameter = diameter\n        self.aperture = aperture\n        self.mask = mask\n        self.psf_npixels = psf_npixels\n        self.psf_pixel_scale = psf_pixel_scale\n    \n    # Our propagate_mono must have the expected behaviour of dLux optics,\n    # meaning it must take the same inputs (wavelength, offset, return_wf) and\n    # return the same outputs (psf).\n    def propagate_mono(self, wavelength, offset=np.zeros(2), return_wf=False):\n        '''Propagates a monochromatic source'''\n\n        # Construct our wavefront\n        wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)\n\n        # Tilt the wavefront\n        wf = wf.tilt(offset)\n\n        # We can use the `self` keyword to access the class attributes\n        wf *= self.aperture\n\n        # Normalise the wavefront\n        wf = wf.normalise()\n\n        # Apply the mask as an array of OPDs\n        wf += self.mask\n\n        # Propagate the wavefront, casting the units of pixel scale to radians\n        pixel_scale = dlu.arcmin_to_rad(self.psf_pixel_scale)\n        wf = wf.MFT(self.psf_npixels, pixel_scale)\n\n        # Return the PSF\n        if return_wf:\n            return wf\n        else:\n            return wf.psf\n</pre> import jax.numpy as np from jax import Array import dLux.utils as dlu import dLux  # We must inherit from the base optics class, `BaseOptics`. This will integrate # our class with the rest of the dLux code. class MyOptics(dLux.optics.BaseOptics):     wf_npixels      : int     diameter        : float     aperture        : Array     mask            : Array     psf_pixel_scale : float     psf_npixels     : int      def __init__(self, wf_npixes, diameter, aperture, mask, psf_npixels,          psf_pixel_scale):         '''Constructs the class'''         self.wf_npixels = wf_npixels         self.diameter = diameter         self.aperture = aperture         self.mask = mask         self.psf_npixels = psf_npixels         self.psf_pixel_scale = psf_pixel_scale          # Our propagate_mono must have the expected behaviour of dLux optics,     # meaning it must take the same inputs (wavelength, offset, return_wf) and     # return the same outputs (psf).     def propagate_mono(self, wavelength, offset=np.zeros(2), return_wf=False):         '''Propagates a monochromatic source'''          # Construct our wavefront         wf = dLux.Wavefront(self.wf_npixels, self.diameter, wavelength)          # Tilt the wavefront         wf = wf.tilt(offset)          # We can use the `self` keyword to access the class attributes         wf *= self.aperture          # Normalise the wavefront         wf = wf.normalise()          # Apply the mask as an array of OPDs         wf += self.mask          # Propagate the wavefront, casting the units of pixel scale to radians         pixel_scale = dlu.arcmin_to_rad(self.psf_pixel_scale)         wf = wf.MFT(self.psf_npixels, pixel_scale)          # Return the PSF         if return_wf:             return wf         else:             return wf.psf In\u00a0[25]: Copied! <pre>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\n\n# Define the parameters\nwf_npixels = 128\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 5e-4 # arcminutes\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Make a mask of random OPDs\nmask = 4.e-7 * jr.normal(jr.PRNGKey(0), (wf_npixels, wf_npixels))\n\n# Construct the optics class\noptics = MyOptics(wf_npixels, diameter, aperture, mask, psf_npixels, \n    psf_pixel_scale)\n\n# Propagate the wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\npsf = optics.propagate(wavelengths)\n</pre> import jax.numpy as np import jax.random as jr import dLux as dl  # Define the parameters wf_npixels = 128 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 5e-4 # arcminutes  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Make a mask of random OPDs mask = 4.e-7 * jr.normal(jr.PRNGKey(0), (wf_npixels, wf_npixels))  # Construct the optics class optics = MyOptics(wf_npixels, diameter, aperture, mask, psf_npixels,      psf_pixel_scale)  # Propagate the wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres psf = optics.propagate(wavelengths) In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture\")\nplt.imshow(optics.aperture.transmission * optics.mask * 1e6)\nplt.colorbar(label=\"OPD (microns)\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/my_optics_psf.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aperture\") plt.imshow(optics.aperture.transmission * optics.mask * 1e6) plt.colorbar(label=\"OPD (microns)\")  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF}$\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/my_optics_psf.png') In\u00a0[27]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Detector\ndetector = dl.LayeredDetector([dl.ApplyJitter(20)])\n\n# Construct Observation\nobservation = dl.Dither(np.array([[0, 0], [1e-6, 1e-6]]))\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, detector, observation)\npsfs = instrument.observe()\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths)  # Construct Detector detector = dl.LayeredDetector([dl.ApplyJitter(20)])  # Construct Observation observation = dl.Dither(np.array([[0, 0], [1e-6, 1e-6]]))  # Construct the instrument and observe instrument = dl.Instrument(optics, source, detector, observation) psfs = instrument.observe() In\u00a0[28]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"$\\sqrt{PSF_1}$\")\nplt.imshow(psfs[0]**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF_2}$\")\nplt.imshow(psfs[1]**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/instrument.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"$\\sqrt{PSF_1}$\") plt.imshow(psfs[0]**0.5) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"$\\sqrt{PSF_2}$\") plt.imshow(psfs[1]**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/instrument.png') In\u00a0[29]: Copied! <pre># Array based spectrum\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nweights = np.linspace(.5, 1, 5)\nspectrum = dl.Spectrum(wavelengths, weights)\n</pre> # Array based spectrum wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres weights = np.linspace(.5, 1, 5) spectrum = dl.Spectrum(wavelengths, weights) In\u00a0[30]: Copied! <pre>import matplotlib.pyplot as plt\nplt.title(\"Spectrum\")\nplt.scatter(spectrum.wavelengths, spectrum.weights)\nplt.ylim(0)\nplt.xlabel(\"Wavelength (meters)\")\nplt.ylabel(\"Normalised Weight\")\nplt.tight_layout()\nplt.savefig('assets/spectrum.png')\n</pre> import matplotlib.pyplot as plt plt.title(\"Spectrum\") plt.scatter(spectrum.wavelengths, spectrum.weights) plt.ylim(0) plt.xlabel(\"Wavelength (meters)\") plt.ylabel(\"Normalised Weight\") plt.tight_layout() plt.savefig('assets/spectrum.png') In\u00a0[31]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\n\n# Construct Observation\ndithers = 1e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Construct the instrument and observe\ninstrument = dl.Instrument(optics, source, observation=observation)\npsfs = instrument.observe()\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths)  # Construct Observation dithers = 1e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) observation = dl.Dither(dithers)  # Construct the instrument and observe instrument = dl.Instrument(optics, source, observation=observation) psfs = instrument.observe() In\u00a0[32]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(20, 4))\nfor i in range(4):\n    plt.subplot(1, 4, i+1)\n    plt.title(\"$\\sqrt{PSF}$\")\n    plt.imshow(psfs[i]**0.5)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/observation.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(20, 4)) for i in range(4):     plt.subplot(1, 4, i+1)     plt.title(\"$\\sqrt{PSF}$\")     plt.imshow(psfs[i]**0.5)     plt.colorbar() plt.tight_layout() plt.savefig('assets/observation.png') In\u00a0[33]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample) In\u00a0[34]: Copied! <pre># Define wavelengths\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\n\n# Construct PointSource\nsources = [dl.PointSource(wavelengths)]\n\n# Construct PointSources\npositions = 3e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nsources.append(dl.PointSources(wavelengths, positions))\n\n# Construct BinarySource\nseparation = 2e-6 # radians\nsources.append(dl.BinarySource(wavelengths, separation=separation))\n\n# Construct ResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.ResolvedSource(wavelengths, distribution=distribution))\n\n# Construct PointResolvedSource\ndistribution = np.ones([10, 10])\nsources.append(dl.PointResolvedSource(wavelengths, distribution=distribution, \n    contrast=3))\n</pre> # Define wavelengths wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres  # Construct PointSource sources = [dl.PointSource(wavelengths)]  # Construct PointSources positions = 3e-6 * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]]) sources.append(dl.PointSources(wavelengths, positions))  # Construct BinarySource separation = 2e-6 # radians sources.append(dl.BinarySource(wavelengths, separation=separation))  # Construct ResolvedSource distribution = np.ones([10, 10]) sources.append(dl.ResolvedSource(wavelengths, distribution=distribution))  # Construct PointResolvedSource distribution = np.ones([10, 10]) sources.append(dl.PointResolvedSource(wavelengths, distribution=distribution,      contrast=3)) In\u00a0[35]: Copied! <pre>import matplotlib.pyplot as plt\ntitles = [\"PointSource\", \"PointSources\", \"BinarySource\", \"ResolvedSource\",\n    \"PointResolvedSource\"]\n\nplt.figure(figsize=(25, 4))\nfor i in range(5):\n    psf = sources[i].model(optics)\n    plt.subplot(1, 5, i+1)\n    plt.title(titles[i])\n    plt.imshow(psf**0.5)\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/sources.png')\n</pre> import matplotlib.pyplot as plt titles = [\"PointSource\", \"PointSources\", \"BinarySource\", \"ResolvedSource\",     \"PointResolvedSource\"]  plt.figure(figsize=(25, 4)) for i in range(5):     psf = sources[i].model(optics)     plt.subplot(1, 5, i+1)     plt.title(titles[i])     plt.imshow(psf**0.5)     plt.colorbar() plt.tight_layout() plt.savefig('assets/sources.png') In\u00a0[36]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\n# Define the optical parameters\nwf_npixels = 256\ndiameter = 1 # metres\npsf_npixels = 128\npsf_pixel_scale = 0.1 # arcseconds\npsf_oversample = 4\n\n# Use ApertureFactory class to make a simple circular aperture\naperture = dl.ApertureFactory(wf_npixels)\n\n# Construct the optics class\noptics = dl.AngularOptics(wf_npixels, diameter, aperture, \n    psf_npixels, psf_pixel_scale, psf_oversample)\n\n# Construct Source\nwavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres\nsource = dl.PointSource(wavelengths)\nraw_psf = source.model(optics)\n</pre> import jax.numpy as np import dLux as dl  # Define the optical parameters wf_npixels = 256 diameter = 1 # metres psf_npixels = 128 psf_pixel_scale = 0.1 # arcseconds psf_oversample = 4  # Use ApertureFactory class to make a simple circular aperture aperture = dl.ApertureFactory(wf_npixels)  # Construct the optics class optics = dl.AngularOptics(wf_npixels, diameter, aperture,      psf_npixels, psf_pixel_scale, psf_oversample)  # Construct Source wavelengths = np.linspace(1e-6, 1.2e-6, 5) # metres source = dl.PointSource(wavelengths) raw_psf = source.model(optics) In\u00a0[37]: Copied! <pre># Construct Detector\ndetector = dl.LayeredDetector([\n    dl.ApplyJitter(20),\n    dl.IntegerDownsample(4),\n    dl.AddConstant(1),\n])\n\n# Combine into instrument and model\ninstrument = dl.Instrument(optics, source, detector)\npsf = instrument.model()\n</pre> # Construct Detector detector = dl.LayeredDetector([     dl.ApplyJitter(20),     dl.IntegerDownsample(4),     dl.AddConstant(1), ])  # Combine into instrument and model instrument = dl.Instrument(optics, source, detector) psf = instrument.model() In\u00a0[38]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Raw PSF\")\nplt.imshow(raw_psf**0.5)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Detector Transformed PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/detectors.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Raw PSF\") plt.imshow(raw_psf**0.5) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"Detector Transformed PSF\") plt.imshow(psf**0.5) plt.colorbar() plt.tight_layout() plt.savefig('assets/detectors.png') In\u00a0[39]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\nimage = dl.Image(np.ones((256, 256)), 0.1)\nimage *= 2\nimage += 1\nimage /= 2\n</pre> import jax.numpy as np import dLux as dl  image = dl.Image(np.ones((256, 256)), 0.1) image *= 2 image += 1 image /= 2 In\u00a0[40]: Copied! <pre>import jax.numpy as np\nimport dLux as dl\n\nnpixels = 16\ndiameter = 1 # metres\nwavelength = 1e-6 # metres\n\nwf = dl.Wavefront(npixels, diameter, wavelength)\n\n# Multiply to modify the amplitude\nwf *= 0.5 # Halves the amplitude\n\n# Multiply by complex array to transform both ampltiude and phase\nwf *= np.ones((npixels, npixels)) * np.exp(1j * np.zeros((npixels, npixels)))\n\n# Multiply or Add by OpticalLayer to apply it\naperture = dl.ApertureFactory(16)\nwf *= aperture\nwf += aperture\n\n# Add to modify the phase through OPD units\nwf += 1 # Adds 1m of OPD across full wavefront\n</pre> import jax.numpy as np import dLux as dl  npixels = 16 diameter = 1 # metres wavelength = 1e-6 # metres  wf = dl.Wavefront(npixels, diameter, wavelength)  # Multiply to modify the amplitude wf *= 0.5 # Halves the amplitude  # Multiply by complex array to transform both ampltiude and phase wf *= np.ones((npixels, npixels)) * np.exp(1j * np.zeros((npixels, npixels)))  # Multiply or Add by OpticalLayer to apply it aperture = dl.ApertureFactory(16) wf *= aperture wf += aperture  # Add to modify the phase through OPD units wf += 1 # Adds 1m of OPD across full wavefront In\u00a0[41]: Copied! <pre>import dLux as dl\n\napertures = [\n    dl.CircularAperture(1.),\n    dl.CircularAperture(1., centre=[.5, .5]),\n    dl.CircularAperture(1., shear=[.05, .05]),\n    dl.CircularAperture(1., compression=[1.05, .95]),\n    dl.CircularAperture(1., softening=20),\n    dl.CircularAperture(1., occulting=True)\n]\n</pre> import dLux as dl  apertures = [     dl.CircularAperture(1.),     dl.CircularAperture(1., centre=[.5, .5]),     dl.CircularAperture(1., shear=[.05, .05]),     dl.CircularAperture(1., compression=[1.05, .95]),     dl.CircularAperture(1., softening=20),     dl.CircularAperture(1., occulting=True) ] In\u00a0[42]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(30, 4))\nfor i in range(len(apertures)):\n    plt.subplot(1, 6, i+1)\n    plt.imshow(apertures[i].transmission(256, 2))\nplt.tight_layout()\nplt.savefig(\"assets/basic_apertures.png\")\n</pre> import matplotlib.pyplot as plt  plt.figure(figsize=(30, 4)) for i in range(len(apertures)):     plt.subplot(1, 6, i+1)     plt.imshow(apertures[i].transmission(256, 2)) plt.tight_layout() plt.savefig(\"assets/basic_apertures.png\") In\u00a0[43]: Copied! <pre>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct a Hexagonal Aperture\nhex = dl.RegPolyAperture(6, 1.)\n\n# Turn it into an aberrated aperture\nzernikes = np.arange(1, 7)\ncoefficients = jr.normal(jr.PRNGKey(0), (6,))\naberrated_hex = dl.AberratedAperture(hex, zernikes, coefficients)\n\n# Promote it to static\nstatic_hex = aberrated_hex.make_static(256, 2)\n</pre> import dLux as dl import jax.numpy as np import jax.random as jr  # Construct a Hexagonal Aperture hex = dl.RegPolyAperture(6, 1.)  # Turn it into an aberrated aperture zernikes = np.arange(1, 7) coefficients = jr.normal(jr.PRNGKey(0), (6,)) aberrated_hex = dl.AberratedAperture(hex, zernikes, coefficients)  # Promote it to static static_hex = aberrated_hex.make_static(256, 2) In\u00a0[44]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(static_hex.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"OPD\")\nplt.imshow(static_hex.transmission * static_hex.opd)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig('assets/aberrated_apertures.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Transmission\") plt.imshow(static_hex.transmission) plt.colorbar()  plt.subplot(1, 2, 2) plt.title(\"OPD\") plt.imshow(static_hex.transmission * static_hex.opd) plt.colorbar() plt.tight_layout() plt.savefig('assets/aberrated_apertures.png') In\u00a0[45]: Copied! <pre>import dLux as dl\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nradial_orders = [2, 3]\ncoefficients = jr.normal(jr.PRNGKey(0), (7,))\n\n# Construct aperture\naperture = dl.ApertureFactory(\n    npixels         = 512,\n    secondary_ratio = 0.1, \n    nstruts         = 4, \n    strut_ratio     = 0.01, \n    radial_orders   = radial_orders, \n    coefficients    = coefficients)\n</pre> import dLux as dl import jax.numpy as np import jax.random as jr  # Construct Zernikes radial_orders = [2, 3] coefficients = jr.normal(jr.PRNGKey(0), (7,))  # Construct aperture aperture = dl.ApertureFactory(     npixels         = 512,     secondary_ratio = 0.1,      nstruts         = 4,      strut_ratio     = 0.01,      radial_orders   = radial_orders,      coefficients    = coefficients) In\u00a0[46]: Copied! <pre>import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Transmission\")\nplt.imshow(aperture.transmission)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nopd = aperture.opd.at[aperture.transmission == 0].set(np.nan)\nplt.title(\"OPD\")\nplt.imshow(opd)\nplt.colorbar()\nplt.tight_layout()\nplt.tight_layout()\nplt.savefig('assets/aperture_factory.png')\n</pre> import matplotlib.pyplot as plt plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Transmission\") plt.imshow(aperture.transmission) plt.colorbar()  plt.subplot(1, 2, 2) opd = aperture.opd.at[aperture.transmission == 0].set(np.nan) plt.title(\"OPD\") plt.imshow(opd) plt.colorbar() plt.tight_layout() plt.tight_layout() plt.savefig('assets/aperture_factory.png') In\u00a0[47]: Copied! <pre>import dLux as dl\n\nzernike_basis = dl.ZernikeBasis(np.arange(1, 7))\n</pre> import dLux as dl  zernike_basis = dl.ZernikeBasis(np.arange(1, 7)) In\u00a0[48]: Copied! <pre>import matplotlib.pyplot as plt\n\nnpix = 256\ncoords = dl.utils.pixel_coords(npix, 2/npix)\nbasis = zernike_basis.calculate_basis(coords)\n\nplt.figure(figsize=(15, 8))\nfor i in range(len(basis)):\n    plt.subplot(2, 3, i+1)\n    plt.title(f\"{zernike_basis.noll_indices[i].name}\")\n    plt.imshow(basis[i])\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/zernike.png\")\n</pre> import matplotlib.pyplot as plt  npix = 256 coords = dl.utils.pixel_coords(npix, 2/npix) basis = zernike_basis.calculate_basis(coords)  plt.figure(figsize=(15, 8)) for i in range(len(basis)):     plt.subplot(2, 3, i+1)     plt.title(f\"{zernike_basis.noll_indices[i].name}\")     plt.imshow(basis[i])     plt.colorbar() plt.tight_layout() plt.savefig(\"assets/zernike.png\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"populate_docs/#usage","title":"Usage\u00b6","text":""},{"location":"populate_docs/#a-simple-optical-system","title":"A Simple Optical System\u00b6","text":""},{"location":"populate_docs/#a-layered-optical-system","title":"A Layered Optical System\u00b6","text":""},{"location":"populate_docs/#recovering-aberrations-from-an-optical-system","title":"Recovering Aberrations from an Optical System\u00b6","text":""},{"location":"populate_docs/#adding-a-detector-observation-using-the-instrument-class","title":"Adding a Detector &amp; Observation using the Instrument class\u00b6","text":""},{"location":"populate_docs/#angular-optics","title":"Angular Optics\u00b6","text":""},{"location":"populate_docs/#instruments","title":"Instruments\u00b6","text":""},{"location":"populate_docs/#spectra","title":"Spectra\u00b6","text":""},{"location":"populate_docs/#observations","title":"Observations\u00b6","text":""},{"location":"populate_docs/#sources","title":"Sources\u00b6","text":""},{"location":"populate_docs/#detectors","title":"Detectors\u00b6","text":""},{"location":"populate_docs/#images","title":"Images\u00b6","text":""},{"location":"populate_docs/#wavefronts","title":"Wavefronts\u00b6","text":""},{"location":"populate_docs/#apertures","title":"Apertures\u00b6","text":""},{"location":"populate_docs/#aberrations","title":"Aberrations\u00b6","text":""},{"location":"API/core/detectors/","title":"Detectors","text":"LayeredDetector <p>             Bases: <code>BaseDetector</code></p> <p>Applies a series of detector layers to some input psf.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>OrderedDict</code> <p>A series of <code>DetectorLayer</code> transformations to apply to the input psf.</p> Source code in <code>src/dLux/detectors.py</code> <pre><code>class LayeredDetector(BaseDetector):\n    \"\"\"\n    Applies a series of detector layers to some input psf.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/LayeredDetector.png)\n\n    Attributes\n    ----------\n    layers: OrderedDict\n        A series of `DetectorLayer` transformations to apply to the input psf.\n    \"\"\"\n\n    layers: OrderedDict\n\n    def __init__(self: LayeredDetector, layers: list[DetectorLayer, tuple]):\n        \"\"\"\n        Parameters\n        ----------\n        layers : list[DetectorLayer, tuple]\n            A list of DetectorLayer objects to apply to the input psf. List entries\n            can be tuples of (key, layer) to specify a key, else the key is taken as\n            the class name of the layer.\n        \"\"\"\n        self.layers = dlu.list2dictionary(layers, True, DetectorLayer)\n        super().__init__()\n\n    def __getattr__(self: LayeredDetector, key: str) -&gt; object:\n        \"\"\"\n        Raises the individual layers via their keys.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers\n            dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        else:\n            raise AttributeError(\n                \"'{}' object has no attribute '{}'\".format(type(self), key)\n            )\n\n    def model(\n        self: LayeredDetector, psf: PSF, return_psf: bool = False\n    ) -&gt; Array:\n        \"\"\"\n        Applied the detector layers to the input psf.\n\n        Parameters\n        ----------\n        psf : PSF\n            The input psf to be transformed.\n\n        Returns\n        -------\n        psf : PSF\n            The output psf after being transformed by the detector layers.\n        \"\"\"\n        for key, layer in self.layers.items():\n            psf = layer.apply(psf)\n        if return_psf:\n            return psf\n        return psf.data\n\n    def insert_layer(\n        self: LayeredDetector, layer: Union[DetectorLayer, tuple], index: int\n    ) -&gt; LayeredDetector:\n        \"\"\"\n        Inserts a layer into the layers dictionary at a specified index. This function\n        calls the list2dictionary function to ensure all keys remain unique. Note that\n        this can result in some keys being modified if they are duplicates. The input\n        'layer' can be a tuple of (key, layer) to specify a key, else the key is taken\n        as the class name of the layer.\n\n        Parameters\n        ----------\n        layer : Any\n            The layer to be inserted.\n        index : int\n            The index at which to insert the layer.\n\n        Returns\n        -------\n        detector : LayeredDetector\n            The updated detector.\n        \"\"\"\n        return self.set(\n            \"layers\",\n            dlu.insert_layer(self.layers, layer, index, DetectorLayer),\n        )\n\n    def remove_layer(self: LayeredDetector, key: str) -&gt; LayeredDetector:\n        \"\"\"\n        Removes a layer from the layers dictionary, specified by its key.\n\n        Parameters\n        ----------\n        key : str\n            The key of the layer to be removed.\n\n        Returns\n        -------\n        detector : LayeredDetector\n            The updated detector.\n        \"\"\"\n        return self.set(\"layers\", dlu.remove_layer(self.layers, key))\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Raises the individual layers via their keys.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p> Source code in <code>src/dLux/detectors.py</code> <pre><code>def __getattr__(self: LayeredDetector, key: str) -&gt; object:\n    \"\"\"\n    Raises the individual layers via their keys.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the layers dictionary.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the layers\n        dictionary.\n    \"\"\"\n    if key in self.layers.keys():\n        return self.layers[key]\n    else:\n        raise AttributeError(\n            \"'{}' object has no attribute '{}'\".format(type(self), key)\n        )\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.__init__","title":"<code>__init__(layers)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list[DetectorLayer, tuple]</code> <p>A list of DetectorLayer objects to apply to the input psf. List entries can be tuples of (key, layer) to specify a key, else the key is taken as the class name of the layer.</p> required Source code in <code>src/dLux/detectors.py</code> <pre><code>def __init__(self: LayeredDetector, layers: list[DetectorLayer, tuple]):\n    \"\"\"\n    Parameters\n    ----------\n    layers : list[DetectorLayer, tuple]\n        A list of DetectorLayer objects to apply to the input psf. List entries\n        can be tuples of (key, layer) to specify a key, else the key is taken as\n        the class name of the layer.\n    \"\"\"\n    self.layers = dlu.list2dictionary(layers, True, DetectorLayer)\n    super().__init__()\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.insert_layer","title":"<code>insert_layer(layer, index)</code>","text":"<p>Inserts a layer into the layers dictionary at a specified index. This function calls the list2dictionary function to ensure all keys remain unique. Note that this can result in some keys being modified if they are duplicates. The input 'layer' can be a tuple of (key, layer) to specify a key, else the key is taken as the class name of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Any</code> <p>The layer to be inserted.</p> required <code>index</code> <code>int</code> <p>The index at which to insert the layer.</p> required <p>Returns:</p> Name Type Description <code>detector</code> <code>LayeredDetector</code> <p>The updated detector.</p> Source code in <code>src/dLux/detectors.py</code> <pre><code>def insert_layer(\n    self: LayeredDetector, layer: Union[DetectorLayer, tuple], index: int\n) -&gt; LayeredDetector:\n    \"\"\"\n    Inserts a layer into the layers dictionary at a specified index. This function\n    calls the list2dictionary function to ensure all keys remain unique. Note that\n    this can result in some keys being modified if they are duplicates. The input\n    'layer' can be a tuple of (key, layer) to specify a key, else the key is taken\n    as the class name of the layer.\n\n    Parameters\n    ----------\n    layer : Any\n        The layer to be inserted.\n    index : int\n        The index at which to insert the layer.\n\n    Returns\n    -------\n    detector : LayeredDetector\n        The updated detector.\n    \"\"\"\n    return self.set(\n        \"layers\",\n        dlu.insert_layer(self.layers, layer, index, DetectorLayer),\n    )\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.model","title":"<code>model(psf, return_psf=False)</code>","text":"<p>Applied the detector layers to the input psf.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The input psf to be transformed.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The output psf after being transformed by the detector layers.</p> Source code in <code>src/dLux/detectors.py</code> <pre><code>def model(\n    self: LayeredDetector, psf: PSF, return_psf: bool = False\n) -&gt; Array:\n    \"\"\"\n    Applied the detector layers to the input psf.\n\n    Parameters\n    ----------\n    psf : PSF\n        The input psf to be transformed.\n\n    Returns\n    -------\n    psf : PSF\n        The output psf after being transformed by the detector layers.\n    \"\"\"\n    for key, layer in self.layers.items():\n        psf = layer.apply(psf)\n    if return_psf:\n        return psf\n    return psf.data\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.remove_layer","title":"<code>remove_layer(key)</code>","text":"<p>Removes a layer from the layers dictionary, specified by its key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the layer to be removed.</p> required <p>Returns:</p> Name Type Description <code>detector</code> <code>LayeredDetector</code> <p>The updated detector.</p> Source code in <code>src/dLux/detectors.py</code> <pre><code>def remove_layer(self: LayeredDetector, key: str) -&gt; LayeredDetector:\n    \"\"\"\n    Removes a layer from the layers dictionary, specified by its key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the layer to be removed.\n\n    Returns\n    -------\n    detector : LayeredDetector\n        The updated detector.\n    \"\"\"\n    return self.set(\"layers\", dlu.remove_layer(self.layers, key))\n</code></pre>"},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector","title":"Detectors","text":""},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.__getattr__","title":"Detectors","text":""},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.__init__","title":"Detectors","text":""},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.insert_layer","title":"Detectors","text":""},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.model","title":"Detectors","text":""},{"location":"API/core/detectors/#dLux.detectors.LayeredDetector.remove_layer","title":"Detectors","text":""},{"location":"API/core/instruments/","title":"Instruments","text":"Telescope <p>             Bases: <code>Instrument</code></p> <p>Class that represents a telescope instrument, holding an optical system, a source object and (optionally) a detector object, automating the process of modelling all three in conjunction.</p> <p>To generate more complex instruments or a set of observations, the <code>Telescope</code> class can be inherited and modified to suit the needs of the user.</p> <p>Attributes:</p> Name Type Description <code>optics</code> <code>BaseOpticalSystem</code> <p>An <code>OpticalSystem</code> object that defines the optical transformations of the instrument.</p> <code>source</code> <code>BaseSource</code> <p>A <code>Source</code> or <code>Scene</code> to objects to model through the instrument.</p> <code>detector</code> <code>BaseDetector</code> <p>A <code>Detector</code> object that defines the detector transformations of the instrument.</p> Source code in <code>src/dLux/instruments.py</code> <pre><code>class Telescope(Instrument):\n    \"\"\"\n    Class that represents a telescope instrument, holding an optical system, a source\n    object and (optionally) a detector object, automating the process of modelling\n    all three in conjunction.\n\n    To generate more complex instruments or a set of observations, the `Telescope`\n    class can be inherited and modified to suit the needs of the user.\n\n    Attributes\n    ----------\n    optics : OpticalSystem\n        An `OpticalSystem` object that defines the optical transformations of the\n        instrument.\n    source : Source\n        A `Source` or `Scene` to objects to model through the instrument.\n    detector : Detector\n        A `Detector` object that defines the detector transformations of the\n        instrument.\n    \"\"\"\n\n    optics: OpticalSystem\n    source: Source\n    detector: Detector\n\n    def __init__(\n        self: Telescope,\n        optics: OpticalSystem,\n        source: Union[list, Source],\n        detector: Detector = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        optics : OpticalSystem\n            An `OpticalSystem` object that defines the optical transformations of the\n            instrument.\n        source : Source\n            A `Source` or `Scene` to objects to model through the instrument. Can be\n            either a single `Source` object, or a list of `Source` objects which is\n            then converted to a `Scene` object. The list entries can also be a tuple of\n            (key, source)  in order to specify a key for the source in the scene.\n        detector : Detector = None\n            A `Detector` object that defines the detector transformations of the\n            instrument.\n        \"\"\"\n        # Optics\n        if not isinstance(optics, OpticalSystem):\n            raise TypeError(\"optics must be an Optics object.\")\n        self.optics = optics\n\n        # Sources\n        if isinstance(source, Source):\n            self.source = source\n        elif isinstance(source, tuple):\n            # If its a (key, source) tuple, we ignore the key\n            self.source = source[1]\n        else:\n            self.source = Scene(source)\n\n        # Detector\n        if not isinstance(detector, Detector) and detector is not None:\n            raise TypeError(\n                \"detector must be an Detector object. \"\n                f\"Got type {type(detector)}\"\n            )\n        self.detector = detector\n\n    def __getattr__(self: Telescope, key: str) -&gt; object:\n        \"\"\"\n        Raises the attributes from the optics, source and detector to the top level of\n        the class.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the sub-dictionaries.\n        \"\"\"\n        for attribute in self.__dict__.values():\n            if hasattr(attribute, key):\n                return getattr(attribute, key)\n        raise AttributeError(\n            f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n        )\n\n    def model(self: Telescope, return_psf: bool = False) -&gt; Array:\n        \"\"\"\n        Models the source objects through the optical system and detector.\n\n        Parameters\n        ----------\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, PSF\n            if `return_psf` is False, the psf Array is returned.\n            If `return_psf` is True, the PSF object is returned.\n\n        \"\"\"\n        # Model optics: return_psf=True for more efficient source calculations\n        psfs = self.optics.model(self.source, return_psf=True)\n\n        # Array based output\n        psf = psfs.data.sum(tuple(range(psfs.ndim)))\n        pixel_scale = psfs.pixel_scale.mean()\n\n        # Pass through detector transformations if it exists\n        psf_obj = PSF(psf, pixel_scale)\n        if self.detector is not None:\n            return self.detector.model(psf_obj, return_psf=return_psf)\n\n        # Return psf\n        if return_psf:\n            return psf_obj\n        return psf_obj.data\n</code></pre> Dither <p>             Bases: <code>Telescope</code></p> <p>Simple extension of the <code>Telescope</code> class that applies a series of dithers to the source positions before modelling the instrument. Serves both as a demonstration of how to extend the <code>Telescope</code> class and as a useful tool for modelling dithered observations.</p> <p>Attributes:</p> Name Type Description <code>optics</code> <code>BaseOpticalSystem</code> <p>An <code>OpticalSystem</code> object that defines the optical transformations of the instrument.</p> <code>source</code> <code>BaseSource</code> <p>A <code>Source</code> or <code>Scene</code> to objects to model through the instrument.</p> <code>detector</code> <code>BaseDetector</code> <p>A <code>Detector</code> object that defines the detector transformations of the instrument.</p> <code>dithers</code> <code>(Array, radians)</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2).</p> Source code in <code>src/dLux/instruments.py</code> <pre><code>class Dither(Telescope):\n    \"\"\"\n    Simple extension of the `Telescope` class that applies a series of dithers to the\n    source positions before modelling the instrument. Serves both as a demonstration\n    of how to extend the `Telescope` class and as a useful tool for modelling\n    dithered observations.\n\n    Attributes\n    ----------\n    optics : OpticalSystem\n        An `OpticalSystem` object that defines the optical transformations of the\n        instrument.\n    source : Source\n        A `Source` or `Scene` to objects to model through the instrument.\n    detector : Detector\n        A `Detector` object that defines the detector transformations of the\n        instrument.\n    dithers : Array, radians\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2).\n    \"\"\"\n\n    dithers: Array\n\n    def __init__(\n        self: Telescope,\n        dithers: Array,\n        optics: OpticalSystem,\n        source: Union[list, Source],\n        detector: Detector = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        dithers : Array, radians\n            The array of dithers to apply to the source positions. The shape of the\n            array should be (ndithers, 2).\n        optics : OpticalSystem\n            An `OpticalSystem` object that defines the optical transformations of the\n            instrument.\n        source : Source\n            A `Source` or `Scene` to objects to model through the instrument. Can be\n            either a single `Source` object, or a list of `Source` objects which is\n            then converted to a `Scene` object. The list entries can also be a tuple of\n            (key, source)  in order to specify a key for the source in the scene.\n        detector : Detector = None\n            A `Detector` object that defines the detector transformations of the\n            instrument.\n        \"\"\"\n        self.dithers = np.asarray(dithers, float)\n        if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:\n            raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")\n        super().__init__(optics=optics, source=source, detector=detector)\n\n    def model(self: Telescope, return_psf: bool = False) -&gt; Array:\n        \"\"\"\n        Models the source objects through the optical system and detector, while also\n        applying the dithers to the source positions.\n\n        Parameters\n        ----------\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, PSF\n            if `return_psf` is False, the psf Array is returned.\n            If `return_psf` is True, the PSF object is returned.\n        \"\"\"\n\n        def dither_and_model(dither, instrument):\n            instrument = instrument.add(\"source.position\", dither)\n            return super(type(instrument), instrument).model(return_psf)\n\n        return vmap(dither_and_model, (0, None))(self.dithers, self)\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Telescope.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Raises the attributes from the optics, source and detector to the top level of the class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the sub-dictionaries.</p> Source code in <code>src/dLux/instruments.py</code> <pre><code>def __getattr__(self: Telescope, key: str) -&gt; object:\n    \"\"\"\n    Raises the attributes from the optics, source and detector to the top level of\n    the class.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the sub-dictionaries.\n    \"\"\"\n    for attribute in self.__dict__.values():\n        if hasattr(attribute, key):\n            return getattr(attribute, key)\n    raise AttributeError(\n        f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n    )\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Telescope.__init__","title":"<code>__init__(optics, source, detector=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>optics</code> <code>BaseOpticalSystem</code> <p>An <code>OpticalSystem</code> object that defines the optical transformations of the instrument.</p> required <code>source</code> <code>BaseSource</code> <p>A <code>Source</code> or <code>Scene</code> to objects to model through the instrument. Can be either a single <code>Source</code> object, or a list of <code>Source</code> objects which is then converted to a <code>Scene</code> object. The list entries can also be a tuple of (key, source)  in order to specify a key for the source in the scene.</p> required <code>detector</code> <code>Detector = None</code> <p>A <code>Detector</code> object that defines the detector transformations of the instrument.</p> <code>None</code> Source code in <code>src/dLux/instruments.py</code> <pre><code>def __init__(\n    self: Telescope,\n    optics: OpticalSystem,\n    source: Union[list, Source],\n    detector: Detector = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    optics : OpticalSystem\n        An `OpticalSystem` object that defines the optical transformations of the\n        instrument.\n    source : Source\n        A `Source` or `Scene` to objects to model through the instrument. Can be\n        either a single `Source` object, or a list of `Source` objects which is\n        then converted to a `Scene` object. The list entries can also be a tuple of\n        (key, source)  in order to specify a key for the source in the scene.\n    detector : Detector = None\n        A `Detector` object that defines the detector transformations of the\n        instrument.\n    \"\"\"\n    # Optics\n    if not isinstance(optics, OpticalSystem):\n        raise TypeError(\"optics must be an Optics object.\")\n    self.optics = optics\n\n    # Sources\n    if isinstance(source, Source):\n        self.source = source\n    elif isinstance(source, tuple):\n        # If its a (key, source) tuple, we ignore the key\n        self.source = source[1]\n    else:\n        self.source = Scene(source)\n\n    # Detector\n    if not isinstance(detector, Detector) and detector is not None:\n        raise TypeError(\n            \"detector must be an Detector object. \"\n            f\"Got type {type(detector)}\"\n        )\n    self.detector = detector\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Telescope.model","title":"<code>model(return_psf=False)</code>","text":"<p>Models the source objects through the optical system and detector.</p> <p>Parameters:</p> Name Type Description Default <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, PSF)</code> <p>if <code>return_psf</code> is False, the psf Array is returned. If <code>return_psf</code> is True, the PSF object is returned.</p> Source code in <code>src/dLux/instruments.py</code> <pre><code>def model(self: Telescope, return_psf: bool = False) -&gt; Array:\n    \"\"\"\n    Models the source objects through the optical system and detector.\n\n    Parameters\n    ----------\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, PSF\n        if `return_psf` is False, the psf Array is returned.\n        If `return_psf` is True, the PSF object is returned.\n\n    \"\"\"\n    # Model optics: return_psf=True for more efficient source calculations\n    psfs = self.optics.model(self.source, return_psf=True)\n\n    # Array based output\n    psf = psfs.data.sum(tuple(range(psfs.ndim)))\n    pixel_scale = psfs.pixel_scale.mean()\n\n    # Pass through detector transformations if it exists\n    psf_obj = PSF(psf, pixel_scale)\n    if self.detector is not None:\n        return self.detector.model(psf_obj, return_psf=return_psf)\n\n    # Return psf\n    if return_psf:\n        return psf_obj\n    return psf_obj.data\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Telescope","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Telescope.__getattr__","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Telescope.__init__","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Telescope.model","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Dither.__init__","title":"<code>__init__(dithers, optics, source, detector=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dithers</code> <code>(Array, radians)</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2).</p> required <code>optics</code> <code>BaseOpticalSystem</code> <p>An <code>OpticalSystem</code> object that defines the optical transformations of the instrument.</p> required <code>source</code> <code>BaseSource</code> <p>A <code>Source</code> or <code>Scene</code> to objects to model through the instrument. Can be either a single <code>Source</code> object, or a list of <code>Source</code> objects which is then converted to a <code>Scene</code> object. The list entries can also be a tuple of (key, source)  in order to specify a key for the source in the scene.</p> required <code>detector</code> <code>Detector = None</code> <p>A <code>Detector</code> object that defines the detector transformations of the instrument.</p> <code>None</code> Source code in <code>src/dLux/instruments.py</code> <pre><code>def __init__(\n    self: Telescope,\n    dithers: Array,\n    optics: OpticalSystem,\n    source: Union[list, Source],\n    detector: Detector = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    dithers : Array, radians\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2).\n    optics : OpticalSystem\n        An `OpticalSystem` object that defines the optical transformations of the\n        instrument.\n    source : Source\n        A `Source` or `Scene` to objects to model through the instrument. Can be\n        either a single `Source` object, or a list of `Source` objects which is\n        then converted to a `Scene` object. The list entries can also be a tuple of\n        (key, source)  in order to specify a key for the source in the scene.\n    detector : Detector = None\n        A `Detector` object that defines the detector transformations of the\n        instrument.\n    \"\"\"\n    self.dithers = np.asarray(dithers, float)\n    if self.dithers.ndim != 2 or self.dithers.shape[1] != 2:\n        raise ValueError(\"dithers must be an array of shape (ndithers, 2)\")\n    super().__init__(optics=optics, source=source, detector=detector)\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Dither.model","title":"<code>model(return_psf=False)</code>","text":"<p>Models the source objects through the optical system and detector, while also applying the dithers to the source positions.</p> <p>Parameters:</p> Name Type Description Default <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, PSF)</code> <p>if <code>return_psf</code> is False, the psf Array is returned. If <code>return_psf</code> is True, the PSF object is returned.</p> Source code in <code>src/dLux/instruments.py</code> <pre><code>def model(self: Telescope, return_psf: bool = False) -&gt; Array:\n    \"\"\"\n    Models the source objects through the optical system and detector, while also\n    applying the dithers to the source positions.\n\n    Parameters\n    ----------\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, PSF\n        if `return_psf` is False, the psf Array is returned.\n        If `return_psf` is True, the PSF object is returned.\n    \"\"\"\n\n    def dither_and_model(dither, instrument):\n        instrument = instrument.add(\"source.position\", dither)\n        return super(type(instrument), instrument).model(return_psf)\n\n    return vmap(dither_and_model, (0, None))(self.dithers, self)\n</code></pre>"},{"location":"API/core/instruments/#dLux.instruments.Dither","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Dither.__init__","title":"Instruments","text":""},{"location":"API/core/instruments/#dLux.instruments.Dither.model","title":"Instruments","text":""},{"location":"API/core/optical_systems/","title":"Optical Systems","text":"OpticalSystem <p>             Bases: <code>BaseOpticalSystem</code></p> <p>Base optics class implementing both the <code>propagate</code> and <code>model</code> methods that are universal to all optics classes.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>class OpticalSystem(BaseOpticalSystem):\n    \"\"\"\n    Base optics class implementing both the `propagate` and `model` methods that are\n    universal to all optics classes.\n    \"\"\"\n\n    def propagate(\n        self: OpticalSystem,\n        wavelengths: Array,\n        offset: Array = np.zeros(2),\n        weights: Array = None,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Propagates a Polychromatic point source through the optics.\n\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The wavelengths of the wavefronts to propagate through the optics.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        weights : Array = None\n            The weight of each wavelength. If None, all weights are equal.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        if return_wf and return_psf:\n            raise ValueError(\n                \"return_wf and return_psf cannot both be True. \"\n                \"Please choose one.\"\n            )\n\n        wavelengths = np.atleast_1d(wavelengths)\n        if weights is None:\n            weights = np.ones_like(wavelengths) / len(wavelengths)\n        else:\n            weights = np.atleast_1d(weights)\n\n        # Check wavelengths and weights\n        if weights.shape != wavelengths.shape:\n            raise ValueError(\n                \"wavelengths and weights must have the \"\n                f\"same shape, got {wavelengths.shape} and {weights.shape} \"\n                \"respectively.\"\n            )\n\n        # Check offset\n        offset = np.array(offset) if not isinstance(offset, Array) else offset\n        if offset.shape != (2,):\n            raise ValueError(\n                \"offset must be a 2-element array, got \"\n                f\"shape {offset.shape}.\"\n            )\n\n        # Calculate - note we multiply by sqrt(weight) to account for the\n        # fact that the PSF is the square of the amplitude\n        prop_fn = lambda wavelength, weight: self.propagate_mono(\n            wavelength, offset, return_wf=True\n        ).multiply(\"amplitude\", weight**0.5)\n        wf = filter_vmap(prop_fn)(wavelengths, weights)\n\n        # Return PSF, Wavefront, or array psf\n        if return_wf:\n            return wf\n        if return_psf:\n            return PSF(wf.psf.sum(0), wf.pixel_scale.mean())\n        return wf.psf.sum(0)\n\n    def model(\n        self: OpticalSystem,\n        source: Source,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the input Source object through the optics.\n\n        Parameters\n        ----------\n        source : Source\n            The Source object to model through the optics.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        return source.model(self, return_wf, return_psf)\n</code></pre> AngularOpticalSystem <p>             Bases: <code>ParametricOpticalSystem</code>, <code>LayeredOpticalSystem</code></p> <p>An extension to the LayeredOpticalSystem class that propagates a wavefront to an image plane with <code>psf_pixel_scale</code> in units of arcseconds.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> <code>diameter</code> <code>(Array, metres)</code> <p>The diameter of the initial wavefront to propagate.</p> <code>layers</code> <code>OrderedDict</code> <p>A series of <code>OpticalLayer</code> transformations to apply to wavefronts.</p> <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> <code>psf_pixel_scale</code> <code>(float, arcseconds)</code> <p>The pixel scale of the final PSF.</p> <code>oversample</code> <code>int</code> <p>The oversampling factor of the final PSF. Decreases the psf_pixel_scale parameter while increasing the psf_npixels parameter.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>class AngularOpticalSystem(ParametricOpticalSystem, LayeredOpticalSystem):\n    \"\"\"\n    An extension to the LayeredOpticalSystem class that propagates a wavefront to an\n    image plane with `psf_pixel_scale` in units of arcseconds.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/AngularOpticalSystem.png)\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    layers : OrderedDict\n        A series of `OpticalLayer` transformations to apply to wavefronts.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, arcseconds\n        The pixel scale of the final PSF.\n    oversample : int\n        The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n        parameter while increasing the psf_npixels parameter.\n    \"\"\"\n\n    def __init__(\n        self: OpticalSystem,\n        wf_npixels: int,\n        diameter: float,\n        layers: list[OpticalLayer, tuple],\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        oversample: int = 1,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        layers : list[OpticalLayer, tuple]\n            A list of `OpticalLayer` transformations to apply to wavefronts. The list\n            entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n            specify a key for the layer in the layers dictionary.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, arcseconds\n            The pixel scale of the final PSF in units of arcseconds.\n        oversample : int\n            The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n            parameter while increasing the psf_npixels parameter.\n        \"\"\"\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            layers=layers,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            oversample=oversample,\n        )\n\n    def propagate_mono(\n        self: OpticalSystem,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : float, metres\n            The wavelength of the wavefront to propagate through the optical layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        return_wf: bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront\n            if `return_wf` is False, returns the psf Array.\n            if `return_wf` is True, returns the Wavefront object.\n        \"\"\"\n        wf = super().propagate_mono(wavelength, offset, return_wf=True)\n\n        # Propagate\n        true_pixel_scale = self.psf_pixel_scale / self.oversample\n        pixel_scale = dlu.arcsec2rad(true_pixel_scale)\n        psf_npixels = self.psf_npixels * self.oversample\n        wf = wf.propagate(psf_npixels, pixel_scale)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n</code></pre> CartesianOpticalSystem <p>             Bases: <code>ParametricOpticalSystem</code>, <code>LayeredOpticalSystem</code></p> <p>An extension to the LayeredOpticalSystem class that propagates a wavefront to an image plane with <code>psf_pixel_scale</code> in units of microns.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> <code>diameter</code> <code>(Array, metres)</code> <p>The diameter of the initial wavefront to propagate.</p> <code>layers</code> <code>OrderedDict</code> <p>A series of <code>OpticalLayer</code> transformations to apply to wavefronts.</p> <code>focal_length</code> <code>(float, metres)</code> <p>The focal length of the system.</p> <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> <code>psf_pixel_scale</code> <code>(float, microns)</code> <p>The pixel scale of the final PSF.</p> <code>oversample</code> <code>int</code> <p>The oversampling factor of the final PSF. Decreases the psf_pixel_scale parameter while increasing the psf_npixels parameter.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>class CartesianOpticalSystem(ParametricOpticalSystem, LayeredOpticalSystem):\n    \"\"\"\n    An extension to the LayeredOpticalSystem class that propagates a wavefront to an\n    image plane with `psf_pixel_scale` in units of microns.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/CartesianOpticalSystem.png)\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    layers : OrderedDict\n        A series of `OpticalLayer` transformations to apply to wavefronts.\n    focal_length : float, metres\n        The focal length of the system.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, microns\n        The pixel scale of the final PSF.\n    oversample : int\n        The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n        parameter while increasing the psf_npixels parameter.\n    \"\"\"\n\n    focal_length: None\n\n    def __init__(\n        self: OpticalSystem,\n        wf_npixels: int,\n        diameter: float,\n        layers: list[OpticalLayer, tuple],\n        focal_length: float,\n        psf_npixels: int,\n        psf_pixel_scale: float,\n        oversample: int = 1,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The number of pixels representing the wavefront.\n        diameter : Array, metres\n            The diameter of the initial wavefront to propagate.\n        layers : list[OpticalLayer, tuple]\n            A list of `OpticalLayer` transformations to apply to wavefronts. The list\n            entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n            specify a key for the layer in the layers dictionary.\n        focal_length : float, metres\n            The focal length of the system.\n        psf_npixels : int\n            The number of pixels of the final PSF.\n        psf_pixel_scale : float, microns\n            The pixel scale of the final PSF in units of microns.\n        oversample : int\n            The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n            parameter while increasing the psf_npixels parameter.\n        \"\"\"\n        self.focal_length = float(focal_length)\n\n        super().__init__(\n            wf_npixels=wf_npixels,\n            diameter=diameter,\n            layers=layers,\n            psf_npixels=psf_npixels,\n            psf_pixel_scale=psf_pixel_scale,\n            oversample=oversample,\n        )\n\n    def propagate_mono(\n        self: OpticalSystem,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : float, metres\n            The wavelength of the wavefront to propagate through the optical layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        return_wf: bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront\n            if `return_wf` is False, returns the psf Array.\n            if `return_wf` is True, returns the Wavefront object.\n        \"\"\"\n        wf = super().propagate_mono(wavelength, offset, return_wf=True)\n\n        # Propagate\n        true_pixel_scale = self.psf_pixel_scale / self.oversample\n        pixel_scale = 1e-6 * true_pixel_scale\n        psf_npixels = self.psf_npixels * self.oversample\n        wf = wf.propagate(psf_npixels, pixel_scale, self.focal_length)\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wf\n        return wf.psf\n</code></pre> LayeredOpticalSystem <p>             Bases: <code>OpticalSystem</code></p> <p>A flexible optical system that allows for the arbitrary chaining of OpticalLayers.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>wf_npixels</code> <code>int</code> <p>The size of the initial wavefront to propagate.</p> <code>diameter</code> <code>(float, metres)</code> <p>The diameter of the wavefront to propagate.</p> <code>layers</code> <code>OrderedDict</code> <p>A series of <code>OpticalLayer</code> transformations to apply to wavefronts.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>class LayeredOpticalSystem(OpticalSystem):\n    \"\"\"\n    A flexible optical system that allows for the arbitrary chaining of OpticalLayers.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/LayeredOpticalSystem.png)\n\n    Attributes\n    ----------\n    wf_npixels : int\n        The size of the initial wavefront to propagate.\n    diameter : float, metres\n        The diameter of the wavefront to propagate.\n    layers : OrderedDict\n        A series of `OpticalLayer` transformations to apply to wavefronts.\n    \"\"\"\n\n    wf_npixels: int\n    diameter: float\n    layers: OrderedDict\n\n    def __init__(\n        self: OpticalSystem,\n        wf_npixels: int,\n        diameter: float,\n        layers: list[OpticalLayer, tuple],\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wf_npixels : int\n            The size of the initial wavefront to propagate.\n        diameter : float\n            The diameter of the wavefront to propagate.\n        layers : list[OpticalLayer, tuple]\n            A list of `OpticalLayer` transformations to apply to wavefronts. The list\n            entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n            specify a key for the layer in the layers dictionary.\n        \"\"\"\n        self.wf_npixels = int(wf_npixels)\n        self.diameter = float(diameter)\n        self.layers = dlu.list2dictionary(layers, True, OpticalLayer)\n\n    def __getattr__(self: OpticalSystem, key: str) -&gt; Any:\n        \"\"\"\n        Raises both the individual layers and the attributes of the layers via\n        their keys.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        for layer in list(self.layers.values()):\n            if hasattr(layer, key):\n                return getattr(layer, key)\n        raise AttributeError(\n            f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n        )\n\n    def propagate_mono(\n        self: OpticalSystem,\n        wavelength: Array,\n        offset: Array = np.zeros(2),\n        return_wf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : float, metres\n            The wavelength of the wavefront to propagate through the optical layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        return_wf: bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront\n            if `return_wf` is False, returns the psf Array.\n            if `return_wf` is True, returns the Wavefront object.\n        \"\"\"\n        # Initialise wavefront\n        wavefront = Wavefront(self.wf_npixels, self.diameter, wavelength)\n        wavefront = wavefront.tilt(offset)\n\n        # Apply layers\n        for layer in list(self.layers.values()):\n            wavefront *= layer\n\n        # Return PSF or Wavefront\n        if return_wf:\n            return wavefront\n        return wavefront.psf\n\n    def insert_layer(\n        self: OpticalSystem, layer: Union[OpticalLayer, tuple], index: int\n    ) -&gt; OpticalSystem:\n        \"\"\"\n        Inserts a layer into the layers dictionary at a specified index. This function\n        calls the list2dictionary function to ensure all keys remain unique. Note that\n        this can result in some keys being modified if they are duplicates. The input\n        'layer' can be a tuple of (key, layer) to specify a key, else the key is taken\n        as the class name of the layer.\n\n        Parameters\n        ----------\n        layer : Any\n            The layer to be inserted.\n        index : int\n            The index at which to insert the layer.\n\n        Returns\n        -------\n        optical_system : OpticalSystem\n            The updated optical system.\n        \"\"\"\n        return self.set(\n            \"layers\", dlu.insert_layer(self.layers, layer, index, OpticalLayer)\n        )\n\n    def remove_layer(self: OpticalLayer, key: str) -&gt; OpticalSystem:\n        \"\"\"\n        Removes a layer from the layers dictionary, specified by its key.\n\n        Parameters\n        ----------\n        key : str\n            The key of the layer to be removed.\n\n        Returns\n        -------\n        optical_system : OpticalSystem\n            The updated optical system.\n        \"\"\"\n        return self.set(\"layers\", dlu.remove_layer(self.layers, key))\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.OpticalSystem.model","title":"<code>model(source, return_wf=False, return_psf=False)</code>","text":"<p>Models the input Source object through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>BaseSource</code> <p>The Source object to model through the optics.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def model(\n    self: OpticalSystem,\n    source: Source,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the input Source object through the optics.\n\n    Parameters\n    ----------\n    source : Source\n        The Source object to model through the optics.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    return source.model(self, return_wf, return_psf)\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.OpticalSystem.propagate","title":"<code>propagate(wavelengths, offset=np.zeros(2), weights=None, return_wf=False, return_psf=False)</code>","text":"<p>Propagates a Polychromatic point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>(Array, metres)</code> <p>The wavelengths of the wavefronts to propagate through the optics.</p> required <code>offset</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>zeros(2)</code> <code>weights</code> <code>Array = None</code> <p>The weight of each wavelength. If None, all weights are equal.</p> <code>None</code> <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def propagate(\n    self: OpticalSystem,\n    wavelengths: Array,\n    offset: Array = np.zeros(2),\n    weights: Array = None,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates a Polychromatic point source through the optics.\n\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The wavelengths of the wavefronts to propagate through the optics.\n    offset : Array, radians = np.zeros(2)\n        The (x, y) offset from the optical axis of the source.\n    weights : Array = None\n        The weight of each wavelength. If None, all weights are equal.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    if return_wf and return_psf:\n        raise ValueError(\n            \"return_wf and return_psf cannot both be True. \"\n            \"Please choose one.\"\n        )\n\n    wavelengths = np.atleast_1d(wavelengths)\n    if weights is None:\n        weights = np.ones_like(wavelengths) / len(wavelengths)\n    else:\n        weights = np.atleast_1d(weights)\n\n    # Check wavelengths and weights\n    if weights.shape != wavelengths.shape:\n        raise ValueError(\n            \"wavelengths and weights must have the \"\n            f\"same shape, got {wavelengths.shape} and {weights.shape} \"\n            \"respectively.\"\n        )\n\n    # Check offset\n    offset = np.array(offset) if not isinstance(offset, Array) else offset\n    if offset.shape != (2,):\n        raise ValueError(\n            \"offset must be a 2-element array, got \"\n            f\"shape {offset.shape}.\"\n        )\n\n    # Calculate - note we multiply by sqrt(weight) to account for the\n    # fact that the PSF is the square of the amplitude\n    prop_fn = lambda wavelength, weight: self.propagate_mono(\n        wavelength, offset, return_wf=True\n    ).multiply(\"amplitude\", weight**0.5)\n    wf = filter_vmap(prop_fn)(wavelengths, weights)\n\n    # Return PSF, Wavefront, or array psf\n    if return_wf:\n        return wf\n    if return_psf:\n        return PSF(wf.psf.sum(0), wf.pixel_scale.mean())\n    return wf.psf.sum(0)\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.OpticalSystem","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.OpticalSystem.model","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.OpticalSystem.propagate","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.AngularOpticalSystem.__init__","title":"<code>__init__(wf_npixels, diameter, layers, psf_npixels, psf_pixel_scale, oversample=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> required <code>diameter</code> <code>(Array, metres)</code> <p>The diameter of the initial wavefront to propagate.</p> required <code>layers</code> <code>list[OpticalLayer, tuple]</code> <p>A list of <code>OpticalLayer</code> transformations to apply to wavefronts. The list entries can be either <code>OpticalLayer</code> objects or tuples of (key, layer) to specify a key for the layer in the layers dictionary.</p> required <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> required <code>psf_pixel_scale</code> <code>(float, arcseconds)</code> <p>The pixel scale of the final PSF in units of arcseconds.</p> required <code>oversample</code> <code>int</code> <p>The oversampling factor of the final PSF. Decreases the psf_pixel_scale parameter while increasing the psf_npixels parameter.</p> <code>1</code> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def __init__(\n    self: OpticalSystem,\n    wf_npixels: int,\n    diameter: float,\n    layers: list[OpticalLayer, tuple],\n    psf_npixels: int,\n    psf_pixel_scale: float,\n    oversample: int = 1,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    layers : list[OpticalLayer, tuple]\n        A list of `OpticalLayer` transformations to apply to wavefronts. The list\n        entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n        specify a key for the layer in the layers dictionary.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, arcseconds\n        The pixel scale of the final PSF in units of arcseconds.\n    oversample : int\n        The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n        parameter while increasing the psf_npixels parameter.\n    \"\"\"\n    super().__init__(\n        wf_npixels=wf_npixels,\n        diameter=diameter,\n        layers=layers,\n        psf_npixels=psf_npixels,\n        psf_pixel_scale=psf_pixel_scale,\n        oversample=oversample,\n    )\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.AngularOpticalSystem.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>(float, metres)</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>zeros(2)</code> <code>return_wf</code> <code>bool</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront)</code> <p>if <code>return_wf</code> is False, returns the psf Array. if <code>return_wf</code> is True, returns the Wavefront object.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def propagate_mono(\n    self: OpticalSystem,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : float, metres\n        The wavelength of the wavefront to propagate through the optical layers.\n    offset : Array, radians = np.zeros(2)\n        The (x, y) offset from the optical axis of the source.\n    return_wf: bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront\n        if `return_wf` is False, returns the psf Array.\n        if `return_wf` is True, returns the Wavefront object.\n    \"\"\"\n    wf = super().propagate_mono(wavelength, offset, return_wf=True)\n\n    # Propagate\n    true_pixel_scale = self.psf_pixel_scale / self.oversample\n    pixel_scale = dlu.arcsec2rad(true_pixel_scale)\n    psf_npixels = self.psf_npixels * self.oversample\n    wf = wf.propagate(psf_npixels, pixel_scale)\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wf\n    return wf.psf\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.AngularOpticalSystem","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.AngularOpticalSystem.__init__","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.AngularOpticalSystem.propagate_mono","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.CartesianOpticalSystem.__init__","title":"<code>__init__(wf_npixels, diameter, layers, focal_length, psf_npixels, psf_pixel_scale, oversample=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The number of pixels representing the wavefront.</p> required <code>diameter</code> <code>(Array, metres)</code> <p>The diameter of the initial wavefront to propagate.</p> required <code>layers</code> <code>list[OpticalLayer, tuple]</code> <p>A list of <code>OpticalLayer</code> transformations to apply to wavefronts. The list entries can be either <code>OpticalLayer</code> objects or tuples of (key, layer) to specify a key for the layer in the layers dictionary.</p> required <code>focal_length</code> <code>(float, metres)</code> <p>The focal length of the system.</p> required <code>psf_npixels</code> <code>int</code> <p>The number of pixels of the final PSF.</p> required <code>psf_pixel_scale</code> <code>(float, microns)</code> <p>The pixel scale of the final PSF in units of microns.</p> required <code>oversample</code> <code>int</code> <p>The oversampling factor of the final PSF. Decreases the psf_pixel_scale parameter while increasing the psf_npixels parameter.</p> <code>1</code> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def __init__(\n    self: OpticalSystem,\n    wf_npixels: int,\n    diameter: float,\n    layers: list[OpticalLayer, tuple],\n    focal_length: float,\n    psf_npixels: int,\n    psf_pixel_scale: float,\n    oversample: int = 1,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The number of pixels representing the wavefront.\n    diameter : Array, metres\n        The diameter of the initial wavefront to propagate.\n    layers : list[OpticalLayer, tuple]\n        A list of `OpticalLayer` transformations to apply to wavefronts. The list\n        entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n        specify a key for the layer in the layers dictionary.\n    focal_length : float, metres\n        The focal length of the system.\n    psf_npixels : int\n        The number of pixels of the final PSF.\n    psf_pixel_scale : float, microns\n        The pixel scale of the final PSF in units of microns.\n    oversample : int\n        The oversampling factor of the final PSF. Decreases the psf_pixel_scale\n        parameter while increasing the psf_npixels parameter.\n    \"\"\"\n    self.focal_length = float(focal_length)\n\n    super().__init__(\n        wf_npixels=wf_npixels,\n        diameter=diameter,\n        layers=layers,\n        psf_npixels=psf_npixels,\n        psf_pixel_scale=psf_pixel_scale,\n        oversample=oversample,\n    )\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.CartesianOpticalSystem.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>(float, metres)</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>zeros(2)</code> <code>return_wf</code> <code>bool</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront)</code> <p>if <code>return_wf</code> is False, returns the psf Array. if <code>return_wf</code> is True, returns the Wavefront object.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def propagate_mono(\n    self: OpticalSystem,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : float, metres\n        The wavelength of the wavefront to propagate through the optical layers.\n    offset : Array, radians = np.zeros(2)\n        The (x, y) offset from the optical axis of the source.\n    return_wf: bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront\n        if `return_wf` is False, returns the psf Array.\n        if `return_wf` is True, returns the Wavefront object.\n    \"\"\"\n    wf = super().propagate_mono(wavelength, offset, return_wf=True)\n\n    # Propagate\n    true_pixel_scale = self.psf_pixel_scale / self.oversample\n    pixel_scale = 1e-6 * true_pixel_scale\n    psf_npixels = self.psf_npixels * self.oversample\n    wf = wf.propagate(psf_npixels, pixel_scale, self.focal_length)\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wf\n    return wf.psf\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.CartesianOpticalSystem","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.CartesianOpticalSystem.__init__","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.CartesianOpticalSystem.propagate_mono","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Raises both the individual layers and the attributes of the layers via their keys.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def __getattr__(self: OpticalSystem, key: str) -&gt; Any:\n    \"\"\"\n    Raises both the individual layers and the attributes of the layers via\n    their keys.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the layers dictionary.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the layers dictionary.\n    \"\"\"\n    if key in self.layers.keys():\n        return self.layers[key]\n    for layer in list(self.layers.values()):\n        if hasattr(layer, key):\n            return getattr(layer, key)\n    raise AttributeError(\n        f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n    )\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.__init__","title":"<code>__init__(wf_npixels, diameter, layers)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wf_npixels</code> <code>int</code> <p>The size of the initial wavefront to propagate.</p> required <code>diameter</code> <code>float</code> <p>The diameter of the wavefront to propagate.</p> required <code>layers</code> <code>list[OpticalLayer, tuple]</code> <p>A list of <code>OpticalLayer</code> transformations to apply to wavefronts. The list entries can be either <code>OpticalLayer</code> objects or tuples of (key, layer) to specify a key for the layer in the layers dictionary.</p> required Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def __init__(\n    self: OpticalSystem,\n    wf_npixels: int,\n    diameter: float,\n    layers: list[OpticalLayer, tuple],\n):\n    \"\"\"\n    Parameters\n    ----------\n    wf_npixels : int\n        The size of the initial wavefront to propagate.\n    diameter : float\n        The diameter of the wavefront to propagate.\n    layers : list[OpticalLayer, tuple]\n        A list of `OpticalLayer` transformations to apply to wavefronts. The list\n        entries can be either `OpticalLayer` objects or tuples of (key, layer) to\n        specify a key for the layer in the layers dictionary.\n    \"\"\"\n    self.wf_npixels = int(wf_npixels)\n    self.diameter = float(diameter)\n    self.layers = dlu.list2dictionary(layers, True, OpticalLayer)\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.insert_layer","title":"<code>insert_layer(layer, index)</code>","text":"<p>Inserts a layer into the layers dictionary at a specified index. This function calls the list2dictionary function to ensure all keys remain unique. Note that this can result in some keys being modified if they are duplicates. The input 'layer' can be a tuple of (key, layer) to specify a key, else the key is taken as the class name of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Any</code> <p>The layer to be inserted.</p> required <code>index</code> <code>int</code> <p>The index at which to insert the layer.</p> required <p>Returns:</p> Name Type Description <code>optical_system</code> <code>OpticalSystem</code> <p>The updated optical system.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def insert_layer(\n    self: OpticalSystem, layer: Union[OpticalLayer, tuple], index: int\n) -&gt; OpticalSystem:\n    \"\"\"\n    Inserts a layer into the layers dictionary at a specified index. This function\n    calls the list2dictionary function to ensure all keys remain unique. Note that\n    this can result in some keys being modified if they are duplicates. The input\n    'layer' can be a tuple of (key, layer) to specify a key, else the key is taken\n    as the class name of the layer.\n\n    Parameters\n    ----------\n    layer : Any\n        The layer to be inserted.\n    index : int\n        The index at which to insert the layer.\n\n    Returns\n    -------\n    optical_system : OpticalSystem\n        The updated optical system.\n    \"\"\"\n    return self.set(\n        \"layers\", dlu.insert_layer(self.layers, layer, index, OpticalLayer)\n    )\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>(float, metres)</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>zeros(2)</code> <code>return_wf</code> <code>bool</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront)</code> <p>if <code>return_wf</code> is False, returns the psf Array. if <code>return_wf</code> is True, returns the Wavefront object.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def propagate_mono(\n    self: OpticalSystem,\n    wavelength: Array,\n    offset: Array = np.zeros(2),\n    return_wf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : float, metres\n        The wavelength of the wavefront to propagate through the optical layers.\n    offset : Array, radians = np.zeros(2)\n        The (x, y) offset from the optical axis of the source.\n    return_wf: bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront\n        if `return_wf` is False, returns the psf Array.\n        if `return_wf` is True, returns the Wavefront object.\n    \"\"\"\n    # Initialise wavefront\n    wavefront = Wavefront(self.wf_npixels, self.diameter, wavelength)\n    wavefront = wavefront.tilt(offset)\n\n    # Apply layers\n    for layer in list(self.layers.values()):\n        wavefront *= layer\n\n    # Return PSF or Wavefront\n    if return_wf:\n        return wavefront\n    return wavefront.psf\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.remove_layer","title":"<code>remove_layer(key)</code>","text":"<p>Removes a layer from the layers dictionary, specified by its key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the layer to be removed.</p> required <p>Returns:</p> Name Type Description <code>optical_system</code> <code>OpticalSystem</code> <p>The updated optical system.</p> Source code in <code>src/dLux/optical_systems.py</code> <pre><code>def remove_layer(self: OpticalLayer, key: str) -&gt; OpticalSystem:\n    \"\"\"\n    Removes a layer from the layers dictionary, specified by its key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the layer to be removed.\n\n    Returns\n    -------\n    optical_system : OpticalSystem\n        The updated optical system.\n    \"\"\"\n    return self.set(\"layers\", dlu.remove_layer(self.layers, key))\n</code></pre>"},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.__getattr__","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.__init__","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.insert_layer","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.propagate_mono","title":"Optical Systems","text":""},{"location":"API/core/optical_systems/#dLux.optical_systems.LayeredOpticalSystem.remove_layer","title":"Optical Systems","text":""},{"location":"API/core/psfs/","title":"PSFs","text":"PSF <p>             Bases: <code>Base</code></p> <p>A simple class that holds the state of some PSF as it it transformed by detector layers.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Array</code> <p>The psf as it is transformed by the detector.</p> <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>class PSF(Base):\n    \"\"\"\n    A simple class that holds the state of some PSF as it it transformed by detector\n    layers.\n\n    Attributes\n    ----------\n    data : Array\n        The psf as it is transformed by the detector.\n    pixel_scale : Array\n        The pixel scale of the psf.\n    \"\"\"\n\n    data: Array\n    pixel_scale: Array\n\n    def __init__(self: PSF, data: Array, pixel_scale: Array):\n        \"\"\"\n        Parameters\n        ----------\n        data : Array\n            The psf to be transformed by the detector.\n        pixel_scale : Array\n            The pixel scale of the psf.\n        \"\"\"\n        self.data = np.asarray(data, dtype=float)\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n\n    @property\n    def npixels(self: PSF) -&gt; int:\n        \"\"\"\n        Returns the side length of the arrays currently representing the psf.\n\n        Returns\n        -------\n        npixels : int\n            The number of pixels that represent the `PSF`.\n        \"\"\"\n        return self.data.shape[-1]\n\n    @property\n    def ndim(self: PSF) -&gt; int:\n        \"\"\"\n        Returns the number of 'dimensions' of the psf. This is used to track the\n        vectorised version of the psf returned from vmapping.\n\n        Returns\n        -------\n        ndim : int\n            The 'dimensionality' of dimensions of the psf.\n        \"\"\"\n        return self.pixel_scale.ndim\n\n    def downsample(self: PSF, n: int) -&gt; PSF:\n        \"\"\"\n        Downsamples the psf by a factor of n. This is done by summing the psf pixels in\n        n x n blocks.\n\n        Parameters\n        ----------\n        n : int\n            The factor by which to downsample the psf.\n\n        Returns\n        -------\n        psf : PSF\n            The downsampled psf.\n        \"\"\"\n        return self.set(\"data\", dlu.downsample(self.data, n, mean=False))\n\n    def convolve(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Convolves the psf with some input array.\n\n        Parameters\n        ----------\n        other : Array\n            The psf to convolve with.\n\n        Returns\n        -------\n        psf : PSF\n            The convolved psf.\n        \"\"\"\n        return self.set(\"data\", convolve(self.data, other, mode=\"same\"))\n\n    def rotate(self: PSF, angle: float, order: int = 1) -&gt; PSF:\n        \"\"\"\n        Rotates the psf by a given angle via interpolation.\n\n        Parameters\n        ----------\n        angle : float\n            The angle by which to rotate the psf.\n        order : int = 1\n            The order of the interpolation method to use.\n\n        Returns\n        -------\n        psf : PSF\n            The rotated psf.\n        \"\"\"\n        return self.set(\"data\", dlu.rotate(self.data, angle, order=order))\n\n    def resize(self: PSF, npixels: int) -&gt; PSF:\n        \"\"\"\n        Resizes the psf via a zero-padding or cropping operation.\n\n        Parameters\n        ----------\n        npixels : int\n            The size to resize the psf to.\n\n        Returns\n        -------\n        psf : PSF\n            The resized psf.\n        \"\"\"\n        return self.set(\"data\", dlu.resize(self.data, npixels))\n\n    def flip(self: PSF, axis: tuple) -&gt; PSF:\n        \"\"\"\n        Flips the psf along the specified axes. Note we use 'ij' indexing, so axis 0 is\n        the y-axis and axis 1 is the x-axis.\n\n        Parameters\n        ----------\n        axis : tuple\n            The axes along which to flip the PSF.\n\n        Returns\n        -------\n        psf : PSF\n            The new flipped PSF.\n        \"\"\"\n        return self.set(\"data\", np.flip(self.data, axis))\n\n    def __mul__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the multiplication operator. This allows for the\n        multiplication of the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to multiply the psf by.\n\n        Returns\n        -------\n        psf : PSF\n            The multiplied psf.\n        \"\"\"\n        return self.multiply(\"data\", other)\n\n    def __imul__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the inplace multiplication operator. This allows for the\n        inplace multiplication of the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to multiply the psf by.\n\n        Returns\n        -------\n        psf : PSF\n            The multiplied psf.\n        \"\"\"\n        return self.__mul__(other)\n\n    def __add__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the addition operator. This allows for the addition of the psf\n        by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to add to the psf.\n\n        Returns\n        -------\n        psf : PSF\n            The added psf.\n        \"\"\"\n        return self.add(\"data\", other)\n\n    def __iadd__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the inplace addition operator. This allows for the inplace\n        addition of the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to add to the psf.\n\n        Returns\n        -------\n        psf : PSF\n            The added psf.\n        \"\"\"\n        return self.__add__(other)\n\n    def __sub__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the subtraction operator. This allows for the subtraction of\n        the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to subtract from the psf.\n\n        Returns\n        -------\n        psf : PSF\n            The subtracted psf.\n        \"\"\"\n        return self.add(\"data\", -other)\n\n    def __isub__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the inplace subtraction operator. This allows for the inplace\n        subtraction of the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to subtract from the psf.\n\n        Returns\n        -------\n        psf : PSF\n            The subtracted psf.\n        \"\"\"\n        return self.__sub__(other)\n\n    def __truediv__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the division operator. This allows for the division of the psf\n        by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to divide the psf by.\n\n        Returns\n        -------\n        psf : PSF\n            The divided psf.\n        \"\"\"\n        return self.divide(\"data\", other)\n\n    def __itruediv__(self: PSF, other: Array) -&gt; PSF:\n        \"\"\"\n        Magic method for the inplace division operator. This allows for the inplace\n        division of the psf by a scalar or another psf.\n\n        Parameters\n        ----------\n        other : Array\n            The scalar or psf to divide the psf by.\n\n        Returns\n        -------\n        psf : PSF\n            The divided psf.\n        \"\"\"\n        return self.__truediv__(other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Returns the number of 'dimensions' of the psf. This is used to track the vectorised version of the psf returned from vmapping.</p> <p>Returns:</p> Name Type Description <code>ndim</code> <code>int</code> <p>The 'dimensionality' of dimensions of the psf.</p>"},{"location":"API/core/psfs/#dLux.psfs.PSF.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the psf.</p> <p>Returns:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels that represent the <code>PSF</code>.</p>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__add__","title":"<code>__add__(other)</code>","text":"<p>Magic method for the addition operator. This allows for the addition of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to add to the psf.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The added psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __add__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the addition operator. This allows for the addition of the psf\n    by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to add to the psf.\n\n    Returns\n    -------\n    psf : PSF\n        The added psf.\n    \"\"\"\n    return self.add(\"data\", other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Magic method for the inplace addition operator. This allows for the inplace addition of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to add to the psf.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The added psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __iadd__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the inplace addition operator. This allows for the inplace\n    addition of the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to add to the psf.\n\n    Returns\n    -------\n    psf : PSF\n        The added psf.\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__imul__","title":"<code>__imul__(other)</code>","text":"<p>Magic method for the inplace multiplication operator. This allows for the inplace multiplication of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to multiply the psf by.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The multiplied psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __imul__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the inplace multiplication operator. This allows for the\n    inplace multiplication of the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to multiply the psf by.\n\n    Returns\n    -------\n    psf : PSF\n        The multiplied psf.\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__init__","title":"<code>__init__(data, pixel_scale)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>Array</code> <p>The psf to be transformed by the detector.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale of the psf.</p> required Source code in <code>src/dLux/psfs.py</code> <pre><code>def __init__(self: PSF, data: Array, pixel_scale: Array):\n    \"\"\"\n    Parameters\n    ----------\n    data : Array\n        The psf to be transformed by the detector.\n    pixel_scale : Array\n        The pixel scale of the psf.\n    \"\"\"\n    self.data = np.asarray(data, dtype=float)\n    self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Magic method for the inplace subtraction operator. This allows for the inplace subtraction of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to subtract from the psf.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The subtracted psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __isub__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the inplace subtraction operator. This allows for the inplace\n    subtraction of the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to subtract from the psf.\n\n    Returns\n    -------\n    psf : PSF\n        The subtracted psf.\n    \"\"\"\n    return self.__sub__(other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__itruediv__","title":"<code>__itruediv__(other)</code>","text":"<p>Magic method for the inplace division operator. This allows for the inplace division of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to divide the psf by.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The divided psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __itruediv__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the inplace division operator. This allows for the inplace\n    division of the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to divide the psf by.\n\n    Returns\n    -------\n    psf : PSF\n        The divided psf.\n    \"\"\"\n    return self.__truediv__(other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Magic method for the multiplication operator. This allows for the multiplication of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to multiply the psf by.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The multiplied psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __mul__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the multiplication operator. This allows for the\n    multiplication of the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to multiply the psf by.\n\n    Returns\n    -------\n    psf : PSF\n        The multiplied psf.\n    \"\"\"\n    return self.multiply(\"data\", other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Magic method for the subtraction operator. This allows for the subtraction of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to subtract from the psf.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The subtracted psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __sub__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the subtraction operator. This allows for the subtraction of\n    the psf by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to subtract from the psf.\n\n    Returns\n    -------\n    psf : PSF\n        The subtracted psf.\n    \"\"\"\n    return self.add(\"data\", -other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Magic method for the division operator. This allows for the division of the psf by a scalar or another psf.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The scalar or psf to divide the psf by.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The divided psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def __truediv__(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Magic method for the division operator. This allows for the division of the psf\n    by a scalar or another psf.\n\n    Parameters\n    ----------\n    other : Array\n        The scalar or psf to divide the psf by.\n\n    Returns\n    -------\n    psf : PSF\n        The divided psf.\n    \"\"\"\n    return self.divide(\"data\", other)\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.convolve","title":"<code>convolve(other)</code>","text":"<p>Convolves the psf with some input array.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Array</code> <p>The psf to convolve with.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The convolved psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def convolve(self: PSF, other: Array) -&gt; PSF:\n    \"\"\"\n    Convolves the psf with some input array.\n\n    Parameters\n    ----------\n    other : Array\n        The psf to convolve with.\n\n    Returns\n    -------\n    psf : PSF\n        The convolved psf.\n    \"\"\"\n    return self.set(\"data\", convolve(self.data, other, mode=\"same\"))\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.downsample","title":"<code>downsample(n)</code>","text":"<p>Downsamples the psf by a factor of n. This is done by summing the psf pixels in n x n blocks.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The factor by which to downsample the psf.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The downsampled psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def downsample(self: PSF, n: int) -&gt; PSF:\n    \"\"\"\n    Downsamples the psf by a factor of n. This is done by summing the psf pixels in\n    n x n blocks.\n\n    Parameters\n    ----------\n    n : int\n        The factor by which to downsample the psf.\n\n    Returns\n    -------\n    psf : PSF\n        The downsampled psf.\n    \"\"\"\n    return self.set(\"data\", dlu.downsample(self.data, n, mean=False))\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.flip","title":"<code>flip(axis)</code>","text":"<p>Flips the psf along the specified axes. Note we use 'ij' indexing, so axis 0 is the y-axis and axis 1 is the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>tuple</code> <p>The axes along which to flip the PSF.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The new flipped PSF.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def flip(self: PSF, axis: tuple) -&gt; PSF:\n    \"\"\"\n    Flips the psf along the specified axes. Note we use 'ij' indexing, so axis 0 is\n    the y-axis and axis 1 is the x-axis.\n\n    Parameters\n    ----------\n    axis : tuple\n        The axes along which to flip the PSF.\n\n    Returns\n    -------\n    psf : PSF\n        The new flipped PSF.\n    \"\"\"\n    return self.set(\"data\", np.flip(self.data, axis))\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.resize","title":"<code>resize(npixels)</code>","text":"<p>Resizes the psf via a zero-padding or cropping operation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The size to resize the psf to.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The resized psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def resize(self: PSF, npixels: int) -&gt; PSF:\n    \"\"\"\n    Resizes the psf via a zero-padding or cropping operation.\n\n    Parameters\n    ----------\n    npixels : int\n        The size to resize the psf to.\n\n    Returns\n    -------\n    psf : PSF\n        The resized psf.\n    \"\"\"\n    return self.set(\"data\", dlu.resize(self.data, npixels))\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF.rotate","title":"<code>rotate(angle, order=1)</code>","text":"<p>Rotates the psf by a given angle via interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle by which to rotate the psf.</p> required <code>order</code> <code>int = 1</code> <p>The order of the interpolation method to use.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The rotated psf.</p> Source code in <code>src/dLux/psfs.py</code> <pre><code>def rotate(self: PSF, angle: float, order: int = 1) -&gt; PSF:\n    \"\"\"\n    Rotates the psf by a given angle via interpolation.\n\n    Parameters\n    ----------\n    angle : float\n        The angle by which to rotate the psf.\n    order : int = 1\n        The order of the interpolation method to use.\n\n    Returns\n    -------\n    psf : PSF\n        The rotated psf.\n    \"\"\"\n    return self.set(\"data\", dlu.rotate(self.data, angle, order=order))\n</code></pre>"},{"location":"API/core/psfs/#dLux.psfs.PSF","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.ndim","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.npixels","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__add__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__iadd__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__imul__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__init__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__isub__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__itruediv__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__mul__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__sub__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.__truediv__","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.convolve","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.downsample","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.flip","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.resize","title":"PSFs","text":""},{"location":"API/core/psfs/#dLux.psfs.PSF.rotate","title":"PSFs","text":""},{"location":"API/core/sources/","title":"Sources","text":"PointSource <p>             Bases: <code>Source</code></p> <p>A simple point source with a spectrum, position and flux.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>(float, photons)</code> <p>The flux of the object.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class PointSource(Source):\n    \"\"\"\n    A simple point source with a spectrum, position and flux.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/PointSource.png)\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : float, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    position: Array\n    flux: float\n\n    def __init__(\n        self: Source,\n        wavelengths: Array = None,\n        position: Array = np.zeros(2),\n        flux: float = 1.0,\n        weights: Array = None,\n        spectrum: Spectrum() = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined. This input is\n            ignored if a Spectrum object is provided.\n        position : Array, radians = np.zeros(2)\n            The (x, y) on-sky position of this object.\n        flux : float, photons = 1.\n            The flux of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        \"\"\"\n        # Position and Flux\n        self.position = np.asarray(position, dtype=float)\n        self.flux = float(flux)\n\n        if self.position.shape != (2,):\n            raise ValueError(\"position must be a 1d array of shape (2,).\")\n\n        super().__init__(\n            wavelengths=wavelengths, weights=weights, spectrum=spectrum\n        )\n\n    def model(\n        self: Source,\n        optics: Optics,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        self = self.normalise()\n        weights = self.weights * self.flux\n        return optics.propagate(\n            self.wavelengths, self.position, weights, return_wf, return_psf\n        )\n</code></pre> PointSources <p>             Bases: <code>Source</code></p> <p>A set of point sources with the same spectrum, but different positions and fluxes.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.</p> <code>flux</code> <code>(Array, photons)</code> <p>The fluxes of the sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class PointSources(Source):\n    \"\"\"\n    A set of point sources with the same spectrum, but different positions and fluxes.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/PointSources.png)\n\n    Attributes\n    ----------\n    position : Array, radians\n        The ((x0, y0), (x1, y1), ...) on-sky positions of these sources.\n    flux : Array, photons\n        The fluxes of the sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    position: Array\n    flux: Array\n\n    def __init__(\n        self: Source,\n        wavelengths: Array = None,\n        position: Array = np.zeros((1, 2)),\n        flux: Array = None,\n        weights: Array = None,\n        spectrum: Spectrum() = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        position : Array, radians = np.zeros((1, 2))\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = None\n            The flux of the object.\n        weights : Array = None\n            The spectral weights of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        \"\"\"\n        super().__init__(\n            spectrum=spectrum, wavelengths=wavelengths, weights=weights\n        )\n\n        # More complex parameter checks here because of extra dims\n        self.position = np.asarray(position, dtype=float)\n        if self.position.ndim != 2:\n            raise ValueError(\"position must be a 2d array.\")\n\n        if flux is None:\n            self.flux = np.ones(len(self.position))\n        else:\n            self.flux = np.asarray(flux, dtype=float)\n\n            if self.flux.ndim != 1:\n                raise ValueError(\"flux must be a 1d array.\")\n\n            if len(self.flux) != len(self.position):\n                raise ValueError(\n                    \"Length of flux must be equal to length of \" \"positions.\"\n                )\n\n    def model(\n        self: Source,\n        optics: Optics,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        if return_wf and return_psf:\n            raise ValueError(\n                \"return_wf and return_psf cannot both be True. \"\n                \"Please choose one.\"\n            )\n        self = self.normalise()\n        weights = self.weights[None, :] * self.flux[:, None]\n        prop_fn = lambda position, weight: optics.propagate(\n            self.wavelengths, position, weight, return_wf=True\n        )\n        wfs = filter_vmap(prop_fn)(self.position, weights)\n\n        if return_wf:\n            return wfs\n        if return_psf:\n            return PSF(wfs.psf.sum((0, 1)), wfs.pixel_scale.mean())\n        else:\n            return wfs.psf.sum((0, 1))\n</code></pre> BinarySource <p>             Bases: <code>Source</code></p> <p>A binary source parameterised by the position, flux, separation, position_angle, and contrast between the two sources.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The mean (x, y) on-sky position of this object.</p> <code>mean_flux</code> <code>(float, photons)</code> <p>The mean flux of the sources.</p> <code>separation</code> <code>(float, radians)</code> <p>The separation of the two sources in radians.</p> <code>position_angle</code> <code>(float, radians)</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>contrast</code> <code>float</code> <p>The contrast ratio between the two sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class BinarySource(Source):\n    \"\"\"\n    A binary source parameterised by the position, flux, separation, position_angle,\n    and contrast between the two sources.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/BinarySource.png)\n\n    Attributes\n    ----------\n    position : Array, radians\n        The mean (x, y) on-sky position of this object.\n    mean_flux : float, photons\n        The mean flux of the sources.\n    separation : float, radians\n        The separation of the two sources in radians.\n    position_angle : float, radians\n        The position angle between the two sources measured clockwise from the\n        vertical axis.\n    contrast : float\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    position: Array\n    mean_flux: float\n    separation: float\n    position_angle: float\n    contrast: float\n\n    def __init__(\n        self: Source,\n        wavelengths: Array = None,\n        position: Array = np.zeros(2),\n        mean_flux: float = 1.0,\n        separation: float = 0.0,\n        position_angle: float = np.pi / 2,\n        contrast: float = 1.0,\n        spectrum: Spectrum() = None,\n        weights: Array = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        position : Array, radians = np.zeros(2)\n            The (x, y) on-sky position of this object.\n        mean_flux : float, photons = 1.\n            The mean flux of the sources.\n        separation : float, radians = 0.\n            The separation of the two sources in radians.\n        position_angle : float, radians = np.pi / 2\n            The position angle between the two sources measured clockwise from the\n            vertical axis.\n        contrast : float = 1.\n            The contrast ratio between the two sources.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        \"\"\"\n        wavelengths = np.asarray(wavelengths, dtype=float)\n        if weights is None:\n            weights = np.ones((2, len(wavelengths)))\n\n        # Position and Flux\n        self.position = np.asarray(position, dtype=float)\n        self.mean_flux = float(mean_flux)\n\n        if self.position.shape != (2,):\n            raise ValueError(\"position must be a 1d array of shape (2,).\")\n\n        # Binary values\n        self.separation = float(separation)\n        self.position_angle = float(position_angle)\n        self.contrast = float(contrast)\n\n        super().__init__(\n            wavelengths=wavelengths,\n            spectrum=spectrum,\n            weights=weights,\n        )\n\n    def model(\n        self: Source,\n        optics: Optics,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        # Normalise and get input values\n        self = self.normalise()\n        positions = dlu.positions_from_sep(\n            self.position, self.separation, self.position_angle\n        )\n        flux = dlu.fluxes_from_contrast(self.mean_flux, self.contrast)\n        weights = self.weights * flux[:, None]\n\n        # Return wf case is simple\n        prop_fn = lambda position, weight: optics.propagate(\n            self.wavelengths, position, weight, return_wf, return_psf\n        )\n        output = filter_vmap(prop_fn)(positions, weights)\n\n        # Return wf is simple case\n        if return_wf:\n            return output\n\n        # Return psf just requires constructing object\n        if return_psf:\n            return PSF(output.data.sum(0), output.pixel_scale.mean())\n\n        # Return array is simple\n        return output.sum(0)\n</code></pre> ResolvedSource <p>             Bases: <code>PointSource</code></p> <p>A single resolved source with a spectrum, position, flux, and distribution array that represents the resolved component.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>(float, photons)</code> <p>The flux of the object.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities representing the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class ResolvedSource(PointSource):\n    \"\"\"\n    A single resolved source with a spectrum, position, flux, and distribution array\n    that represents the resolved component.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ResolvedSource.png)\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : float, photons\n        The flux of the object.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    distribution: Array\n\n    def __init__(\n        self: Source,\n        wavelengths: Array = None,\n        position: Array = np.zeros(2),\n        flux: float = 1.0,\n        distribution: Array = np.ones((3, 3)),\n        weights: Array = None,\n        spectrum: Spectrum() = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        position : Array, radians = np.zeros(2)\n            The (x, y) on-sky position of this object.\n        flux : float, photons = 1.\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        weights : Array = None\n            The spectral weights of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        \"\"\"\n        distribution = np.asarray(distribution, dtype=float)\n        self.distribution = distribution / distribution.sum()\n\n        if self.distribution.ndim != 2:\n            raise ValueError(\"distribution must be a 2d array.\")\n\n        super().__init__(\n            position=position,\n            flux=flux,\n            spectrum=spectrum,\n            wavelengths=wavelengths,\n            weights=weights,\n        )\n\n    def normalise(self: Source) -&gt; Source:\n        \"\"\"\n        Method for returning a new source object with a normalised total\n        spectrum and source distribution.\n\n        Returns\n        -------\n        source : Source\n            The source object with the normalised spectrum and distribution.\n        \"\"\"\n        spectrum = self.spectrum.normalise()\n        distribution_floor = np.maximum(self.distribution, 0.0)\n        distribution = distribution_floor / distribution_floor.sum()\n        return self.set([\"spectrum\", \"distribution\"], [spectrum, distribution])\n\n    def model(\n        self: Source,\n        optics: Optics = None,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        if return_wf and return_psf:\n            raise ValueError(\n                \"return_wf and return_psf cannot both be True. \"\n                \"Please choose one.\"\n            )\n        # Normalise and get parameters\n        self = self.normalise()\n        weights = self.weights * self.flux\n\n        # Note we always return wf here so we can convolve each wavelength\n        # individually if a chromatic wavefront output is required.\n        wf = optics.propagate(\n            self.wavelengths, self.position, weights, return_wf=True\n        )\n\n        # Returning wf is a special case\n        if return_wf:\n            conv_fn = lambda psf: convolve(psf, self.distribution, mode=\"same\")\n            return wf.set(\"amplitude\", vmap(conv_fn)(wf.psf) ** 0.5)\n\n        # Return psf object\n        conv_psf = convolve(wf.psf.sum(0), self.distribution, mode=\"same\")\n        if return_psf:\n            return PSF(conv_psf, wf.pixel_scale.mean())\n\n        # Return array psf\n        return conv_psf\n</code></pre> PointResolvedSource <p>             Bases: <code>ResolvedSource</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source. An example would be an unresolved star with a resolved dust shell or debris disk. These two objects share the same spectra but have their flux defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array of intensities that represent the resolved distribution.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>(float, photons)</code> <p>The mean flux of the point and resolved source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities representing the resolved source.</p> <code>contrast</code> <code>float</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class PointResolvedSource(ResolvedSource):\n    \"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source. An example would be an unresolved star with\n    a resolved dust shell or debris disk. These two objects share the same\n    spectra but have their flux defined by flux (the mean flux) and the flux\n    ratio (contrast) between the point source and resolved distribution. The\n    resolved component is defined by an array of intensities that represent\n    the resolved distribution.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/PointResolvedSource.png)\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : float, photons\n        The mean flux of the point and resolved source.\n    distribution : Array\n        The array of intensities representing the resolved source.\n    contrast : float\n        The contrast ratio between the point source and the resolved source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n\n    contrast: float\n\n    def __init__(\n        self: Source,\n        wavelengths: Array = None,\n        position: Array = np.zeros(2),\n        flux: float = 1.0,\n        distribution: Array = np.ones((3, 3)),\n        contrast: float = 1.0,\n        weights: Array = None,\n        spectrum: Spectrum() = None,\n    ) -&gt; Source:\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres = None\n            The array of wavelengths at which the spectrum is defined.\n        position : Array, radians = np.zeros(2)\n            The (x, y) on-sky position of this object.\n        flux : float, photons = 1.\n            The mean flux of the point and resolved source.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities representing the resolved source.\n        contrast : float = 1.\n            The contrast ratio between the point source and the resolved source.\n        weights : Array = None\n            The spectral weights of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        \"\"\"\n        wavelengths = np.asarray(wavelengths, dtype=float)\n        if weights is None:\n            weights = np.ones((2, len(wavelengths)))\n\n        self.contrast = float(contrast)\n\n        super().__init__(\n            wavelengths=wavelengths,\n            position=position,\n            flux=flux,\n            distribution=distribution,\n            spectrum=spectrum,\n            weights=weights,\n            # contrast=contrast,\n        )\n\n    def model(\n        self: Source,\n        optics: Optics,\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        if return_wf and return_psf:\n            raise ValueError(\n                \"return_wf and return_psf cannot both be True. \"\n                \"Please choose one.\"\n            )\n        # Normalise and get parameters\n        self = self.normalise()\n        flux = dlu.fluxes_from_contrast(self.flux, self.contrast)\n        weights = self.weights * flux[:, None]\n\n        # Note we always return wf here so we can convolve each wavelength\n        # individually if a chromatic wavefront output is required. We also\n        # Can not propagate the weights since they have different values\n        # for the point and resolved source.\n        wf = optics.propagate(self.wavelengths, self.position, return_wf=True)\n\n        # Returning wf is a special case, we need to convolve each psf with\n        # the distribution, and them re-combine them into a vectorised wf\n        if return_wf:\n            # Perform convolution\n            conv_fn = lambda psf: convolve(psf, self.distribution, mode=\"same\")\n            conv_wf = wf.set(\"amplitude\", vmap(conv_fn)(wf.psf) ** 0.5)\n\n            # Stack leaves manually, this is a bit of a hack to get around\n            # string leaf errors from tree_map, and to avoid\n            # flattening/unflattening with partition and combine\n            stack_leaves = lambda x, y: np.stack([x, y], axis=0)\n            amplitudes = stack_leaves(wf.amplitude, conv_wf.amplitude)\n            phases = stack_leaves(wf.phase, conv_wf.phase)\n            pixel_scales = stack_leaves(wf.pixel_scale, conv_wf.pixel_scale)\n            wavelengths = stack_leaves(wf.wavelength, conv_wf.wavelength)\n\n            # Combine into single wf and finally apply weights\n            combined_wf = wf.set(\n                [\"wavelength\", \"amplitude\", \"phase\", \"pixel_scale\"],\n                [wavelengths, amplitudes, phases, pixel_scales],\n            )\n            return combined_wf.multiply(\"amplitude\", weights[:, :, None, None])\n\n        # Create singe array psf object\n        point_psf = (np.expand_dims(weights[0], (1, 2)) * wf.psf).sum(0)\n        resolved_psf = (np.expand_dims(weights[1], (1, 2)) * wf.psf).sum(0)\n        conv_psf = convolve(resolved_psf, self.distribution, mode=\"same\")\n        psf = point_psf + conv_psf\n        if return_psf:\n            return PSF(psf, wf.pixel_scale.mean())\n\n        # Return array psf\n        return psf\n</code></pre> Scene <p>             Bases: <code>BaseSource</code></p> <p>A source object that holds a set of sources that are model simultaneously.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>sources</code> <code>dict</code> <p>A dictionary of source objects to model simultaneously.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>class Scene(BaseSource):\n    \"\"\"\n    A source object that holds a set of sources that are model simultaneously.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Scene.png)\n\n    Attributes\n    ----------\n    sources : dict\n        A dictionary of source objects to model simultaneously.\n    \"\"\"\n\n    sources: dict\n\n    def __init__(self: Scene, sources: list[Source]):\n        \"\"\"\n        Parameters\n        ----------\n        sources : list[Source]\n            A list of source objects to model simultaneously.\n        \"\"\"\n        super().__init__()\n        if isinstance(sources, (BaseSource, tuple)):\n            sources = [sources]\n        self.sources = dlu.list2dictionary(sources, False, BaseSource)\n\n    def normalise(self: Scene) -&gt; Scene:\n        \"\"\"\n        Method for returning a new scene with normalised source objects.\n\n        Returns\n        -------\n        scene : Scene\n            The normalised scene object.\n        \"\"\"\n        is_source = lambda leaf: isinstance(leaf, BaseSource)\n        norm_fn = lambda source: source.normalise()\n        sources = tree_map(norm_fn, self.sources, is_leaf=is_source)\n        return self.set(\"sources\", sources)\n\n    def __getattr__(self: Source, key: str) -&gt; Any:\n        \"\"\"\n        Raises the individual sources via their keys.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the sub-dictionaries.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the sub-dictionaries.\n        \"\"\"\n        if key in self.sources.keys():\n            return self.sources[key]\n        raise AttributeError(\n            f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n        )\n\n    def model(\n        self: Scene,\n        optics: Optics(),\n        return_wf: bool = False,\n        return_psf: bool = False,\n    ) -&gt; Array:\n        \"\"\"\n        Models the source object through the provided optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source object.\n        return_wf : bool = False\n            Should the Wavefront object be returned instead of the psf Array?\n        return_psf : bool = False\n            Should the PSF object be returned instead of the psf Array?\n\n        Returns\n        -------\n        object : Array, Wavefront, PSF\n            if `return_wf` is False and `return_psf` is False, returns the psf Array.\n            if `return_wf` is True and `return_psf` is False, returns the Wavefront\n                object.\n            if `return_wf` is False and `return_psf` is True, returns the PSF object.\n        \"\"\"\n        self = self.normalise()\n\n        # Define leaf_fn and map across sources\n        leaf_fn = lambda leaf: isinstance(leaf, BaseSource)\n        output = tree_map(\n            lambda s: s.model(optics, return_wf, return_psf),\n            self.sources,\n            is_leaf=leaf_fn,\n        )\n\n        # Return wf case is simple\n        if return_wf:\n            return output\n\n        # Return psf case requires mapping across the psf outputs\n        if return_psf:\n            # Define mapping function\n            leaf_fn = lambda leaf: isinstance(leaf, PSF)\n            get_psfs = lambda psf: psf.data.sum(tuple(range(psf.ndim)))\n            get_pscales = lambda psf: psf.pixel_scale.mean()\n\n            # Get values and return PSF\n            psf = dlu.map2array(get_psfs, output, leaf_fn).sum(0)\n            pixel_scale = dlu.map2array(get_pscales, output, leaf_fn).mean()\n            return PSF(psf, pixel_scale)\n\n        # Return array is simple\n        return dlu.map2array(lambda x: x, output).sum(0)\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointSource.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros(2), flux=1.0, weights=None, spectrum=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined. This input is ignored if a Spectrum object is provided.</p> <code>None</code> <code>position</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) on-sky position of this object.</p> <code>zeros(2)</code> <code>flux</code> <code>float, photons = 1.</code> <p>The flux of the object.</p> <code>1.0</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(\n    self: Source,\n    wavelengths: Array = None,\n    position: Array = np.zeros(2),\n    flux: float = 1.0,\n    weights: Array = None,\n    spectrum: Spectrum() = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined. This input is\n        ignored if a Spectrum object is provided.\n    position : Array, radians = np.zeros(2)\n        The (x, y) on-sky position of this object.\n    flux : float, photons = 1.\n        The flux of the object.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    # Position and Flux\n    self.position = np.asarray(position, dtype=float)\n    self.flux = float(flux)\n\n    if self.position.shape != (2,):\n        raise ValueError(\"position must be a 1d array of shape (2,).\")\n\n    super().__init__(\n        wavelengths=wavelengths, weights=weights, spectrum=spectrum\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointSource.model","title":"<code>model(optics, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Source,\n    optics: Optics,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    self = self.normalise()\n    weights = self.weights * self.flux\n    return optics.propagate(\n        self.wavelengths, self.position, weights, return_wf, return_psf\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointSource","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointSource.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointSource.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointSources.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros((1, 2)), flux=None, weights=None, spectrum=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>position</code> <code>Array, radians = np.zeros((1, 2))</code> <p>The (x, y) on-sky position of this object.</p> <code>zeros((1, 2))</code> <code>flux</code> <code>Array, photons = None</code> <p>The flux of the object.</p> <code>None</code> <code>weights</code> <code>Array = None</code> <p>The spectral weights of the object.</p> <code>None</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(\n    self: Source,\n    wavelengths: Array = None,\n    position: Array = np.zeros((1, 2)),\n    flux: Array = None,\n    weights: Array = None,\n    spectrum: Spectrum() = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    position : Array, radians = np.zeros((1, 2))\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = None\n        The flux of the object.\n    weights : Array = None\n        The spectral weights of the object.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    super().__init__(\n        spectrum=spectrum, wavelengths=wavelengths, weights=weights\n    )\n\n    # More complex parameter checks here because of extra dims\n    self.position = np.asarray(position, dtype=float)\n    if self.position.ndim != 2:\n        raise ValueError(\"position must be a 2d array.\")\n\n    if flux is None:\n        self.flux = np.ones(len(self.position))\n    else:\n        self.flux = np.asarray(flux, dtype=float)\n\n        if self.flux.ndim != 1:\n            raise ValueError(\"flux must be a 1d array.\")\n\n        if len(self.flux) != len(self.position):\n            raise ValueError(\n                \"Length of flux must be equal to length of \" \"positions.\"\n            )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointSources.model","title":"<code>model(optics, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Source,\n    optics: Optics,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    if return_wf and return_psf:\n        raise ValueError(\n            \"return_wf and return_psf cannot both be True. \"\n            \"Please choose one.\"\n        )\n    self = self.normalise()\n    weights = self.weights[None, :] * self.flux[:, None]\n    prop_fn = lambda position, weight: optics.propagate(\n        self.wavelengths, position, weight, return_wf=True\n    )\n    wfs = filter_vmap(prop_fn)(self.position, weights)\n\n    if return_wf:\n        return wfs\n    if return_psf:\n        return PSF(wfs.psf.sum((0, 1)), wfs.pixel_scale.mean())\n    else:\n        return wfs.psf.sum((0, 1))\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointSources","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointSources.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointSources.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.BinarySource.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros(2), mean_flux=1.0, separation=0.0, position_angle=np.pi / 2, contrast=1.0, spectrum=None, weights=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>position</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) on-sky position of this object.</p> <code>zeros(2)</code> <code>mean_flux</code> <code>float, photons = 1.</code> <p>The mean flux of the sources.</p> <code>1.0</code> <code>separation</code> <code>float, radians = 0.</code> <p>The separation of the two sources in radians.</p> <code>0.0</code> <code>position_angle</code> <code>float, radians = np.pi / 2</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>pi / 2</code> <code>contrast</code> <code>float = 1.</code> <p>The contrast ratio between the two sources.</p> <code>1.0</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(\n    self: Source,\n    wavelengths: Array = None,\n    position: Array = np.zeros(2),\n    mean_flux: float = 1.0,\n    separation: float = 0.0,\n    position_angle: float = np.pi / 2,\n    contrast: float = 1.0,\n    spectrum: Spectrum() = None,\n    weights: Array = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    position : Array, radians = np.zeros(2)\n        The (x, y) on-sky position of this object.\n    mean_flux : float, photons = 1.\n        The mean flux of the sources.\n    separation : float, radians = 0.\n        The separation of the two sources in radians.\n    position_angle : float, radians = np.pi / 2\n        The position angle between the two sources measured clockwise from the\n        vertical axis.\n    contrast : float = 1.\n        The contrast ratio between the two sources.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    wavelengths = np.asarray(wavelengths, dtype=float)\n    if weights is None:\n        weights = np.ones((2, len(wavelengths)))\n\n    # Position and Flux\n    self.position = np.asarray(position, dtype=float)\n    self.mean_flux = float(mean_flux)\n\n    if self.position.shape != (2,):\n        raise ValueError(\"position must be a 1d array of shape (2,).\")\n\n    # Binary values\n    self.separation = float(separation)\n    self.position_angle = float(position_angle)\n    self.contrast = float(contrast)\n\n    super().__init__(\n        wavelengths=wavelengths,\n        spectrum=spectrum,\n        weights=weights,\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.BinarySource.model","title":"<code>model(optics, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Source,\n    optics: Optics,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    # Normalise and get input values\n    self = self.normalise()\n    positions = dlu.positions_from_sep(\n        self.position, self.separation, self.position_angle\n    )\n    flux = dlu.fluxes_from_contrast(self.mean_flux, self.contrast)\n    weights = self.weights * flux[:, None]\n\n    # Return wf case is simple\n    prop_fn = lambda position, weight: optics.propagate(\n        self.wavelengths, position, weight, return_wf, return_psf\n    )\n    output = filter_vmap(prop_fn)(positions, weights)\n\n    # Return wf is simple case\n    if return_wf:\n        return output\n\n    # Return psf just requires constructing object\n    if return_psf:\n        return PSF(output.data.sum(0), output.pixel_scale.mean())\n\n    # Return array is simple\n    return output.sum(0)\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.BinarySource","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.BinarySource.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.BinarySource.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.ResolvedSource.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros(2), flux=1.0, distribution=np.ones((3, 3)), weights=None, spectrum=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>position</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) on-sky position of this object.</p> <code>zeros(2)</code> <code>flux</code> <code>float, photons = 1.</code> <p>The flux of the object.</p> <code>1.0</code> <code>distribution</code> <code>Array = np.ones((3, 3))</code> <p>The array of intensities representing the resolved source.</p> <code>ones((3, 3))</code> <code>weights</code> <code>Array = None</code> <p>The spectral weights of the object.</p> <code>None</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(\n    self: Source,\n    wavelengths: Array = None,\n    position: Array = np.zeros(2),\n    flux: float = 1.0,\n    distribution: Array = np.ones((3, 3)),\n    weights: Array = None,\n    spectrum: Spectrum() = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    position : Array, radians = np.zeros(2)\n        The (x, y) on-sky position of this object.\n    flux : float, photons = 1.\n        The flux of the object.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities representing the resolved source.\n    weights : Array = None\n        The spectral weights of the object.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    distribution = np.asarray(distribution, dtype=float)\n    self.distribution = distribution / distribution.sum()\n\n    if self.distribution.ndim != 2:\n        raise ValueError(\"distribution must be a 2d array.\")\n\n    super().__init__(\n        position=position,\n        flux=flux,\n        spectrum=spectrum,\n        wavelengths=wavelengths,\n        weights=weights,\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.ResolvedSource.model","title":"<code>model(optics=None, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> <code>None</code> <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Source,\n    optics: Optics = None,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    if return_wf and return_psf:\n        raise ValueError(\n            \"return_wf and return_psf cannot both be True. \"\n            \"Please choose one.\"\n        )\n    # Normalise and get parameters\n    self = self.normalise()\n    weights = self.weights * self.flux\n\n    # Note we always return wf here so we can convolve each wavelength\n    # individually if a chromatic wavefront output is required.\n    wf = optics.propagate(\n        self.wavelengths, self.position, weights, return_wf=True\n    )\n\n    # Returning wf is a special case\n    if return_wf:\n        conv_fn = lambda psf: convolve(psf, self.distribution, mode=\"same\")\n        return wf.set(\"amplitude\", vmap(conv_fn)(wf.psf) ** 0.5)\n\n    # Return psf object\n    conv_psf = convolve(wf.psf.sum(0), self.distribution, mode=\"same\")\n    if return_psf:\n        return PSF(conv_psf, wf.pixel_scale.mean())\n\n    # Return array psf\n    return conv_psf\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.ResolvedSource.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new source object with a normalised total spectrum and source distribution.</p> <p>Returns:</p> Name Type Description <code>source</code> <code>Source</code> <p>The source object with the normalised spectrum and distribution.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def normalise(self: Source) -&gt; Source:\n    \"\"\"\n    Method for returning a new source object with a normalised total\n    spectrum and source distribution.\n\n    Returns\n    -------\n    source : Source\n        The source object with the normalised spectrum and distribution.\n    \"\"\"\n    spectrum = self.spectrum.normalise()\n    distribution_floor = np.maximum(self.distribution, 0.0)\n    distribution = distribution_floor / distribution_floor.sum()\n    return self.set([\"spectrum\", \"distribution\"], [spectrum, distribution])\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.ResolvedSource","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.ResolvedSource.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.ResolvedSource.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.ResolvedSource.normalise","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointResolvedSource.__init__","title":"<code>__init__(wavelengths=None, position=np.zeros(2), flux=1.0, distribution=np.ones((3, 3)), contrast=1.0, weights=None, spectrum=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, metres = None</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>position</code> <code>Array, radians = np.zeros(2)</code> <p>The (x, y) on-sky position of this object.</p> <code>zeros(2)</code> <code>flux</code> <code>float, photons = 1.</code> <p>The mean flux of the point and resolved source.</p> <code>1.0</code> <code>distribution</code> <code>Array = np.ones((3, 3))</code> <p>The array of intensities representing the resolved source.</p> <code>ones((3, 3))</code> <code>contrast</code> <code>float = 1.</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>1.0</code> <code>weights</code> <code>Array = None</code> <p>The spectral weights of the object.</p> <code>None</code> <code>spectrum</code> <code>Spectrum = None</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(\n    self: Source,\n    wavelengths: Array = None,\n    position: Array = np.zeros(2),\n    flux: float = 1.0,\n    distribution: Array = np.ones((3, 3)),\n    contrast: float = 1.0,\n    weights: Array = None,\n    spectrum: Spectrum() = None,\n) -&gt; Source:\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres = None\n        The array of wavelengths at which the spectrum is defined.\n    position : Array, radians = np.zeros(2)\n        The (x, y) on-sky position of this object.\n    flux : float, photons = 1.\n        The mean flux of the point and resolved source.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities representing the resolved source.\n    contrast : float = 1.\n        The contrast ratio between the point source and the resolved source.\n    weights : Array = None\n        The spectral weights of the object.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    \"\"\"\n    wavelengths = np.asarray(wavelengths, dtype=float)\n    if weights is None:\n        weights = np.ones((2, len(wavelengths)))\n\n    self.contrast = float(contrast)\n\n    super().__init__(\n        wavelengths=wavelengths,\n        position=position,\n        flux=flux,\n        distribution=distribution,\n        spectrum=spectrum,\n        weights=weights,\n        # contrast=contrast,\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointResolvedSource.model","title":"<code>model(optics, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Source,\n    optics: Optics,\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    if return_wf and return_psf:\n        raise ValueError(\n            \"return_wf and return_psf cannot both be True. \"\n            \"Please choose one.\"\n        )\n    # Normalise and get parameters\n    self = self.normalise()\n    flux = dlu.fluxes_from_contrast(self.flux, self.contrast)\n    weights = self.weights * flux[:, None]\n\n    # Note we always return wf here so we can convolve each wavelength\n    # individually if a chromatic wavefront output is required. We also\n    # Can not propagate the weights since they have different values\n    # for the point and resolved source.\n    wf = optics.propagate(self.wavelengths, self.position, return_wf=True)\n\n    # Returning wf is a special case, we need to convolve each psf with\n    # the distribution, and them re-combine them into a vectorised wf\n    if return_wf:\n        # Perform convolution\n        conv_fn = lambda psf: convolve(psf, self.distribution, mode=\"same\")\n        conv_wf = wf.set(\"amplitude\", vmap(conv_fn)(wf.psf) ** 0.5)\n\n        # Stack leaves manually, this is a bit of a hack to get around\n        # string leaf errors from tree_map, and to avoid\n        # flattening/unflattening with partition and combine\n        stack_leaves = lambda x, y: np.stack([x, y], axis=0)\n        amplitudes = stack_leaves(wf.amplitude, conv_wf.amplitude)\n        phases = stack_leaves(wf.phase, conv_wf.phase)\n        pixel_scales = stack_leaves(wf.pixel_scale, conv_wf.pixel_scale)\n        wavelengths = stack_leaves(wf.wavelength, conv_wf.wavelength)\n\n        # Combine into single wf and finally apply weights\n        combined_wf = wf.set(\n            [\"wavelength\", \"amplitude\", \"phase\", \"pixel_scale\"],\n            [wavelengths, amplitudes, phases, pixel_scales],\n        )\n        return combined_wf.multiply(\"amplitude\", weights[:, :, None, None])\n\n    # Create singe array psf object\n    point_psf = (np.expand_dims(weights[0], (1, 2)) * wf.psf).sum(0)\n    resolved_psf = (np.expand_dims(weights[1], (1, 2)) * wf.psf).sum(0)\n    conv_psf = convolve(resolved_psf, self.distribution, mode=\"same\")\n    psf = point_psf + conv_psf\n    if return_psf:\n        return PSF(psf, wf.pixel_scale.mean())\n\n    # Return array psf\n    return psf\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.PointResolvedSource","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointResolvedSource.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.PointResolvedSource.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.Scene.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Raises the individual sources via their keys.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the sub-dictionaries.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the sub-dictionaries.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def __getattr__(self: Source, key: str) -&gt; Any:\n    \"\"\"\n    Raises the individual sources via their keys.\n\n    Parameters\n    ----------\n    key : str\n        The key of the item to be searched for in the sub-dictionaries.\n\n    Returns\n    -------\n    item : object\n        The item corresponding to the supplied key in the sub-dictionaries.\n    \"\"\"\n    if key in self.sources.keys():\n        return self.sources[key]\n    raise AttributeError(\n        f\"{self.__class__.__name__} has no attribute \" f\"{key}.\"\n    )\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.Scene.__init__","title":"<code>__init__(sources)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>sources</code> <code>list[Source]</code> <p>A list of source objects to model simultaneously.</p> required Source code in <code>src/dLux/sources.py</code> <pre><code>def __init__(self: Scene, sources: list[Source]):\n    \"\"\"\n    Parameters\n    ----------\n    sources : list[Source]\n        A list of source objects to model simultaneously.\n    \"\"\"\n    super().__init__()\n    if isinstance(sources, (BaseSource, tuple)):\n        sources = [sources]\n    self.sources = dlu.list2dictionary(sources, False, BaseSource)\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.Scene.model","title":"<code>model(optics, return_wf=False, return_psf=False)</code>","text":"<p>Models the source object through the provided optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source object.</p> required <code>return_wf</code> <code>bool = False</code> <p>Should the Wavefront object be returned instead of the psf Array?</p> <code>False</code> <code>return_psf</code> <code>bool = False</code> <p>Should the PSF object be returned instead of the psf Array?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>object</code> <code>(Array, Wavefront, PSF)</code> <p>if <code>return_wf</code> is False and <code>return_psf</code> is False, returns the psf Array. if <code>return_wf</code> is True and <code>return_psf</code> is False, returns the Wavefront     object. if <code>return_wf</code> is False and <code>return_psf</code> is True, returns the PSF object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def model(\n    self: Scene,\n    optics: Optics(),\n    return_wf: bool = False,\n    return_psf: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Models the source object through the provided optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source object.\n    return_wf : bool = False\n        Should the Wavefront object be returned instead of the psf Array?\n    return_psf : bool = False\n        Should the PSF object be returned instead of the psf Array?\n\n    Returns\n    -------\n    object : Array, Wavefront, PSF\n        if `return_wf` is False and `return_psf` is False, returns the psf Array.\n        if `return_wf` is True and `return_psf` is False, returns the Wavefront\n            object.\n        if `return_wf` is False and `return_psf` is True, returns the PSF object.\n    \"\"\"\n    self = self.normalise()\n\n    # Define leaf_fn and map across sources\n    leaf_fn = lambda leaf: isinstance(leaf, BaseSource)\n    output = tree_map(\n        lambda s: s.model(optics, return_wf, return_psf),\n        self.sources,\n        is_leaf=leaf_fn,\n    )\n\n    # Return wf case is simple\n    if return_wf:\n        return output\n\n    # Return psf case requires mapping across the psf outputs\n    if return_psf:\n        # Define mapping function\n        leaf_fn = lambda leaf: isinstance(leaf, PSF)\n        get_psfs = lambda psf: psf.data.sum(tuple(range(psf.ndim)))\n        get_pscales = lambda psf: psf.pixel_scale.mean()\n\n        # Get values and return PSF\n        psf = dlu.map2array(get_psfs, output, leaf_fn).sum(0)\n        pixel_scale = dlu.map2array(get_pscales, output, leaf_fn).mean()\n        return PSF(psf, pixel_scale)\n\n    # Return array is simple\n    return dlu.map2array(lambda x: x, output).sum(0)\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.Scene.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new scene with normalised source objects.</p> <p>Returns:</p> Name Type Description <code>scene</code> <code>Scene</code> <p>The normalised scene object.</p> Source code in <code>src/dLux/sources.py</code> <pre><code>def normalise(self: Scene) -&gt; Scene:\n    \"\"\"\n    Method for returning a new scene with normalised source objects.\n\n    Returns\n    -------\n    scene : Scene\n        The normalised scene object.\n    \"\"\"\n    is_source = lambda leaf: isinstance(leaf, BaseSource)\n    norm_fn = lambda source: source.normalise()\n    sources = tree_map(norm_fn, self.sources, is_leaf=is_source)\n    return self.set(\"sources\", sources)\n</code></pre>"},{"location":"API/core/sources/#dLux.sources.Scene","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.Scene.__getattr__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.Scene.__init__","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.Scene.model","title":"Sources","text":""},{"location":"API/core/sources/#dLux.sources.Scene.normalise","title":"Sources","text":""},{"location":"API/core/spectra/","title":"Spectra","text":"Spectrum <p>             Bases: <code>SimpleSpectrum</code></p> <p>A simple spectrum class using wavelengths and weights.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p> Source code in <code>src/dLux/spectra.py</code> <pre><code>class Spectrum(SimpleSpectrum):\n    \"\"\"\n    A simple spectrum class using wavelengths and weights.\n\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Spectrum.png)\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array\n        The relative weights of each wavelength.\n    \"\"\"\n\n    weights: Array\n\n    def __init__(self: Spectrum, wavelengths: Array, weights: Array = None):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        weights : Array = None\n            The relative weights of each wavelength. Input weights\n            are automatically normalised to a sum of 1.\n        \"\"\"\n        super().__init__(wavelengths)\n        if weights is None:\n            in_shape = self.wavelengths.shape\n            weights = np.ones(in_shape) / in_shape[-1]\n\n        weights = np.asarray(weights, dtype=float)\n        if weights.ndim == 2:\n            self.weights = weights / weights.sum(-1)[:, None]\n        else:\n            self.weights = weights / weights.sum()\n\n        if self.weights.ndim == 1:\n            if self.wavelengths.shape != self.weights.shape:\n                raise ValueError(\n                    \"wavelengths and weights must have the same \" \"shape.\"\n                )\n        else:\n            if self.wavelengths.shape != self.weights.shape[-1:]:\n                raise ValueError(\n                    \"wavelengths and weights must have the same \" \"shape.\"\n                )\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n        \"\"\"\n        Returns a normalised spectrum object, where the weights are normalised to a\n        sum of 1.\n\n        Returns\n        -------\n        spectrum : Spectrum\n            The spectrum object with the normalised spectrum.\n        \"\"\"\n        if self.weights.ndim == 2:\n            weight_sum = self.weights.sum(-1)[:, None]\n        else:\n            weight_sum = self.weights.sum()\n        return self.divide(\"weights\", weight_sum)\n</code></pre> PolySpectrum <p>             Bases: <code>SimpleSpectrum</code></p> <p>Implements a generic polynomial spectrum, such as a linear spectrum.</p> <p>This implements a polynomial as follows: f(x) = c0 + c1x + c2x^2 + ... + cn*x^n</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> Source code in <code>src/dLux/spectra.py</code> <pre><code>class PolySpectrum(SimpleSpectrum):\n    \"\"\"\n    Implements a generic polynomial spectrum, such as a linear spectrum.\n\n    This implements a polynomial as follows: f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/PolySpectrum.png)\n\n    Attributes\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    \"\"\"\n\n    coefficients: Array\n\n    def __init__(self: Spectrum, wavelengths: Array, coefficients: Array):\n        \"\"\"\n        Parameters\n        ----------\n        wavelengths : Array, metres\n            The array of wavelengths at which the spectrum is defined.\n        coefficients : Array\n            The array of polynomial coefficient values.\n        \"\"\"\n        super().__init__(wavelengths)\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n        if self.coefficients.ndim != 1:\n            raise ValueError(\"Coefficients must be a 1d array.\")\n\n    def _eval_weight(self: Spectrum, wavelength: Array) -&gt; Array:\n        \"\"\"\n        Evaluates the polynomial function at the supplied wavelength.\n\n        Parameters\n        ----------\n        wavelength : Array, metres\n            The wavelength at which to evaluate the polynomial function.\n\n        Returns\n        -------\n        weight : Array\n            The relative weight of the supplied wavelength.\n        \"\"\"\n        return np.array(\n            [\n                self.coefficients[i] * wavelength**i\n                for i in range(len(self.coefficients))\n            ]\n        ).sum()\n\n    @property\n    def weights(self: Spectrum) -&gt; Array:\n        \"\"\"\n        Gets the relative spectral weights by evaluating the polynomial function at the\n        internal wavelengths. Output weights are automatically normalised to a sum of\n        1.\n\n        Returns\n        -------\n        weights : Array\n            The normalised relative weights of each wavelength.\n        \"\"\"\n        weights = vmap(self._eval_weight)(self.wavelengths)\n        return weights / weights.sum()\n\n    def normalise(self: Spectrum) -&gt; Spectrum:\n        \"\"\"\n        Calculated weights are automatically normalised, so this method simply returns\n        an unmodified object.\n\n        Returns\n        --------\n        spectrum : Spectrum\n            The unmodified spectrum object\n        \"\"\"\n        return self\n</code></pre>"},{"location":"API/core/spectra/#dLux.spectra.Spectrum.__init__","title":"<code>__init__(wavelengths, weights=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>weights</code> <code>Array = None</code> <p>The relative weights of each wavelength. Input weights are automatically normalised to a sum of 1.</p> <code>None</code> Source code in <code>src/dLux/spectra.py</code> <pre><code>def __init__(self: Spectrum, wavelengths: Array, weights: Array = None):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array = None\n        The relative weights of each wavelength. Input weights\n        are automatically normalised to a sum of 1.\n    \"\"\"\n    super().__init__(wavelengths)\n    if weights is None:\n        in_shape = self.wavelengths.shape\n        weights = np.ones(in_shape) / in_shape[-1]\n\n    weights = np.asarray(weights, dtype=float)\n    if weights.ndim == 2:\n        self.weights = weights / weights.sum(-1)[:, None]\n    else:\n        self.weights = weights / weights.sum()\n\n    if self.weights.ndim == 1:\n        if self.wavelengths.shape != self.weights.shape:\n            raise ValueError(\n                \"wavelengths and weights must have the same \" \"shape.\"\n            )\n    else:\n        if self.wavelengths.shape != self.weights.shape[-1:]:\n            raise ValueError(\n                \"wavelengths and weights must have the same \" \"shape.\"\n            )\n</code></pre>"},{"location":"API/core/spectra/#dLux.spectra.Spectrum.normalise","title":"<code>normalise()</code>","text":"<p>Returns a normalised spectrum object, where the weights are normalised to a sum of 1.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Spectrum</code> <p>The spectrum object with the normalised spectrum.</p> Source code in <code>src/dLux/spectra.py</code> <pre><code>def normalise(self: Spectrum) -&gt; Spectrum:\n    \"\"\"\n    Returns a normalised spectrum object, where the weights are normalised to a\n    sum of 1.\n\n    Returns\n    -------\n    spectrum : Spectrum\n        The spectrum object with the normalised spectrum.\n    \"\"\"\n    if self.weights.ndim == 2:\n        weight_sum = self.weights.sum(-1)[:, None]\n    else:\n        weight_sum = self.weights.sum()\n    return self.divide(\"weights\", weight_sum)\n</code></pre>"},{"location":"API/core/spectra/#dLux.spectra.Spectrum","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.Spectrum.__init__","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.Spectrum.normalise","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.weights","title":"<code>weights: Array</code>  <code>property</code>","text":"<p>Gets the relative spectral weights by evaluating the polynomial function at the internal wavelengths. Output weights are automatically normalised to a sum of 1.</p> <p>Returns:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The normalised relative weights of each wavelength.</p>"},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.__init__","title":"<code>__init__(wavelengths, coefficients)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>(Array, metres)</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> required Source code in <code>src/dLux/spectra.py</code> <pre><code>def __init__(self: Spectrum, wavelengths: Array, coefficients: Array):\n    \"\"\"\n    Parameters\n    ----------\n    wavelengths : Array, metres\n        The array of wavelengths at which the spectrum is defined.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    \"\"\"\n    super().__init__(wavelengths)\n    self.coefficients = np.asarray(coefficients, dtype=float)\n\n    if self.coefficients.ndim != 1:\n        raise ValueError(\"Coefficients must be a 1d array.\")\n</code></pre>"},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Calculated weights are automatically normalised, so this method simply returns an unmodified object.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Spectrum</code> <p>The unmodified spectrum object</p> Source code in <code>src/dLux/spectra.py</code> <pre><code>def normalise(self: Spectrum) -&gt; Spectrum:\n    \"\"\"\n    Calculated weights are automatically normalised, so this method simply returns\n    an unmodified object.\n\n    Returns\n    --------\n    spectrum : Spectrum\n        The unmodified spectrum object\n    \"\"\"\n    return self\n</code></pre>"},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.weights","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.__init__","title":"Spectra","text":""},{"location":"API/core/spectra/#dLux.spectra.PolySpectrum.normalise","title":"Spectra","text":""},{"location":"API/core/transformations/","title":"Transformations","text":"CoordTransform <p>             Bases: <code>Base</code></p> <p>A simple class to handle the coordinate transformations applied dynamic aperture classes. Transformations are applied in the order:     1. Translation     2. Rotation     3. Compression     4. Shear</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>translation</code> <code>Array</code> <p>The (x, y) shift applied to the coords.</p> <code>rotation</code> <code>Array</code> <p>The clockwise rotation applied to the coords.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression applied to the coords.</p> <code>shear</code> <code>Array</code> <p>The (x, y) shear applied to the coords.</p> Source code in <code>src/dLux/transformations.py</code> <pre><code>class CoordTransform(Base):\n    \"\"\"\n    A simple class to handle the coordinate transformations applied dynamic\n    aperture classes. Transformations are applied in the order:\n        1. Translation\n        2. Rotation\n        3. Compression\n        4. Shear\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/CoordTransform.png)\n\n    Attributes\n    ----------\n    translation: Array\n        The (x, y) shift applied to the coords.\n    rotation: Array\n        The clockwise rotation applied to the coords.\n    compression: Array\n        The (x, y) compression applied to the coords.\n    shear: Array\n        The (x, y) shear applied to the coords.\n    \"\"\"\n\n    translation: Array\n    rotation: float\n    compression: Array\n    shear: Array\n\n    def __init__(\n        self: CoordTransform,\n        translation: Array = None,\n        rotation: float = None,\n        compression: Array = None,\n        shear: Array = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        translation: Array\n            The (x, y) shift applied to the coords.\n        rotation: float, radians\n            The clockwise rotation applied to the coords.\n        compression: Array\n            The (x, y) compression applied to the coords.\n        shear: Array\n            The (x, y) shear applied to the coords.\n        \"\"\"\n        if translation is not None:\n            self.translation = np.asarray(translation, dtype=float)\n            if self.translation.shape != (2,):\n                raise ValueError(\"center must be have shape (2,).\")\n        else:\n            self.translation = None\n\n        if rotation is not None:\n            self.rotation = np.asarray(rotation, dtype=float)\n            if self.rotation.shape != ():\n                raise ValueError(\"rotation must have shaoe ().\")\n        else:\n            self.rotation = None\n\n        if compression is not None:\n            self.compression = np.asarray(compression, dtype=float)\n            if self.compression.shape != (2,):\n                raise ValueError(\"compression must have shape (2,).\")\n        else:\n            self.compression = None\n\n        if shear is not None:\n            self.shear = np.asarray(shear, dtype=float)\n            if self.shear.shape != (2,):\n                raise ValueError(\"shear must be have shape (2,).\")\n        else:\n            self.shear = None\n\n    def calculate(self: CoordTransform, npix: int, diam: float) -&gt; Array:\n        \"\"\"\n        Generate the transformed coords from diameter and npix.\n\n        Parameters\n        ----------\n        npix : int\n            The number of pixels in the output array.\n        diam : float\n            The diameter of the output array in metres.\n\n        Returns\n        -------\n        coords : Array\n            The transformed coordinates.\n        \"\"\"\n        return self.apply(dlu.pixel_coords(npix, diam))\n\n    def apply(self: CoordTransform, coords: Array) -&gt; Array:\n        \"\"\"\n        Apply the transformations to the input coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The input coordinates to be transformed.\n\n        Returns\n        -------\n        coords : Array\n            The transformed coordinates.\n        \"\"\"\n        if self.translation is not None:\n            coords = dlu.translate_coords(coords, self.translation)\n        if self.shear is not None:\n            coords = dlu.shear_coords(coords, self.shear)\n        if self.compression is not None:\n            coords = dlu.compress_coords(coords, self.compression)\n        if self.rotation is not None:\n            coords = dlu.rotate_coords(coords, self.rotation)\n        return coords\n</code></pre>"},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.__init__","title":"<code>__init__(translation=None, rotation=None, compression=None, shear=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>translation</code> <code>Array</code> <p>The (x, y) shift applied to the coords.</p> <code>None</code> <code>rotation</code> <code>float</code> <p>The clockwise rotation applied to the coords.</p> <code>None</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression applied to the coords.</p> <code>None</code> <code>shear</code> <code>Array</code> <p>The (x, y) shear applied to the coords.</p> <code>None</code> Source code in <code>src/dLux/transformations.py</code> <pre><code>def __init__(\n    self: CoordTransform,\n    translation: Array = None,\n    rotation: float = None,\n    compression: Array = None,\n    shear: Array = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    translation: Array\n        The (x, y) shift applied to the coords.\n    rotation: float, radians\n        The clockwise rotation applied to the coords.\n    compression: Array\n        The (x, y) compression applied to the coords.\n    shear: Array\n        The (x, y) shear applied to the coords.\n    \"\"\"\n    if translation is not None:\n        self.translation = np.asarray(translation, dtype=float)\n        if self.translation.shape != (2,):\n            raise ValueError(\"center must be have shape (2,).\")\n    else:\n        self.translation = None\n\n    if rotation is not None:\n        self.rotation = np.asarray(rotation, dtype=float)\n        if self.rotation.shape != ():\n            raise ValueError(\"rotation must have shaoe ().\")\n    else:\n        self.rotation = None\n\n    if compression is not None:\n        self.compression = np.asarray(compression, dtype=float)\n        if self.compression.shape != (2,):\n            raise ValueError(\"compression must have shape (2,).\")\n    else:\n        self.compression = None\n\n    if shear is not None:\n        self.shear = np.asarray(shear, dtype=float)\n        if self.shear.shape != (2,):\n            raise ValueError(\"shear must be have shape (2,).\")\n    else:\n        self.shear = None\n</code></pre>"},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.apply","title":"<code>apply(coords)</code>","text":"<p>Apply the transformations to the input coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The input coordinates to be transformed.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The transformed coordinates.</p> Source code in <code>src/dLux/transformations.py</code> <pre><code>def apply(self: CoordTransform, coords: Array) -&gt; Array:\n    \"\"\"\n    Apply the transformations to the input coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The input coordinates to be transformed.\n\n    Returns\n    -------\n    coords : Array\n        The transformed coordinates.\n    \"\"\"\n    if self.translation is not None:\n        coords = dlu.translate_coords(coords, self.translation)\n    if self.shear is not None:\n        coords = dlu.shear_coords(coords, self.shear)\n    if self.compression is not None:\n        coords = dlu.compress_coords(coords, self.compression)\n    if self.rotation is not None:\n        coords = dlu.rotate_coords(coords, self.rotation)\n    return coords\n</code></pre>"},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.calculate","title":"<code>calculate(npix, diam)</code>","text":"<p>Generate the transformed coords from diameter and npix.</p> <p>Parameters:</p> Name Type Description Default <code>npix</code> <code>int</code> <p>The number of pixels in the output array.</p> required <code>diam</code> <code>float</code> <p>The diameter of the output array in metres.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The transformed coordinates.</p> Source code in <code>src/dLux/transformations.py</code> <pre><code>def calculate(self: CoordTransform, npix: int, diam: float) -&gt; Array:\n    \"\"\"\n    Generate the transformed coords from diameter and npix.\n\n    Parameters\n    ----------\n    npix : int\n        The number of pixels in the output array.\n    diam : float\n        The diameter of the output array in metres.\n\n    Returns\n    -------\n    coords : Array\n        The transformed coordinates.\n    \"\"\"\n    return self.apply(dlu.pixel_coords(npix, diam))\n</code></pre>"},{"location":"API/core/transformations/#dLux.transformations.CoordTransform","title":"Transformations","text":""},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.__init__","title":"Transformations","text":""},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.apply","title":"Transformations","text":""},{"location":"API/core/transformations/#dLux.transformations.CoordTransform.calculate","title":"Transformations","text":""},{"location":"API/core/wavefronts/","title":"Wavefronts","text":"Wavefront <p>             Bases: <code>Base</code></p> <p>A simple class to hold the state of some wavefront as it is transformed and propagated throughout an optical system. All wavefronts assume square arrays.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>(float, meters)</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>(Array, power)</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>(Array, radians)</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale of the phase and amplitude arrays. If <code>units='Cartesian'</code> then the pixel scale is in meters/pixel, else if <code>units='Angular'</code> then the pixel scale is in radians/pixel.</p> <code>plane</code> <code>str</code> <p>The current plane type of wavefront, can be 'Pupil', 'Focal' or 'Intermediate'.</p> <code>units</code> <code>str</code> <p>The current units of the wavefront, can be 'Cartesian' or 'Angular'.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>class Wavefront(Base):\n    \"\"\"\n    A simple class to hold the state of some wavefront as it is transformed and\n    propagated throughout an optical system. All wavefronts assume square arrays.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale of the phase and amplitude arrays. If `units='Cartesian'` then\n        the pixel scale is in meters/pixel, else if `units='Angular'` then the pixel\n        scale is in radians/pixel.\n    plane : str\n        The current plane type of wavefront, can be 'Pupil', 'Focal' or 'Intermediate'.\n    units : str\n        The current units of the wavefront, can be 'Cartesian' or 'Angular'.\n    \"\"\"\n\n    wavelength: float\n    pixel_scale: float\n    amplitude: Array\n    phase: Array\n    plane: str\n    units: str\n\n    def __init__(\n        self: Wavefront, npixels: int, diameter: float, wavelength: float\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels that represent the `Wavefront`.\n        diameter : float, meters\n            The total diameter of the `Wavefront`.\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        \"\"\"\n        self.wavelength = np.asarray(wavelength, float)\n        self.pixel_scale = np.asarray(diameter / npixels, float)\n        self.amplitude = (\n            np.ones((npixels, npixels), dtype=float) / npixels**2\n        )\n        self.phase = np.zeros((npixels, npixels), dtype=float)\n\n        # Always initialised in Pupil plane with Cartesian Coords\n        self.plane = \"Pupil\"\n        self.units = \"Cartesian\"\n\n    ####################\n    # Getter Functions #\n    ####################\n    @property\n    def diameter(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the current wavefront diameter calculated using the pixel scale and\n        number of pixels.\n\n        Returns\n        -------\n        diameter : Array, meters or radians\n            The current diameter of the wavefront.\n        \"\"\"\n        return self.npixels * self.pixel_scale\n\n    @property\n    def npixels(self: Wavefront) -&gt; int:\n        \"\"\"\n        Returns the side length of the arrays currently representing the wavefront.\n        Taken from the last axis of the amplitude array.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[-1]\n\n    @property\n    def real(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the real component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The real component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.cos(self.phase)\n\n    @property\n    def imaginary(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the imaginary component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The imaginary component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.sin(self.phase)\n\n    @property\n    def phasor(self: Wavefront) -&gt; Array:\n        \"\"\"\n        The electric field phasor described by this Wavefront in complex form.\n\n        Returns\n        -------\n        field : Array\n            The electric field phasor of the wavefront.\n        \"\"\"\n        return self.amplitude * np.exp(1j * self.phase)\n\n    @property\n    def psf(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Calculates the Point Spread Function (PSF), i.e. the squared modulus\n        of the complex wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return self.amplitude**2\n\n    @property\n    def coordinates(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the physical positions of the wavefront pixels in meters.\n\n        Returns\n        -------\n        coordinates : Array\n            The coordinates of the centers of each pixel representing the\n            wavefront.\n        \"\"\"\n        return dlu.pixel_coords(self.npixels, self.diameter)\n\n    @property\n    def wavenumber(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the wavenumber of the wavefront (2 * pi / wavelength).\n\n        Returns\n        -------\n        wavenumber : Array, 1/meters\n            The wavenumber of the wavefront.\n        \"\"\"\n        return 2 * np.pi / self.wavelength\n\n    @property\n    def fringe_size(self: Wavefront) -&gt; Array:\n        \"\"\"\n        Returns the size of the fringes in angular units.\n\n        TODO Units check from focal plane\n        Returns\n        -------\n        fringe_size : Array, radians\n            The size of the linear diffraction fringe of the wavefront.\n        \"\"\"\n        return self.wavelength / self.diameter\n\n    @property\n    def ndim(self: Wavefront) -&gt; int:\n        \"\"\"\n        Returns the number of 'dimensions' of the wavefront. This is used to track the\n        vectorised version of the wavefront returned from vmapping.\n\n        Returns\n        -------\n        ndim : int\n            The 'dimensionality' of dimensions of the wavefront.\n        \"\"\"\n        return self.pixel_scale.ndim\n\n    #################\n    # Magic Methods #\n    #################\n    def __add__(self: Wavefront, other: Any) -&gt; Wavefront:\n        \"\"\"\n        Adds the input 'other' to the wavefront. If the input is a numeric type, it is\n        treated as an OPD, else if it is an optical layer, it will be applied to the\n        wavefront.\n\n        Parameters\n        ----------\n        other : Any\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type\n        if other is None:\n            return self\n\n        # Some Optical Layer\n        if isinstance(other, OpticalLayer()):\n            return other.apply(self)\n\n        # Array based inputs - Defaults to OPD\n        if isinstance(other, (Array, float, int)):\n            return self.add_opd(other)\n\n        # Other\n        else:\n            raise TypeError(\n                \"Can only add an array or OpticalLayer to \"\n                f\"Wavefront. Got: {type(other)}.\"\n            )\n\n    def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:\n        \"\"\"\n        Provides the += operator for the wavefront, calling the __add__ method.\n\n        Parameters\n        ----------\n        other : Any\n            The input to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__add__(other)\n\n    def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:\n        \"\"\"\n        Multiplies the input 'other' to the wavefront. If the input is a numeric type,\n        it is treated as an array of transmission values and is multiplied by the\n        wavefront amplitude, unless it is a complex number, in which case it will be\n        multiplied with the wavefront phasor. If it is an optical layer, it will be\n        applied to the wavefront.\n\n        Parameters\n        ----------\n        other : Any\n            The input to multiply with the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        # None Type, return None\n        if other is None:\n            return self\n\n        # Some Optical Layer, apply it\n        if isinstance(other, OpticalLayer()):\n            return other.apply(self)\n\n        # Array based inputs\n        if isinstance(other, (Array, float, int)):\n            # Complex array - Multiply the phasors\n            if isinstance(other, Array) and other.dtype.kind == \"c\":\n                phasor = self.phasor * other\n                return self.set(\n                    [\"amplitude\", \"phase\"], [np.abs(phasor), np.angle(phasor)]\n                )\n\n            # Scalar array - Multiply amplitude\n            else:\n                return self.multiply(\"amplitude\", other)\n\n        # Other\n        else:\n            raise TypeError(\n                \"Can only multiply Wavefront by array or \"\n                f\"OpticalLayer. Got: {type(other)}.\"\n            )\n\n    def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:\n        \"\"\"\n        Provides the *= operator for the wavefront, calling the __mul__ method.\n\n        Parameters\n        ----------\n        other : Any\n            The input to multiply with the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The output wavefront.\n        \"\"\"\n        return self.__mul__(other)\n\n    ###################\n    # Adder Functions #\n    ###################\n    def add_opd(self: Wavefront, opd: Array) -&gt; Wavefront:\n        \"\"\"\n        Adds an optical path difference (OPD) to the wavefront.\n\n        Parameters\n        ----------\n        opd : Array, meters\n            The opd to add to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phases updated according to the supplied opd.\n        \"\"\"\n        return self.add(\"phase\", self.wavenumber * opd)\n\n    def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:\n        \"\"\"\n        Adds a phase to the wavefront.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            The phase to be added to the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with updated phases.\n        \"\"\"\n        # Add this extra None check to allow PhaseOptics to have a None phase\n        # and still be able to be 'added' to it, making this the phase\n        # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`\n        if phase is not None:\n            return self.add(\"phase\", phase)\n        return self\n\n    ###################\n    # Other Functions #\n    ###################\n    def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:\n        \"\"\"\n        Tilts the wavefront by the (x, y) angles.\n\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The tilted wavefront.\n        \"\"\"\n        if not isinstance(angles, Array) or angles.shape != (2,):\n            raise ValueError(\"angles must be an array of shape (2,).\")\n        opd = -(angles[:, None, None] * self.coordinates).sum(0)\n        return self.add_opd(opd)\n\n    def normalise(self: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Normalises the total power of the wavefront to 1.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The normalised wavefront.\n        \"\"\"\n        return self.divide(\"amplitude\", np.linalg.norm(self.amplitude))\n\n    def _to_field(self: Wavefront, complex: bool = False) -&gt; Array:\n        \"\"\"\n        Returns the wavefront in either (amplitude, phase) or (real, imaginary) form.\n\n        Parameters\n        ----------\n        complex : bool = False\n            Whether to return the wavefront in (real, imaginary) form.\n\n        Returns\n        -------\n        field : Array\n            The wavefront in either (amplitude, phase) or (real, imaginary) form.\n        \"\"\"\n        if complex:\n            return np.array([self.real, self.imaginary])\n        return np.array([self.amplitude, self.phase])\n\n    def _to_amplitude_phase(self: Wavefront, field: Array) -&gt; Array:\n        \"\"\"\n        Transforms the input field in (real, imaginary) to (amplitude, phase) form.\n\n        Parameters\n        ----------\n        field : Array\n            The wavefront field in (real, imaginary) form.\n\n        Returns\n        -------\n        field : Array\n            The wavefront field in (amplitude, phase) form.\n        \"\"\"\n        amplitude = np.hypot(field[0], field[1])\n        phase = np.arctan2(field[1], field[0])\n        return np.array([amplitude, phase])\n\n    def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:\n        \"\"\"\n        Flips the wavefront along the specified axes. Note we use 'ij' indexing, so\n        axis 0 is the y-axis and axis 1 is the x-axis.\n\n        Parameters\n        ----------\n        axis : tuple\n            The axes along which to flip the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new flipped wavefront.\n        \"\"\"\n        field = self._to_field()\n        flipper = vmap(np.flip, (0, None))\n        amplitude, phase = flipper(field, axis)\n        return self.set([\"amplitude\", \"phase\"], [amplitude, phase])\n\n    def scale_to(\n        self: Wavefront,\n        npixels: int,\n        pixel_scale: Array,\n        complex: bool = False,\n    ) -&gt; Wavefront:\n        \"\"\"\n        Interpolated the wavefront to a given npixels and pixel_scale. Can be done on\n        the real and imaginary components by passing in complex=True.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels  to interpolate to.\n        pixel_scale: Array\n            The pixel scale to interpolate to.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the wavefront as\n            opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new interpolated wavefront.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Scale the field\n        scale_fn = vmap(dlu.scale, (0, None, None))\n        field = scale_fn(field, npixels, pixel_scale / self.pixel_scale)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set(\n            [\"amplitude\", \"phase\", \"pixel_scale\"],\n            [field[0], field[1], pixel_scale],\n        )\n\n    def rotate(\n        self: Wavefront, angle: Array, order: int = 1, complex: bool = False\n    ) -&gt; Wavefront:\n        \"\"\"\n        Rotates the wavefront by a given angle via interpolation. Can be done on the\n        real and imaginary components by passing in complex=True.\n\n        Parameters\n        ----------\n        angle : Array, radians\n            The angle by which to rotate the wavefront in a clockwise\n            direction.\n        order : int = 1\n            The interpolation order to use.\n        complex : bool = False\n            Whether to rotate the real and imaginary representation of the wavefront as\n            opposed to the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront rotated by angle in the clockwise direction.\n        \"\"\"\n        # Get field in either (amplitude, phase) or (real, imaginary)\n        field = self._to_field(complex=complex)\n\n        # Rotate the field\n        rotator = vmap(dlu.rotate, (0, None, None))\n        field = rotator(field, angle, order)\n\n        # Cast back to (amplitude, phase) if needed\n        if complex:\n            field = self._to_amplitude_phase(field)\n\n        # Return new wavefront\n        return self.set([\"amplitude\", \"phase\"], [field[0], field[1]])\n\n    def resize(self: Wavefront, npixels: int) -&gt; Wavefront:\n        \"\"\"\n        Resizes the wavefront via a zero-padding or cropping operation.\n\n        Parameters\n        ----------\n        npixels : int\n            The size to resize the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The resized wavefront.\n        \"\"\"\n        field = self._to_field()\n        amplitude, phase = vmap(dlu.resize, (0, None))(field, npixels)\n        return self.set([\"amplitude\", \"phase\"], [amplitude, phase])\n\n    #########################\n    # Propagation Functions #\n    #########################\n    def _prep_prop(self: Wavefront, focal_length) -&gt; tuple:\n        \"\"\"\n        Determines the propagation direction, output plane and output units.\n\n        Parameters\n        ----------\n        focal_length : Union[float, None]\n            The focal length of the propagation.\n\n        Returns\n        -------\n        inverse : bool\n            Whether the propagation is inverse or not.\n        plane : str\n            The output plane of the propagation.\n        units : str\n            The output units of the propagation.\n        \"\"\"\n        # Determine propagation direction, output plane and output units\n        if self.plane == \"Pupil\":\n            inverse = False\n            plane = \"Focal\"\n            if focal_length is None:\n                units = \"Angular\"\n            else:\n                units = \"Cartesian\"\n        else:\n            if focal_length is not None and self.units == \"Angular\":\n                raise ValueError(\n                    \"focal_length can not be specific when\"\n                    \"propagating from a Focal plane with angular units.\"\n                )\n            inverse = True\n            plane = \"Pupil\"\n            units = \"Cartesian\"\n\n        return inverse, plane, units\n\n    def propagate_FFT(\n        self: Wavefront,\n        focal_length: float = None,\n        pad: int = 2,\n    ) -&gt; Wavefront:\n        \"\"\"\n        Propagates the wavefront by performing a Fast Fourier Transform.\n\n        Parameters\n        ----------\n        focal_length : float = None\n            The focal length of the propagation. If None, the output pixel scale has\n            units of radians, else meters.\n        pad : int = 2\n            The padding factory to apply to the input wavefront before the FFT.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        inverse, plane, units = self._prep_prop(focal_length)\n\n        # Calculate\n        phasor, pixel_scale = dlu.FFT(\n            self.phasor,\n            self.wavelength,\n            self.pixel_scale,\n            focal_length,\n            pad,\n            inverse,\n        )\n\n        # Return new wavefront\n        return self.set(\n            [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n            [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n        )\n\n    # TODO: Class method this?\n    def _MFT(\n        self: Wavefront,\n        phasor: Array,\n        wavelength: float,\n        pixel_scale: float,\n        *args: tuple,\n    ) -&gt; Array:\n        \"\"\"\n        Simple alias for the MFT function to allow for vectorisation over phasors,\n        wavelengths, pixel_scales, etc.\n\n        Parameters\n        ----------\n        phasor : Array\n            The phasor to propagate.\n        wavelength : float\n            The wavelength of the wavefront.\n        pixel_scale : float\n            The pixel scale of the wavefront.\n        args : tuple\n            The propagation arguments.\n\n        Returns\n        -------\n        phasor : Array\n            The propagated phasor.\n        \"\"\"\n        return dlu.MFT(phasor, wavelength, pixel_scale, *args)\n\n    def propagate(\n        self: Wavefront,\n        npixels: int,\n        pixel_scale: float,\n        focal_length: float = None,\n        shift: Array = np.zeros(2),\n        pixel: bool = True,\n    ) -&gt; Wavefront:\n        \"\"\"\n        Propagates the wavefront by performing an MFT, allowing for the output pixel\n        scale and npixels to be specified.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The pixel scale of the output plane.\n        focal_length : float = None\n            The focal length of the propagation. If None, the propagation is angular\n            and pixel_scale_out is taken in as radians/pixel, else meters/pixel.\n        shift : Array = np.zeros(2)\n            The shift in the center of the output plane.\n        pixel : bool = True\n            Should the shift be taken in units of pixels, or pixel scale.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        inverse, plane, units = self._prep_prop(focal_length)\n\n        # Enforce array so output can be vectorised by vmap\n        pixel_scale = np.asarray(pixel_scale, float)\n\n        # Calculate\n        # Using a self._MFT here allows for broadband wavefronts to define\n        # vectorised propagation fn over phasors, wavels, px_scales, etc.\n        # It also makes the code muuuuch nicer to read\n        args = (npixels, pixel_scale, focal_length, shift, pixel, inverse)\n        phasor = self._MFT(\n            self.phasor, self.wavelength, self.pixel_scale, *args\n        )\n\n        # Update\n        return self.set(\n            [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n            [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n        )\n\n    # # TODO: Class method this?\n    # def _fresnel(self, phasor, wavelength, pixel_scale, focal_shift, *args):\n    #     return dlu.fresnel_MFT(phasor, wavelength, pixel_scale, *args)\n\n    def propagate_fresnel(\n        self: Wavefront,\n        npixels: int,\n        pixel_scale: float,\n        focal_length: float,\n        focal_shift: float = 0.0,\n        shift: Array = np.zeros(2),\n        pixel: bool = True,\n    ) -&gt; Wavefront:\n        \"\"\"\n        Propagates the phasor using a Far-Field Fresnel propagation. This allows for\n        psfs to be better modelled a few wavelengths from the focal plane.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The pixel scale of the output plane.\n        focal_length : float\n            The focal length of the propagation.\n        focal_shift: float, meters = 0.\n            The shift from focus to propagate to.\n        shift : Array = np.zeros(2)\n            The shift in the center of the output plane.\n        pixel : bool = True\n            Should the shift be taken in units of pixels, or pixel scale.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The propagated wavefront.\n        \"\"\"\n        # TODO: Try inverse propagation to see if it works, it probably will\n        if self.plane == \"Pupil\":\n            inverse = False\n        else:\n            inverse = True\n        plane = \"Intermediate\"\n        units = \"Cartesian\"\n\n        # We can't fresnel from a focal plane\n        if self.plane != \"Pupil\":\n            raise ValueError(\n                \"Can only do an fresnel propagation from a Pupil plane, \"\n                f\"current plane is {self.plane}.\"\n            )\n\n        # Calculate\n        phasor = dlu.fresnel_MFT(\n            self.phasor,\n            self.wavelength,\n            self.pixel_scale,\n            npixels,\n            pixel_scale,\n            focal_length,\n            focal_shift,\n            shift,\n            pixel,\n            inverse,\n        )\n\n        # Update\n        return self.set(\n            [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n            [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n        )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.coordinates","title":"<code>coordinates: Array</code>  <code>property</code>","text":"<p>Returns the physical positions of the wavefront pixels in meters.</p> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The coordinates of the centers of each pixel representing the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"<code>diameter: Array</code>  <code>property</code>","text":"<p>Returns the current wavefront diameter calculated using the pixel scale and number of pixels.</p> <p>Returns:</p> Name Type Description <code>diameter</code> <code>(Array, meters or radians)</code> <p>The current diameter of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.fringe_size","title":"<code>fringe_size: Array</code>  <code>property</code>","text":"<p>Returns the size of the fringes in angular units.</p> <p>TODO Units check from focal plane</p> <p>Returns:</p> Name Type Description <code>fringe_size</code> <code>(Array, radians)</code> <p>The size of the linear diffraction fringe of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"<code>imaginary: Array</code>  <code>property</code>","text":"<p>Returns the imaginary component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The imaginary component of the <code>Wavefront</code> phasor.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Returns the number of 'dimensions' of the wavefront. This is used to track the vectorised version of the wavefront returned from vmapping.</p> <p>Returns:</p> Name Type Description <code>ndim</code> <code>int</code> <p>The 'dimensionality' of dimensions of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the wavefront. Taken from the last axis of the amplitude array.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"<code>phasor: Array</code>  <code>property</code>","text":"<p>The electric field phasor described by this Wavefront in complex form.</p> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The electric field phasor of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"<code>psf: Array</code>  <code>property</code>","text":"<p>Calculates the Point Spread Function (PSF), i.e. the squared modulus of the complex wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.real","title":"<code>real: Array</code>  <code>property</code>","text":"<p>Returns the real component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The real component of the <code>Wavefront</code> phasor.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"<code>wavenumber: Array</code>  <code>property</code>","text":"<p>Returns the wavenumber of the wavefront (2 * pi / wavelength).</p> <p>Returns:</p> Name Type Description <code>wavenumber</code> <code>(Array, 1 / meters)</code> <p>The wavenumber of the wavefront.</p>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds the input 'other' to the wavefront. If the input is a numeric type, it is treated as an OPD, else if it is an optical layer, it will be applied to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def __add__(self: Wavefront, other: Any) -&gt; Wavefront:\n    \"\"\"\n    Adds the input 'other' to the wavefront. If the input is a numeric type, it is\n    treated as an OPD, else if it is an optical layer, it will be applied to the\n    wavefront.\n\n    Parameters\n    ----------\n    other : Any\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    # None Type\n    if other is None:\n        return self\n\n    # Some Optical Layer\n    if isinstance(other, OpticalLayer()):\n        return other.apply(self)\n\n    # Array based inputs - Defaults to OPD\n    if isinstance(other, (Array, float, int)):\n        return self.add_opd(other)\n\n    # Other\n    else:\n        raise TypeError(\n            \"Can only add an array or OpticalLayer to \"\n            f\"Wavefront. Got: {type(other)}.\"\n        )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Provides the += operator for the wavefront, calling the add method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The input to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def __iadd__(self: Wavefront, other: Any) -&gt; Wavefront:\n    \"\"\"\n    Provides the += operator for the wavefront, calling the __add__ method.\n\n    Parameters\n    ----------\n    other : Any\n        The input to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__imul__","title":"<code>__imul__(other)</code>","text":"<p>Provides the *= operator for the wavefront, calling the mul method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The input to multiply with the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def __imul__(self: Wavefront, other: Any) -&gt; Wavefront:\n    \"\"\"\n    Provides the *= operator for the wavefront, calling the __mul__ method.\n\n    Parameters\n    ----------\n    other : Any\n        The input to multiply with the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"<code>__init__(npixels, diameter, wavelength)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p> required <code>diameter</code> <code>(float, meters)</code> <p>The total diameter of the <code>Wavefront</code>.</p> required <code>wavelength</code> <code>(float, meters)</code> <p>The wavelength of the <code>Wavefront</code>.</p> required Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def __init__(\n    self: Wavefront, npixels: int, diameter: float, wavelength: float\n):\n    \"\"\"\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels that represent the `Wavefront`.\n    diameter : float, meters\n        The total diameter of the `Wavefront`.\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    \"\"\"\n    self.wavelength = np.asarray(wavelength, float)\n    self.pixel_scale = np.asarray(diameter / npixels, float)\n    self.amplitude = (\n        np.ones((npixels, npixels), dtype=float) / npixels**2\n    )\n    self.phase = np.zeros((npixels, npixels), dtype=float)\n\n    # Always initialised in Pupil plane with Cartesian Coords\n    self.plane = \"Pupil\"\n    self.units = \"Cartesian\"\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiplies the input 'other' to the wavefront. If the input is a numeric type, it is treated as an array of transmission values and is multiplied by the wavefront amplitude, unless it is a complex number, in which case it will be multiplied with the wavefront phasor. If it is an optical layer, it will be applied to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The input to multiply with the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The output wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def __mul__(self: Wavefront, other: Any) -&gt; Wavefront:\n    \"\"\"\n    Multiplies the input 'other' to the wavefront. If the input is a numeric type,\n    it is treated as an array of transmission values and is multiplied by the\n    wavefront amplitude, unless it is a complex number, in which case it will be\n    multiplied with the wavefront phasor. If it is an optical layer, it will be\n    applied to the wavefront.\n\n    Parameters\n    ----------\n    other : Any\n        The input to multiply with the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The output wavefront.\n    \"\"\"\n    # None Type, return None\n    if other is None:\n        return self\n\n    # Some Optical Layer, apply it\n    if isinstance(other, OpticalLayer()):\n        return other.apply(self)\n\n    # Array based inputs\n    if isinstance(other, (Array, float, int)):\n        # Complex array - Multiply the phasors\n        if isinstance(other, Array) and other.dtype.kind == \"c\":\n            phasor = self.phasor * other\n            return self.set(\n                [\"amplitude\", \"phase\"], [np.abs(phasor), np.angle(phasor)]\n            )\n\n        # Scalar array - Multiply amplitude\n        else:\n            return self.multiply(\"amplitude\", other)\n\n    # Other\n    else:\n        raise TypeError(\n            \"Can only multiply Wavefront by array or \"\n            f\"OpticalLayer. Got: {type(other)}.\"\n        )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"<code>add_opd(opd)</code>","text":"<p>Adds an optical path difference (OPD) to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>(Array, meters)</code> <p>The opd to add to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phases updated according to the supplied opd.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def add_opd(self: Wavefront, opd: Array) -&gt; Wavefront:\n    \"\"\"\n    Adds an optical path difference (OPD) to the wavefront.\n\n    Parameters\n    ----------\n    opd : Array, meters\n        The opd to add to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the phases updated according to the supplied opd.\n    \"\"\"\n    return self.add(\"phase\", self.wavenumber * opd)\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"<code>add_phase(phase)</code>","text":"<p>Adds a phase to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>(Array, radians)</code> <p>The phase to be added to the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with updated phases.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def add_phase(self: Wavefront, phase: Array) -&gt; Wavefront:\n    \"\"\"\n    Adds a phase to the wavefront.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be added to the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with updated phases.\n    \"\"\"\n    # Add this extra None check to allow PhaseOptics to have a None phase\n    # and still be able to be 'added' to it, making this the phase\n    # equivalent of `wf += opd` -&gt; `wf = wf.add_phase(phase)`\n    if phase is not None:\n        return self.add(\"phase\", phase)\n    return self\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.flip","title":"<code>flip(axis)</code>","text":"<p>Flips the wavefront along the specified axes. Note we use 'ij' indexing, so axis 0 is the y-axis and axis 1 is the x-axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>tuple</code> <p>The axes along which to flip the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new flipped wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def flip(self: Wavefront, axis: tuple) -&gt; Wavefront:\n    \"\"\"\n    Flips the wavefront along the specified axes. Note we use 'ij' indexing, so\n    axis 0 is the y-axis and axis 1 is the x-axis.\n\n    Parameters\n    ----------\n    axis : tuple\n        The axes along which to flip the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new flipped wavefront.\n    \"\"\"\n    field = self._to_field()\n    flipper = vmap(np.flip, (0, None))\n    amplitude, phase = flipper(field, axis)\n    return self.set([\"amplitude\", \"phase\"], [amplitude, phase])\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the total power of the wavefront to 1.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The normalised wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def normalise(self: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Normalises the total power of the wavefront to 1.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The normalised wavefront.\n    \"\"\"\n    return self.divide(\"amplitude\", np.linalg.norm(self.amplitude))\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate","title":"<code>propagate(npixels, pixel_scale, focal_length=None, shift=np.zeros(2), pixel=True)</code>","text":"<p>Propagates the wavefront by performing an MFT, allowing for the output pixel scale and npixels to be specified.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale of the output plane.</p> required <code>focal_length</code> <code>float = None</code> <p>The focal length of the propagation. If None, the propagation is angular and pixel_scale_out is taken in as radians/pixel, else meters/pixel.</p> <code>None</code> <code>shift</code> <code>Array = np.zeros(2)</code> <p>The shift in the center of the output plane.</p> <code>zeros(2)</code> <code>pixel</code> <code>bool = True</code> <p>Should the shift be taken in units of pixels, or pixel scale.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def propagate(\n    self: Wavefront,\n    npixels: int,\n    pixel_scale: float,\n    focal_length: float = None,\n    shift: Array = np.zeros(2),\n    pixel: bool = True,\n) -&gt; Wavefront:\n    \"\"\"\n    Propagates the wavefront by performing an MFT, allowing for the output pixel\n    scale and npixels to be specified.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale of the output plane.\n    focal_length : float = None\n        The focal length of the propagation. If None, the propagation is angular\n        and pixel_scale_out is taken in as radians/pixel, else meters/pixel.\n    shift : Array = np.zeros(2)\n        The shift in the center of the output plane.\n    pixel : bool = True\n        Should the shift be taken in units of pixels, or pixel scale.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    inverse, plane, units = self._prep_prop(focal_length)\n\n    # Enforce array so output can be vectorised by vmap\n    pixel_scale = np.asarray(pixel_scale, float)\n\n    # Calculate\n    # Using a self._MFT here allows for broadband wavefronts to define\n    # vectorised propagation fn over phasors, wavels, px_scales, etc.\n    # It also makes the code muuuuch nicer to read\n    args = (npixels, pixel_scale, focal_length, shift, pixel, inverse)\n    phasor = self._MFT(\n        self.phasor, self.wavelength, self.pixel_scale, *args\n    )\n\n    # Update\n    return self.set(\n        [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n    )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate_FFT","title":"<code>propagate_FFT(focal_length=None, pad=2)</code>","text":"<p>Propagates the wavefront by performing a Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>float = None</code> <p>The focal length of the propagation. If None, the output pixel scale has units of radians, else meters.</p> <code>None</code> <code>pad</code> <code>int = 2</code> <p>The padding factory to apply to the input wavefront before the FFT.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def propagate_FFT(\n    self: Wavefront,\n    focal_length: float = None,\n    pad: int = 2,\n) -&gt; Wavefront:\n    \"\"\"\n    Propagates the wavefront by performing a Fast Fourier Transform.\n\n    Parameters\n    ----------\n    focal_length : float = None\n        The focal length of the propagation. If None, the output pixel scale has\n        units of radians, else meters.\n    pad : int = 2\n        The padding factory to apply to the input wavefront before the FFT.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    inverse, plane, units = self._prep_prop(focal_length)\n\n    # Calculate\n    phasor, pixel_scale = dlu.FFT(\n        self.phasor,\n        self.wavelength,\n        self.pixel_scale,\n        focal_length,\n        pad,\n        inverse,\n    )\n\n    # Return new wavefront\n    return self.set(\n        [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n    )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate_fresnel","title":"<code>propagate_fresnel(npixels, pixel_scale, focal_length, focal_shift=0.0, shift=np.zeros(2), pixel=True)</code>","text":"<p>Propagates the phasor using a Far-Field Fresnel propagation. This allows for psfs to be better modelled a few wavelengths from the focal plane.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale of the output plane.</p> required <code>focal_length</code> <code>float</code> <p>The focal length of the propagation.</p> required <code>focal_shift</code> <code>float</code> <p>The shift from focus to propagate to.</p> <code>0.0</code> <code>shift</code> <code>Array = np.zeros(2)</code> <p>The shift in the center of the output plane.</p> <code>zeros(2)</code> <code>pixel</code> <code>bool = True</code> <p>Should the shift be taken in units of pixels, or pixel scale.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The propagated wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def propagate_fresnel(\n    self: Wavefront,\n    npixels: int,\n    pixel_scale: float,\n    focal_length: float,\n    focal_shift: float = 0.0,\n    shift: Array = np.zeros(2),\n    pixel: bool = True,\n) -&gt; Wavefront:\n    \"\"\"\n    Propagates the phasor using a Far-Field Fresnel propagation. This allows for\n    psfs to be better modelled a few wavelengths from the focal plane.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale of the output plane.\n    focal_length : float\n        The focal length of the propagation.\n    focal_shift: float, meters = 0.\n        The shift from focus to propagate to.\n    shift : Array = np.zeros(2)\n        The shift in the center of the output plane.\n    pixel : bool = True\n        Should the shift be taken in units of pixels, or pixel scale.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The propagated wavefront.\n    \"\"\"\n    # TODO: Try inverse propagation to see if it works, it probably will\n    if self.plane == \"Pupil\":\n        inverse = False\n    else:\n        inverse = True\n    plane = \"Intermediate\"\n    units = \"Cartesian\"\n\n    # We can't fresnel from a focal plane\n    if self.plane != \"Pupil\":\n        raise ValueError(\n            \"Can only do an fresnel propagation from a Pupil plane, \"\n            f\"current plane is {self.plane}.\"\n        )\n\n    # Calculate\n    phasor = dlu.fresnel_MFT(\n        self.phasor,\n        self.wavelength,\n        self.pixel_scale,\n        npixels,\n        pixel_scale,\n        focal_length,\n        focal_shift,\n        shift,\n        pixel,\n        inverse,\n    )\n\n    # Update\n    return self.set(\n        [\"amplitude\", \"phase\", \"pixel_scale\", \"plane\", \"units\"],\n        [np.abs(phasor), np.angle(phasor), pixel_scale, plane, units],\n    )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.resize","title":"<code>resize(npixels)</code>","text":"<p>Resizes the wavefront via a zero-padding or cropping operation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The size to resize the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The resized wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def resize(self: Wavefront, npixels: int) -&gt; Wavefront:\n    \"\"\"\n    Resizes the wavefront via a zero-padding or cropping operation.\n\n    Parameters\n    ----------\n    npixels : int\n        The size to resize the wavefront to.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The resized wavefront.\n    \"\"\"\n    field = self._to_field()\n    amplitude, phase = vmap(dlu.resize, (0, None))(field, npixels)\n    return self.set([\"amplitude\", \"phase\"], [amplitude, phase])\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"<code>rotate(angle, order=1, complex=False)</code>","text":"<p>Rotates the wavefront by a given angle via interpolation. Can be done on the real and imaginary components by passing in complex=True.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>(Array, radians)</code> <p>The angle by which to rotate the wavefront in a clockwise direction.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use.</p> <code>1</code> <code>complex</code> <code>bool = False</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront rotated by angle in the clockwise direction.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def rotate(\n    self: Wavefront, angle: Array, order: int = 1, complex: bool = False\n) -&gt; Wavefront:\n    \"\"\"\n    Rotates the wavefront by a given angle via interpolation. Can be done on the\n    real and imaginary components by passing in complex=True.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in a clockwise\n        direction.\n    order : int = 1\n        The interpolation order to use.\n    complex : bool = False\n        Whether to rotate the real and imaginary representation of the wavefront as\n        opposed to the amplitude and phase representation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront rotated by angle in the clockwise direction.\n    \"\"\"\n    # Get field in either (amplitude, phase) or (real, imaginary)\n    field = self._to_field(complex=complex)\n\n    # Rotate the field\n    rotator = vmap(dlu.rotate, (0, None, None))\n    field = rotator(field, angle, order)\n\n    # Cast back to (amplitude, phase) if needed\n    if complex:\n        field = self._to_amplitude_phase(field)\n\n    # Return new wavefront\n    return self.set([\"amplitude\", \"phase\"], [field[0], field[1]])\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.scale_to","title":"<code>scale_to(npixels, pixel_scale, complex=False)</code>","text":"<p>Interpolated the wavefront to a given npixels and pixel_scale. Can be done on the real and imaginary components by passing in complex=True.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels  to interpolate to.</p> required <code>pixel_scale</code> <code>Array</code> <p>The pixel scale to interpolate to.</p> required <code>complex</code> <code>bool = False</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new interpolated wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def scale_to(\n    self: Wavefront,\n    npixels: int,\n    pixel_scale: Array,\n    complex: bool = False,\n) -&gt; Wavefront:\n    \"\"\"\n    Interpolated the wavefront to a given npixels and pixel_scale. Can be done on\n    the real and imaginary components by passing in complex=True.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels  to interpolate to.\n    pixel_scale: Array\n        The pixel scale to interpolate to.\n    complex : bool = False\n        Whether to rotate the real and imaginary representation of the wavefront as\n        opposed to the amplitude and phase representation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new interpolated wavefront.\n    \"\"\"\n    # Get field in either (amplitude, phase) or (real, imaginary)\n    field = self._to_field(complex=complex)\n\n    # Scale the field\n    scale_fn = vmap(dlu.scale, (0, None, None))\n    field = scale_fn(field, npixels, pixel_scale / self.pixel_scale)\n\n    # Cast back to (amplitude, phase) if needed\n    if complex:\n        field = self._to_amplitude_phase(field)\n\n    # Return new wavefront\n    return self.set(\n        [\"amplitude\", \"phase\", \"pixel_scale\"],\n        [field[0], field[1], pixel_scale],\n    )\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.tilt","title":"<code>tilt(angles)</code>","text":"<p>Tilts the wavefront by the (x, y) angles.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>(Array, radians)</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The tilted wavefront.</p> Source code in <code>src/dLux/wavefronts.py</code> <pre><code>def tilt(self: Wavefront, angles: Array) -&gt; Wavefront:\n    \"\"\"\n    Tilts the wavefront by the (x, y) angles.\n\n    Parameters\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The tilted wavefront.\n    \"\"\"\n    if not isinstance(angles, Array) or angles.shape != (2,):\n        raise ValueError(\"angles must be an array of shape (2,).\")\n    opd = -(angles[:, None, None] * self.coordinates).sum(0)\n    return self.add_opd(opd)\n</code></pre>"},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.coordinates","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.fringe_size","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.ndim","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.real","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__add__","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__iadd__","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__imul__","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.__mul__","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.flip","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate_FFT","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.propagate_fresnel","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.resize","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.scale_to","title":"Wavefronts","text":""},{"location":"API/core/wavefronts/#dLux.wavefronts.Wavefront.tilt","title":"Wavefronts","text":""},{"location":"API/layers/aberrations/","title":"Aberrations","text":"Zernike <p>             Bases: <code>Base</code></p> <p>A Zernike polynomial that can be generated dynamically in a way that is both jit and grad safe. If you want a static zernike (most use cases), use the zernike functions found in <code>utils.zernikes</code> and load the basis into a <code>BasisOptic</code> class.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0) : Piston</p> <p>2, 3 -&gt; (1, -1), (1, 1) : Tip, Tilt</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2) : Defocus, Astigmatism</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3) : Coma, Trefoil</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> <code>name</code> <code>str</code> <p>The name of the Zernike polynomial.</p> <code>_c</code> <code>Array</code> <p>The array of normalisation coefficients used in the radial calculation. This is a pre-calculated parameter and should not be changed.</p> <code>_k</code> <code>Array</code> <p>The array of powers using the radial calculation. This is a pre-calculated parameter and should not be changed.</p> Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>class Zernike(Base):\n    \"\"\"\n    A Zernike polynomial that can be generated dynamically in a way that is both jit and\n    grad safe. If you want a _static_ zernike (most use cases), use the zernike\n    functions found in `utils.zernikes` and load the basis into a `BasisOptic` class.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988). The basic\n    translation between the noll index and the pair of numbers is shown below:\n\n    1 -&gt; (0, 0) : Piston\n\n    2, 3 -&gt; (1, -1), (1, 1) : Tip, Tilt\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2) : Defocus, Astigmatism\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3) : Coma, Trefoil\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Zernike.png)\n\n    Attributes\n    ----------\n    j : int\n        The Zernike (noll) index.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    name : str\n        The name of the Zernike polynomial.\n    _c : Array\n        The array of normalisation coefficients used in the radial calculation.\n        This is a pre-calculated parameter and should not be changed.\n    _k : Array\n        The array of powers using the radial calculation. This is a pre-calculated\n        parameter and should not be changed.\n    \"\"\"\n\n    j: int\n    n: int\n    m: int\n    name: str\n    _c: Array\n    _k: Array\n\n    def __init__(self: Zernike, j: int):\n        \"\"\"\n        Construct for the Zernike class.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n        \"\"\"\n        if int(j) &lt; 1:\n            raise ValueError(\"The Zernike index must be greater than 0.\")\n        self.j = int(j)\n        self.name = dlu.zernike_name(j)\n        self.n, self.m = dlu.noll_indices(j)\n        self._c, self._k = dlu.zernike_factors(j)\n\n    def calculate(self: Zernike, coordinates: Array, nsides: int = 0) -&gt; Array:\n        \"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: standard zernike polynomials are only defined up to a radial value of 1,\n        so generating one that spans the entire aperture needs a diameter of 2.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike is calculated\n            on a circular aperture.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        if nsides == 0:\n            return dlu.zernike_fast(\n                self.n, self.m, self._c, self._k, coordinates\n            )\n        else:\n            return dlu.polike_fast(\n                nsides, self.n, self.m, self._c, self._k, coordinates\n            )\n</code></pre> ZernikeBasis <p>             Bases: <code>Base</code></p> <p>A Basis of Zernike polynomials that can be generated dynamically in a way that is both jit and grad safe. If you want a static zernike (most use cases), use the zernike functions found in <code>utils.zernikes</code> and load the basis into a <code>BasisOptic</code> class.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0) : Piston</p> <p>2, 3 -&gt; (1, -1), (1, 1) : Tip, Tilt</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2) : Defocus, Astigmatism</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3) : Coma, Trefoil</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>list[Zernike]</code> <p>The list of <code>Zernike</code> polynomial classes to calculate.</p> Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>class ZernikeBasis(Base):\n    \"\"\"\n    A Basis of Zernike polynomials that can be generated dynamically in a way that is\n    both jit and grad safe. If you want a _static_ zernike (most use cases), use the\n    zernike functions found in `utils.zernikes` and load the basis into a `BasisOptic`\n    class.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988). The basic\n    translation between the noll index and the pair of numbers is shown below:\n\n    1 -&gt; (0, 0) : Piston\n\n    2, 3 -&gt; (1, -1), (1, 1) : Tip, Tilt\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2) : Defocus, Astigmatism\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3) : Coma, Trefoil\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ZernikeBasis.png)\n\n    Attributes\n    ----------\n    basis : list[Zernike]\n        The list of `Zernike` polynomial classes to calculate.\n    \"\"\"\n\n    basis: list[Zernike]\n\n    def __init__(self: ZernikeBasis, js: list[int]):\n        \"\"\"\n        Constructor for the DynamicZernike class.\n\n        Parameters\n        ----------\n        js : list[int]\n            The list of Zernike (noll) indices to calculate.\n        \"\"\"\n        self.basis = [Zernike(j) for j in js]\n\n    def calculate_basis(\n        self: ZernikeBasis, coordinates: Array, nsides: int = 0\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the full Zernike polynomial basis.\n\n        Note: standard zernike polynomials are only defined up to a radial value of 1,\n        so generating a basis that spans the entire aperture needs a diameter of 2.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The Cartesian coordinates to calculate the Zernike basis upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike basis is calculated\n            on a circular aperture.\n\n        Returns\n        -------\n        basis : Array\n            The Zernike polynomial basis.\n        \"\"\"\n        leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n        calculate_fn = lambda z: z.calculate(coordinates, nsides)\n        return np.array(\n            jtu.tree_map(calculate_fn, self.basis, is_leaf=leaf_fn)\n        )\n</code></pre>"},{"location":"API/layers/aberrations/#dLux.layers.aberrations.Zernike.__init__","title":"<code>__init__(j)</code>","text":"<p>Construct for the Zernike class.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>def __init__(self: Zernike, j: int):\n    \"\"\"\n    Construct for the Zernike class.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n    \"\"\"\n    if int(j) &lt; 1:\n        raise ValueError(\"The Zernike index must be greater than 0.\")\n    self.j = int(j)\n    self.name = dlu.zernike_name(j)\n    self.n, self.m = dlu.noll_indices(j)\n    self._c, self._k = dlu.zernike_factors(j)\n</code></pre>"},{"location":"API/layers/aberrations/#dLux.layers.aberrations.Zernike.calculate","title":"<code>calculate(coordinates, nsides=0)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: standard zernike polynomials are only defined up to a radial value of 1, so generating one that spans the entire aperture needs a diameter of 2.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>def calculate(self: Zernike, coordinates: Array, nsides: int = 0) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial.\n\n    Note: standard zernike polynomials are only defined up to a radial value of 1,\n    so generating one that spans the entire aperture needs a diameter of 2.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike upon.\n    nsides : int\n        The number of sides of the aperture. If 0, the Zernike is calculated\n        on a circular aperture.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    if nsides == 0:\n        return dlu.zernike_fast(\n            self.n, self.m, self._c, self._k, coordinates\n        )\n    else:\n        return dlu.polike_fast(\n            nsides, self.n, self.m, self._c, self._k, coordinates\n        )\n</code></pre>"},{"location":"API/layers/aberrations/#dLux.layers.aberrations.Zernike","title":"Aberrations","text":""},{"location":"API/layers/aberrations/#dLux.layers.aberrations.Zernike.__init__","title":"Aberrations","text":""},{"location":"API/layers/aberrations/#dLux.layers.aberrations.Zernike.calculate","title":"Aberrations","text":""},{"location":"API/layers/aberrations/#dLux.layers.aberrations.ZernikeBasis.__init__","title":"<code>__init__(js)</code>","text":"<p>Constructor for the DynamicZernike class.</p> <p>Parameters:</p> Name Type Description Default <code>js</code> <code>list[int]</code> <p>The list of Zernike (noll) indices to calculate.</p> required Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>def __init__(self: ZernikeBasis, js: list[int]):\n    \"\"\"\n    Constructor for the DynamicZernike class.\n\n    Parameters\n    ----------\n    js : list[int]\n        The list of Zernike (noll) indices to calculate.\n    \"\"\"\n    self.basis = [Zernike(j) for j in js]\n</code></pre>"},{"location":"API/layers/aberrations/#dLux.layers.aberrations.ZernikeBasis.calculate_basis","title":"<code>calculate_basis(coordinates, nsides=0)</code>","text":"<p>Calculates the full Zernike polynomial basis.</p> <p>Note: standard zernike polynomials are only defined up to a radial value of 1, so generating a basis that spans the entire aperture needs a diameter of 2.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike basis upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike basis is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The Zernike polynomial basis.</p> Source code in <code>src/dLux/layers/aberrations.py</code> <pre><code>def calculate_basis(\n    self: ZernikeBasis, coordinates: Array, nsides: int = 0\n) -&gt; Array:\n    \"\"\"\n    Calculates the full Zernike polynomial basis.\n\n    Note: standard zernike polynomials are only defined up to a radial value of 1,\n    so generating a basis that spans the entire aperture needs a diameter of 2.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike basis upon.\n    nsides : int\n        The number of sides of the aperture. If 0, the Zernike basis is calculated\n        on a circular aperture.\n\n    Returns\n    -------\n    basis : Array\n        The Zernike polynomial basis.\n    \"\"\"\n    leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n    calculate_fn = lambda z: z.calculate(coordinates, nsides)\n    return np.array(\n        jtu.tree_map(calculate_fn, self.basis, is_leaf=leaf_fn)\n    )\n</code></pre>"},{"location":"API/layers/aberrations/#dLux.layers.aberrations.ZernikeBasis","title":"Aberrations","text":""},{"location":"API/layers/aberrations/#dLux.layers.aberrations.ZernikeBasis.__init__","title":"Aberrations","text":""},{"location":"API/layers/aberrations/#dLux.layers.aberrations.ZernikeBasis.calculate_basis","title":"Aberrations","text":""},{"location":"API/layers/apertures/","title":"Aperture Layers","text":"BaseDynamicAperture <p>             Bases: <code>ApertureLayer</code></p> <p>An abstract base class that implements the coordinate transformation attribute.</p> <p>Attributes:</p> Name Type Description <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class BaseDynamicAperture(ApertureLayer):\n    \"\"\"\n    An abstract base class that implements the coordinate transformation attribute.\n\n    Attributes\n    ----------\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    transformation: CoordTransform\n\n    def __init__(\n        self: ApertureLayer,\n        transformation: CoordTransform = None,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        normalise : bool = False\n            Should the aperture normalise the wavefront after being applied.\n        \"\"\"\n        super().__init__(normalise=normalise)\n        if transformation is not None:\n            if not isinstance(transformation, CoordTransform):\n                raise TypeError(\n                    \"transformation must be a CoordTransform object. \"\n                    \"Use the CoordTransform class to create one.\"\n                )\n        self.transformation = transformation\n\n    def __getattr__(self: ApertureLayer, key: str) -&gt; Any:\n        \"\"\"Raises transformation attributes to the ApertureLayer level.\"\"\"\n        if hasattr(self.transformation, key):\n            return getattr(self.transformation, key)\n        raise AttributeError(f\"{key} not in {self.__class__.__name__}\")\n\n    def apply(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        # Apply aperture\n        wavefront *= self.transmission(\n            wavefront.coordinates, wavefront.pixel_scale\n        )\n        if self.normalise:\n            return wavefront.normalise()\n        return wavefront\n</code></pre> CircularAperture <p>             Bases: <code>DynamicAperture</code></p> <p>A dynamically generated circular aperture parameterised by its radius. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>(float, meters)</code> <p>The radius of the aperture.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a</p> <code>softening</code> <code>(float, pixels)</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class CircularAperture(DynamicAperture):\n    \"\"\"\n    A dynamically generated circular aperture parameterised by its radius. Both jit and\n    grad compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/CircularAperture.png)\n\n    Attributes\n    ----------\n    radius: float, meters\n        The radius of the aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a\n    softening: float, pixels\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    radius: float\n\n    def __init__(\n        self: ApertureLayer,\n        radius: float,\n        transformation: CoordTransform = None,\n        occulting: bool = False,\n        softening: float = 1.0,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        radius: Array, meters\n            The radius of the aperture.\n\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        super().__init__(\n            transformation=transformation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n        self.radius = float(radius)\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        clip_val = pixel_scale * self.softness / 2\n        return dlu.soft_circle(coords, self.radius, clip_val, self.occulting)\n\n    @property\n    def extent(self: ApertureLayer) -&gt; float:\n        \"\"\"\n        Returns the maximum extent of the aperture.\n\n        Returns\n        -------\n        extent : float\n            The maximum extent of the aperture.\n        \"\"\"\n        return self.radius\n\n    @property\n    def nsides(self: ApertureLayer) -&gt; int:\n        \"\"\"\n        Returns the number of sides of the aperture.\n\n        Returns\n        -------\n        nsides : int\n            The number of sides of the aperture.\n        \"\"\"\n        return 0\n</code></pre> RectangularAperture <p>             Bases: <code>DynamicAperture</code></p> <p>A dynamically generated rectangular aperture parameterised by it width and height. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>height</code> <code>(float, meters)</code> <p>The length of the aperture in the y-direction.</p> <code>width</code> <code>(float, meters)</code> <p>The length of the aperture in the x-direction.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>(float, pixels)</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class RectangularAperture(DynamicAperture):\n    \"\"\"\n    A dynamically generated rectangular aperture parameterised by it width and height.\n    Both jit and grad compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/RectangularAperture.png)\n\n    Attributes\n    ----------\n    height: float, meters\n        The length of the aperture in the y-direction.\n    width: float, meters\n        The length of the aperture in the x-direction.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    height: float\n    width: float\n\n    def __init__(\n        self: ApertureLayer,\n        height: float,\n        width: float,\n        transformation: CoordTransform = None,\n        occulting: bool = False,\n        softening: float = 1.0,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        height: Array, meters\n            The length of the aperture in the y-direction.\n        width: Array, meters\n            The length of the aperture in the x-direction.\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: float, pixels = 1.0\n            The approximate pixel width of the soft boundary applied to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        self.height = float(height)\n        self.width = float(width)\n\n        super().__init__(\n            transformation=transformation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        clip_val = pixel_scale * self.softness / 2\n        return dlu.soft_rectangle(\n            coords, self.width, self.height, clip_val, self.occulting\n        )\n\n    @property\n    def extent(self: ApertureLayer) -&gt; float:\n        \"\"\"\n        Returns the maximum extent of the aperture.\n\n        Returns\n        -------\n        extent : float\n            The maximum extent of the aperture.\n        \"\"\"\n        return np.hypot(self.height / 2.0, self.width / 2.0)\n\n    @property\n    def nsides(self: ApertureLayer) -&gt; int:\n        \"\"\"\n        Returns the number of sides of the aperture.\n\n        Returns\n        -------\n        nsides : int\n            The number of sides of the aperture.\n        \"\"\"\n        return 4\n</code></pre> RegPolyAperture <p>             Bases: <code>DynamicAperture</code></p> <p>Creates a dynamically generated regular polygon aperture parameterised by its number of sides and maximum radius. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> <code>rmax</code> <code>(float, meters)</code> <p>The maximum radius to the vertices from its center.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>(float, pixels)</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class RegPolyAperture(DynamicAperture):\n    \"\"\"\n    Creates a dynamically generated regular polygon aperture parameterised by its\n    number of sides and maximum radius. Both jit and grad compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/RegPolyAperture.png)\n\n    Attributes\n    ----------\n    nsides: int\n        The number of sides of the aperture.\n    rmax: float, meters\n        The maximum radius to the vertices from its center.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    nsides: int\n    rmax: float\n\n    def __init__(\n        self: ApertureLayer,\n        nsides: int,\n        rmax: float,\n        transformation: CoordTransform = None,\n        occulting: bool = False,\n        softening: float = 1.0,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        nsides: int\n            The number of sides of the aperture.\n        rmax: float, meters\n            The maximum radius to the vertices from its center.\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: float, pixels = 1.0\n            The approximate pixel width of the soft boundary applied to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        self.nsides = int(nsides)\n        self.rmax = float(rmax)\n\n        super().__init__(\n            transformation=transformation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        clip_val = pixel_scale * self.softness / 2\n        return dlu.soft_reg_polygon(\n            coords, self.rmax, self.nsides, clip_val, self.occulting\n        )\n\n    @property\n    def extent(self: ApertureLayer) -&gt; float:\n        \"\"\"\n        Returns the maximum extent of the aperture.\n\n        Returns\n        -------\n        extent : float\n            The maximum extent of the aperture.\n        \"\"\"\n        return self.rmax\n</code></pre> Spider <p>             Bases: <code>DynamicAperture</code></p> <p>Creates a dynamically generated spider aperture parameterised by its arm width and number of arms. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>width</code> <code>(float, meters)</code> <p>The width of the spider.</p> <code>angles</code> <code>(Array, degrees)</code> <p>The angle of each arm of the spider.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>(float, pixels)</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class Spider(DynamicAperture):\n    \"\"\"\n    Creates a dynamically generated spider aperture parameterised by its arm width and\n    number of arms. Both jit and grad compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Spider.png)\n\n    Attributes\n    ----------\n    width: float, meters\n        The width of the spider.\n    angles: Array, degrees\n        The angle of each arm of the spider.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    width: float\n    angles: Array\n\n    def __init__(\n        self: ApertureLayer,\n        width: float,\n        angles: Array,\n        transformation: CoordTransform = None,\n        occulting: bool = True,\n        softening: float = 1.0,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        width: float, meters\n            The width of the spider.\n        angles: Array, degrees\n            The angle of each arm of the spider.\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        occulting: bool = True\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: float, pixels = 1.0\n            The approximate pixel width of the soft boundary applied to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        super().__init__(\n            transformation=transformation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.width = float(width)\n        self.angles = np.asarray(angles, dtype=float)\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        clip_val = pixel_scale * self.softness / 2\n        return dlu.soft_spider(\n            coords, self.width, self.angles, clip_val, self.occulting\n        )\n\n    @property\n    def extent(self: ApertureLayer) -&gt; float:\n        \"\"\"\n        Returns the maximum extent of the aperture.\n\n        Returns\n        -------\n        extent : float\n            The maximum extent of the aperture.\n        \"\"\"\n        raise TypeError(\"Spiders do not have an extent.\")\n\n    @property\n    def nsides(self: ApertureLayer) -&gt; int:\n        \"\"\"\n        Returns the number of sides of the aperture.\n\n        Returns\n        -------\n        nsides : int\n            The number of sides of the aperture.\n        \"\"\"\n        raise TypeError(\"Spiders do not have a number of sides.\")\n</code></pre> SquareAperture <p>             Bases: <code>DynamicAperture</code></p> <p>A dynamically generated square aperture parameterised by it side length. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>width</code> <code>(float, meters)</code> <p>The side length of the aperture.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>(float, pixels)</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class SquareAperture(DynamicAperture):\n    \"\"\"\n    A dynamically generated square aperture parameterised by it side length.\n    Both jit and grad compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/SquareAperture.png)\n\n    Attributes\n    ----------\n    width: float, meters\n        The side length of the aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    width: float\n\n    def __init__(\n        self: ApertureLayer,\n        width: float,\n        transformation: CoordTransform = None,\n        occulting: bool = False,\n        softening: float = 1.0,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        width: Array, meters\n            The side length of the aperture.\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        occulting: bool = False\n            Is the aperture occulting or transmissive. False results in a\n            transmissive aperture, and True results in an occulting aperture.\n        softening: float, pixels = 1.0\n            The approximate pixel width of the soft boundary applied to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        super().__init__(\n            transformation=transformation,\n            occulting=occulting,\n            softening=softening,\n            normalise=normalise,\n        )\n\n        self.width = float(width)\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        clip_val = pixel_scale * self.softness / 2\n        return dlu.soft_square(coords, self.width, clip_val, self.occulting)\n\n    @property\n    def extent(self: ApertureLayer) -&gt; float:\n        \"\"\"\n        Returns the maximum extent of the aperture.\n\n        Returns\n        -------\n        extent : float\n            The maximum extent of the aperture.\n        \"\"\"\n        return np.sqrt(2) * self.width\n\n    @property\n    def nsides(self: ApertureLayer) -&gt; int:\n        \"\"\"\n        Returns the number of sides of the aperture.\n\n        Returns\n        -------\n        nsides : int\n            The number of sides of the aperture.\n        \"\"\"\n        return 4\n</code></pre> AberratedAperture <p>             Bases: <code>BasisLayer</code>, <code>ApertureLayer</code></p> <p>Creates a dynamically generated Aperture with aberrations. Both jit and grad compatible.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> <code>basis</code> <code>list[Zernike]</code> <p>A list of basis functions that generate the basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations.</p> <code>as_phase</code> <code>bool</code> <p>Whether to apply the basis as a phase phase or OPD. If True the basis is applied as a phase, else it is applied as an OPD.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class AberratedAperture(BasisLayer, ApertureLayer):\n    \"\"\"\n    Creates a dynamically generated Aperture with aberrations. Both jit and grad\n    compatible.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/AberratedAperture.png)\n\n    Attributes\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    basis: list[Zernike]\n        A list of basis functions that generate the basis vectors.\n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    as_phase : bool\n        Whether to apply the basis as a phase phase or OPD. If True the basis is\n        applied as a phase, else it is applied as an OPD.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    aperture: ApertureLayer\n\n    def __init__(\n        self: ApertureLayer,\n        aperture: ApertureLayer,\n        noll_inds: Array,\n        coefficients: Array = None,\n        as_phase: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture on which the aberration basis is defined.\n        noll_inds: Array\n            The noll indices of the basis functions to use.\n        coefficients: Array = None\n            The amplitude of each basis vector of the aberrations.\n        as_phase : bool = False\n            Whether to apply the basis as a phase phase or OPD. If True the basis is\n            applied as a phase, else it is applied as an OPD.\n        \"\"\"\n        # Ensure aperture is dynamic\n        if not isinstance(aperture, DynamicAperture):\n            raise TypeError(\n                \"AberratedApertures can not contain Static, \"\n                \"Compound or Multi Apertures. AberratedApertures can be \"\n                \"placed in Compound or Multi Apertures, which can then be \"\n                \"promoted to Static.\"\n            )\n\n        super().__init__(normalise=aperture.normalise, as_phase=as_phase)\n\n        # Ensure transmissive\n        if aperture.occulting:\n            raise TypeError(\"AberratedApertures can not be occulting.\")\n\n        if isinstance(aperture, Spider):\n            raise TypeError(\"AberratedApertures can not be spiders.\")\n\n        # Set Aperture\n        self.aperture = aperture\n        self.basis = ZernikeBasis(noll_inds)\n\n        if coefficients is None:\n            coefficients = np.zeros(len(noll_inds))\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n    def calculate(self: ApertureLayer):\n        \"\"\"\n        Required abstract method. Raises NotImplementedError as it is invalid here.\n        \"\"\"\n        raise NotImplementedError(\n            \"Aberrated Apertures can not use the .calculate() method because \"\n            \"they need coords to be generated on. please use \"\n            \".eval_basis(coords) method instead.\"\n        )\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        return self.aperture.transmission(coords, pixel_scale)\n\n    def calc_basis(self: ApertureLayer, coords: Array) -&gt; Array:\n        \"\"\"\n        Calculates the basis vectors at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array\n            The basis vectors at the given coordinates.\n        \"\"\"\n        if self.aperture.transformation is not None:\n            coords = self.aperture.transformation.apply(coords)\n        coords /= self.aperture.extent\n        return self.basis.calculate_basis(coords, self.aperture.nsides)\n\n    def eval_basis(self: ApertureLayer, coords: Array) -&gt; Array:\n        \"\"\"\n        Evaluates the basis vectors at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to evaluate the basis vectors on.\n\n        Returns\n        -------\n        aberrations : Array\n            The aberrations at the given coordinates.\n        \"\"\"\n        basis = self.calc_basis(coords)\n        return dlu.eval_basis(basis, self.coefficients)\n\n    def apply(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        # Transmission\n        wavefront *= self.transmission(\n            wavefront.coordinates, wavefront.pixel_scale\n        )\n        if self.normalise:\n            wavefront = wavefront.normalise()\n\n        # Transform coordinate\n        if self.aperture.transformation is not None:\n            coords = self.aperture.transformation.apply(wavefront.coordinates)\n        else:\n            coords = wavefront.coordinates\n\n        # Aberrations\n        aberrations = self.eval_basis(coords)\n        if self.as_phase:\n            wavefront = wavefront.add_phase(aberrations)\n        else:\n            wavefront += aberrations\n        return wavefront\n</code></pre> CompoundAperture <p>             Bases: <code>CompositeAperture</code></p> <p>Dynamically generates an Apertures from a series of overlapping sub-apertures. Both jit and grad compatible.</p> <p>This class combines the aperture via a multiplication of the sub-apertures. An example would be a HST-like aperture with an obscuring secondary mirror and spiders.</p> <p>This class can only contain a single AberratedAperture.</p> <p>If you want to combine apertures via an addition of the sub-apertures such as an aperture mask, use the MultiAperture class.</p> <p>Note that this class can not contain a MultiAperture, but MultiApertures can contain CompoundApertures.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict</code> <p>The sub-apertures that make up the full aperture.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class CompoundAperture(CompositeAperture):\n    \"\"\"\n    Dynamically generates an Apertures from a series of overlapping sub-apertures. Both\n    jit and grad compatible.\n\n    This class combines the aperture via a _multiplication_ of the sub-apertures. An\n    example would be a HST-like aperture with an obscuring secondary mirror and spiders.\n\n    This class can only contain a _single_ AberratedAperture.\n\n    If you want to combine apertures via an _addition_ of the sub-apertures such as an\n    aperture mask, use the MultiAperture class.\n\n    Note that this class can not contain a MultiAperture, but MultiApertures can\n    contain CompoundApertures.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/CompoundAperture.png)\n\n    Attributes\n    ----------\n    apertures: dict\n        The sub-apertures that make up the full aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def __init__(\n        self: ApertureLayer,\n        apertures: list,\n        transformation: CoordTransform = None,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        apertures: list[ApertureLayer]\n            The sub-apertures that make up the full aperture.\n        transformation: CoordTransform\n            The object that applies the coordinate transformations to the aperture.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the aperture.\n        \"\"\"\n        super().__init__(\n            apertures=apertures,\n            transformation=transformation,\n            normalise=normalise,\n        )\n\n        # Check for more than one aberrated aperture\n        naberrated = 0\n        for aperture in self.apertures.values():\n            if isinstance(aperture, AberratedAperture):\n                naberrated += 1\n            if naberrated &gt; 1:\n                raise TypeError(\n                    \"CompoundAperture can only have a single \"\n                    \"AberratedAperture.\"\n                )\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        return self.transmissions(coords, pixel_scale).prod(0)\n</code></pre> MultiAperture <p>             Bases: <code>CompositeAperture</code></p> <p>Dynamically generates an Apertures from a series of separated sub-apertures. Both jit and grad compatible.</p> <p>This class combines the aperture via an addition of the sub-apertures. An example would be a aperture mask with multiple holes.</p> <p>This class can only contain a multiple AberratedAperture, or CompoundApertures.</p> <p>If you want to combine apertures via a multiplication of the sub-apertures such as HST-like aperture, use the CompoundAperture class.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict</code> <p>The sub-apertures that make up the full aperture.</p> <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>class MultiAperture(CompositeAperture):\n    \"\"\"\n    Dynamically generates an Apertures from a series of separated sub-apertures. Both\n    jit and grad compatible.\n\n    This class combines the aperture via an _addition_ of the sub-apertures. An example\n    would be a aperture mask with multiple holes.\n\n    This class can only contain a _multiple_ AberratedAperture, or CompoundApertures.\n\n    If you want to combine apertures via a _multiplication_ of the sub-apertures such\n    as HST-like aperture, use the CompoundAperture class.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/MultiAperture.png)\n\n    Attributes\n    ----------\n    apertures: dict\n        The sub-apertures that make up the full aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n\n    def eval_basis(self: ApertureLayer, coords: Array) -&gt; Array:\n        \"\"\"\n        Evaluates the basis vectors at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to evaluate the basis vectors on.\n\n        Returns\n        -------\n        aberrations : Array\n            The aberrations at the given coordinates.\n        \"\"\"\n        return super().eval_basis(coords).sum(0)\n\n    def transmission(\n        self: ApertureLayer, coords: Array, pixel_scale: float\n    ) -&gt; Array:\n        \"\"\"\n        Calculates the transmission of the aperture at the given coordinates.\n\n        Parameters\n        ----------\n        coords : Array\n            The coordinates to calculate the transmission on.\n        pixel_scale : float\n            The pixel scale of the coordinates.\n\n        Returns\n        -------\n        transmission : Array\n            The transmission of the aperture at the given coordinates.\n        \"\"\"\n        if self.transformation is not None:\n            coords = self.transformation.apply(coords)\n        return self.transmissions(coords, pixel_scale).sum(0)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.BaseDynamicAperture.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def apply(self: ApertureLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    # Apply aperture\n    wavefront *= self.transmission(\n        wavefront.coordinates, wavefront.pixel_scale\n    )\n    if self.normalise:\n        return wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.BaseDynamicAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.BaseDynamicAperture.apply","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CircularAperture.__init__","title":"<code>__init__(radius, transformation=None, occulting=False, softening=1.0, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the aperture.</p> required <p>occulting: bool = False     Is the aperture occulting or transmissive. False results in a     transmissive aperture, and True results in an occulting aperture. softening: Array, pixels = np.array(1.)     The approximate pixel width of the soft boundary applied to the aperture. normalise : bool = False     Whether to normalise the wavefront after passing through the aperture.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    radius: float,\n    transformation: CoordTransform = None,\n    occulting: bool = False,\n    softening: float = 1.0,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    radius: Array, meters\n        The radius of the aperture.\n\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    super().__init__(\n        transformation=transformation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n    self.radius = float(radius)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.CircularAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    clip_val = pixel_scale * self.softness / 2\n    return dlu.soft_circle(coords, self.radius, clip_val, self.occulting)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.CircularAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CircularAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CircularAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RectangularAperture.__init__","title":"<code>__init__(height, width, transformation=None, occulting=False, softening=1.0, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>height</code> <code>float</code> <p>The length of the aperture in the y-direction.</p> required <code>width</code> <code>float</code> <p>The length of the aperture in the x-direction.</p> required <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>None</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>float</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>1.0</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    height: float,\n    width: float,\n    transformation: CoordTransform = None,\n    occulting: bool = False,\n    softening: float = 1.0,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    height: Array, meters\n        The length of the aperture in the y-direction.\n    width: Array, meters\n        The length of the aperture in the x-direction.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels = 1.0\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    self.height = float(height)\n    self.width = float(width)\n\n    super().__init__(\n        transformation=transformation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.RectangularAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    clip_val = pixel_scale * self.softness / 2\n    return dlu.soft_rectangle(\n        coords, self.width, self.height, clip_val, self.occulting\n    )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.RectangularAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RectangularAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RectangularAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RegPolyAperture.__init__","title":"<code>__init__(nsides, rmax, transformation=None, occulting=False, softening=1.0, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>rmax</code> <code>float</code> <p>The maximum radius to the vertices from its center.</p> required <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>None</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>float</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>1.0</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    nsides: int,\n    rmax: float,\n    transformation: CoordTransform = None,\n    occulting: bool = False,\n    softening: float = 1.0,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    nsides: int\n        The number of sides of the aperture.\n    rmax: float, meters\n        The maximum radius to the vertices from its center.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels = 1.0\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    self.nsides = int(nsides)\n    self.rmax = float(rmax)\n\n    super().__init__(\n        transformation=transformation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.RegPolyAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    clip_val = pixel_scale * self.softness / 2\n    return dlu.soft_reg_polygon(\n        coords, self.rmax, self.nsides, clip_val, self.occulting\n    )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.RegPolyAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RegPolyAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.RegPolyAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.Spider.__init__","title":"<code>__init__(width, angles, transformation=None, occulting=True, softening=1.0, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The width of the spider.</p> required <code>angles</code> <code>Array</code> <p>The angle of each arm of the spider.</p> required <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>None</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>True</code> <code>softening</code> <code>float</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>1.0</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    width: float,\n    angles: Array,\n    transformation: CoordTransform = None,\n    occulting: bool = True,\n    softening: float = 1.0,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    width: float, meters\n        The width of the spider.\n    angles: Array, degrees\n        The angle of each arm of the spider.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool = True\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels = 1.0\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    super().__init__(\n        transformation=transformation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.width = float(width)\n    self.angles = np.asarray(angles, dtype=float)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.Spider.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    clip_val = pixel_scale * self.softness / 2\n    return dlu.soft_spider(\n        coords, self.width, self.angles, clip_val, self.occulting\n    )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.Spider","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.Spider.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.Spider.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.SquareAperture.__init__","title":"<code>__init__(width, transformation=None, occulting=False, softening=1.0, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The side length of the aperture.</p> required <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>None</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or transmissive. False results in a transmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>float</code> <p>The approximate pixel width of the soft boundary applied to the aperture.</p> <code>1.0</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    width: float,\n    transformation: CoordTransform = None,\n    occulting: bool = False,\n    softening: float = 1.0,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    width: Array, meters\n        The side length of the aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    occulting: bool = False\n        Is the aperture occulting or transmissive. False results in a\n        transmissive aperture, and True results in an occulting aperture.\n    softening: float, pixels = 1.0\n        The approximate pixel width of the soft boundary applied to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    super().__init__(\n        transformation=transformation,\n        occulting=occulting,\n        softening=softening,\n        normalise=normalise,\n    )\n\n    self.width = float(width)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.SquareAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    clip_val = pixel_scale * self.softness / 2\n    return dlu.soft_square(coords, self.width, clip_val, self.occulting)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.SquareAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.SquareAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.SquareAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.AberratedAperture.__init__","title":"<code>__init__(aperture, noll_inds, coefficients=None, as_phase=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> required <code>noll_inds</code> <code>Array</code> <p>The noll indices of the basis functions to use.</p> required <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations.</p> <code>None</code> <code>as_phase</code> <code>bool = False</code> <p>Whether to apply the basis as a phase phase or OPD. If True the basis is applied as a phase, else it is applied as an OPD.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    aperture: ApertureLayer,\n    noll_inds: Array,\n    coefficients: Array = None,\n    as_phase: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    noll_inds: Array\n        The noll indices of the basis functions to use.\n    coefficients: Array = None\n        The amplitude of each basis vector of the aberrations.\n    as_phase : bool = False\n        Whether to apply the basis as a phase phase or OPD. If True the basis is\n        applied as a phase, else it is applied as an OPD.\n    \"\"\"\n    # Ensure aperture is dynamic\n    if not isinstance(aperture, DynamicAperture):\n        raise TypeError(\n            \"AberratedApertures can not contain Static, \"\n            \"Compound or Multi Apertures. AberratedApertures can be \"\n            \"placed in Compound or Multi Apertures, which can then be \"\n            \"promoted to Static.\"\n        )\n\n    super().__init__(normalise=aperture.normalise, as_phase=as_phase)\n\n    # Ensure transmissive\n    if aperture.occulting:\n        raise TypeError(\"AberratedApertures can not be occulting.\")\n\n    if isinstance(aperture, Spider):\n        raise TypeError(\"AberratedApertures can not be spiders.\")\n\n    # Set Aperture\n    self.aperture = aperture\n    self.basis = ZernikeBasis(noll_inds)\n\n    if coefficients is None:\n        coefficients = np.zeros(len(noll_inds))\n    self.coefficients = np.asarray(coefficients, dtype=float)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.AberratedAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    return self.aperture.transmission(coords, pixel_scale)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.AberratedAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.AberratedAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.AberratedAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CompoundAperture.__init__","title":"<code>__init__(apertures, transformation=None, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>transformation</code> <code>CoordTransform</code> <p>The object that applies the coordinate transformations to the aperture.</p> <code>None</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the aperture.</p> <code>False</code> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def __init__(\n    self: ApertureLayer,\n    apertures: list,\n    transformation: CoordTransform = None,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    apertures: list[ApertureLayer]\n        The sub-apertures that make up the full aperture.\n    transformation: CoordTransform\n        The object that applies the coordinate transformations to the aperture.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the aperture.\n    \"\"\"\n    super().__init__(\n        apertures=apertures,\n        transformation=transformation,\n        normalise=normalise,\n    )\n\n    # Check for more than one aberrated aperture\n    naberrated = 0\n    for aperture in self.apertures.values():\n        if isinstance(aperture, AberratedAperture):\n            naberrated += 1\n        if naberrated &gt; 1:\n            raise TypeError(\n                \"CompoundAperture can only have a single \"\n                \"AberratedAperture.\"\n            )\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.CompoundAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    return self.transmissions(coords, pixel_scale).prod(0)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.CompoundAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CompoundAperture.__init__","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.CompoundAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.MultiAperture.transmission","title":"<code>transmission(coords, pixel_scale)</code>","text":"<p>Calculates the transmission of the aperture at the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the transmission on.</p> required <code>pixel_scale</code> <code>float</code> <p>The pixel scale of the coordinates.</p> required <p>Returns:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The transmission of the aperture at the given coordinates.</p> Source code in <code>src/dLux/layers/apertures.py</code> <pre><code>def transmission(\n    self: ApertureLayer, coords: Array, pixel_scale: float\n) -&gt; Array:\n    \"\"\"\n    Calculates the transmission of the aperture at the given coordinates.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the transmission on.\n    pixel_scale : float\n        The pixel scale of the coordinates.\n\n    Returns\n    -------\n    transmission : Array\n        The transmission of the aperture at the given coordinates.\n    \"\"\"\n    if self.transformation is not None:\n        coords = self.transformation.apply(coords)\n    return self.transmissions(coords, pixel_scale).sum(0)\n</code></pre>"},{"location":"API/layers/apertures/#dLux.layers.apertures.MultiAperture","title":"Apertures","text":""},{"location":"API/layers/apertures/#dLux.layers.apertures.MultiAperture.transmission","title":"Apertures","text":""},{"location":"API/layers/detector_layers/","title":"Detector Layers","text":"ApplyPixelResponse <p>             Bases: <code>DetectorLayer</code></p> <p>Applies a pixel response array to the input psf, via a multiplication. This can be used to model variations in the inter and intra-pixel sensitivity variations common to most detectors.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>class ApplyPixelResponse(DetectorLayer):\n    \"\"\"\n    Applies a pixel response array to the input psf, via a multiplication. This can be\n    used to model variations in the inter and intra-pixel sensitivity variations common\n    to most detectors.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ApplyPixelResponse.png)\n\n    Attributes\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input psf.\n    \"\"\"\n\n    pixel_response: Array\n\n    def __init__(self: DetectorLayer, pixel_response: Array):\n        \"\"\"\n        Parameters\n        ----------\n        pixel_response : Array\n            The pixel_response to apply to the input psf. Must be a 2-dimensional array\n            equal to size of the psf at time of application.\n        \"\"\"\n        super().__init__()\n        self.pixel_response = np.asarray(pixel_response, dtype=float)\n        if self.pixel_response.ndim != 2:\n            raise ValueError(\"pixel_response must be a 2 dimensional array.\")\n\n    def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n        \"\"\"\n        Applies the layer to the PSF.\n\n        Parameters\n        ----------\n        psf : PSF\n            The psf to operate on.\n\n        Returns\n        -------\n        psf : PSF\n            The transformed psf.\n        \"\"\"\n        return psf * self.pixel_response\n</code></pre> ApplyJitter <p>             Bases: <code>DetectorLayer</code></p> <p>Convolves the psf with a radially symmetric Gaussian kernel parameterised by its standard deviation (sigma).</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>(float, pixels)</code> <p>The standard deviation of the Gaussian kernel, in units of pixels.</p> <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>class ApplyJitter(DetectorLayer):\n    \"\"\"\n    Convolves the psf with a radially symmetric Gaussian kernel parameterised by its\n    standard deviation (sigma).\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ApplyJitter.png)\n\n    Attributes\n    ----------\n    sigma : float, pixels\n        The standard deviation of the Gaussian kernel, in units of pixels.\n    kernel_size : int\n        The size of the convolution kernel to use.\n    \"\"\"\n\n    kernel_size: int\n    sigma: float\n\n    def __init__(self: DetectorLayer, sigma: float, kernel_size: int = 10):\n        \"\"\"\n        Parameters\n        ----------\n        sigma : float, pixels\n            The standard deviation of the Gaussian kernel, in units of pixels.\n        kernel_size : int = 10\n            The size of the convolution kernel to use.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n        self.sigma = float(sigma)\n\n    def generate_kernel(self: DetectorLayer, pixel_scale: float) -&gt; Array:\n        \"\"\"\n        Generates the normalised Gaussian kernel.\n\n        Returns\n        -------\n        kernel : Array\n            The Gaussian kernel.\n        \"\"\"\n        # TODO: Move to utils?\n        # Generate distribution\n        sigma = self.sigma * pixel_scale\n        x = np.linspace(-10, 10, self.kernel_size) * pixel_scale\n        kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)\n        return kernel / np.sum(kernel)\n\n    def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n        \"\"\"\n        Applies the layer to the PSF.\n\n        Parameters\n        ----------\n        psf : PSF\n            The psf to operate on.\n\n        Returns\n        -------\n        psf : PSF\n            The transformed psf.\n        \"\"\"\n        kernel = self.generate_kernel(psf.pixel_scale)\n        return psf.convolve(kernel)\n</code></pre> ApplySaturation <p>             Bases: <code>DetectorLayer</code></p> <p>Applies a simple saturation model to the input psf, by clipping any values above the threshold value.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>threshold</code> <code>float</code> <p>The threshold at which the saturation is applied.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>class ApplySaturation(DetectorLayer):\n    \"\"\"\n    Applies a simple saturation model to the input psf, by clipping any values above\n    the threshold value.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ApplySaturation.png)\n\n    Attributes\n    ----------\n    threshold : float\n        The threshold at which the saturation is applied.\n    \"\"\"\n\n    threshold: float\n\n    def __init__(self: DetectorLayer, threshold: float):\n        \"\"\"\n        Parameters\n        ----------\n        threshold : float\n            The threshold at which the saturation is applied.\n        \"\"\"\n        super().__init__()\n        self.threshold = float(threshold)\n\n    def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n        \"\"\"\n        Applies the layer to the PSF.\n\n        Parameters\n        ----------\n        psf : PSF\n            The psf to operate on.\n\n        Returns\n        -------\n        psf : PSF\n            The transformed psf.\n        \"\"\"\n        return psf.min(\"data\", self.threshold)\n</code></pre> AddConstant <p>             Bases: <code>DetectorLayer</code></p> <p>Adds a constant to the output psf. This is typically used to model the mean value of the detector noise.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>value</code> <code>float</code> <p>The value to add to the psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>class AddConstant(DetectorLayer):\n    \"\"\"\n    Adds a constant to the output psf. This is typically used to model the mean value of\n    the detector noise.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/AddConstant.png)\n\n    Attributes\n    ----------\n    value : float\n        The value to add to the psf.\n    \"\"\"\n\n    value: float\n\n    def __init__(self: DetectorLayer, value: float):\n        \"\"\"\n        Parameters\n        ----------\n        value : float\n            The value to add to the psf.\n        \"\"\"\n        super().__init__()\n        self.value = float(value)\n\n    def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n        \"\"\"\n        Applies the layer to the PSF.\n\n        Parameters\n        ----------\n        psf : PSF\n            The psf to operate on.\n\n        Returns\n        -------\n        psf : PSF\n            The transformed psf.\n        \"\"\"\n        return psf + self.value\n</code></pre> Downsample <p>             Bases: <code>DetectorLayer</code></p> <p>Downsamples an input psf by an integer number of pixels via a sum. Typically used to downsample an oversampled psf to the true pixel size. Note kernel_size must be an integer multiple of the input psf size.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>class Downsample(DetectorLayer):\n    \"\"\"\n    Downsamples an input psf by an integer number of pixels via a sum. Typically used\n    to downsample an oversampled psf to the true pixel size. Note kernel_size must be\n    an integer multiple of the input psf size.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Downsample.png)\n\n    Attributes\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    \"\"\"\n\n    kernel_size: int\n\n    def __init__(self: DetectorLayer, kernel_size: int):\n        \"\"\"\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the downsampling kernel.\n        \"\"\"\n        super().__init__()\n        self.kernel_size = int(kernel_size)\n\n    def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n        \"\"\"\n        Applies the layer to the PSF.\n\n        Parameters\n        ----------\n        psf : PSF\n            The psf to operate on.\n\n        Returns\n        -------\n        psf : PSF\n            The transformed psf.\n        \"\"\"\n        return psf.downsample(self.kernel_size)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyPixelResponse.__init__","title":"<code>__init__(pixel_response)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input psf. Must be a 2-dimensional array equal to size of the psf at time of application.</p> required Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, pixel_response: Array):\n    \"\"\"\n    Parameters\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input psf. Must be a 2-dimensional array\n        equal to size of the psf at time of application.\n    \"\"\"\n    super().__init__()\n    self.pixel_response = np.asarray(pixel_response, dtype=float)\n    if self.pixel_response.ndim != 2:\n        raise ValueError(\"pixel_response must be a 2 dimensional array.\")\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyPixelResponse.apply","title":"<code>apply(psf)</code>","text":"<p>Applies the layer to the PSF.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The psf to operate on.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The transformed psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n    \"\"\"\n    Applies the layer to the PSF.\n\n    Parameters\n    ----------\n    psf : PSF\n        The psf to operate on.\n\n    Returns\n    -------\n    psf : PSF\n        The transformed psf.\n    \"\"\"\n    return psf * self.pixel_response\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyPixelResponse","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyPixelResponse.__init__","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyPixelResponse.apply","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.__init__","title":"<code>__init__(sigma, kernel_size=10)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>(float, pixels)</code> <p>The standard deviation of the Gaussian kernel, in units of pixels.</p> required <code>kernel_size</code> <code>int = 10</code> <p>The size of the convolution kernel to use.</p> <code>10</code> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, sigma: float, kernel_size: int = 10):\n    \"\"\"\n    Parameters\n    ----------\n    sigma : float, pixels\n        The standard deviation of the Gaussian kernel, in units of pixels.\n    kernel_size : int = 10\n        The size of the convolution kernel to use.\n    \"\"\"\n    super().__init__()\n    self.kernel_size = int(kernel_size)\n    self.sigma = float(sigma)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.apply","title":"<code>apply(psf)</code>","text":"<p>Applies the layer to the PSF.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The psf to operate on.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The transformed psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n    \"\"\"\n    Applies the layer to the PSF.\n\n    Parameters\n    ----------\n    psf : PSF\n        The psf to operate on.\n\n    Returns\n    -------\n    psf : PSF\n        The transformed psf.\n    \"\"\"\n    kernel = self.generate_kernel(psf.pixel_scale)\n    return psf.convolve(kernel)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.generate_kernel","title":"<code>generate_kernel(pixel_scale)</code>","text":"<p>Generates the normalised Gaussian kernel.</p> <p>Returns:</p> Name Type Description <code>kernel</code> <code>Array</code> <p>The Gaussian kernel.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def generate_kernel(self: DetectorLayer, pixel_scale: float) -&gt; Array:\n    \"\"\"\n    Generates the normalised Gaussian kernel.\n\n    Returns\n    -------\n    kernel : Array\n        The Gaussian kernel.\n    \"\"\"\n    # TODO: Move to utils?\n    # Generate distribution\n    sigma = self.sigma * pixel_scale\n    x = np.linspace(-10, 10, self.kernel_size) * pixel_scale\n    kernel = norm.pdf(x, scale=sigma) * norm.pdf(x[:, None], scale=sigma)\n    return kernel / np.sum(kernel)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.__init__","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.apply","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplyJitter.generate_kernel","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplySaturation.__init__","title":"<code>__init__(threshold)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>The threshold at which the saturation is applied.</p> required Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, threshold: float):\n    \"\"\"\n    Parameters\n    ----------\n    threshold : float\n        The threshold at which the saturation is applied.\n    \"\"\"\n    super().__init__()\n    self.threshold = float(threshold)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplySaturation.apply","title":"<code>apply(psf)</code>","text":"<p>Applies the layer to the PSF.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The psf to operate on.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The transformed psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n    \"\"\"\n    Applies the layer to the PSF.\n\n    Parameters\n    ----------\n    psf : PSF\n        The psf to operate on.\n\n    Returns\n    -------\n    psf : PSF\n        The transformed psf.\n    \"\"\"\n    return psf.min(\"data\", self.threshold)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplySaturation","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplySaturation.__init__","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.ApplySaturation.apply","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.AddConstant.__init__","title":"<code>__init__(value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to add to the psf.</p> required Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, value: float):\n    \"\"\"\n    Parameters\n    ----------\n    value : float\n        The value to add to the psf.\n    \"\"\"\n    super().__init__()\n    self.value = float(value)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.AddConstant.apply","title":"<code>apply(psf)</code>","text":"<p>Applies the layer to the PSF.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The psf to operate on.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The transformed psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n    \"\"\"\n    Applies the layer to the PSF.\n\n    Parameters\n    ----------\n    psf : PSF\n        The psf to operate on.\n\n    Returns\n    -------\n    psf : PSF\n        The transformed psf.\n    \"\"\"\n    return psf + self.value\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.AddConstant","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.AddConstant.__init__","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.AddConstant.apply","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.Downsample.__init__","title":"<code>__init__(kernel_size)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> required Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def __init__(self: DetectorLayer, kernel_size: int):\n    \"\"\"\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    \"\"\"\n    super().__init__()\n    self.kernel_size = int(kernel_size)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.Downsample.apply","title":"<code>apply(psf)</code>","text":"<p>Applies the layer to the PSF.</p> <p>Parameters:</p> Name Type Description Default <code>psf</code> <code>PSF</code> <p>The psf to operate on.</p> required <p>Returns:</p> Name Type Description <code>psf</code> <code>PSF</code> <p>The transformed psf.</p> Source code in <code>src/dLux/layers/detector_layers.py</code> <pre><code>def apply(self: DetectorLayer, psf: PSF) -&gt; PSF:\n    \"\"\"\n    Applies the layer to the PSF.\n\n    Parameters\n    ----------\n    psf : PSF\n        The psf to operate on.\n\n    Returns\n    -------\n    psf : PSF\n        The transformed psf.\n    \"\"\"\n    return psf.downsample(self.kernel_size)\n</code></pre>"},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.Downsample","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.Downsample.__init__","title":"Detector Layers","text":""},{"location":"API/layers/detector_layers/#dLux.layers.detector_layers.Downsample.apply","title":"Detector Layers","text":""},{"location":"API/layers/optical_layers/","title":"Optical Layers","text":"TransmissiveLayer <p>             Bases: <code>OpticalLayer</code></p> <p>Base class to hold transmissive layers imbuing them with a transmission and normalise parameter.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>class TransmissiveLayer(OpticalLayer):\n    \"\"\"\n    Base class to hold transmissive layers imbuing them with a transmission and\n    normalise parameter.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/TransmissiveLayer.png)\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n\n    transmission: Array\n    normalise: bool\n\n    def __init__(\n        self: OpticalLayer,\n        transmission: Array = None,\n        normalise: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The array of transmission values to be applied to the input wavefront.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the optic.\n        \"\"\"\n        if transmission is not None:\n            transmission = np.asarray(transmission, dtype=float)\n        self.transmission = transmission\n        self.normalise = bool(normalise)\n        super().__init__(**kwargs)\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> AberratedLayer <p>             Bases: <code>OpticalLayer</code></p> <p>Optical layer for holding static aberrations. Aberrations can be applied as either a phase or OPD, or both.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>opd</code> <code>(Array, metres)</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>phase</code> <code>(Array, radians)</code> <p>The Array of phase values to be applied to the input wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>class AberratedLayer(OpticalLayer):\n    \"\"\"\n    Optical layer for holding static aberrations. Aberrations can be applied as either\n    a phase or OPD, or both.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/AberratedLayer.png)\n\n    Attributes\n    ----------\n    opd : Array, metres\n        The Array of OPD values to be applied to the input wavefront.\n    phase : Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    \"\"\"\n\n    opd: Array\n    phase: Array\n\n    def __init__(\n        self: OpticalLayer,\n        opd: Array = None,\n        phase: Array = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        opd : Array, metres = None\n            The Array of OPD values to be applied to the input wavefront.\n        phase : Array, radians = None\n            The Array of phase values to be applied to the input wavefront.\n        \"\"\"\n        if opd is not None:\n            opd = np.asarray(opd, dtype=float)\n        self.opd = opd\n\n        if phase is not None:\n            phase = np.asarray(phase, dtype=float)\n        self.phase = phase\n\n        if self.opd is not None and self.phase is not None:\n            if self.opd.shape != self.phase.shape:\n                raise ValueError(\n                    \"opd and phase must have the same shape. Got \"\n                    f\"shapes {self.opd.shape} and {self.phase.shape}.\"\n                )\n        super().__init__(**kwargs)\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront += self.opd\n        wavefront = wavefront.add_phase(self.phase)\n        return wavefront\n</code></pre> BasisLayer <p>             Bases: <code>OpticalLayer</code></p> <p>An OpticalLayer class that holds a set of basis vectors and coefficients, which are dot-producted at run time to produce the output. The basis can be applied as either a phase or OPD, by setting the <code>as_phase</code> attribute.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>Union[Array, list]</code> <p>The set of basis vectors. Should in generate be a 3 dimensional array.</p> <code>coefficients</code> <code>Array</code> <p>The array of coefficients to be applied to each basis vector.</p> <code>as_phase</code> <code>bool = False</code> <p>Whether to apply the basis as a phase or OPD. If True the output is applied as a phase, else it is applied as an OPD.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>class BasisLayer(OpticalLayer):\n    \"\"\"\n    An OpticalLayer class that holds a set of basis vectors and coefficients, which are\n    dot-producted at run time to produce the output. The basis can be applied as either\n    a phase or OPD, by setting the `as_phase` attribute.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/BasisLayer.png)\n\n    Attributes\n    ----------\n    basis: Union[Array, list]\n        The set of basis vectors. Should in generate be a 3 dimensional array.\n    coefficients: Array\n        The array of coefficients to be applied to each basis vector.\n    as_phase: bool = False\n        Whether to apply the basis as a phase or OPD. If True the output is applied as\n        a phase, else it is applied as an OPD.\n    \"\"\"\n\n    basis: Union[Array, list]\n    coefficients: Array\n    as_phase: bool\n\n    # NOTE: We need the None basis input for aberrated apertures\n    def __init__(\n        self: OpticalLayer,\n        basis: Array = None,\n        coefficients: Array = None,\n        as_phase: bool = False,\n        **kwargs,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        basis: Union[Array, list]\n            The set of basis vectors. Should in generate be a 3 dimensional array.\n        coefficients: Array\n            The Array of coefficients to be applied to each basis vector.\n        as_phase: bool = False\n            Whether to apply the basis as a phase or OPD. If True the output is applied\n            as a phase, else it is applied as an OPD.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if basis is not None:\n            basis = np.asarray(basis, dtype=float)\n            if coefficients is None:\n                coefficients = np.zeros(basis.shape[:-2])\n            else:\n                coefficients = np.asarray(coefficients, dtype=float)\n                if basis.shape[:-2] != coefficients.shape:\n                    raise ValueError(\n                        \"The number of basis vectors must be equal to \"\n                        \"the number of coefficients.\"\n                    )\n\n        self.basis = basis\n        self.coefficients = coefficients\n        self.as_phase = bool(as_phase)\n\n    def eval_basis(self: OpticalLayer) -&gt; Array:\n        \"\"\"\n        Calculates the dot product of the basis vectors and coefficients.\n\n        Returns\n        -------\n        output : Array\n            The output of the dot product between the basis vectors and coefficients.\n        \"\"\"\n        return dlu.eval_basis(self.basis, self.coefficients)\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        output = self.eval_basis()\n        if self.as_phase:\n            wavefront = wavefront.add_phase(output)\n        else:\n            wavefront += output\n        return wavefront\n</code></pre> Tilt <p>             Bases: <code>OpticalLayer</code></p> <p>Tilts the wavefront by the input (x, y) angles.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>angles</code> <code>(Array, radians)</code> <p>The (x, y) angles by which to tilt the wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>class Tilt(OpticalLayer):\n    \"\"\"\n    Tilts the wavefront by the input (x, y) angles.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Tilt.png)\n\n    Attributes\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    \"\"\"\n\n    angles: Array\n\n    def __init__(self: OpticalLayer, angles: Array):\n        \"\"\"\n        Parameters\n        ----------\n        angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n        \"\"\"\n        super().__init__()\n        self.angles = np.asarray(angles, dtype=float)\n\n        if self.angles.shape != (2,):\n            raise ValueError(\"angles must have have (2,)\")\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.tilt(self.angles)\n</code></pre> Normalise <p>             Bases: <code>OpticalLayer</code></p> <p>Normalises the wavefront to unit intensity.</p> UML <p></p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>class Normalise(OpticalLayer):\n    \"\"\"\n    Normalises the wavefront to unit intensity.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Normalise.png)\n    \"\"\"\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.normalise()\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.TransmissiveLayer.__init__","title":"<code>__init__(transmission=None, normalise=False, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The array of transmission values to be applied to the input wavefront.</p> <code>None</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the optic.</p> <code>False</code> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def __init__(\n    self: OpticalLayer,\n    transmission: Array = None,\n    normalise: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Parameters\n    ----------\n    transmission: Array = None\n        The array of transmission values to be applied to the input wavefront.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n    if transmission is not None:\n        transmission = np.asarray(transmission, dtype=float)\n    self.transmission = transmission\n    self.normalise = bool(normalise)\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.TransmissiveLayer.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.TransmissiveLayer","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.TransmissiveLayer.__init__","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.TransmissiveLayer.apply","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.AberratedLayer.__init__","title":"<code>__init__(opd=None, phase=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>opd</code> <code>Array, metres = None</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>None</code> <code>phase</code> <code>Array, radians = None</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>None</code> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def __init__(\n    self: OpticalLayer,\n    opd: Array = None,\n    phase: Array = None,\n    **kwargs,\n):\n    \"\"\"\n    Parameters\n    ----------\n    opd : Array, metres = None\n        The Array of OPD values to be applied to the input wavefront.\n    phase : Array, radians = None\n        The Array of phase values to be applied to the input wavefront.\n    \"\"\"\n    if opd is not None:\n        opd = np.asarray(opd, dtype=float)\n    self.opd = opd\n\n    if phase is not None:\n        phase = np.asarray(phase, dtype=float)\n    self.phase = phase\n\n    if self.opd is not None and self.phase is not None:\n        if self.opd.shape != self.phase.shape:\n            raise ValueError(\n                \"opd and phase must have the same shape. Got \"\n                f\"shapes {self.opd.shape} and {self.phase.shape}.\"\n            )\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.AberratedLayer.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront += self.opd\n    wavefront = wavefront.add_phase(self.phase)\n    return wavefront\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.AberratedLayer","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.AberratedLayer.__init__","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.AberratedLayer.apply","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.__init__","title":"<code>__init__(basis=None, coefficients=None, as_phase=False, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array</code> <p>The set of basis vectors. Should in generate be a 3 dimensional array.</p> <code>None</code> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>None</code> <code>as_phase</code> <code>bool</code> <p>Whether to apply the basis as a phase or OPD. If True the output is applied as a phase, else it is applied as an OPD.</p> <code>False</code> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def __init__(\n    self: OpticalLayer,\n    basis: Array = None,\n    coefficients: Array = None,\n    as_phase: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Parameters\n    ----------\n    basis: Union[Array, list]\n        The set of basis vectors. Should in generate be a 3 dimensional array.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    as_phase: bool = False\n        Whether to apply the basis as a phase or OPD. If True the output is applied\n        as a phase, else it is applied as an OPD.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if basis is not None:\n        basis = np.asarray(basis, dtype=float)\n        if coefficients is None:\n            coefficients = np.zeros(basis.shape[:-2])\n        else:\n            coefficients = np.asarray(coefficients, dtype=float)\n            if basis.shape[:-2] != coefficients.shape:\n                raise ValueError(\n                    \"The number of basis vectors must be equal to \"\n                    \"the number of coefficients.\"\n                )\n\n    self.basis = basis\n    self.coefficients = coefficients\n    self.as_phase = bool(as_phase)\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    output = self.eval_basis()\n    if self.as_phase:\n        wavefront = wavefront.add_phase(output)\n    else:\n        wavefront += output\n    return wavefront\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.eval_basis","title":"<code>eval_basis()</code>","text":"<p>Calculates the dot product of the basis vectors and coefficients.</p> <p>Returns:</p> Name Type Description <code>output</code> <code>Array</code> <p>The output of the dot product between the basis vectors and coefficients.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def eval_basis(self: OpticalLayer) -&gt; Array:\n    \"\"\"\n    Calculates the dot product of the basis vectors and coefficients.\n\n    Returns\n    -------\n    output : Array\n        The output of the dot product between the basis vectors and coefficients.\n    \"\"\"\n    return dlu.eval_basis(self.basis, self.coefficients)\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.__init__","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.apply","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.BasisLayer.eval_basis","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Tilt.__init__","title":"<code>__init__(angles)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>angles</code> <code>(Array, radians)</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def __init__(self: OpticalLayer, angles: Array):\n    \"\"\"\n    Parameters\n    ----------\n    angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    \"\"\"\n    super().__init__()\n    self.angles = np.asarray(angles, dtype=float)\n\n    if self.angles.shape != (2,):\n        raise ValueError(\"angles must have have (2,)\")\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Tilt.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.tilt(self.angles)\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Tilt","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Tilt.__init__","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Tilt.apply","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Normalise.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optical_layers.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.normalise()\n</code></pre>"},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Normalise","title":"Optical Layers","text":""},{"location":"API/layers/optical_layers/#dLux.layers.optical_layers.Normalise.apply","title":"Optical Layers","text":""},{"location":"API/layers/optics/","title":"Optics","text":"Optic <p>             Bases: <code>TransmissiveLayer</code>, <code>AberratedLayer</code></p> <p>A basic 'Optic' class, which optionally applies a transmission, OPD and phase to the input wavefront, with the option for normalise after.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>opd</code> <code>(Array, metres)</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>phase</code> <code>(Array, radians)</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>class Optic(TransmissiveLayer, AberratedLayer):\n    \"\"\"\n    A basic 'Optic' class, which optionally applies a transmission, OPD and phase to\n    the input wavefront, with the option for normalise after.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Optic.png)\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    opd : Array, metres\n        The Array of OPD values to be applied to the input wavefront.\n    phase : Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    normalise: bool\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n\n    def __init__(\n        self: OpticalLayer,\n        transmission: Array = None,\n        opd: Array = None,\n        phase: Array = None,\n        normalise: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        transmission: Array = None\n            The Array of transmission values to be applied to the input wavefront.\n        opd : Array, metres = None\n            The Array of OPD values to be applied to the input wavefront.\n        phase : Array, radians = None\n            The Array of phase values to be applied to the input wavefront.\n        normalise: bool = False\n            Whether to normalise the wavefront after passing through the optic.\n        \"\"\"\n        super().__init__(\n            transmission=transmission,\n            opd=opd,\n            phase=phase,\n            normalise=normalise,\n        )\n\n        if self.transmission is not None:\n            if self.opd is not None:\n                if self.transmission.shape != self.opd.shape:\n                    raise ValueError(\n                        \"transmission and opd must have the same shape. Got \"\n                        f\"shapes {self.transmission.shape} and {self.opd.shape}.\"\n                    )\n            if self.phase is not None:\n                if self.transmission.shape != self.phase.shape:\n                    raise ValueError(\n                        \"transmission and phase must have the same shape. Got \"\n                        f\"shapes {self.transmission.shape} and {self.phase.shape}.\"\n                    )\n\n    def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n        wavefront += self.opd\n        wavefront = wavefront.add_phase(self.phase)\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre> BasisOptic <p>             Bases: <code>TransmissiveLayer</code>, <code>BasisLayer</code></p> <p>A basic 'Optic' class, with a aberrations applied through a set of basis vectors coefficients. This can be applied either as an opd or phase, using the <code>as_phase</code> attribute. Also optionally applies a transmission and normalisation.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>basis</code> <code>(Array, metres)</code> <p>Arrays holding the pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>as_phase</code> <code>bool</code> <p>Whether to apply the basis as a phase phase or OPD. If True the basis is applied as a phase, else it is applied as an OPD.</p> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>class BasisOptic(TransmissiveLayer, BasisLayer):\n    \"\"\"\n    A basic 'Optic' class, with a aberrations applied through a set of basis vectors\n    coefficients. This can be applied either as an opd or phase, using the `as_phase`\n    attribute. Also optionally applies a transmission and normalisation.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/BasisOptic.png)\n\n    Attributes\n    ----------\n    transmission: Array\n        The Array of transmission values to be applied to the input wavefront.\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    as_phase : bool\n        Whether to apply the basis as a phase phase or OPD. If True the basis is\n        applied as a phase, else it is applied as an OPD.\n    normalise : bool\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n\n    def __init__(\n        self: OpticalLayer,\n        basis,\n        transmission=None,\n        coefficients=None,\n        as_phase=False,\n        normalise=False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        basis: Array, metres\n            Arrays holding the pre-calculated basis vectors.\n        coefficients: Array = None\n            The Array of coefficients to be applied to each basis vector.\n        transmission: Array = None\n            The Array of transmission values to be applied to the input wavefront.\n        as_phase : bool = False\n            Whether to apply the basis as a phase phase or OPD. If True the basis is\n            applied as a phase, else it is applied as an OPD.\n        normalise : bool = False\n            Whether to normalise the wavefront after passing through the optic.\n        \"\"\"\n        super().__init__(\n            transmission=transmission,\n            basis=basis,\n            coefficients=coefficients,\n            as_phase=as_phase,\n            normalise=normalise,\n        )\n\n    def apply(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        wavefront *= self.transmission\n\n        if self.as_phase:\n            wavefront = wavefront.add_phase(self.eval_basis())\n        else:\n            wavefront += self.eval_basis()\n\n        if self.normalise:\n            wavefront = wavefront.normalise()\n        return wavefront\n</code></pre>"},{"location":"API/layers/optics/#dLux.layers.optics.Optic.__init__","title":"<code>__init__(transmission=None, opd=None, phase=None, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>None</code> <code>opd</code> <code>Array, metres = None</code> <p>The Array of OPD values to be applied to the input wavefront.</p> <code>None</code> <code>phase</code> <code>Array, radians = None</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>None</code> <code>normalise</code> <code>bool</code> <p>Whether to normalise the wavefront after passing through the optic.</p> <code>False</code> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>def __init__(\n    self: OpticalLayer,\n    transmission: Array = None,\n    opd: Array = None,\n    phase: Array = None,\n    normalise: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    transmission: Array = None\n        The Array of transmission values to be applied to the input wavefront.\n    opd : Array, metres = None\n        The Array of OPD values to be applied to the input wavefront.\n    phase : Array, radians = None\n        The Array of phase values to be applied to the input wavefront.\n    normalise: bool = False\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n    super().__init__(\n        transmission=transmission,\n        opd=opd,\n        phase=phase,\n        normalise=normalise,\n    )\n\n    if self.transmission is not None:\n        if self.opd is not None:\n            if self.transmission.shape != self.opd.shape:\n                raise ValueError(\n                    \"transmission and opd must have the same shape. Got \"\n                    f\"shapes {self.transmission.shape} and {self.opd.shape}.\"\n                )\n        if self.phase is not None:\n            if self.transmission.shape != self.phase.shape:\n                raise ValueError(\n                    \"transmission and phase must have the same shape. Got \"\n                    f\"shapes {self.transmission.shape} and {self.phase.shape}.\"\n                )\n</code></pre>"},{"location":"API/layers/optics/#dLux.layers.optics.Optic.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n    wavefront += self.opd\n    wavefront = wavefront.add_phase(self.phase)\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"API/layers/optics/#dLux.layers.optics.Optic","title":"Optics","text":""},{"location":"API/layers/optics/#dLux.layers.optics.Optic.__init__","title":"Optics","text":""},{"location":"API/layers/optics/#dLux.layers.optics.Optic.apply","title":"Optics","text":""},{"location":"API/layers/optics/#dLux.layers.optics.BasisOptic.__init__","title":"<code>__init__(basis, transmission=None, coefficients=None, as_phase=False, normalise=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>basis</code> <p>Arrays holding the pre-calculated basis vectors.</p> required <code>coefficients</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>None</code> <code>transmission</code> <p>The Array of transmission values to be applied to the input wavefront.</p> <code>None</code> <code>as_phase</code> <code>bool = False</code> <p>Whether to apply the basis as a phase phase or OPD. If True the basis is applied as a phase, else it is applied as an OPD.</p> <code>False</code> <code>normalise</code> <code>bool = False</code> <p>Whether to normalise the wavefront after passing through the optic.</p> <code>False</code> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>def __init__(\n    self: OpticalLayer,\n    basis,\n    transmission=None,\n    coefficients=None,\n    as_phase=False,\n    normalise=False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    basis: Array, metres\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array = None\n        The Array of coefficients to be applied to each basis vector.\n    transmission: Array = None\n        The Array of transmission values to be applied to the input wavefront.\n    as_phase : bool = False\n        Whether to apply the basis as a phase phase or OPD. If True the basis is\n        applied as a phase, else it is applied as an OPD.\n    normalise : bool = False\n        Whether to normalise the wavefront after passing through the optic.\n    \"\"\"\n    super().__init__(\n        transmission=transmission,\n        basis=basis,\n        coefficients=coefficients,\n        as_phase=as_phase,\n        normalise=normalise,\n    )\n</code></pre>"},{"location":"API/layers/optics/#dLux.layers.optics.BasisOptic.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/optics.py</code> <pre><code>def apply(self: OpticalLayer, wavefront: Wavefront()) -&gt; Wavefront():\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    wavefront *= self.transmission\n\n    if self.as_phase:\n        wavefront = wavefront.add_phase(self.eval_basis())\n    else:\n        wavefront += self.eval_basis()\n\n    if self.normalise:\n        wavefront = wavefront.normalise()\n    return wavefront\n</code></pre>"},{"location":"API/layers/optics/#dLux.layers.optics.BasisOptic","title":"Optics","text":""},{"location":"API/layers/optics/#dLux.layers.optics.BasisOptic.__init__","title":"Optics","text":""},{"location":"API/layers/optics/#dLux.layers.optics.BasisOptic.apply","title":"Optics","text":""},{"location":"API/layers/propagators/","title":"Propagators","text":"MFT <p>             Bases: <code>Propagator</code></p> <p>Propagates a <code>Wavefront</code> using the MFT algorithm, allowing for the pixel_scale and number of pixels to be specified in the output plane.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale in the output plane. Has units of radians/pixel if focal_length is None, else meters/pixel.</p> <code>focal_length</code> <code>(float, meters)</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>class MFT(Propagator):\n    \"\"\"\n    Propagates a `Wavefront` using the MFT algorithm, allowing for the pixel_scale and\n    number of pixels to be specified in the output plane.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/MFT.png)\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale in the output plane. Has units of radians/pixel if focal_length\n        is None, else meters/pixel.\n    focal_length : float, meters\n        The focal_length of the lens/mirror this propagator represents. If None, the\n        output pixel_scale has units radians/pixel, else meters/pixels.\n    \"\"\"\n\n    npixels: int\n    pixel_scale: float\n\n    def __init__(\n        self: Propagator,\n        npixels: int,\n        pixel_scale: float,\n        focal_length: float = None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The pixel scale in the output plane. Has units of radians/pixel if\n            focal_length is None, else meters/pixel.\n        focal_length : float = None, meters\n            The focal_length of the lens/mirror this propagator represents. If None,\n            the output pixel_scale has units radians/pixel, else meters/pixels.\n        \"\"\"\n        super().__init__(focal_length=focal_length)\n\n        self.pixel_scale = float(pixel_scale)\n        self.npixels = int(npixels)\n\n    def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.propagate(\n            self.npixels,\n            self.pixel_scale,\n            self.focal_length,\n        )\n</code></pre> FFT <p>             Bases: <code>Propagator</code></p> <p>Propagates a <code>Wavefront</code> using the FFT algorithm.</p> UML <p></p> ShiftedMFT <p>             Bases: <code>MFT</code></p> <p>Propagates a <code>Wavefront</code> using the MFT algorithm, allowing for the pixel_scale and number of pixels to be specified in the output plane. Also optionally allows for a shift to be applied to the wavefront in the output plane.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale in the output plane. Has units of radians/pixel if focal_length is None, else meters/pixel.</p> <code>focal_length</code> <code>(float, meters)</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel</code> <code>bool</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane (ie radians if focal_length is None, else meters).</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>class ShiftedMFT(MFT):\n    \"\"\"\n    Propagates a `Wavefront` using the MFT algorithm, allowing for the pixel_scale and\n    number of pixels to be specified in the output plane. Also optionally allows for a\n    shift to be applied to the wavefront in the output plane.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/ShiftedMFT.png)\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale in the output plane. Has units of radians/pixel if focal_length\n        is None, else meters/pixel.\n    focal_length : float, meters\n        The focal_length of the lens/mirror this propagator represents. If None, the\n        output pixel_scale has units radians/pixel, else meters/pixels.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        If True the shift value is assumed to be in units of pixels, else the physical\n        units of the output plane (ie radians if focal_length is None, else meters).\n    \"\"\"\n\n    shift: Array\n    pixel: bool\n\n    def __init__(\n        self: Propagator,\n        npixels: int,\n        pixel_scale: float,\n        shift: Array,\n        focal_length: float = None,\n        pixel: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The pixel scale in the output plane. Has units of radians/pixel if\n            focal_length is None, else meters/pixel.\n        shift : Array\n            The (x, y) shift to apply to the wavefront in the output plane.\n        focal_length : float = None, meters\n            The focal_length of the lens/mirror this propagator represents. If None,\n            the output pixel_scale has units radians/pixel, else meters/pixels.\n        pixel : bool = False\n            If True the shift value is assumed to be in units of pixels, else the\n            physical units of the output plane (ie radians if focal_length is None,\n            else meters).\n        \"\"\"\n        super().__init__(\n            pixel_scale=pixel_scale,\n            npixels=npixels,\n            focal_length=focal_length,\n        )\n\n        self.shift = np.asarray(shift, float)\n        self.pixel = bool(pixel)\n\n        if self.shift.shape != (2,):\n            raise ValueError(\n                f\"Shift must be a 2D array, got {self.shift.shape}.\"\n            )\n\n    def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.propagate(\n            self.npixels,\n            self.pixel_scale,\n            self.focal_length,\n            self.shift,\n            self.pixel,\n        )\n</code></pre> FarFieldFresnel <p>             Bases: <code>ShiftedMFT</code></p> <p>Propagates a <code>Wavefront</code> using the MFT algorithm, modified to allows for more accurate representations of wavefront behaviour in the far-field regime, a few wavelengths away from focus in either direction. Allows for the pixel_scale and number of pixels to be specified in the output plane, and optionally allows for a shift to be applied to the wavefront in the output plane.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale</code> <code>float, meters/</code> <p>The pixel scale in the output plane.</p> <code>focal_length</code> <code>(float, meters)</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel</code> <code>bool</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane.</p> <code>focal_shift</code> <code>(float, meters)</code> <p>The shift in the propagation distance of the wavefront from focus.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>class FarFieldFresnel(ShiftedMFT):\n    \"\"\"\n    Propagates a `Wavefront` using the MFT algorithm, modified to allows for more\n    accurate representations of wavefront behaviour in the far-field regime, a few\n    wavelengths away from focus in either direction. Allows for the pixel_scale and\n    number of pixels to be specified in the output plane, and optionally allows for a\n    shift to be applied to the wavefront in the output plane.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/FarFieldFresnel.png)\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/\n        The pixel scale in the output plane.\n    focal_length : float, meters\n        The focal_length of the lens/mirror this propagator represents.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool\n        If True the shift value is assumed to be in units of pixels, else the physical\n        units of the output plane.\n    focal_shift : float, meters\n        The shift in the propagation distance of the wavefront from focus.\n    \"\"\"\n\n    focal_shift: float\n\n    def __init__(\n        self: Propagator,\n        npixels: int,\n        pixel_scale: float,\n        focal_length: float,\n        focal_shift: float,\n        shift: Array = np.zeros(2),\n        pixel: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels in the output plane.\n        pixel_scale : float, meters/\n            The pixel scale in the output plane.\n        focal_length : float, meters\n            The focal_length of the lens/mirror this propagator represents.\n        focal_shift : float, meters\n            The shift in the propagation distance of the wavefront from focus.\n        shift : Array = np.zeros(2)\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel : bool = False\n            If True the shift value is assumed to be in units of pixels, else the\n            physical units of the output plane.\n        \"\"\"\n        self.focal_shift = float(focal_shift)\n        super().__init__(\n            shift=shift,\n            pixel=pixel,\n            focal_length=focal_length,\n            pixel_scale=pixel_scale,\n            npixels=npixels,\n        )\n\n    def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.propagate_fresnel(\n            self.npixels,\n            self.pixel_scale,\n            self.focal_length,\n            self.focal_shift,\n            self.shift,\n            self.pixel,\n        )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.MFT.__init__","title":"<code>__init__(npixels, pixel_scale, focal_length=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale in the output plane. Has units of radians/pixel if focal_length is None, else meters/pixel.</p> required <code>focal_length</code> <code>float = None, meters</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> <code>None</code> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def __init__(\n    self: Propagator,\n    npixels: int,\n    pixel_scale: float,\n    focal_length: float = None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale in the output plane. Has units of radians/pixel if\n        focal_length is None, else meters/pixel.\n    focal_length : float = None, meters\n        The focal_length of the lens/mirror this propagator represents. If None,\n        the output pixel_scale has units radians/pixel, else meters/pixels.\n    \"\"\"\n    super().__init__(focal_length=focal_length)\n\n    self.pixel_scale = float(pixel_scale)\n    self.npixels = int(npixels)\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.MFT.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.propagate(\n        self.npixels,\n        self.pixel_scale,\n        self.focal_length,\n    )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.MFT","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.MFT.__init__","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.MFT.apply","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT--todo-update-padding-to-take-in-units-of-npixels-rather-than-factor","title":"TODO: Update padding to take in units of npixels, rather than factor.","text":"<p>Attributes:</p> Name Type Description <code>focal_length</code> <code>float</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> <code>pad</code> <code>int</code> <p>The zero-padding factor to apply to the <code>Wavefront</code> before propagation. In general, this should be greater than 2 to avoid aliasing.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>class FFT(Propagator):\n    \"\"\"\n    Propagates a `Wavefront` using the FFT algorithm.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/FFT.png)\n\n    # TODO: Update padding to take in units of npixels, rather than factor.\n\n    Attributes\n    ----------\n    focal_length : float\n        The focal_length of the lens/mirror this propagator represents. If None, the\n        output pixel_scale has units radians/pixel, else meters/pixels.\n    pad : int\n        The zero-padding factor to apply to the `Wavefront` before propagation. In\n        general, this should be greater than 2 to avoid aliasing.\n    \"\"\"\n\n    pad: int\n\n    def __init__(self: Propagator, focal_length: float = None, pad: int = 2):\n        \"\"\"\n        Parameters\n        ----------\n        focal_length : float = None\n            The focal_length of the lens/mirror this propagator represents. If None, the\n            output pixel_scale has units radians/pixel, else meters/pixels.\n        pad : int = 2\n            The zero-padding factor to apply to the `Wavefront` before propagation. In\n            general, this should be greater than 2 to avoid aliasing.\n        \"\"\"\n        super().__init__(focal_length=focal_length)\n        self.pad = int(pad)\n\n    def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n        \"\"\"\n        Applies the layer to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The transformed wavefront.\n        \"\"\"\n        return wavefront.propagate_FFT(self.focal_length, self.pad)\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT.__init__","title":"<code>__init__(focal_length=None, pad=2)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>float = None</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> <code>None</code> <code>pad</code> <code>int = 2</code> <p>The zero-padding factor to apply to the <code>Wavefront</code> before propagation. In general, this should be greater than 2 to avoid aliasing.</p> <code>2</code> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def __init__(self: Propagator, focal_length: float = None, pad: int = 2):\n    \"\"\"\n    Parameters\n    ----------\n    focal_length : float = None\n        The focal_length of the lens/mirror this propagator represents. If None, the\n        output pixel_scale has units radians/pixel, else meters/pixels.\n    pad : int = 2\n        The zero-padding factor to apply to the `Wavefront` before propagation. In\n        general, this should be greater than 2 to avoid aliasing.\n    \"\"\"\n    super().__init__(focal_length=focal_length)\n    self.pad = int(pad)\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.propagate_FFT(self.focal_length, self.pad)\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT--todo-update-padding-to-take-in-units-of-npixels-rather-than-factor","title":"TODO: Update padding to take in units of npixels, rather than factor.","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT.__init__","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FFT.apply","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.ShiftedMFT.__init__","title":"<code>__init__(npixels, pixel_scale, shift, focal_length=None, pixel=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale in the output plane. Has units of radians/pixel if focal_length is None, else meters/pixel.</p> required <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> required <code>focal_length</code> <code>float = None, meters</code> <p>The focal_length of the lens/mirror this propagator represents. If None, the output pixel_scale has units radians/pixel, else meters/pixels.</p> <code>None</code> <code>pixel</code> <code>bool = False</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane (ie radians if focal_length is None, else meters).</p> <code>False</code> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def __init__(\n    self: Propagator,\n    npixels: int,\n    pixel_scale: float,\n    shift: Array,\n    focal_length: float = None,\n    pixel: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The pixel scale in the output plane. Has units of radians/pixel if\n        focal_length is None, else meters/pixel.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    focal_length : float = None, meters\n        The focal_length of the lens/mirror this propagator represents. If None,\n        the output pixel_scale has units radians/pixel, else meters/pixels.\n    pixel : bool = False\n        If True the shift value is assumed to be in units of pixels, else the\n        physical units of the output plane (ie radians if focal_length is None,\n        else meters).\n    \"\"\"\n    super().__init__(\n        pixel_scale=pixel_scale,\n        npixels=npixels,\n        focal_length=focal_length,\n    )\n\n    self.shift = np.asarray(shift, float)\n    self.pixel = bool(pixel)\n\n    if self.shift.shape != (2,):\n        raise ValueError(\n            f\"Shift must be a 2D array, got {self.shift.shape}.\"\n        )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.ShiftedMFT.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.propagate(\n        self.npixels,\n        self.pixel_scale,\n        self.focal_length,\n        self.shift,\n        self.pixel,\n    )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.ShiftedMFT","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.ShiftedMFT.__init__","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.ShiftedMFT.apply","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FarFieldFresnel.__init__","title":"<code>__init__(npixels, pixel_scale, focal_length, focal_shift, shift=np.zeros(2), pixel=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale</code> <code>float, meters/</code> <p>The pixel scale in the output plane.</p> required <code>focal_length</code> <code>(float, meters)</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>focal_shift</code> <code>(float, meters)</code> <p>The shift in the propagation distance of the wavefront from focus.</p> required <code>shift</code> <code>Array = np.zeros(2)</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>zeros(2)</code> <code>pixel</code> <code>bool = False</code> <p>If True the shift value is assumed to be in units of pixels, else the physical units of the output plane.</p> <code>False</code> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def __init__(\n    self: Propagator,\n    npixels: int,\n    pixel_scale: float,\n    focal_length: float,\n    focal_shift: float,\n    shift: Array = np.zeros(2),\n    pixel: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels in the output plane.\n    pixel_scale : float, meters/\n        The pixel scale in the output plane.\n    focal_length : float, meters\n        The focal_length of the lens/mirror this propagator represents.\n    focal_shift : float, meters\n        The shift in the propagation distance of the wavefront from focus.\n    shift : Array = np.zeros(2)\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel : bool = False\n        If True the shift value is assumed to be in units of pixels, else the\n        physical units of the output plane.\n    \"\"\"\n    self.focal_shift = float(focal_shift)\n    super().__init__(\n        shift=shift,\n        pixel=pixel,\n        focal_length=focal_length,\n        pixel_scale=pixel_scale,\n        npixels=npixels,\n    )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.FarFieldFresnel.apply","title":"<code>apply(wavefront)</code>","text":"<p>Applies the layer to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The transformed wavefront.</p> Source code in <code>src/dLux/layers/propagators.py</code> <pre><code>def apply(self: Propagator, wavefront: Wavefront) -&gt; Wavefront:\n    \"\"\"\n    Applies the layer to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The transformed wavefront.\n    \"\"\"\n    return wavefront.propagate_fresnel(\n        self.npixels,\n        self.pixel_scale,\n        self.focal_length,\n        self.focal_shift,\n        self.shift,\n        self.pixel,\n    )\n</code></pre>"},{"location":"API/layers/propagators/#dLux.layers.propagators.FarFieldFresnel","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FarFieldFresnel.__init__","title":"Propagators","text":""},{"location":"API/layers/propagators/#dLux.layers.propagators.FarFieldFresnel.apply","title":"Propagators","text":""},{"location":"API/layers/unified_layers/","title":"Unified Layers","text":"Rotate <p>             Bases: <code>UnifiedLayer</code></p> <p>Rotates either a wavefront or PSF by a given angle. This is done using interpolation methods. The 'complex' input only has an effect if the input is a wavefront.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>(float, radians)</code> <p>The angle by which to rotate the input in the clockwise direction.</p> <code>order</code> <code>int</code> <p>The order of the interpolation to use. Must be 0 or 1.</p> <code>complex</code> <code>bool</code> <p>Should the rotation be performed on the 'complex' (real, imaginary), as opposed to the default 'phasor' (amplitude, phase) arrays. Only applies if the input is a wavefront.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>class Rotate(UnifiedLayer):\n    \"\"\"\n    Rotates either a wavefront or PSF by a given angle. This is done using\n    interpolation methods. The 'complex' input only has an effect if the input is a\n    wavefront.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Rotate.png)\n\n    Attributes\n    ----------\n    angle : float, radians\n        The angle by which to rotate the input in the clockwise direction.\n    order : int\n        The order of the interpolation to use. Must be 0 or 1.\n    complex : bool\n        Should the rotation be performed on the 'complex' (real, imaginary), as opposed\n        to the default 'phasor' (amplitude, phase) arrays. Only applies if the input is\n        a wavefront.\n    \"\"\"\n\n    angle: float\n    order: int\n    complex: bool\n\n    def __init__(\n        self: UnifiedLayer,\n        angle: float,\n        order: int = 1,\n        complex: bool = False,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        angle : float, radians\n            The angle by which to rotate the input in the clockwise direction.\n        order : int = 1\n            The order of the interpolation to use. Must be 0 or 1.\n        complex : bool = False\n            Should the rotation be performed on the 'complex' (real, imaginary), as\n            opposed to the default 'phasor' (amplitude, phase) arrays. Only applies if\n            the input is a wavefront.\n        \"\"\"\n        super().__init__()\n        self.angle = float(angle)\n        self.order = int(order)\n        self.complex = bool(complex)\n\n        if self.order not in (0, 1):\n            raise ValueError(\"Order must be 0, 1\")\n\n    def apply(\n        self: UnifiedLayer, input: Union[Wavefront, PSF]\n    ) -&gt; Union[Wavefront, PSF]:\n        \"\"\"\n        Applies the rotation to the input.\n\n        Parameters\n        ----------\n        input : Union[Wavefront, PSF]\n            The input to rotate.\n\n        Returns\n        -------\n        input : Union[Wavefront, PSF]\n            The rotated input.\n        \"\"\"\n        if isinstance(input, PSF):\n            return input.rotate(self.angle, self.order)\n        else:\n            return input.rotate(self.angle, self.order, self.complex)\n</code></pre> Flip <p>             Bases: <code>UnifiedLayer</code></p> <p>Flips either a wavefront or PSF about the input axes. Can be either an int or a tuple of ints. This class uses the 'ij' indexing convention, ie axis 0 is the y-axis, and axis 1 is the x-axis.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>axes</code> <code>Union[tuple, int]</code> <p>The axes to flip the input about. This class uses the 'ij' indexing convention, ie axis 0 is the y-axis, and axis 1 is the x-axis.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>class Flip(UnifiedLayer):\n    \"\"\"\n    Flips either a wavefront or PSF about the input axes. Can be either an int or a\n    tuple of ints. This class uses the 'ij' indexing convention, ie axis 0 is the\n    y-axis, and axis 1 is the x-axis.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Flip.png)\n\n    Attributes\n    ----------\n    axes : Union[tuple, int]\n        The axes to flip the input about. This class uses the 'ij' indexing convention,\n        ie axis 0 is the y-axis, and axis 1 is the x-axis.\n    \"\"\"\n\n    axes: Union[tuple[int], int]\n\n    def __init__(self: UnifiedLayer, axes: Union[tuple[int], int]):\n        \"\"\"\n        Parameters\n        ----------\n        axes : Union[tuple, int]\n            The axes to flip the input about. This class uses the 'ij' indexing\n            convention, ie axis 0 is the y-axis, and axis 1 is the x-axis.\n        \"\"\"\n        super().__init__()\n        self.axes = axes\n\n        if isinstance(self.axes, tuple):\n            for axes in self.axes:\n                if not isinstance(axes, int):\n                    raise ValueError(\"All axes must be integers.\")\n        elif not isinstance(self.axes, int):\n            raise ValueError(\"axes must be integers.\")\n\n    def apply(\n        self: UnifiedLayer, input: Union[Wavefront, PSF]\n    ) -&gt; Union[Wavefront, PSF]:\n        \"\"\"\n        Flips the input about the input axes.\n\n        Parameters\n        ----------\n        input : Union[Wavefront, PSF]\n            The input to flip.\n\n        Returns\n        -------\n        input : Union[Wavefront, PSF]\n            The flipped input.\n        \"\"\"\n        return input.flip(self.axes)\n</code></pre> Resize <p>             Bases: <code>UnifiedLayer</code></p> <p>Resizes either a wavefront or PSF by either padding or cropping. Note this class only supports padding and cropping of even sizes to even sizes, and odd sizes to odd sizes to ensure all operations are paraxial.</p> UML <p></p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The desired output size.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>class Resize(UnifiedLayer):\n    \"\"\"\n    Resizes either a wavefront or PSF by either padding or cropping. Note this class\n    only supports padding and cropping of even sizes to even sizes, and odd sizes to\n    odd sizes to ensure all operations are paraxial.\n\n    ??? abstract \"UML\"\n        ![UML](../../assets/uml/Resize.png)\n\n    Attributes\n    ----------\n    npixels : int\n        The desired output size.\n    \"\"\"\n\n    npixels: int\n\n    def __init__(self: UnifiedLayer, npixels: int):\n        \"\"\"\n        Parameters\n        ----------\n        npixels : tuple\n            The desired output size.\n        \"\"\"\n        super().__init__()\n        self.npixels = int(npixels)\n\n    def apply(\n        self: UnifiedLayer, input: Union[Wavefront, PSF]\n    ) -&gt; Union[Wavefront, PSF]:\n        \"\"\"\n        Resizes the input.\n\n        Parameters\n        ----------\n        input : Union[Wavefront, PSF]\n            The input to resize.\n\n        Returns\n        -------\n        input : Union[Wavefront, PSF]\n            The resized input.\n        \"\"\"\n        return input.resize(self.npixels)\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Rotate.__init__","title":"<code>__init__(angle, order=1, complex=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>angle</code> <code>(float, radians)</code> <p>The angle by which to rotate the input in the clockwise direction.</p> required <code>order</code> <code>int = 1</code> <p>The order of the interpolation to use. Must be 0 or 1.</p> <code>1</code> <code>complex</code> <code>bool = False</code> <p>Should the rotation be performed on the 'complex' (real, imaginary), as opposed to the default 'phasor' (amplitude, phase) arrays. Only applies if the input is a wavefront.</p> <code>False</code> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def __init__(\n    self: UnifiedLayer,\n    angle: float,\n    order: int = 1,\n    complex: bool = False,\n):\n    \"\"\"\n    Parameters\n    ----------\n    angle : float, radians\n        The angle by which to rotate the input in the clockwise direction.\n    order : int = 1\n        The order of the interpolation to use. Must be 0 or 1.\n    complex : bool = False\n        Should the rotation be performed on the 'complex' (real, imaginary), as\n        opposed to the default 'phasor' (amplitude, phase) arrays. Only applies if\n        the input is a wavefront.\n    \"\"\"\n    super().__init__()\n    self.angle = float(angle)\n    self.order = int(order)\n    self.complex = bool(complex)\n\n    if self.order not in (0, 1):\n        raise ValueError(\"Order must be 0, 1\")\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Rotate.apply","title":"<code>apply(input)</code>","text":"<p>Applies the rotation to the input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The input to rotate.</p> required <p>Returns:</p> Name Type Description <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The rotated input.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def apply(\n    self: UnifiedLayer, input: Union[Wavefront, PSF]\n) -&gt; Union[Wavefront, PSF]:\n    \"\"\"\n    Applies the rotation to the input.\n\n    Parameters\n    ----------\n    input : Union[Wavefront, PSF]\n        The input to rotate.\n\n    Returns\n    -------\n    input : Union[Wavefront, PSF]\n        The rotated input.\n    \"\"\"\n    if isinstance(input, PSF):\n        return input.rotate(self.angle, self.order)\n    else:\n        return input.rotate(self.angle, self.order, self.complex)\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Rotate","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Rotate.__init__","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Rotate.apply","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Flip.__init__","title":"<code>__init__(axes)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>axes</code> <code>Union[tuple, int]</code> <p>The axes to flip the input about. This class uses the 'ij' indexing convention, ie axis 0 is the y-axis, and axis 1 is the x-axis.</p> required Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def __init__(self: UnifiedLayer, axes: Union[tuple[int], int]):\n    \"\"\"\n    Parameters\n    ----------\n    axes : Union[tuple, int]\n        The axes to flip the input about. This class uses the 'ij' indexing\n        convention, ie axis 0 is the y-axis, and axis 1 is the x-axis.\n    \"\"\"\n    super().__init__()\n    self.axes = axes\n\n    if isinstance(self.axes, tuple):\n        for axes in self.axes:\n            if not isinstance(axes, int):\n                raise ValueError(\"All axes must be integers.\")\n    elif not isinstance(self.axes, int):\n        raise ValueError(\"axes must be integers.\")\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Flip.apply","title":"<code>apply(input)</code>","text":"<p>Flips the input about the input axes.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The input to flip.</p> required <p>Returns:</p> Name Type Description <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The flipped input.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def apply(\n    self: UnifiedLayer, input: Union[Wavefront, PSF]\n) -&gt; Union[Wavefront, PSF]:\n    \"\"\"\n    Flips the input about the input axes.\n\n    Parameters\n    ----------\n    input : Union[Wavefront, PSF]\n        The input to flip.\n\n    Returns\n    -------\n    input : Union[Wavefront, PSF]\n        The flipped input.\n    \"\"\"\n    return input.flip(self.axes)\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Flip","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Flip.__init__","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Flip.apply","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Resize.__init__","title":"<code>__init__(npixels)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>tuple</code> <p>The desired output size.</p> required Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def __init__(self: UnifiedLayer, npixels: int):\n    \"\"\"\n    Parameters\n    ----------\n    npixels : tuple\n        The desired output size.\n    \"\"\"\n    super().__init__()\n    self.npixels = int(npixels)\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Resize.apply","title":"<code>apply(input)</code>","text":"<p>Resizes the input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The input to resize.</p> required <p>Returns:</p> Name Type Description <code>input</code> <code>Union[Wavefront, PSF]</code> <p>The resized input.</p> Source code in <code>src/dLux/layers/unified_layers.py</code> <pre><code>def apply(\n    self: UnifiedLayer, input: Union[Wavefront, PSF]\n) -&gt; Union[Wavefront, PSF]:\n    \"\"\"\n    Resizes the input.\n\n    Parameters\n    ----------\n    input : Union[Wavefront, PSF]\n        The input to resize.\n\n    Returns\n    -------\n    input : Union[Wavefront, PSF]\n        The resized input.\n    \"\"\"\n    return input.resize(self.npixels)\n</code></pre>"},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Resize","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Resize.__init__","title":"Unified Layers","text":""},{"location":"API/layers/unified_layers/#dLux.layers.unified_layers.Resize.apply","title":"Unified Layers","text":""},{"location":"API/utils/array_ops/","title":"Array Operations","text":"<p>Contains a series of functions for performing paraxial operations on arrays.</p> pad_to <p>Paraxially zero-pads the input array to the shape (npixels, npixels). Due to the paraxial requirement, the input array must be square and even arrays can only be padded to even shapes, and odd shaped arrays can only be padded to odd shapes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to pad.</p> required <code>npixels</code> <code>int</code> <p>The size to pad to the array to.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The padded array.</p> Source code in <code>src/dLux/utils/array_ops.py</code> <pre><code>def pad_to(array: Array, npixels: int) -&gt; Array:\n    \"\"\"\n    Paraxially zero-pads the input array to the shape (npixels, npixels). Due to the\n    paraxial requirement, the input array must be square and even arrays can only\n    be padded to even shapes, and odd shaped arrays can only be padded to odd shapes.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to pad.\n    npixels : int\n        The size to pad to the array to.\n\n    Returns\n    -------\n    array : Array\n        The padded array.\n    \"\"\"\n    npixels_in = array.shape[-1]\n    if npixels_in % 2 != npixels % 2:\n        raise ValueError(\n            \"Only supports even -&gt; even or odd -&gt; odd padding.\"\n            f\"Input array has {npixels_in} pixels, and requested padding to \"\n            f\"{npixels} pixels\"\n        )\n    if npixels &lt; npixels_in:\n        raise ValueError(\n            \"npixels must be larger than the current array, \"\n            f\"npixels_in = {npixels_in} &lt; npixels = {npixels}\"\n        )\n\n    return np.pad(array, (npixels - npixels_in) // 2)\n</code></pre> crop_to <p>Paraxially crops the input array to the shape (npixels, npixels). Due to the paraxial requirement, the input array must be square and even arrays can only be cropped to even shapes, and odd shaped arrays can only be cropped to odd shapes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to crop.</p> required <code>npixels</code> <code>int</code> <p>The size to crop the array to.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The cropped array.</p> Source code in <code>src/dLux/utils/array_ops.py</code> <pre><code>def crop_to(array: Array, npixels: int) -&gt; Array:\n    \"\"\"\n    Paraxially crops the input array to the shape (npixels, npixels). Due to the\n    paraxial requirement, the input array must be square and even arrays can only\n    be cropped to even shapes, and odd shaped arrays can only be cropped to odd shapes.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to crop.\n    npixels : int\n        The size to crop the array to.\n\n    Returns\n    -------\n    array : Array\n        The cropped array.\n    \"\"\"\n    npixels_in = array.shape[-1]\n    if npixels_in % 2 != npixels % 2:\n        raise ValueError(\n            \"Only supports even -&gt; even or odd -&gt; odd cropping.\"\n            f\"Input array has {npixels_in} pixels, and requested cropping to \"\n            f\"{npixels} pixels\"\n        )\n    if npixels &gt; npixels_in:\n        raise ValueError(\n            \"npixels must be smaller than the current array, \"\n            f\"npixels_in = {npixels_in} &gt; npixels = {npixels}\"\n        )\n\n    start, stop = (npixels_in - npixels) // 2, (npixels_in + npixels) // 2\n    return array[start:stop, start:stop]\n</code></pre> resize <p>Resizes the input array to the shape (npixels, npixels), using either a pad or crop depending on the input array size. Due to the paraxial requirement, the input array must be square and even arrays can only be resized to even shapes, and odd shaped arrays can only be resized to odd shapes.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to resize.</p> required <code>npixels</code> <code>int</code> <p>The size to output the array.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The resized array.</p> Source code in <code>src/dLux/utils/array_ops.py</code> <pre><code>def resize(array: Array, npixels: int) -&gt; Array:\n    \"\"\"\n    Resizes the input array to the shape (npixels, npixels), using either a pad or crop\n    depending on the input array size. Due to the paraxial requirement, the input array\n    must be square and even arrays can only be resized to even shapes, and odd shaped\n    arrays can only be resized to odd shapes.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to resize.\n    npixels : int\n        The size to output the array.\n\n    Returns\n    -------\n    array : Array\n        The resized array.\n    \"\"\"\n    npixels_in = array.shape[-1]\n\n    if npixels == npixels_in:\n        return array\n    elif npixels &lt; npixels_in:\n        return crop_to(array, npixels)\n    else:\n        return pad_to(array, npixels)\n</code></pre> downsample <p>Downsamples the input array by a factor of n, either by taking the mean or sum of the array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to downsample.</p> required <code>n</code> <code>int</code> <p>The factor by which to downsample the array.</p> required <code>mean</code> <code>bool = True</code> <p>Whether to downsample by taking the mean or sum of the array.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The downsampled array.</p> Source code in <code>src/dLux/utils/array_ops.py</code> <pre><code>def downsample(array: Array, n: int, mean: bool = True) -&gt; Array:\n    \"\"\"\n    Downsamples the input array by a factor of n, either by taking the mean or sum\n    of the array.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to downsample.\n    n : int\n        The factor by which to downsample the array.\n    mean : bool = True\n        Whether to downsample by taking the mean or sum of the array.\n\n    Returns\n    -------\n    array : Array\n        The downsampled array.\n    \"\"\"\n    if array.shape[0] != array.shape[1]:\n        raise ValueError(\n            f\"Input array has shape {array.shape}, which is not square\"\n        )\n    if array.shape[0] % n != 0:\n        raise ValueError(\n            f\"Input array has {array.shape[0]} pixels, which is not divisible \"\n            f\"by {n}\"\n        )\n\n    method = np.mean if mean else np.sum\n    size_in = array.shape[0]\n    size_out = size_in // n\n\n    # Downsample first dimension\n    array = method(array.reshape((size_in * size_out, n)), 1)\n    array = array.reshape(size_in, size_out).T\n\n    # Downsample second dimension\n    array = method(array.reshape((size_out * size_out, n)), 1)\n    array = array.reshape(size_out, size_out).T\n    return array\n</code></pre>"},{"location":"API/utils/array_ops/#dLux.utils.array_ops.pad_to","title":"Array Operations","text":""},{"location":"API/utils/array_ops/#dLux.utils.array_ops.crop_to","title":"Array Operations","text":""},{"location":"API/utils/array_ops/#dLux.utils.array_ops.resize","title":"Array Operations","text":""},{"location":"API/utils/array_ops/#dLux.utils.array_ops.downsample","title":"Array Operations","text":""},{"location":"API/utils/coordinates/","title":"Coordinates","text":"<p>This module contains a series of functions which are used to calculate coordinate arrays, apply transformations to coordinate arrays, and convert between Cartesian and polar coordinates.</p> pixel_coords <p>Returns a paraxial set of 2d coordinates for each pixel center.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The output size of the coordinates array to generate.</p> required <code>diameter</code> <code>float</code> <p>The diameter of the coordinates array to generate.</p> required <code>polar</code> <code>bool = False</code> <p>Output the coordinates in polar (r, phi) coordinates.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The array of pixel center coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def pixel_coords(npixels: int, diameter: float, polar: bool = False) -&gt; Array:\n    \"\"\"\n    Returns a paraxial set of 2d coordinates for each pixel center.\n\n    Parameters\n    ----------\n    npixels : int\n        The output size of the coordinates array to generate.\n    diameter : float\n        The diameter of the coordinates array to generate.\n    polar : bool = False\n        Output the coordinates in polar (r, phi) coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The array of pixel center coordinates.\n    \"\"\"\n    coords = nd_coords((npixels,) * 2, (diameter / npixels,) * 2)\n    if polar:\n        return cart2polar(coords)\n    return coords\n</code></pre> nd_coords <p>Returns a set of nd pixel center coordinates, with an optional offset. Each dimension can have a different number of pixels, pixel scale and offset by passing in tuples of values: <code>nd_coords((10, 10), (1, 2), (0, 1))</code>. pixel scale and offset can also be passed in as floats to apply those values to all dimensions, ie: <code>nd_coords((10, 10), 1, 0)</code>.</p> <p>The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>Union[int, tuple]</code> <p>The number of pixels in each dimension.</p> required <code>pixel_scales</code> <code>Union[tuple, float] = 1.</code> <p>The pixel_scales of each dimension. If a tuple, the length of the tuple must match the number of dimensions. If a float, the same scale is applied to all dimensions.</p> <code>1.0</code> <code>offsets</code> <code>Union[tuple, float] = 0.</code> <p>The offset of the pixel centers in each dimension. If a tuple, the length of the tuple must match the number of dimensions. If a float, the same offset is applied to all dimensions. set to 0.</p> <code>0.0</code> <code>indexing</code> <code>str = 'xy'</code> <p>The indexing of the output. Default is 'xy'. See numpy.meshgrid for more details.</p> <code>'xy'</code> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The positions of the pixel centers in the given dimensions.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def nd_coords(\n    npixels: Union[int, tuple],\n    pixel_scales: Union[tuple, float] = 1.0,\n    offsets: Union[tuple, float] = 0.0,\n    indexing: str = \"xy\",\n) -&gt; Array:\n    \"\"\"\n    Returns a set of nd pixel center coordinates, with an optional offset. Each\n    dimension can have a different number of pixels, pixel scale and offset by passing\n    in tuples of values: `nd_coords((10, 10), (1, 2), (0, 1))`. pixel scale and offset\n    can also be passed in as floats to apply those values to all dimensions, ie:\n    `nd_coords((10, 10), 1, 0)`.\n\n    The indexing argument is the same as in numpy.meshgrid., i.e.: Giving the\n    string \u2018ij\u2019 returns a meshgrid with matrix indexing, while \u2018xy\u2019 returns a\n    meshgrid with Cartesian indexing. In the 2-D case with inputs of length M\n    and N, the outputs are of shape (N, M) for \u2018xy\u2019 indexing and (M, N) for\n    \u2018ij\u2019 indexing. In the 3-D case with inputs of length M, N and P, outputs\n    are of shape (N, M, P) for \u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.\n\n    Parameters\n    ----------\n    npixels : Union[int, tuple]\n        The number of pixels in each dimension.\n    pixel_scales : Union[tuple, float] = 1.\n        The pixel_scales of each dimension. If a tuple, the length\n        of the tuple must match the number of dimensions. If a float, the same\n        scale is applied to all dimensions.\n    offsets : Union[tuple, float] = 0.\n        The offset of the pixel centers in each dimension. If a tuple, the\n        length of the tuple must match the number of dimensions. If a float,\n        the same offset is applied to all dimensions.\n        set to 0.\n    indexing : str = 'xy'\n        The indexing of the output. Default is 'xy'. See numpy.meshgrid for\n        more details.\n\n    Returns\n    -------\n    coordinates : Array\n        The positions of the pixel centers in the given dimensions.\n    \"\"\"\n    if indexing not in [\"xy\", \"ij\"]:\n        raise ValueError(\"indexing must be either 'xy' or 'ij'.\")\n\n    # Promote npixels to tuple to handle 1d case\n    if not isinstance(npixels, tuple):\n        npixels = (npixels,)\n\n    # Assume equal pixel scales if not given\n    if not isinstance(pixel_scales, tuple):\n        pixel_scales = (pixel_scales,) * len(npixels)\n\n    # Assume no offset if not given\n    if not isinstance(offsets, tuple):\n        offsets = (offsets,) * len(npixels)\n\n    def pixel_fn(n, offset, scale):\n        # TODO: calculate the start and end points first and then use linspace\n        # so that ops are done on floats not arrays\n        # scale = diam / n\n        pix = np.arange(n) - (n - 1) / 2.0\n        pix *= scale\n        pix -= offset\n        return pix\n\n    # Generate the linear edges of each axes\n    # TODO: tree_flatten()[0] to avoid squeeze?\n    lin_pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)\n\n    # output (x, y) for 2d, else in order\n    positions = np.array(np.meshgrid(*lin_pixels, indexing=indexing))\n\n    # Squeeze for empty axis removal in 1d case\n    return np.squeeze(positions)\n</code></pre> cart2polar <p>Converts the input (x, y) Cartesian coordinates into (r, phi) polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (x, y) Cartesian coordinates to be converted into polar coordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input Cartesian coordinates converted into (r, phi) polar coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def cart2polar(coordinates: Array) -&gt; Array:\n    \"\"\"\n    Converts the input (x, y) Cartesian coordinates into (r, phi) polar\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (x, y) Cartesian coordinates to be converted into polar\n        coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input Cartesian coordinates converted into (r, phi) polar\n        coordinates.\n    \"\"\"\n    x, y = coordinates\n    return np.array([np.hypot(x, y), np.arctan2(y, x)])\n</code></pre> polar2cart <p>Converts the input (r, phi) polar coordinates into (x, y) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (r, phi) polar coordinates to be converted into Cartesian coordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input polar coordinates converted into (x, y) Cartesian coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def polar2cart(coordinates: Array) -&gt; Array:\n    \"\"\"\n    Converts the input (r, phi) polar coordinates into (x, y) Cartesian\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (r, phi) polar coordinates to be converted into Cartesian\n        coordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input polar coordinates converted into (x, y) Cartesian\n        coordinates.\n    \"\"\"\n    r, phi = coordinates\n    return np.array([r * np.cos(phi), r * np.sin(phi)])\n</code></pre> <p>These remaining functions are primarily used as a back-end, and are not geared to be user-facing. For user-friendly coordinate transformations, use the <code>dLux.CoordTransform</code> class.</p> translate_coords <p>Translates the coordinates by to a new centre. Translation must have shape (2,).</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The input coordinates to translate.</p> required <code>translation</code> <code>Array</code> <p>The translation to apply to the coordinates.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The translated coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def translate_coords(coords: Array, translation: Array) -&gt; Array:\n    \"\"\"\n    Translates the coordinates by to a new centre. Translation must have shape (2,).\n\n    Parameters\n    ----------\n    coords : Array\n        The input coordinates to translate.\n    translation : Array\n        The translation to apply to the coordinates.\n\n    Returns\n    -------\n    coords : Array\n        The translated coordinates.\n    \"\"\"\n    return coords - translation[:, None, None]\n</code></pre> compress_coords <p>Compresses the coordinates by a given factor. Compress must have shape (2,).</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The input coordinates to compress.</p> required <code>compress</code> <code>Array</code> <p>The compression to apply to the coordinates.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The compressed coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def compress_coords(coords: Array, compress: Array) -&gt; Array:\n    \"\"\"\n    Compresses the coordinates by a given factor. Compress must have shape (2,).\n\n    Parameters\n    ----------\n    coords : Array\n        The input coordinates to compress.\n    compress : Array\n        The compression to apply to the coordinates.\n\n    Returns\n    -------\n    coords : Array\n        The compressed coordinates.\n    \"\"\"\n    return coords * compress[:, None, None]\n</code></pre> shear_coords <p>Shears the coordinates by a given factor. Shear must have shape (2,).</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The input coordinates to shear.</p> required <code>shear</code> <code>Array</code> <p>The shear to apply to the coordinates.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The sheared coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def shear_coords(coords: Array, shear: Array) -&gt; Array:\n    \"\"\"\n    Shears the coordinates by a given factor. Shear must have shape (2,).\n\n    Parameters\n    ----------\n    coords : Array\n        The input coordinates to shear.\n    shear : Array\n        The shear to apply to the coordinates.\n\n    Returns\n    -------\n    coords : Array\n        The sheared coordinates.\n    \"\"\"\n    trans_coords = np.transpose(coords, (0, 2, 1))\n    return coords + trans_coords * shear[:, None, None]\n</code></pre> rotate_coords <p>Rotates the coordinates by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The input coordinates to rotate.</p> required <code>rotation</code> <code>(float, radians)</code> <p>The rotation to apply to the coordinates.</p> required <p>Returns:</p> Name Type Description <code>coords</code> <code>Array</code> <p>The rotated coordinates.</p> Source code in <code>src/dLux/utils/coordinates.py</code> <pre><code>def rotate_coords(coords: Array, rotation: float) -&gt; Array:\n    \"\"\"\n    Rotates the coordinates by a given angle.\n\n    Parameters\n    ----------\n    coords : Array\n        The input coordinates to rotate.\n    rotation : float, radians\n        The rotation to apply to the coordinates.\n\n    Returns\n    -------\n    coords : Array\n        The rotated coordinates.\n    \"\"\"\n\n    x, y = coords\n    new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n    new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n    return np.array([new_x, new_y])\n</code></pre>"},{"location":"API/utils/coordinates/#dLux.utils.coordinates.pixel_coords","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.nd_coords","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.cart2polar","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.polar2cart","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.translate_coords","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.compress_coords","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.shear_coords","title":"Coordinates","text":""},{"location":"API/utils/coordinates/#dLux.utils.coordinates.rotate_coords","title":"Coordinates","text":""},{"location":"API/utils/geometry/","title":"Geometry","text":"<p>This module is used as for calculating geometric shapes on coordinate arrays, used to generate apertures. Each shape has two functions. One that generates a hard-edged oversampled one for more accurate aperture shapes, but is not differentiable/jittable. These are the <code>circle</code>, <code>square</code>, etc functions. The other type are differentiable and jittable in order to gain dynamic aperture that can be fit to data. These instead calculate the distance of each pixel from an edge and 'clip' the values between 0-1 for distances above a specified threshold. These functions are denoted with a <code>soft_</code> prefix, ie <code>soft_circle</code>, <code>soft_square</code>, etc.</p> <p>There are also some other helper functions for scaling and downsampling.</p> <p>TODO: Little tutorial on generating apertures.</p> circle <p>Calculates a soft-edged circle via downsampling. This function is not differentiable.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the circle on.</p> required <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>invert</code> <code>bool = False</code> <p>Whether to invert the circle.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>circle</code> <code>Array</code> <p>The circle.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def circle(coords: Array, radius: float, invert: bool = False) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged circle via downsampling. This function is not\n    differentiable.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the circle on.\n    radius : float\n        The radius of the circle.\n    invert : bool = False\n        Whether to invert the circle.\n\n    Returns\n    -------\n    circle : Array\n        The circle.\n    \"\"\"\n    if invert:\n        return (circ_distance(coords, radius) &gt; 0).astype(float)\n    return (circ_distance(coords, radius) &lt; 0).astype(float)\n</code></pre> square <p>Calculates a soft-edged square via downsampling. This function is not differentiable.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the square on.</p> required <code>width</code> <code>float</code> <p>The width of the square.</p> required <code>invert</code> <code>bool = False</code> <p>Whether to invert the square.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>square</code> <code>Array</code> <p>The square.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def square(coords: Array, width: float, invert: bool = False) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged square via downsampling. This function is not\n    differentiable.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the square on.\n    width : float\n        The width of the square.\n    invert : bool = False\n        Whether to invert the square.\n\n    Returns\n    -------\n    square : Array\n        The square.\n    \"\"\"\n    if invert:\n        return (square_distance(coords, width) &gt; 0).astype(float)\n    return (square_distance(coords, width) &lt; 0).astype(float)\n</code></pre> rectangle <p>Calculates a soft-edged rectangle via downsampling. This function is not differentiable.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the rectangle on.</p> required <code>width</code> <code>float</code> <p>The width of the rectangle.</p> required <code>height</code> <code>float</code> <p>The height of the rectangle.</p> required <p>Returns:</p> Name Type Description <code>rectangle</code> <code>Array</code> <p>The rectangle.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def rectangle(\n    coords: Array, width: float, height: float, invert: bool = False\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged rectangle via downsampling. This function is not\n    differentiable.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the rectangle on.\n    width : float\n        The width of the rectangle.\n    height : float\n        The height of the rectangle.\n\n    Returns\n    -------\n    rectangle : Array\n        The rectangle.\n    \"\"\"\n    if invert:\n        return (rectangle_distance(coords, width, height) &gt; 0).astype(float)\n    return (rectangle_distance(coords, width, height) &lt; 0).astype(float)\n</code></pre> reg_polygon <p>Calculates a soft-edged regular polygon via downsampling. This function is not differentiable.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the polygon on.</p> required <code>rmax</code> <code>float</code> <p>The radius of the polygon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the polygon.</p> required <code>invert</code> <code>bool = False</code> <p>Whether to invert the polygon.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>polygon</code> <code>Array</code> <p>The polygon.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def reg_polygon(\n    coords: Array, rmax: float, nsides: int, invert: bool = False\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged regular polygon via downsampling. This function is not\n    differentiable.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the polygon on.\n    rmax : float\n        The radius of the polygon.\n    nsides : int\n        The number of sides of the polygon.\n    invert : bool = False\n        Whether to invert the polygon.\n\n    Returns\n    -------\n    polygon : Array\n        The polygon.\n    \"\"\"\n    if invert:\n        return (reg_polygon_distance(coords, nsides, rmax) &gt; 0).astype(float)\n    return (reg_polygon_distance(coords, nsides, rmax) &lt; 0).astype(float)\n</code></pre> spider <p>Calculates a soft-edged spider via downsampling. This function is not differentiable.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the spider on.</p> required <code>width</code> <code>float</code> <p>The width of the spider.</p> required <code>angles</code> <code>Array</code> <p>The angles of the spider.</p> required <p>Returns:</p> Name Type Description <code>spider</code> <code>Array</code> <p>The spider.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def spider(coords: Array, width: float, angles: Array) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged spider via downsampling. This function is not\n    differentiable.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the spider on.\n    width : float\n        The width of the spider.\n    angles : Array\n        The angles of the spider.\n\n    Returns\n    -------\n    spider : Array\n        The spider.\n    \"\"\"\n    angles = np.array(angles) if not isinstance(angles, np.ndarray) else angles\n    calc_fn = vmap(lambda angle: spider_distance(coords, width, angle) &lt; 0)\n    return (\n        ~lax.reduce(calc_fn(angles), np.array(False), lax.bitwise_or, (0,))\n    ).astype(float)\n</code></pre> combine <p>Combines multiple arrays by multiplying them together, and downsampling the output.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Array</code> <p>The arrays to be combined. Should have shape (n_arrays, npix, npix).</p> required <code>oversample</code> <code>int = 1</code> <p>The amount to downsample the output by.</p> <code>1</code> <code>sum</code> <code>bool = False</code> <p>Whether to sum the arrays instead of multiplying them.</p> <code>False</code> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def combine(arrays: Array, oversample: int = 1, sum: bool = False) -&gt; Array:\n    \"\"\"\n    Combines multiple arrays by multiplying them together, and downsampling the output.\n\n    Parameters\n    ----------\n    arrays : Array\n        The arrays to be combined. Should have shape (n_arrays, npix, npix).\n    oversample : int = 1\n        The amount to downsample the output by.\n    sum : bool = False\n        Whether to sum the arrays instead of multiplying them.\n    \"\"\"\n    method = np.sum if sum else np.prod\n    array = np.array(arrays)\n    if oversample == 1:\n        return method(array, 0)\n    return dlu.downsample(method(array, 0), oversample)\n</code></pre> soft_circle <p>Calculates a soft-edged circle differentiably. The 'clip_dist' parameter defines the distance from the edge to 'soften' up to. A large clip_dist will result in a circle with a very soft edge, while a small clip_dist will result in a circle with a very hard edge.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the circle on.</p> required <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>clip_dist</code> <code>float = 0.1</code> <p>The distance from the edge to 'soften' up to. circle.</p> <code>0.1</code> <code>invert</code> <code>bool = False</code> <p>Whether to invert the circle.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>circle</code> <code>Array</code> <p>The softened circle.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def soft_circle(\n    coords: Array, radius: float, clip_dist: float = 0.1, invert: bool = False\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged circle differentiably. The 'clip_dist' parameter defines\n    the distance from the edge to 'soften' up to. A large clip_dist will result in a\n    circle with a very soft edge, while a small clip_dist will result in a circle with\n    a very hard edge.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the circle on.\n    radius : float\n        The radius of the circle.\n    clip_dist : float = 0.1\n        The distance from the edge to 'soften' up to.\n        circle.\n    invert : bool = False\n        Whether to invert the circle.\n\n    Returns\n    -------\n    circle : Array\n        The softened circle.\n    \"\"\"\n    distances = -circ_distance(coords, radius)\n    return soften(distances, clip_dist, invert)\n</code></pre> soft_square <p>Calculates a soft-edged square differentiably. The 'clip_dist' parameter defines the distance from the edge to 'soften' up to. A large clip_dist will result in a square with a very soft edge, while a small clip_dist will result in a square with a very hard edge.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the square on.</p> required <code>width</code> <code>float</code> <p>The width of the square.</p> required <code>clip_dist</code> <code>float = 0.1</code> <p>The distance from the edge to 'soften' up to. square.</p> <code>0.1</code> <code>invert</code> <code>bool = False</code> <p>Whether to invert the square.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>square</code> <code>Array</code> <p>The softened square.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def soft_square(\n    coords: Array, width: float, clip_dist: float = 0.1, invert: bool = False\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged square differentiably. The 'clip_dist' parameter defines\n    the distance from the edge to 'soften' up to. A large clip_dist will result in a\n    square with a very soft edge, while a small clip_dist will result in a square with\n    a very hard edge.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the square on.\n    width : float\n        The width of the square.\n    clip_dist : float = 0.1\n        The distance from the edge to 'soften' up to.\n        square.\n    invert : bool = False\n        Whether to invert the square.\n\n    Returns\n    -------\n    square : Array\n        The softened square.\n    \"\"\"\n    distances = -square_distance(coords, width)\n    return soften(distances, clip_dist, invert)\n</code></pre> soft_rectangle <p>Calculates a soft-edged rectangle differentiably. The 'clip_dist' parameter defines the distance from the edge to 'soften' up to. A large clip_dist will result in a rectangle with a very soft edge, while a small clip_dist will result in a rectangle with a very hard edge.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the rectangle on.</p> required <code>width</code> <code>float</code> <p>The width of the rectangle.</p> required <code>height</code> <code>float</code> <p>The height of the rectangle.</p> required <code>clip_dist</code> <code>float = 0.1</code> <p>The distance from the edge to 'soften' up to.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>rectangle</code> <code>Array</code> <p>The softened rectangle.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def soft_rectangle(\n    coords: Array,\n    width: float,\n    height: float,\n    clip_dist: float = 0.1,\n    invert: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged rectangle differentiably. The 'clip_dist' parameter defines\n    the distance from the edge to 'soften' up to. A large clip_dist will result in a\n    rectangle with a very soft edge, while a small clip_dist will result in a rectangle\n    with a very hard edge.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the rectangle on.\n    width : float\n        The width of the rectangle.\n    height : float\n        The height of the rectangle.\n    clip_dist : float = 0.1\n        The distance from the edge to 'soften' up to.\n\n    Returns\n    -------\n    rectangle : Array\n        The softened rectangle.\n    \"\"\"\n    distances = -rectangle_distance(coords, width, height)\n    return soften(distances, clip_dist, invert)\n</code></pre> soft_reg_polygon <p>Calculates a soft-edged regular polygon differentiably. The 'clip_dist' parameter defines the distance from the edge to 'soften' up to. A large clip_dist will result in a polygon with a very soft edge, while a small clip_dist will result in a polygon with a very hard edge.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the polygon on.</p> required <code>radius</code> <code>float</code> <p>The radius of the polygon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the polygon.</p> required <code>clip_dist</code> <code>float = 0.1</code> <p>The distance from the edge to 'soften' up to.</p> <code>0.1</code> <code>invert</code> <code>bool = False</code> <p>Whether to invert the polygon.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>polygon</code> <code>Array</code> <p>The softened polygon.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def soft_reg_polygon(\n    coords: Array,\n    radius: float,\n    nsides: int,\n    clip_dist: float = 0.1,\n    invert: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged regular polygon differentiably. The 'clip_dist' parameter\n    defines the distance from the edge to 'soften' up to. A large clip_dist will result\n    in a polygon with a very soft edge, while a small clip_dist will result in a polygon\n    with a very hard edge.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the polygon on.\n    radius : float\n        The radius of the polygon.\n    nsides : int\n        The number of sides of the polygon.\n    clip_dist : float = 0.1\n        The distance from the edge to 'soften' up to.\n    invert : bool = False\n        Whether to invert the polygon.\n\n    Returns\n    -------\n    polygon : Array\n        The softened polygon.\n    \"\"\"\n    distances = -reg_polygon_distance(coords, nsides, radius)\n    return soften(distances, clip_dist, invert)\n</code></pre> soft_spider <p>Calculates a soft-edged spider differentiably. The 'clip_dist' parameter defines the distance from the edge to 'soften' up to. A large clip_dist will result in a spider with a very soft edge, while a small clip_dist will result in a spider with a very hard edge.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Array</code> <p>The coordinates to calculate the spider on.</p> required <code>width</code> <code>float</code> <p>The width of the spider.</p> required <code>angles</code> <code>Array</code> <p>The angles of the spider.</p> required <code>clip_dist</code> <code>float = 0.1</code> <p>The distance from the edge to 'soften' up to.</p> <code>0.1</code> <code>invert</code> <code>bool = False</code> <p>Whether to invert the spider.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>spider</code> <code>Array</code> <p>The softened spider.</p> Source code in <code>src/dLux/utils/geometry.py</code> <pre><code>def soft_spider(\n    coords: Array,\n    width: float,\n    angles: Array,\n    clip_dist: float = 0.1,\n    invert: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Calculates a soft-edged spider differentiably. The 'clip_dist' parameter defines\n    the distance from the edge to 'soften' up to. A large clip_dist will result in a\n    spider with a very soft edge, while a small clip_dist will result in a spider with\n    a very hard edge.\n\n    Parameters\n    ----------\n    coords : Array\n        The coordinates to calculate the spider on.\n    width : float\n        The width of the spider.\n    angles : Array\n        The angles of the spider.\n    clip_dist : float = 0.1\n        The distance from the edge to 'soften' up to.\n    invert : bool = False\n        Whether to invert the spider.\n\n    Returns\n    -------\n    spider : Array\n        The softened spider.\n    \"\"\"\n    angles = np.array(angles) if not isinstance(angles, np.ndarray) else angles\n    spider_fn = vmap(lambda angle: spider_distance(coords, width, angle))\n    spiders = -spider_fn(angles).min(axis=0)\n    return soften(spiders, clip_dist, invert)\n</code></pre>"},{"location":"API/utils/geometry/#dLux.utils.geometry.circle","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.square","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.rectangle","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.reg_polygon","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.spider","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.combine","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.soft_circle","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.soft_square","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.soft_rectangle","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.soft_reg_polygon","title":"Geometry","text":""},{"location":"API/utils/geometry/#dLux.utils.geometry.soft_spider","title":"Geometry","text":""},{"location":"API/utils/helpers/","title":"Helpers","text":"<p>This module contains the leftover functions that don't fit anywhere else in the <code>utils</code> module!</p> list2dictionary <p>Converts some input list to a dictionary. The input list entries can either be objects, in which case the keys are taken as the class name, else a (key, object) tuple can be used to specify a key.</p> <p>If any duplicate keys are found, the key is appended with an index value. ie if two of the list entries have the same key 'layer', they will be assigned 'layer_0' and layer_1' respectively, depending on their input order in the list.</p> <p>Parameters:</p> Name Type Description Default <code>list_in</code> <code>list</code> <p>The list of objects to be converted into a dictionary.</p> required <code>ordered</code> <code>bool</code> <p>Whether to return an ordered or regular dictionary.</p> required <code>allowed_types</code> <code>tuple</code> <p>The allowed types of layers to be included in the dictionary.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>dictionary</code> <code>dict</code> <p>The equivalent dictionary or ordered dictionary.</p> Source code in <code>src/dLux/utils/helpers.py</code> <pre><code>def list2dictionary(\n    list_in: list, ordered: bool, allowed_types: tuple = ()\n) -&gt; dict:\n    \"\"\"\n    Converts some input list to a dictionary. The input list entries can either be\n    objects, in which case the keys are taken as the class name, else a (key, object)\n    tuple can be used to specify a key.\n\n    If any duplicate keys are found, the key is appended with an index value. ie if two\n    of the list entries have the same key 'layer', they will be assigned 'layer_0' and\n    layer_1' respectively, depending on their input order in the list.\n\n    Parameters\n    ----------\n    list_in : list\n        The list of objects to be converted into a dictionary.\n    ordered : bool\n        Whether to return an ordered or regular dictionary.\n    allowed_types : tuple\n        The allowed types of layers to be included in the dictionary.\n\n    Returns\n    -------\n    dictionary : dict\n        The equivalent dictionary or ordered dictionary.\n    \"\"\"\n    # Construct names list and identify repeats\n    names, repeats = [], []\n    for item in list_in:\n        # Check for specified names\n        if isinstance(item, tuple):\n            # item, name = item\n            name, item = item\n        else:\n            name = item.__class__.__name__\n\n        # Check input types\n        if allowed_types != () and not isinstance(item, allowed_types):\n            raise TypeError(\n                f\"Item {name} is not an allowed type, got \" f\"{type(item)}\"\n            )\n\n        # Check for Repeats\n        if name in names:\n            repeats.append(name)\n        names.append(name)\n\n    # Get list of unique repeats\n    repeats = list(set(repeats))\n\n    # Iterate over repeat names\n    for i in range(len(repeats)):\n        # Iterate over names list and append index value to name\n        idx = 0\n        for j in range(len(names)):\n            if repeats[i] == names[j]:\n                names[j] = names[j] + \"_{}\".format(idx)\n                idx += 1\n\n    # Turn list into Dictionary\n    dict_out = OrderedDict() if ordered else {}\n    for i in range(len(names)):\n        # Check for spaces in names\n        if \" \" in names[i]:\n            raise ValueError(f\"Names can not contain spaces, got {names[i]}\")\n\n        # Add to dict\n        if isinstance(list_in[i], tuple):\n            # item = list_in[i][0]\n            item = list_in[i][1]\n        else:\n            item = list_in[i]\n        dict_out[names[i]] = item\n    return dict_out\n</code></pre> map2array <p>Maps a function across a pytree, flattening it and turning it into an array.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>The function to be mapped across the pytree.</p> required <code>tree</code> <code>Any</code> <p>The pytree to be mapped across.</p> required <code>leaf_fn</code> <code>Callable = None</code> <p>The function to be used to determine whether a leaf is reached.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The flattened array of the pytree.</p> Source code in <code>src/dLux/utils/helpers.py</code> <pre><code>def map2array(fn: Callable, tree: Any, leaf_fn: Callable = None) -&gt; Array:\n    \"\"\"\n    Maps a function across a pytree, flattening it and turning it into an\n    array.\n\n    Parameters\n    ----------\n    fn : Callable\n        The function to be mapped across the pytree.\n    tree : Any\n        The pytree to be mapped across.\n    leaf_fn : Callable = None\n        The function to be used to determine whether a leaf is reached.\n\n    Returns\n    -------\n    array : Array\n        The flattened array of the pytree.\n    \"\"\"\n    if leaf_fn is not None:\n        return np.array(tree_flatten(tree_map(fn, tree, is_leaf=leaf_fn))[0])\n    else:\n        return np.array(tree_flatten(tree_map(fn, tree))[0])\n</code></pre> insert_layer <p>Inserts a layer into a dictionary of layers at a specified index. This function calls the list2dictionary function to ensure all keys remain unique. Note that this can result in some keys being modified if they are duplicates. The input 'layer' can be a tuple of (key, layer) to specify a key, else the key is taken as the class name of the layer.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary of layers to insert the layer into.</p> required <code>layer</code> <code>Any</code> <p>The layer to be inserted.</p> required <code>index</code> <code>int</code> <p>The index at which to insert the layer.</p> required <code>type</code> <code>Any</code> <p>The type of layer to be inserted. Used for type-checking.</p> required <p>Returns:</p> Name Type Description <code>layers</code> <code>dict</code> <p>The updated dictionary of layers.</p> Source code in <code>src/dLux/utils/helpers.py</code> <pre><code>def insert_layer(layers: dict, layer: Any, index: int, type: Any) -&gt; dict:\n    \"\"\"\n    Inserts a layer into a dictionary of layers at a specified index. This function\n    calls the list2dictionary function to ensure all keys remain unique. Note that this\n    can result in some keys being modified if they are duplicates. The input 'layer'\n    can be a tuple of (key, layer) to specify a key, else the key is taken as the\n    class name of the layer.\n\n    Parameters\n    ----------\n    layers : dict\n        The dictionary of layers to insert the layer into.\n    layer : Any\n        The layer to be inserted.\n    index : int\n        The index at which to insert the layer.\n    type : Any\n        The type of layer to be inserted. Used for type-checking.\n\n    Returns\n    -------\n    layers : dict\n        The updated dictionary of layers.\n    \"\"\"\n    layers_list = list(zip(layers.keys(), layers.values()))\n    layers_list.insert(index, layer)\n    return list2dictionary(layers_list, True, type)\n</code></pre> remove_layer <p>Removes a layer from a dictionary of layers, specified by its key.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>dict</code> <p>The dictionary of layers to remove the layer from.</p> required <code>key</code> <code>str</code> <p>The key of the layer to be removed.</p> required <p>Returns:</p> Name Type Description <code>layers</code> <code>dict</code> <p>The updated dictionary of layers.</p> Source code in <code>src/dLux/utils/helpers.py</code> <pre><code>def remove_layer(layers: dict, key: str) -&gt; dict:\n    \"\"\"\n    Removes a layer from a dictionary of layers, specified by its key.\n\n    Parameters\n    ----------\n    layers : dict\n        The dictionary of layers to remove the layer from.\n    key : str\n        The key of the layer to be removed.\n\n    Returns\n    -------\n    layers : dict\n        The updated dictionary of layers.\n    \"\"\"\n    layers.pop(key)\n    return layers\n</code></pre>"},{"location":"API/utils/helpers/#dLux.utils.helpers.list2dictionary","title":"Helpers","text":""},{"location":"API/utils/helpers/#dLux.utils.helpers.map2array","title":"Helpers","text":""},{"location":"API/utils/helpers/#dLux.utils.helpers.insert_layer","title":"Helpers","text":""},{"location":"API/utils/helpers/#dLux.utils.helpers.remove_layer","title":"Helpers","text":""},{"location":"API/utils/interpolation/","title":"Interpolation Utility Functions","text":"<p>This module contains basic paraxial interpolation functions.</p> scale <p>Paraxially interpolates an array based on the sampling ratio, and npixels_out.</p> rotate <p>Rotates an array by the angle, using interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>(Array, radians)</code> <p>The angle to rotate the array by.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use. Can be 0 or 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p> Source code in <code>src/dLux/utils/interpolation.py</code> <pre><code>def rotate(array: Array, angle: Array, order: int = 1) -&gt; Array:\n    \"\"\"\n    Rotates an array by the angle, using interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    order : int = 1\n        The interpolation order to use. Can be 0 or 1.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n\n    # TODO: Use rotate_coords\n    def _rotate(coordinates: Array, rotation: Array) -&gt; Array:\n        x, y = coordinates[0], coordinates[1]\n        new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n        new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n        return np.array([new_x, new_y])\n\n    # Get coordinates\n    npixels = array.shape[0]\n    centre = (npixels - 1) / 2\n    coordinates = dlu.nd_coords((npixels, npixels), indexing=\"ij\")\n    coordinates_rotated = _rotate(coordinates, angle) + centre\n\n    # Interpolate\n    return map_coordinates(array, coordinates_rotated, order=order)\n</code></pre>"},{"location":"API/utils/interpolation/#dLux.utils.interpolation.scale--todo-check-if-a-half-pixel-offset-is-produced","title":"TODO: Check if a half-pixel offset is produced","text":"<p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input field to interpolate, either in amplitude and phase, or real and imaginary.</p> required <code>npixels</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>ratio</code> <code>float</code> <p>The relative input to output scales, TODO: does 2 make it bigger or smaller? i.e. input scale/output scale. &lt;- get this right.</p> required <code>order</code> <code>int = 1</code> <p>The interpolation order to use. Can be 0 or 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The interpolated array.</p> Source code in <code>src/dLux/utils/interpolation.py</code> <pre><code>def scale(array: Array, npixels: int, ratio: float, order: int = 1) -&gt; Array:\n    \"\"\"\n    Paraxially interpolates an array based on the sampling ratio, and npixels_out.\n\n    # TODO: Check if a half-pixel offset is produced\n\n    Parameters\n    ----------\n    array : Array\n        The input field to interpolate, either in amplitude and phase, or real\n        and imaginary.\n    npixels : int\n        The number of pixel in the output array.\n    ratio : float\n        The relative input to output scales, TODO: does 2 make it bigger or\n        smaller? i.e. input scale/output scale. &lt;- get this right.\n    order : int = 1\n        The interpolation order to use. Can be 0 or 1.\n\n    Returns\n    -------\n    array : Array\n        The interpolated array.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = array.shape[-1]\n    # TODO: Update with array_coordinates\n    coordinates = generate_coordinates(npixels_in, npixels, ratio)\n    return map_coordinates(array, coordinates, order=order)\n</code></pre>"},{"location":"API/utils/interpolation/#dLux.utils.interpolation.scale","title":"Interpolation","text":""},{"location":"API/utils/interpolation/#dLux.utils.interpolation.scale--todo-check-if-a-half-pixel-offset-is-produced","title":"TODO: Check if a half-pixel offset is produced","text":""},{"location":"API/utils/interpolation/#dLux.utils.interpolation.rotate","title":"Interpolation","text":""},{"location":"API/utils/math/","title":"Math Utility Functions","text":"<p>This module contains some basic maths functions used under the hood.</p> factorial <p>Calculate n! in a jax friendly way. Note that n == 0 is not a safe case.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The value to calculate the factorial of.</p> required <p>Returns:</p> Type Description <code>n! : float</code> <p>The factorial of the value.</p> Source code in <code>src/dLux/utils/math.py</code> <pre><code>def factorial(n: float) -&gt; float:\n    \"\"\"\n    Calculate n! in a jax friendly way. Note that n == 0 is not a\n    safe case.\n\n    Parameters\n    ----------\n    n : float\n        The value to calculate the factorial of.\n\n    Returns\n    -------\n    n! : float\n        The factorial of the value.\n    \"\"\"\n    return lax.exp(lax.lgamma(n + 1.0))\n</code></pre> triangular_number <p>Calculate the nth triangular number.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The nth triangular number to calculate.</p> required <p>Returns:</p> Name Type Description <code>n</code> <code>int</code> <p>The nth triangular number.</p> Source code in <code>src/dLux/utils/math.py</code> <pre><code>def triangular_number(n: int) -&gt; int:\n    \"\"\"\n    Calculate the nth triangular number.\n\n    Parameters\n    ----------\n    n : int\n        The nth triangular number to calculate.\n\n    Returns\n    -------\n    n : int\n        The nth triangular number.\n    \"\"\"\n    return n * (n + 1) / 2\n</code></pre> eval_basis <p>Performs an n-dimensional dot-product between the basis and coefficients arrays.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array</code> <p>The basis to use.</p> required <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> required Source code in <code>src/dLux/utils/math.py</code> <pre><code>def eval_basis(basis: Array, coefficients: Array) -&gt; Array:\n    \"\"\"\n    Performs an n-dimensional dot-product between the basis and coefficients arrays.\n\n    Parameters\n    ----------\n    basis: Array\n        The basis to use.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    \"\"\"\n    ndim = coefficients.ndim\n    return np.tensordot(basis, coefficients, axes=2 * (tuple(range(ndim)),))\n</code></pre> nandiv <p>Divides two arrays, replacing any NaNs with a fill value.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Array</code> <p>The numerator.</p> required <code>b</code> <code>Array</code> <p>The denominator.</p> required <code>fill</code> <code>Any = np.inf</code> <p>The value to replace NaNs with.</p> <code>inf</code> <p>Returns:</p> Type Description <code>a / b : Array</code> <p>The result of the division.</p> Source code in <code>src/dLux/utils/math.py</code> <pre><code>def nandiv(a: Array, b: Array, fill: Any = np.inf) -&gt; Array:\n    \"\"\"\n    Divides two arrays, replacing any NaNs with a fill value.\n\n    Parameters\n    ----------\n    a : Array\n        The numerator.\n    b : Array\n        The denominator.\n    fill : Any = np.inf\n        The value to replace NaNs with.\n\n    Returns\n    -------\n    a / b : Array\n        The result of the division.\n    \"\"\"\n    return np.where(b == 0, fill, a / b)\n</code></pre>"},{"location":"API/utils/math/#dLux.utils.math.factorial","title":"Math","text":""},{"location":"API/utils/math/#dLux.utils.math.triangular_number","title":"Math","text":""},{"location":"API/utils/math/#dLux.utils.math.eval_basis","title":"Math","text":""},{"location":"API/utils/math/#dLux.utils.math.nandiv","title":"Math","text":""},{"location":"API/utils/optics/","title":"Optics Utility Functions","text":"<p>This module contains a number of common equations used in optics, such as converting between Optical Path Difference (OPD) and phase, and a few functions used to calculate sampling rates in focal planes.</p> wavenumber <p>Calculates the wavenumber of a given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>(Array, metres)</code> <p>The wavelength to calculate the wavenumber for.</p> required <p>Returns:</p> Name Type Description <code>wavenumber</code> <code>(Array, radians / meter)</code> <p>The wavenumber of the input wavelength.</p> Source code in <code>src/dLux/utils/optics.py</code> <pre><code>def wavenumber(wavelength: float) -&gt; float:\n    \"\"\"\n    Calculates the wavenumber of a given wavelength.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength to calculate the wavenumber for.\n\n    Returns\n    -------\n    wavenumber : Array, radians/meter\n        The wavenumber of the input wavelength.\n    \"\"\"\n    return 2 * np.pi / wavelength\n</code></pre> opd2phase <p>Converts the input Optical Path Difference (opd) in units of meters to phases in units of radians for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>(Array, metres)</code> <p>The Optical Path Difference (opd) to be converted into phase.</p> required <code>wavelength</code> <code>(Array, metres)</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>phase</code> <code>(Array, radians)</code> <p>The equivalent phase value for the given opd and wavelength.</p> Source code in <code>src/dLux/utils/optics.py</code> <pre><code>def opd2phase(opd: Array, wavelength: float) -&gt; Array:\n    \"\"\"\n    Converts the input Optical Path Difference (opd) in units of meters to phases in\n    units of radians for the given wavelength.\n\n    Parameters\n    ----------\n    opd : Array, metres\n        The Optical Path Difference (opd) to be converted into phase.\n    wavelength : Array, metres\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    phase : Array, radians\n        The equivalent phase value for the given opd and wavelength.\n    \"\"\"\n    return wavenumber(wavelength) * opd\n</code></pre> phase2opd <p>Converts the input phase in units of radians to the equivalent Optical Path Difference (OPD) in metres for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>(Array, radians)</code> <p>The phase to be converted into OPD</p> required <code>wavelength</code> <code>(Array, metres)</code> <p>The wavelength at which to calculate the OPD for.</p> required <p>Returns:</p> Name Type Description <code>opd</code> <code>(Array, metres)</code> <p>The equivalent opd value for the given phase and wavelength.</p> Source code in <code>src/dLux/utils/optics.py</code> <pre><code>def phase2opd(phase: Array, wavelength: float) -&gt; Array:\n    \"\"\"\n    Converts the input phase in units of radians to the equivalent Optical Path\n    Difference (OPD) in metres for the given wavelength.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be converted into OPD\n    wavelength : Array, metres\n        The wavelength at which to calculate the OPD for.\n\n    Returns\n    -------\n    opd : Array, metres\n        The equivalent opd value for the given phase and wavelength.\n    \"\"\"\n    return phase / wavenumber(wavelength)\n</code></pre> fringe_size <p>Calculates the linear size of the diffraction fringes.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>(Array, metres)</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>diameter</code> <code>(Array, metres)</code> <p>The diameter of the aperture.</p> required <code>focal_length</code> <code>Array, float = None</code> <p>The focal length of the optical system. If none is provided, the fringe size is given in units of radians, else it is given in units of metres.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>fringe_size</code> <code>(Array, radians, meters)</code> <p>The fringe size. Has units of radians of focal length is None, else meters.</p> Source code in <code>src/dLux/utils/optics.py</code> <pre><code>def fringe_size(\n    wavelength: float, diameter: float, focal_length: float = None\n) -&gt; Array:\n    \"\"\"\n    Calculates the linear size of the diffraction fringes.\n\n    Parameters\n    ----------\n    wavelength : Array, metres\n        The wavelength at which to calculate the diffraction fringe for.\n    diameter : Array, metres\n        The diameter of the aperture.\n    focal_length : Array, float = None\n        The focal length of the optical system. If none is provided, the fringe\n        size is given in units of radians, else it is given in units of metres.\n\n    Returns\n    -------\n    fringe_size : Array, radians, meters\n        The fringe size. Has units of radians of focal length is None, else meters.\n    \"\"\"\n    if focal_length is None:\n        return wavelength / diameter\n    else:\n        return wavelength * focal_length / diameter\n</code></pre>"},{"location":"API/utils/optics/#dLux.utils.optics.wavenumber","title":"Optics","text":""},{"location":"API/utils/optics/#dLux.utils.optics.opd2phase","title":"Optics","text":""},{"location":"API/utils/optics/#dLux.utils.optics.phase2opd","title":"Optics","text":""},{"location":"API/utils/optics/#dLux.utils.optics.fringe_size","title":"Optics","text":""},{"location":"API/utils/propagation/","title":"Propagation","text":"<p>This module contains the core diffraction engine of dLux, with the core code to propagate phasors is various different ways.</p> FFT <p>Calculates the Fast Fourier Transform (FFT) of the input phasor.</p> <p>Parameters:</p> Name Type Description Default <code>phasor</code> <code>Array[complex]</code> <p>The input phasor.</p> required <code>wavelength</code> <code>(float, meters)</code> <p>The wavelength of the input phasor.</p> required <code>pixel_scale</code> <code>(float, meters / pixel)</code> <p>The pixel scale of the input phasor.</p> required <code>focal_length</code> <code>float = None</code> <p>The focal length of the propagation. If None, the output pixel scale has units of radians, else meters.</p> <code>None</code> <code>pad</code> <code>int = 2</code> <p>The amount to pad the input array by before propagation. Note this function does not automatically crop the output.</p> <code>2</code> <code>inverse</code> <code>bool = False</code> <p>Is this a forward or inverse FFT.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>phasor</code> <code>Array[complex]</code> <p>The propagated phasor.</p> Source code in <code>src/dLux/utils/propagation.py</code> <pre><code>def FFT(\n    phasor: Array,\n    wavelength: float,\n    pixel_scale: float,\n    focal_length: float = None,\n    pad: int = 2,\n    inverse: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Calculates the Fast Fourier Transform (FFT) of the input phasor.\n\n    Parameters\n    ----------\n    phasor : Array[complex]\n        The input phasor.\n    wavelength : float, meters\n        The wavelength of the input phasor.\n    pixel_scale : float, meters/pixel\n        The pixel scale of the input phasor.\n    focal_length : float = None\n        The focal length of the propagation. If None, the output pixel scale has units\n        of radians, else meters.\n    pad : int = 2\n        The amount to pad the input array by before propagation. Note this function\n        does not automatically crop the output.\n    inverse : bool = False\n        Is this a forward or inverse FFT.\n\n    Returns\n    -------\n    phasor : Array[complex]\n        The propagated phasor.\n    \"\"\"\n    npixels = phasor.shape[-1]\n\n    # Calculate the output pixel scale\n    fringe_size = wavelength / (pixel_scale * npixels)\n    new_pixel_scale = fringe_size / pad\n    if focal_length is not None:\n        new_pixel_scale *= focal_length\n\n    # Pad the input array\n    npixels = (npixels * (pad - 1)) // 2\n    phasor = np.pad(phasor, npixels)\n\n    # Perform the FFT\n    if inverse:\n        phasor = np.fft.fft2(np.fft.ifftshift(phasor)) / phasor.shape[-1]\n    else:\n        phasor = np.fft.fftshift(np.fft.ifft2(phasor)) * phasor.shape[-1]\n\n    return phasor, new_pixel_scale\n</code></pre> MFT <p>Propagates a phasor using a Matrix Fourier Transform (MFT), allowing for output pixel scale and a shift to be specified.</p> <p>TODO: Add link to Soumer et al. 2007(?), which describes the MFT.</p> <p>Parameters:</p> Name Type Description Default <code>phasor</code> <code>Array</code> <p>The input phasor.</p> required <code>wavelength</code> <code>(float, meters)</code> <p>The wavelength of the input phasor.</p> required <code>pixel_scale_in</code> <code>(float, meters / pixel, radians / pixel)</code> <p>The pixel scale of the input plane.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale of the output plane.</p> required <code>focal_length</code> <code>float = None</code> <p>The focal length of the propagation. If None, the propagation is angular and pixel_scale_out is taken in as radians/pixel, else meters/pixel.</p> <code>None</code> <code>shift</code> <code>Array = np.zeros(2)</code> <p>The shift in the center of the output plane.</p> <code>zeros(2)</code> <code>pixel</code> <code>bool = True</code> <p>Should the shift be taken in units of pixels, or pixel scale.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>phasor</code> <code>Array</code> <p>The propagated phasor.</p> Source code in <code>src/dLux/utils/propagation.py</code> <pre><code>def MFT(\n    phasor: Array,\n    wavelength: float,\n    pixel_scale_in: float,\n    npixels_out: int,\n    pixel_scale_out: float,\n    focal_length: float = None,\n    shift: Array = np.zeros(2),\n    pixel: bool = True,\n    inverse: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates a phasor using a Matrix Fourier Transform (MFT), allowing for output\n    pixel scale and a shift to be specified.\n\n    TODO: Add link to Soumer et al. 2007(?), which describes the MFT.\n\n    Parameters\n    ----------\n    phasor : Array\n        The input phasor.\n    wavelength : float, meters\n        The wavelength of the input phasor.\n    pixel_scale_in : float, meters/pixel, radians/pixel\n        The pixel scale of the input plane.\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : float, meters/pixel or radians/pixel\n        The pixel scale of the output plane.\n    focal_length : float = None\n        The focal length of the propagation. If None, the propagation is angular and\n        pixel_scale_out is taken in as radians/pixel, else meters/pixel.\n    shift : Array = np.zeros(2)\n        The shift in the center of the output plane.\n    pixel : bool = True\n        Should the shift be taken in units of pixels, or pixel scale.\n\n\n    Returns\n    -------\n    phasor : Array\n        The propagated phasor.\n    \"\"\"\n    # Get parameters\n    npixels_in = phasor.shape[-1]\n    if not pixel:\n        shift /= pixel_scale_out\n\n    # Alias the transfer matrix function\n    get_tf_mat = lambda s: transfer_matrix(\n        wavelength,\n        npixels_in,\n        pixel_scale_in,\n        npixels_out,\n        pixel_scale_out,\n        s,\n        focal_length,\n        0.0,\n        inverse,\n    )\n\n    # Get transfer matrices and propagate\n    x_mat, y_mat = vmap(get_tf_mat)(shift)\n    phasor = (y_mat.T @ phasor) @ x_mat\n\n    # Normalise\n    nfringes = calc_nfringes(\n        wavelength,\n        npixels_in,\n        pixel_scale_in,\n        npixels_out,\n        pixel_scale_out,\n        focal_length,\n    )\n    phasor *= np.exp(\n        np.log(nfringes) - (np.log(npixels_in) + np.log(npixels_out))\n    )\n\n    return phasor\n</code></pre> fresnel_MFT <p>Propagates the phasor using a Far-Field Fresnel propagation. This allows for psfs to be better modelled a few wavelengths from the focal plane.</p> <p>NOTE: This does have an 'inverse' parameter, however behaviour is not guaranteed to be correct when <code>inverse=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>phasor</code> <code>Array[complex]</code> <p>The input phasor.</p> required <code>wavelength</code> <code>(float, meters)</code> <p>The wavelength of the input phasor.</p> required <code>pixel_scale_in</code> <code>(float, meters / pixel, radians / pixel)</code> <p>The pixel scale of the input plane.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>(float, meters / pixel or radians / pixel)</code> <p>The pixel scale of the output plane.</p> required <code>focal_length</code> <code>float</code> <p>The focal length of the propagation.</p> required <code>focal_shift</code> <code>float</code> <p>The shift from focus to propagate to.</p> required <code>shift</code> <code>Array = np.zeros(2)</code> <p>The shift in the center of the output plane.</p> <code>zeros(2)</code> <code>pixel</code> <code>bool = True</code> <p>Should the shift be taken in units of pixels, or pixel scale.</p> <code>True</code> <code>inverse</code> <code>bool</code> <p>Is this a forward or inverse propagation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>phasor</code> <code>Array[complex]</code> <p>The propagated phasor.</p> Source code in <code>src/dLux/utils/propagation.py</code> <pre><code>def fresnel_MFT(\n    phasor: Array,\n    wavelength: float,\n    pixel_scale_in: float,\n    npixels_out: int,\n    pixel_scale_out: float,\n    focal_length: float,\n    focal_shift: float,\n    shift: Array = np.zeros(2),\n    pixel: bool = True,\n    inverse: bool = False,\n) -&gt; Array:\n    \"\"\"\n    Propagates the phasor using a Far-Field Fresnel propagation. This allows for psfs\n    to be better modelled a few wavelengths from the focal plane.\n\n    NOTE: This does have an 'inverse' parameter, however behaviour is not\n    guaranteed to be correct when `inverse=True`.\n\n    Parameters\n    ----------\n    phasor : Array[complex]\n        The input phasor.\n    wavelength : float, meters\n        The wavelength of the input phasor.\n    pixel_scale_in : float, meters/pixel, radians/pixel\n        The pixel scale of the input plane.\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : float, meters/pixel or radians/pixel\n        The pixel scale of the output plane.\n    focal_length : float\n        The focal length of the propagation.\n    focal_shift: float, meters\n        The shift from focus to propagate to.\n    shift : Array = np.zeros(2)\n        The shift in the center of the output plane.\n    pixel : bool = True\n        Should the shift be taken in units of pixels, or pixel scale.\n    inverse: bool = False\n        Is this a forward or inverse propagation.\n\n    Returns\n    -------\n    phasor : Array[complex]\n        The propagated phasor.\n    \"\"\"\n    # Calculate phase factors\n    first_factor, second_factor = fresnel_phase_factors(\n        wavelength,\n        phasor.shape[-1],\n        pixel_scale_in,\n        npixels_out,\n        pixel_scale_out,\n        focal_length,\n        focal_shift,\n    )\n\n    # Propagate\n    phasor *= first_factor\n    phasor = MFT(\n        phasor,\n        wavelength,\n        pixel_scale_in,\n        npixels_out,\n        pixel_scale_out,\n        focal_length,\n        shift,\n        pixel,\n        inverse,\n    )\n\n    phasor *= second_factor\n    return phasor\n</code></pre>"},{"location":"API/utils/propagation/#dLux.utils.propagation.FFT","title":"Propagation","text":""},{"location":"API/utils/propagation/#dLux.utils.propagation.MFT","title":"Propagation","text":""},{"location":"API/utils/propagation/#dLux.utils.propagation.fresnel_MFT","title":"Propagation","text":""},{"location":"API/utils/source/","title":"Source Parametrisations","text":"<p>This is a small module for converting from parametric source values (separation, position angle, mean flux, contrast, etc) to individual source properties (position, flux, etc).</p> fluxes_from_contrast <p>Computes the fluxes of a binary object given the mean flux and contrast.</p> <p>Parameters:</p> Name Type Description Default <code>mean_flux</code> <code>float</code> <p>The mean flux of the binary object.</p> required <code>contrast</code> <code>float</code> <p>The contrast of the binary object.</p> required <p>Returns:</p> Name Type Description <code>fluxes</code> <code>Array</code> <p>The flux (flux1, flux2) of the binary object.</p> Source code in <code>src/dLux/utils/source.py</code> <pre><code>def fluxes_from_contrast(mean_flux: float, contrast: float) -&gt; Array:\n    \"\"\"\n    Computes the fluxes of a binary object given the mean flux and contrast.\n\n    Parameters\n    ----------\n    mean_flux : float\n        The mean flux of the binary object.\n    contrast : float\n        The contrast of the binary object.\n\n    Returns\n    -------\n    fluxes : Array\n        The flux (flux1, flux2) of the binary object.\n    \"\"\"\n    return 2 * np.array([contrast * mean_flux, mean_flux]) / (1 + contrast)\n</code></pre> positions_from_sep <p>Computes the on-sky positions of a binary object given the separation and position angle.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>(Array, radians)</code> <p>The on-sky position of the primary object.</p> required <code>separation</code> <code>(float, radians)</code> <p>The separation of the binary object.</p> required <code>position_angle</code> <code>(float, radians)</code> <p>The position angle of the binary object.</p> required <p>Returns:</p> Name Type Description <code>position</code> <code>(Array, radians)</code> <p>The ((x, y), (x, y)) on-sky position of this object.</p> Source code in <code>src/dLux/utils/source.py</code> <pre><code>def positions_from_sep(\n    position: Array, separation: float, position_angle: float\n) -&gt; Array:\n    \"\"\"\n    Computes the on-sky positions of a binary object given the separation and\n    position angle.\n\n    Parameters\n    ----------\n    position : Array, radians\n        The on-sky position of the primary object.\n    separation : float, radians\n        The separation of the binary object.\n    position_angle : float, radians\n        The position angle of the binary object.\n\n    Returns\n    -------\n    position : Array, radians\n        The ((x, y), (x, y)) on-sky position of this object.\n    \"\"\"\n    r, phi = separation / 2, position_angle\n    sep_vec = np.array([r * np.sin(phi), r * np.cos(phi)])\n    return np.array([position + sep_vec, position - sep_vec])\n</code></pre>"},{"location":"API/utils/source/#dLux.utils.source.fluxes_from_contrast","title":"Source","text":""},{"location":"API/utils/source/#dLux.utils.source.positions_from_sep","title":"Source","text":""},{"location":"API/utils/units/","title":"Units","text":"<p>This module contains functions for converting between different units.</p> rad2arcsec <p>Converts the inputs values from radians to arcseconds.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, radians)</code> <p>The input values in units of radians to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcseconds)</code> <p>The input values converted into arcseconds.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def rad2arcsec(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from radians to arcseconds.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600 * 180 / np.pi\n</code></pre> rad2deg <p>Converts the inputs values from radians to degrees.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, radians)</code> <p>The input values in units of radians to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, degrees)</code> <p>The input values converted into degrees.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def rad2deg(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from radians to degrees.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values * 180 / np.pi\n</code></pre> rad2arcmin <p>Converts the inputs values from radians to arcminutes.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, radians)</code> <p>The input values in units of radians to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcminutes)</code> <p>The input values converted into arcminutes.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def rad2arcmin(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from radians to arcminutes.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60 * 180 / np.pi\n</code></pre> deg2rad <p>Converts the inputs values from degrees to radians.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, degrees)</code> <p>The input values in units of degrees to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, radians)</code> <p>The input values converted into radians.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def deg2rad(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from degrees to radians.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / 180\n</code></pre> deg2arcmin <p>Converts the inputs values from degrees to arcminutes.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, degrees)</code> <p>The input values in units of degrees to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcminutes)</code> <p>The input values converted into arcminutes.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def deg2arcmin(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from degrees to arcminutes.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60\n</code></pre> deg2arcsec <p>Converts the inputs values from degrees to arcseconds.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, degrees)</code> <p>The input values in units of degrees to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcseconds)</code> <p>The input values converted into arcseconds.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def deg2arcsec(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from degrees to arcseconds.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600\n</code></pre> arcmin2rad <p>Converts the inputs values from arcminutes to radians.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcminutes)</code> <p>The input values in units of arcminutes to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, radians)</code> <p>The input values converted into radians.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcmin2rad(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcminutes to radians.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (60 * 180)\n</code></pre> arcmin2deg <p>Converts the inputs values from arcminutes to degrees.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcminutes)</code> <p>The input values in units of arcminutes to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, degrees)</code> <p>The input values converted into degrees.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcmin2deg(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcminutes to degrees.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 60\n</code></pre> arcmin2arcsec <p>Converts the inputs values from arcminutes to arcseconds.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcminutes)</code> <p>The input values in units of arcminutes to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcseconds)</code> <p>The input values converted into arcseconds.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcmin2arcsec(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcminutes to arcseconds.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into\n        arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 60\n</code></pre> arcsec2rad <p>Converts the inputs values from arcseconds to radians.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcseconds)</code> <p>The input values in units of arcseconds to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, radians)</code> <p>The input values converted into radians.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcsec2rad(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcseconds to radians.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (3600 * 180)\n</code></pre> arcsec2deg <p>Converts the inputs values from arcseconds to degrees.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcseconds)</code> <p>The input values in units of arcseconds to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, degrees)</code> <p>The input values converted into degrees.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcsec2deg(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcseconds to degrees.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 3600\n</code></pre> arcsec2arcmin <p>Converts the inputs values from arcseconds to arcminutes.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>(Array, arcseconds)</code> <p>The input values in units of arcseconds to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>(Array, arcminutes)</code> <p>The input values converted into arcminutes.</p> Source code in <code>src/dLux/utils/units.py</code> <pre><code>def arcsec2arcmin(values: Array) -&gt; Array:\n    \"\"\"\n    Converts the inputs values from arcseconds to arcminutes.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into\n        arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values / 60\n</code></pre>"},{"location":"API/utils/units/#dLux.utils.units.rad2arcsec","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.rad2deg","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.rad2arcmin","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.deg2rad","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.deg2arcmin","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.deg2arcsec","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcmin2rad","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcmin2deg","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcmin2arcsec","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcsec2rad","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcsec2deg","title":"Units","text":""},{"location":"API/utils/units/#dLux.utils.units.arcsec2arcmin","title":"Units","text":""},{"location":"API/utils/zernikes/","title":"Zernike Polynomials","text":"<p>This module contains the code required to generate Zernike polynomials.</p> zernike_name <p>Gets the name of the jth Zernike polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required <p>Returns:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the Zernike polynomial.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def zernike_name(j: int) -&gt; str:\n    \"\"\"\n    Gets the name of the jth Zernike polynomial.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n\n    Returns\n    -------\n    name : str\n        The name of the Zernike polynomial.\n    \"\"\"\n    return zernike_names[int(j)] if j &gt;= 1 and j &lt;= 36 else f\"Zernike {int(j)}\"\n</code></pre> noll_indices <p>Calculate the radial and azimuthal orders of the Zernike polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required <p>Returns:</p> Type Description <code>n, m : tuple[int]</code> <p>The radial and azimuthal orders of the Zernike polynomial.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def noll_indices(j: int) -&gt; tuple[int]:\n    \"\"\"\n    Calculate the radial and azimuthal orders of the Zernike polynomial.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n\n    Returns\n    -------\n    n, m : tuple[int]\n        The radial and azimuthal orders of the Zernike polynomial.\n    \"\"\"\n    n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)\n    smallest_j_in_row = n * (n + 1) / 2 + 1\n    number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2\n    sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2\n    base_case = n &amp; 1\n    m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)\n    return int(n), int(m)\n</code></pre> zernike_factors <p>Calculates the normalisation coefficients and powers of the Zernike polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required <p>Returns:</p> Type Description <code>c, k : tuple[Array]</code> <p>The normalisation coefficients and powers of the Zernike polynomial.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def zernike_factors(j: int) -&gt; tuple[Array]:\n    \"\"\"\n    Calculates the normalisation coefficients and powers of the Zernike polynomial.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n\n    Returns\n    -------\n    c, k : tuple[Array]\n        The normalisation coefficients and powers of the Zernike polynomial.\n    \"\"\"\n    if j &lt; 1:\n        raise ValueError(\"The Zernike index must be greater than 0.\")\n    n, m = noll_indices(j)\n\n    # Calculate k\n    k = np.arange(((n - m) // 2) + 1, dtype=float)\n\n    # Calculate c\n    sign = lax.pow(-1.0, k)\n    _fact_1 = dlu.factorial(np.abs(n - k))\n    _fact_2 = dlu.factorial(k)\n    _fact_3 = dlu.factorial(((n + m) // 2) - k)\n    _fact_4 = dlu.factorial(((n - m) // 2) - k)\n    c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4\n    return c, k\n</code></pre> zernike <p>Calculates the Zernike polynomial. Note that this function is not-jittable as is has dynamic array shapes. To use this function in a jittable way, use the zernike_fast function, with the pre-calculated c and k parameters.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>diameter</code> <code>float = 2</code> <p>The diameter of the aperture to calculate the Zernike polynomial upon.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def zernike(j: int, coordinates: Array, diameter: float = 2) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial. Note that this function is not-jittable as is\n    has dynamic array shapes. To use this function in a jittable way, use the\n    zernike_fast function, with the pre-calculated c and k parameters.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    diameter : float = 2\n        The diameter of the aperture to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    coordinates = scale_coords(coordinates, diameter / 2)\n    polar_coordinates = dlu.cart2polar(coordinates)\n    rho = polar_coordinates[0]\n    theta = polar_coordinates[1]\n    aperture = rho &lt;= 1.0\n    n, m = noll_indices(j)\n    c, k = zernike_factors(j)\n    return aperture * eval_radial(rho, n, c, k) * eval_azimuthal(theta, n, m)\n</code></pre> zernike_fast <p>Calculates the Zernike polynomial using the pre-calculated c and k parameters, such that this function is jittable.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> required <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> required <code>c</code> <code>Array</code> <p>The normalisation coefficients of the Zernike polynomial.</p> required <code>k</code> <code>Array</code> <p>The powers of the Zernike polynomial.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def zernike_fast(\n    n: int, m: int, c: Array, k: Array, coordinates: Array\n) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial using the pre-calculated c and k parameters, such\n    that this function is jittable.\n\n    Parameters\n    ----------\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    c : Array\n        The normalisation coefficients of the Zernike polynomial.\n    k : Array\n        The powers of the Zernike polynomial.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    polar_coordinates = dlu.cart2polar(coordinates)\n    rho = polar_coordinates[0]\n    theta = polar_coordinates[1]\n    aperture = rho &lt;= 1.0\n    return aperture * eval_radial(rho, n, c, k) * eval_azimuthal(theta, n, m)\n</code></pre> zernike_basis <p>Calculates the Zernike polynomial basis. Note that this function is not-jittable.</p> <p>Parameters:</p> Name Type Description Default <code>js</code> <code>list[int]</code> <p>The Zernike (noll) indices.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>diameter</code> <code>float = 2</code> <p>The diameter of the aperture to calculate the Zernike polynomial upon.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>zernike_basis</code> <code>Array</code> <p>The Zernike polynomial basis.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def zernike_basis(\n    js: list[int], coordinates: Array, diameter: float = 2\n) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial basis. Note that this function is not-jittable.\n\n    Parameters\n    ----------\n    js : list[int]\n        The Zernike (noll) indices.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    diameter : float = 2\n        The diameter of the aperture to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    zernike_basis : Array\n        The Zernike polynomial basis.\n    \"\"\"\n    return np.array([zernike(j, coordinates, diameter) for j in js])\n</code></pre> polike <p>Calculates the Zernike polynomial on an n-sided aperture. Note that this function is not-jittable as is has dynamic array shapes. To use this function in a jittable way, use the polike_fast function, with the pre-calculated c and k parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>diameter</code> <code>float = 2</code> <p>The diameter of the aperture to calculate the Zernike polynomial upon.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>polike</code> <code>Array</code> <p>The Zernike polynomial on an n-sided aperture.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def polike(\n    nsides: int, j: int, coordinates: Array, diameter: float = 2\n) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial on an n-sided aperture. Note that this function\n    is not-jittable as is has dynamic array shapes. To use this function in a jittable\n    way, use the polike_fast function, with the pre-calculated c and k parameters.\n\n    Parameters\n    ----------\n    nsides : int\n        The number of sides of the aperture.\n    j : int\n        The Zernike (noll) index.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    diameter : float = 2\n        The diameter of the aperture to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    polike : Array\n        The Zernike polynomial on an n-sided aperture.\n    \"\"\"\n    if nsides &lt; 3:\n        raise ValueError(f\"nsides must be &gt;= 3, not {nsides}.\")\n    coordinates = scale_coords(coordinates, diameter / 2)\n    theta = dlu.cart2polar(coordinates)[1]\n    alpha = np.pi / nsides\n    phi = theta + alpha\n    wedge = np.floor((phi + alpha) / (2.0 * alpha))\n    u_alpha = phi - wedge * (2 * alpha)\n    r_alpha = np.cos(alpha) / np.cos(u_alpha)\n    return 1 / r_alpha * zernike(j, coordinates / r_alpha)\n</code></pre> polike_fast <p>Calculates the Zernike polynomial on an n-sided aperture using the pre-calculated c and k parameters, such that this function is jittable.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> required <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> required <code>c</code> <code>Array</code> <p>The normalisation coefficients of the Zernike polynomial.</p> required <code>k</code> <code>Array</code> <p>The powers of the Zernike polynomial.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <p>Returns:</p> Name Type Description <code>polike</code> <code>Array</code> <p>The Zernike polynomial on an n-sided aperture.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def polike_fast(\n    nsides: int, n: int, m: int, c: Array, k: Array, coordinates: Array\n) -&gt; Array:\n    \"\"\"\n    Calculates the Zernike polynomial on an n-sided aperture using the pre-calculated\n    c and k parameters, such that this function is jittable.\n\n    Parameters\n    ----------\n    nsides : int\n        The number of sides of the aperture.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    c : Array\n        The normalisation coefficients of the Zernike polynomial.\n    k : Array\n        The powers of the Zernike polynomial.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    polike : Array\n        The Zernike polynomial on an n-sided aperture.\n    \"\"\"\n    if nsides &lt; 3:\n        raise ValueError(f\"nsides must be &gt;= 3, not {nsides}.\")\n    alpha = np.pi / nsides\n    phi = dlu.cart2polar(coordinates)[1] + alpha\n    wedge = np.floor((phi + alpha) / (2.0 * alpha))\n    u_alpha = phi - wedge * (2 * alpha)\n    r_alpha = np.cos(alpha) / np.cos(u_alpha)\n    return 1 / r_alpha * zernike_fast(n, m, c, k, coordinates / r_alpha)\n</code></pre> polike_basis <p>Calculates the Zernike polynomial basis on an n-sided aperture. Note that this function is not-jittable.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>js</code> <code>list[int]</code> <p>The Zernike (noll) indices.</p> required <code>coordinates</code> <code>Array</code> <p>The Cartesian coordinates to calculate the Zernike polynomial upon.</p> required <code>diameter</code> <code>float = 2</code> <p>The diameter of the aperture to calculate the Zernike polynomial upon.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>polike_basis</code> <code>Array</code> <p>The Zernike polynomial basis on an n-sided aperture.</p> Source code in <code>src/dLux/utils/zernikes.py</code> <pre><code>def polike_basis(\n    nsides: int, js: list[int], coordinates: Array, diameter: float = 2\n):\n    \"\"\"\n    Calculates the Zernike polynomial basis on an n-sided aperture. Note that this\n    function is not-jittable.\n\n    Parameters\n    ----------\n    nsides : int\n        The number of sides of the aperture.\n    js : list[int]\n        The Zernike (noll) indices.\n    coordinates : Array\n        The Cartesian coordinates to calculate the Zernike polynomial upon.\n    diameter : float = 2\n        The diameter of the aperture to calculate the Zernike polynomial upon.\n\n    Returns\n    -------\n    polike_basis : Array\n        The Zernike polynomial basis on an n-sided aperture.\n    \"\"\"\n    return np.array([polike(nsides, j, coordinates, diameter) for j in js])\n</code></pre>"},{"location":"API/utils/zernikes/#dLux.utils.zernikes.zernike_name","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.noll_indices","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.zernike_factors","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.zernike","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.zernike_fast","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.zernike_basis","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.polike","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.polike_fast","title":"Zernikes","text":""},{"location":"API/utils/zernikes/#dLux.utils.zernikes.polike_basis","title":"Zernikes","text":""},{"location":"tutorials/examples/HMC/","title":"NumPyro and Hamiltonian Monte Carlo","text":"<p>In this tutorial we will see how we to integrate our \u2202Lux optical models with the Probabilistic Programming Language (PPL) NumPyro. This allows us to run a subset of MCMC algorithms known as Hamiltonian Monte Carlo (HMC), which take advantage of autodiff to infer the relationship between a large number of parameters.</p> <p>In this example we will simulate a binary star through a simple optical system, and simultaneously infer the stellar and optical parameters.</p> <pre><code># Set CPU count for numpyro multi-chain multi-thread\nimport os\nos.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'\n\nimport jax.random as jr\nimport jax.numpy as np\nimport dLux as dl\nimport dLux.utils as dlu\nimport matplotlib.pyplot as plt\n\n# Set global plotting parameters\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = 'serif'\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>Let's construct the source and optics. In this case, we will use the <code>AlphaCen</code> source from the <code>dLuxToliman</code> package as it gives separation in arcseconds and flux in log units. This will make our NumPyro sampling functions simpler.</p> <pre><code>from dLuxToliman import AlphaCen\n\n# Use the AlphaCen object for separation in units of arcseconds, and flux in log\nsource = AlphaCen()\nsource = source.set(['log_flux', 'separation'], [3.5, 0.1])\n\n# Aperture properties\nwf_npix = 128\ndiameter = 1\n\n# Construct an aperture with a single spider as the asymmetry\ncoords = dlu.pixel_coords(5*wf_npix, diameter)\ncircle = dlu.circle(coords, diameter/2)\ntransmission = dlu.combine([circle], 5)\n\n# Zernike aberrations\nzernike_indexes = np.arange(4, 11)\ntrue_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), zernike_indexes.shape)\ncoords = dlu.pixel_coords(wf_npix, diameter)\nbasis = np.array([dlu.zernike(i, coords, diameter) for i in zernike_indexes])\n\nlayers = [('aperture', dl.layers.BasisOptic(basis, transmission, true_coeffs, normalise=True))]\n\n# Psf properties\npsf_npixels = 16\npsf_pixel_scale = 0.03\n\n# Construct\noptics = dl.AngularOpticalSystem(wf_npix, diameter, layers, psf_npixels, psf_pixel_scale)\n\n# Construct Telescope\ntelescope = dl.Telescope(optics, ('source', source))\n</code></pre> <p>Now, let's create simulated data and examine them.</p> <pre><code>## Generate psf\npsf = telescope.model()\npsf_photon = jr.poisson(jr.PRNGKey(0), psf)\nbg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape)\ndata = psf_photon + bg_noise\n\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 2)\nplt.title(\"PSF with photon noise\")\nplt.imshow(psf_photon)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/examples/HMC/#inference-with-numpyro","title":"Inference with NumPyro","text":"<p>Awesome, now we are going to try and infer these parameters using HMC. There are quite a few different parameters we want to infer:</p>"},{"location":"tutorials/examples/HMC/#source-parameters","title":"Source Parameters","text":"<ul> <li>The $(x,y)$ mean position (2 parameters)</li> <li>The separation (1 parameter)</li> <li>The position angle (1 parameter)</li> <li>The mean flux (1 parameter)</li> <li>The contrast ratio (1 parameter)</li> </ul>"},{"location":"tutorials/examples/HMC/#optical-parameters","title":"Optical Parameters","text":"<ul> <li>The Zernike aberration coefficients (7 parameters)</li> </ul> <p>This gives us a total of 13 parameters, which is quite high dimensional for regular MCMC algorithms.</p> <p>Next, we construct our NumPyro sampling function. In this function we need to define prior distribution variables for our parameters, along with the corresponding parameter path. This allows for NumPyro to simultaneously sample the posterior of all parameters by taking advantage of the differentiable nature of these models.</p> <p>With these parameters, we create a <code>plate</code> which defines our data. We use a Poisson likelihood since photon noise is our dominant noise source.</p> <pre><code># PPL\nimport numpyro as npy\nimport numpyro.distributions as dist\n\nparameters = ['x_position', 'y_position', 'separation', 'position_angle', \n    'log_flux', 'contrast']\n\ndef psf_model(data, model):\n    \"\"\"\n    Define the numpyro function\n    \"\"\"\n    values = [\n        npy.sample(\"x\",        dist.Uniform(-0.1, 0.1)),\n        npy.sample(\"y\",        dist.Uniform(-0.1, 0.1)),\n        npy.sample(\"r\",        dist.Uniform(0.01, 0.5)),\n        npy.sample(\"theta\",    dist.Uniform(80, 100)),\n        npy.sample(\"log_flux\", dist.Uniform(3, 4)),\n        npy.sample(\"contrast\", dist.Uniform(1, 5)),\n    ]\n\n    with npy.plate(\"data\", len(data.flatten())):\n        poisson_model = dist.Poisson(\n            model.set(parameters, values).model().flatten())\n        return npy.sample(\"psf\", poisson_model, obs=data.flatten())\n</code></pre> <p>Using the model above, we can now sample from the posterior distribution using the No U-Turn Sampler (NUTS).</p> <pre><code>from jax import device_count\nsampler = npy.infer.MCMC(\n    npy.infer.NUTS(psf_model),    \n    num_warmup=2000,\n    num_samples=2000,\n    num_chains=device_count(),\n    progress_bar=True,\n)\n%time sampler.run(jr.PRNGKey(0), data, telescope)\n</code></pre> <pre><code>  0%|          | 0/4000 [00:00&lt;?, ?it/s]\n\n\n\n  0%|          | 0/4000 [00:00&lt;?, ?it/s]\n\n\n\n  0%|          | 0/4000 [00:00&lt;?, ?it/s]\n\n\n\n  0%|          | 0/4000 [00:00&lt;?, ?it/s]\n\n\nCPU times: user 4min 23s, sys: 23.5 s, total: 4min 47s\nWall time: 53.5 s\n</code></pre> <p>Let's examine the summary. Note: here we want to make sure that all the <code>r_hat</code> values are $\\sim1$.</p> <pre><code>sampler.print_summary()\nvalues_out = sampler.get_samples()\n</code></pre> <pre><code>                mean       std    median      5.0%     95.0%     n_eff     r_hat\n  contrast      2.59      0.25      2.58      2.19      3.01   4132.96      1.00\n  log_flux      3.51      0.01      3.51      3.50      3.52   6821.95      1.00\n         r      0.10      0.00      0.10      0.09      0.10   4214.09      1.00\n     theta     88.70      1.60     88.71     86.09     91.31   4491.81      1.00\n         x      0.01      0.00      0.01      0.00      0.01   3672.32      1.00\n         y     -0.00      0.00     -0.00     -0.00      0.00   4784.68      1.00\n\nNumber of divergences: 0\n</code></pre> <pre><code>import chainconsumer as cc\n\nchain = cc.ChainConsumer()\nchain.add_chain(values_out)\nchain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\nfig = chain.plotter.plot()\nfig.set_size_inches((15,15));\n</code></pre> <p></p> <p>Excellent! All the parameters are well constrained.</p>"},{"location":"tutorials/examples/designing_a_mask/","title":"Phase Mask Design","text":"<p>In this notebook we will illustrate the inverse design of a phase mask, choosing the example from Wong et al., 2021: designing a diffractive pupil phase mask for the Toliman telescope.</p> <p>In order to get high precision centroids, we need to maximise the gradient energy of the pupil; in order to satisfy fabrication constraints, we need a binary mask with phases of only 0 or \u03c0.</p> <pre><code># Core jax\nimport jax.numpy as np\nimport jax.random as jr\nfrom jax import vmap\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.layers as dll\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>We will first generate an orthonormal basis for the pupil phases, then threshold this to {0, 1} while preserving soft-edges using the Continuous Latent-Image Mask Binarization (CLIMB) algorithm from the Wong et al. paper.</p> <p>Generate basis vectors however you like -- in this case we are using logarithmic radial harmonics and sines/cosines in $\\theta$ -- but you can do whatever you want here. This code is not important; just generate your favourite not-necessarily-orthonormal basis, and we will use Principal Component Analysis (PCA) to orthonormalise it later on.</p> <pre><code># Define arrays sizes, samplings, symmetries\nwf_npix = 256\noversample = 3\nnslice = 3\n\n# Define basis hyper parameters\na = 10\nb = 8\nith = 10\n\n# Define coordinate grids\nnpix = wf_npix * oversample\nc = (npix - 1) / 2.\nxs = (np.arange(npix) - c) / c\nXX, YY = np.meshgrid(xs, xs)\nRR = np.sqrt(XX ** 2 + YY ** 2)\nPHI = np.arctan2(YY, XX)\n\n# Generate basis vectors to map over\nAs = np.arange(-a, a+1)\nBs = nslice * np.arange(0, b+1)\nCs = np.array([-np.pi/2, np.pi/2])\nIs = np.arange(-ith, ith+1)\n\n# Define basis functions\nLRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C)\nsine_fn = lambda i, RR: np.sin(i * np.pi * RR)\ncose_fn = lambda i, RR: np.cos(i * np.pi * RR)\n\n# Map over basis functions\ngen_LRHF_basis = vmap(vmap(vmap( \\\n                            LRHF_fn, (None, 0, None, None, None)), \n                                     (0, None, None, None, None)), \n                                     (None, None, 0, None, None))\ngen_sine_basis = vmap(sine_fn, in_axes=(0, None))\ngen_cose_basis = vmap(cose_fn, in_axes=(0, None))\n\n# Generate basis\nLRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\\n            .reshape([len(As)*len(Bs)*len(Cs), npix, npix])\nsine_basis = gen_sine_basis(Is, RR)\ncose_basis = gen_cose_basis(Is, RR)\n\n# Format shapes and combine\nLRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix])\nsine_flat = sine_basis.reshape([len(sine_basis), npix*npix])\ncose_flat = cose_basis.reshape([len(cose_basis), npix*npix])\nfull_basis = np.concatenate([\n    LRHF_flat,\n    sine_flat,\n    cose_flat\n])\n</code></pre> <p>Orthonormalise with PCA -- you could also use Gram-Schmidt if you prefer.</p> <pre><code># Pre-load basis if it exists, else generate it\ntry:\n    basis = np.load('files/basis.npy')\nexcept FileNotFoundError:\n    from sklearn.decomposition import PCA\n    pca = PCA().fit(full_basis)\n\n    components = pca.components_.reshape([len(full_basis), npix, npix])\n    components = np.copy(components[:99,:,:])\n    basis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])\n\n    # save for use later\n    np.save('files/basis', basis)\n</code></pre> <p>Visualising the pretty basis vectors:</p> <pre><code>nfigs = 24\nncols = 8\nnrows = 1 + nfigs//ncols\n\nplt.figure(figsize=(4*ncols, 4*nrows))\nfor i in range(nfigs):\n    plt.subplot(nrows, ncols, i+1)\n    plt.imshow(basis[i], cmap='seismic')\n    plt.xticks([])\n    plt.yticks([])\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/examples/designing_a_mask/#optimising-the-pupil","title":"Optimising the Pupil","text":"<p>First we want to construct a \u2202Lux layer that we can use to design a binary mask; for this, we will use <code>ApplyBasisCLIMB</code> which soft-thresholds the edges (see Wong et al., 2021, sec. 3.2.2). In brief, this creates an optical path difference (OPD) map as a weighted sum of modes; we set it to \u03c0 phase where it is positive, we set it to zero phase where it is negative, and we soft-edge it on the edges to propagate gradients.</p> <p>These models reside in the external <code>dLuxToliman</code> package, which you can install with <code>pip install dLuxToliman</code>.</p> <pre><code>from dLuxToliman import TolimanOpticalSystem, ApplyBasisCLIMB\n\n# Define our mask layer, here we use ApplyBasisCLIMB\nwavels = 1e-9 * np.linspace(595, 695, 3)\ncoeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)])\nCLIMB = ApplyBasisCLIMB(basis, np.mean(wavels), coeffs)\noptics = TolimanOpticalSystem(psf_npixels=64, mask=CLIMB)\n</code></pre> <p>We also add a small amount of Gaussian jitter to assist in engineering the PSF shape, then define a simple point source. We then combine all of these together into an <code>Instrument</code> object.</p> <pre><code># Add some detector jitter\ndetector = dl.LayeredDetector([dll.ApplyJitter(1)])\n\n# Define a source\nsource = dl.PointSource(wavelengths=wavels)\n\n# Create our instrument\ntel = dl.Telescope(optics, source, detector)\n</code></pre> <p>We also define a maximum radius which we want light to be confined within. Now, let's examine all this together.</p> <pre><code>lamd = wavels.max() / optics.diameter\npixel_scale = dlu.arcsec2rad(optics.psf_pixel_scale / optics.oversample)\nsampling_rate = lamd / pixel_scale\nrmax = 8*sampling_rate # 8 lam/D\n</code></pre> <pre><code>aperture = tel.aperture.transmission\nmask = tel.pupil.get_binary_phase()\nouter = plt.Circle((64, 64), rmax, fill=False, color='w')\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture*mask, cmap='hot')\nplt.title('Input OPD')\n\nax = plt.subplot(1, 2, 2)\nax.imshow(tel.model())\nax.set_title('Input PSF')\nax.add_patch(outer)\nplt.show()\n</code></pre> <p></p> <p>Now, let's define our loss function. We can pass the string path to our mask coefficients to the <code>zdx.filter_value_and_grad</code> function in order to generate gradients for only those terms!</p> <pre><code>from dLuxToliman import get_radial_mask, get_GE, get_RGE, get_RWGE\nparam = 'pupil.coefficients'\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef loss_func(tel, rmax=150, power=0.5):\n    # Get PSF, Gradients and Mask\n    psf = tel.model()\n\n    Rmask = get_radial_mask(psf.shape[0], 0, rmax)\n\n    # Calculate loss\n    loss1 = - np.power(Rmask*get_GE(psf),  power).sum()\n    loss2 = - np.power(Rmask*get_RGE(psf), power).sum()\n    return loss1 + loss2\n</code></pre> <p>Evaluate once to <code>jit</code> compile:</p> <pre><code>%%time\nloss, grads = loss_func(tel, rmax=rmax) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</code></pre> <pre><code>Initial Loss: -35.9885139465332\nCPU times: user 3.7 s, sys: 104 ms, total: 3.81 s\nWall time: 2.84 s\n</code></pre> <p>Gradient descent time!</p> <pre><code>model = tel\noptim, opt_state = zdx.get_optimiser(model, param, optax.adam(8e1))\n\nlosses, models_out = [], []\nwith tqdm(range(100),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_func(model, rmax=rmax)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</code></pre> <pre><code>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]\n</code></pre> <p>Visualising the results:</p> <pre><code>coeffs_out = np.array([model.get(param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\naxes['C'].imshow(aperture*mask,cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = tel.set('detector.layers', {}).model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nfinal = models_out[-1]\naxes['E'].imshow(aperture*final.pupil.get_binary_phase(),cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = final.model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\nplt.show()\n</code></pre> <p></p> <pre><code># Visualise GE Metrics\noversample = 2\nfinal_optics = models_out[-1].optics\nparams = ['psf_pixel_scale', 'psf_npixels']\noversampled = final_optics.multiply(params, [1/oversample, oversample*npix])\noversampled_psf = final_optics.model(source)\n\n# Plot\nplt.figure(figsize=(20, 4))\nplt.subplot(1, 4, 1)\nplt.title(\"PSF\")\nplt.imshow(psf_out)\nplt.colorbar()\n\nplt.subplot(1, 4, 2)\nplt.title(\"Gradient Energy\")\nplt.imshow(get_GE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 3)\nplt.title(\"Radial GE\")\nplt.imshow(get_RGE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 4)\nplt.title(\"Radial Weighted GE\")\nplt.imshow(get_RWGE(psf_out))\nplt.colorbar()\nplt.show()\n</code></pre> <p></p> <pre><code># Save mask for use in flatfield_calibration notebook\nmask_out = models_out[-1].pupil.get_binary_phase()\nnp.save(\"files/test_mask\", mask_out)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/examples/fisher_information/","title":"Fisher Information","text":"<p>Autodiff doesn't just make it faster to solve optimisation and inference problems -- it also allows you to use powerful ideas in statistics requiring second derivatives that are intractable analytically or with finite differences.</p> <p>The Fisher Information Matrix, or the inverse of the Hessian of the likelihood, can be used for - the Laplace approximation to a posterior for variational inference, giving you the Gaussian covariance of the posterior near the maximum likelihood point; - Fisher forecasting, where you calculate this for an instrument or experiment at expected parameters to predict how well it will constrain them; and - optimal design, as the Cram\u00e9r-Rao lower bound on the precision of an experiment is the inverse of the Fisher information matrix - so you want to make this as tight as possible!</p> <p>Because <code>jax</code> lets us compute the Hessian of our loss function, we can use the Fisher matrix for variational inference without MCMC, and also more powerfully as an objective function to optimise a telescope design; why bother engineering a PSF for a particular goal, when you could model the system end to end and optimise the Fisher forecast precision of the parameter of interest? *</p> <p>* This is the topic of another Desdoigts et al. paper in prep.</p> <p>This notebook follows on from Phase Mask Design and will reuse some code without repeating explanations.</p> <pre><code># Core jax\nimport jax\nfrom jax.config import config\n\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>Using models from the <code>dLuxToliman</code> package, we need to construct the components of our model: - the optimisable mask - the source - the optics</p> <pre><code>from dLuxToliman import AlphaCen, TolimanOpticalSystem, ApplyBasisCLIMB\n\n# Construct source\nsource = AlphaCen()\n\n# Optimisable binary mask\nclimb_basis = np.load(\"files/basis.npy\")\ncoefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)])\nmean_wl = source.wavelengths.mean()\nmask_layer = ApplyBasisCLIMB(climb_basis, 1e-9*mean_wl, coefficients)\n\n# Construct instrument\noptics = TolimanOpticalSystem(psf_npixels=100, mask=mask_layer, radial_orders=[2, 3])\nmodel = dl.Telescope(optics, source)\n</code></pre> <p>Visualising the mask and PSF:</p> <pre><code>aperture = model.aperture.transmission\nmask = model.pupil.get_binary_phase()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture * mask, cmap='hot')\nplt.title('Input OPD')\n\nplt.subplot(1, 2, 2)\npsf = model.model()\nplt.imshow(psf)\nplt.colorbar()\nplt.title('Input PSF')\nplt.show()\n</code></pre> <p></p> <p>Next, we need to define our loss function. We want to maximize the Fisher information; conveniently, <code>zodiax</code> has a Bayesian module that can calculate the covariance matrix and its entropy. This means we only need to define the likelihood function, the parameters we want to marginalise over, and the parameters we wish to optimise.</p> <p>We will optimise the mask coefficients and marginalise over the binary source parameters and optical aberrations.</p> <p>Note we define the <code>shape_dict</code> here to cast the wavelength to a single value, resulting in a marginalisation over the mean wavelength.</p> <pre><code># Marginal params\nshape_dict = {'wavelengths': (1,)}\nmarginal_params = ['separation', 'contrast', 'position_angle', 'wavelengths', \n    'psf_pixel_scale', 'aperture.coefficients']\n\n# Loss function\nopt_param = 'pupil.coefficients'\n@zdx.filter_jit\n@zdx.filter_value_and_grad(opt_param)\ndef fim_loss_func(model, parameters):\n    cov = zdx.self_covariance_matrix(model, parameters, zdx.bayes.poiss_loglike, \n        shape_dict=shape_dict)\n    return zdx.covaraince_entropy(cov)\n</code></pre> <p>Call the loss function once to compile:</p> <pre><code>%%time\nloss, grads = fim_loss_func(model, marginal_params)\nprint(\"Initial Loss: {}\".format(loss))\n</code></pre> <pre><code>Initial Loss: -196.04754638671875\nCPU times: user 14.7 s, sys: 506 ms, total: 15.2 s\nWall time: 9.75 s\n</code></pre> <p>Now run gradient descent!</p> <pre><code>optim, opt_state = zdx.get_optimiser(model, opt_param, optax.adam(2e1))\n\nlosses, models_out = [], [model]\nwith tqdm(range(50),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = fim_loss_func(model, marginal_params)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</code></pre> <pre><code>Gradient Descent:   0%|          | 0/50 [00:00&lt;?, ?it/s]\n</code></pre> <pre><code>coeffs_out = np.array([model.get(opt_param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\nmask = models_out[0].pupil.get_binary_phase()\naxes['C'].imshow(aperture * mask, cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = models_out[0].model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nmask = models_out[-1].pupil.get_binary_phase()\naxes['E'].imshow(aperture * mask, cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = models_out[-1].model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n\nplt.show()\n</code></pre> <p></p> <p>Let's calculate the elements of the covariance matrix:</p> <pre><code>%%time\ncovs = [zdx.self_covariance_matrix(model, marginal_params, zdx.bayes.poiss_loglike, \n        shape_dict=shape_dict) for model in [models_out[0], models_out[-1]]]\n</code></pre> <pre><code>CPU times: user 11.1 s, sys: 716 ms, total: 11.8 s\nWall time: 6.03 s\n</code></pre> <p>And using ChainConsumer we can easily visualise this covariance:</p> <pre><code>from chainconsumer import ChainConsumer\n\nparam_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",\n               \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",\n               \"TfoilX\", \"TfoilY\"]\nX = np.zeros(len(param_names))\nc = ChainConsumer()\nc.add_covariance(X, covs[0], parameters=param_names, name='Initial')\nc.add_covariance(X, covs[1], parameters=param_names, name='Final')\nc.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\n# fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised\nfig = c.plotter.plot()\n</code></pre> <p></p> <p>It looks like the optimisation worked - marginal posterior bounds for all optical parameters are much tighter after the optimisation.</p> <p>We see that in this narrowband simulation, most parameters are not tightly correlated; but separation, plate scale and wavelength are almost indistinguishable. This makes sense, as they affect the PSF in the same way! Only independent constraints on wavelength can save us here. If you want to do precise astrometry, you have to nail down your plate scale and spectrum; we see that the marginal posterior for separation is unchanged, but dominated entirely by this degeneracy with plate scale and wavelength, which is much tighter for the optimised pupil.</p> <p>This is why we superimpose a grating over our pupil in the Toliman telescope design (design paper, Fig 6) -- we can measure a stellar spectrum and separate this from the astrometry.</p> <p>If we were doing this properly for a telescope design, we would want to take this into account -- our real goal is precisely measuring separation, and everything else is something we can marginalise over. If we incorporate our prior constraints on plate scale and wavelength, I am sure we will do even better.</p>"},{"location":"tutorials/examples/flatfield_calibration/","title":"Pixel Level Calibration","text":"<p>There are a lot of existing frameworks for phase retrieval, but it is not necessarily straightforward to simultaneously retrieve:</p> <ul> <li>aberrations (the optical distortions, maybe tens of parameters)</li> <li>astrometry (the positions of stars, tens of parameters)</li> <li>inter-pixel sensitivity (aka the 'flat field', on a large pixel grid!)</li> </ul> <p>The dimensionality of the pixel grid can be so high that it is hard to retrieve without automatic differentiation (autodiff). With \u2202Lux, it's easy*!</p> <p>* This is the topic of a Desdoigts et al. paper in prep. It was not easy to build, and we're pretty happy about it.</p> <pre><code># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.layers as dll\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>Now we need to construct our model. There are three components that we need:</p> <ol> <li> <p>Optics: Here we will use the pre-built Toliman optics model from the <code>dLuxToliman</code> package, ensuring we add some aberration to recover.</p> </li> <li> <p>Detector: Here we create a simple detector that applies a simple flat field.</p> </li> <li> <p>Sources: This will be a set of point sources with different positions and fluxes. </p> </li> </ol> <p>Let's put all this together and see how it looks.</p> <pre><code>from dLuxToliman import TolimanOpticalSystem\n\n# Construct optics\ncoeffs = 2e-8 * jr.normal(jr.PRNGKey(0), (7,))\noptics = TolimanOpticalSystem(radial_orders=[2, 3], coefficients=coeffs, psf_npixels=128)\n\n# Create Detector\ndet_npix = optics.psf_npixels * optics.oversample\npix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])\ndetector = dl.LayeredDetector([dll.ApplyPixelResponse(pix_response)])\n\n# Create Sources\nNstars = 15\ntrue_positions = dlu.arcsec2rad(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-20, maxval=20))\ntrue_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(1), (Nstars,))\nwavels = 1e-9 * np.linspace(545, 645, 3)\nsource = dl.PointSources(wavels, true_positions, true_fluxes)\n</code></pre> <p>Now we need to introduce the dithers. We can utilise the built-in <code>Dither</code> observation class:</p> <pre><code># Observation strategy, define dithers\ndet_pixsize = dlu.arcsec2rad(optics.psf_pixel_scale / optics.oversample)\ndithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]]) / 5\n\n# Combine into instrument and observe!\ntel = dl.Dither(dithers, optics, source, detector)\npsfs = tel.model()\n</code></pre> <pre><code># Apply some noise to the PSF Background noise\ndata = jr.poisson(jr.PRNGKey(0), psfs)\n\nplt.figure(figsize=(26, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.title(f\"Image: {i+1}\")\n    plt.imshow(data[i] * 1e-3)\n    plt.xlabel(\"x (arcsec)\")\n    plt.ylabel(\"y (arcsec)\")\n    plt.colorbar(label='Photons $x10^3$')\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>There are four sets of parameters we are going to learn:  - Positions  - Fluxes  - Zernike aberrations  - Pixel responses</p> <p>We start by defining the paths to those parameters; we will define them individually so that we can refer to them easily later.</p> <pre><code>positions = 'source.position'\nfluxes    = 'source.flux'\nzernikes  = 'aperture.coefficients'\nflatfield = 'ApplyPixelResponse.pixel_response'\n\nparameters = [positions, fluxes, zernikes, flatfield]\n</code></pre> <p>Each of these parameters needs a different initialisation:  - Positions need to be shifted by some random value  - Fluxes need to be multiplied by some random value  - Zernike coefficients need to be set to zero  - Pixel response values need to be set to one</p> <p>We perturb the values to initialise the model.</p> <pre><code># Add small random values to the positions\nmodel = tel.add(positions, 2.*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))\n\n# Multiply the fluxes by small random values\nmodel = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))\n\n# Set the zernike coefficients to zero\nmodel = model.set(zernikes, np.zeros(model.get(zernikes).shape))\n\n# Set the flat field to uniform\nmodel = model.set(flatfield, np.ones((det_npix, det_npix)))\n\n# Generate psfs\npsfs = model.model()\n</code></pre> <p>We can see the residuals are not optimal:</p> <pre><code>plt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.title(f\"Residual: {i+1}\")\n    plt.imshow((psfs[i] - data[i])*1e-3)\n    plt.xlabel(\"x (arcsec)\")\n    plt.ylabel(\"y (arcsec)\")\n    plt.colorbar(label='Photons $x10^3$')\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>Now we want to generate an <code>optax</code> optimiser object that we can use to train each parameter individually. Because of the various scales and effects on the loss function that each parameter has, we need to set individual learning rates and optimisation schedules for every parameter. Luckily, we have built some functions to help specifically with that!</p> <pre><code># So first we simply set the simple parameters to use an adam optimiser \n# algorithm, with individual learning rates\npos_optimiser   = optax.adam(1e-7)\nflux_optimiser  = optax.adam(1e6)\ncoeff_optimiser = optax.adam(2e-9)\n\n# Now the flat-field, because it is highly covariant with the mean flux level\n# we don't start learning its parameters until the 100th epoch.\nFF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8, \n                             boundaries_and_scales={100 : int(1e8)})\nFF_optimiser = optax.adam(FF_sched)\n\n# Combine the optimisers into a list\noptimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]\n\n# Generate out optax optimiser, and also get our args\noptim, opt_state = zdx.get_optimiser(model, parameters, optimisers)\n</code></pre> <p>Poisson log-likelihood:</p> <pre><code>@zdx.filter_jit\n@zdx.filter_value_and_grad(parameters)\ndef loss_fn(model, data):\n    out = model.model()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</code></pre> <p>Call once to jit compile:</p> <pre><code>%%time\nloss, grads = loss_fn(model, data) # Compile\nprint(\"Initial Loss: {}\".format(int(loss)))\n</code></pre> <pre><code>Initial Loss: 1296900864\nCPU times: user 3.69 s, sys: 125 ms, total: 3.81 s\nWall time: 867 ms\n</code></pre> <p>Run gradient descent:</p> <pre><code>losses, models_out = [], []\nwith tqdm(range(200),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_fn(model, data)    \n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        losses.append(loss)\n        models_out.append(model)\n        t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar\n</code></pre> <pre><code>Gradient Descent:   0%|          | 0/200 [00:00&lt;?, ?it/s]\n</code></pre> <p>Format the output into arrays:</p> <pre><code>nepochs = len(models_out)\npsfs_out = models_out[-1].model()\n\npositions_found  = np.array([model.get(positions) for model in models_out])\nfluxes_found     = np.array([model.get(fluxes)    for model in models_out])\nzernikes_found   = np.array([model.get(zernikes)  for model in models_out])\nflatfields_found = np.array([model.get(flatfield) for model in models_out])\n</code></pre> <p>Pull out the quantities to be plotted (e.g. final model and residuals):</p> <pre><code>coeff_residuals = coeffs - zernikes_found\nflux_residuals = true_fluxes - fluxes_found\n\nscaler = 1e3\npositions_residuals = true_positions - positions_found\nr_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1])\nr_residuals = dlu.rad2arcsec(r_residuals_rads)\n</code></pre> <pre><code>j = len(models_out)\nplt.figure(figsize=(16, 13))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Log10 Loss\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Log10 ADU\")\nplt.plot(np.log10(np.array(losses)[:j]))\n\nplt.subplot(3, 2, 2)\nplt.title(\"Stellar Positions\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Positional Error (arcseconds)\")\nplt.plot(r_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 3)\nplt.title(\"Stellar Fluxes\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Flux Error (Photons)\")\nplt.plot(flux_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Zernike Coeff Residuals\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Residual Amplitude\")\nplt.plot(coeff_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>How did the phase retrieval go? Really well, as it happens!</p> <pre><code># OPDs\ntrue_opd = tel.aperture.eval_basis()\nopds_found = np.array([model.aperture.eval_basis() for model in models_out])\nfound_opd = opds_found[-1]\nopd_residuls = true_opd - opds_found\nopd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5\n\nvmin = np.min(np.array([true_opd, found_opd]))\nvmax = np.max(np.array([true_opd, found_opd]))\n\n# Coefficients\ntrue_coeff = tel.get(zernikes)\nfound_coeff = models_out[-1].get(zernikes)\nindex = np.arange(len(true_coeff))+4\n\nplt.figure(figsize=(20, 10))\nplt.suptitle(\"Optical Aberrations\")\n\nplt.subplot(2, 2, 1)\nplt.title(\"RMS OPD residual\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"RMS OPD (nm)\")\nplt.plot(opd_rmse_nm)\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Zernike Coefficient Amplitude\")\nplt.xlabel(\"Index\")\nplt.ylabel(\"Amplitude\")\nplt.scatter(index, true_coeff, label=\"True Value\")\nplt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x')\nplt.bar(index, true_coeff - found_coeff, label='Residual')\nplt.axhline(0, c='k', alpha=0.5)\nplt.legend()\n\nplt.subplot(2, 3, 4)\nplt.title(\"True OPD\")\nplt.imshow(true_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found OPD\")\nplt.imshow(found_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"OPD Residual\")\nplt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax)\nplt.colorbar()\nplt.show()\n</code></pre> <p></p> <p>Most impressively, we are recovering the thousands of flat field parameters pretty well too!</p> <pre><code># calculate the mask where there was enough flux to infer the flat field\nthresh = 2500\nfmask = data.mean(0) &gt;= thresh\n\nout_mask = np.where(data.mean(0) &lt; thresh)\nin_mask = np.where(data.mean(0) &gt;= thresh)\n\ndata_tile = np.tile(data.mean(0), [len(models_out), 1, 1])\nin_mask_tiled = np.where(data_tile &gt;= thresh)\n\n# calculate residuals\npr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]\n\n# for correlation plot\ntrue_pr_masked = pix_response.at[out_mask].set(1)\nfound_pr_masked = flatfields_found[-1].at[out_mask].set(1)\n\n# FF Scatter Plot\ndata_sum = data.sum(0) # [flux_mask]\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\n# Errors\npfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])])\nptrue = pix_response[in_mask]\npr_res = ptrue - pfound\nmasked_error = np.abs(pr_res).mean(-1)\n\nplt.figure(figsize=(20, 10))\nplt.subplot(2, 3, (1,2))\nplt.title(\"Pixel Response\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Mean Sensitivity Error\")\nplt.plot(masked_error)\nplt.axhline(0, c='k', alpha=0.5)\n\n# FF Scatter Plot\ndata_sum = data.sum(0)\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\nplt.subplot(2, 3, 3)\nplt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75)\nplt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5)\nplt.colorbar()\nplt.title(\"Sensitivity Residual\")\nplt.ylabel(\"Recovered Sensitivity\")\nplt.xlabel(\"True Sensitivity\")\n\nplt.subplot(2, 3, 4)\nplt.title(\"True Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked)\nplt.colorbar()\n\nvmin = np.min(pix_response)\nvmax = np.max(pix_response)\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(found_pr_masked, vmin=vmin, vmax=vmax)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"Pixel Response Residual\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2)\nplt.colorbar()\n\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/examples/phase_retrieval_demo/","title":"Phase Retrieval in \u2202Lux","text":"<p>In this notebook, we will go through a simple example of phase retrieval in \u2202Lux: recovering Zernike coefficients for an aberrated circular aperture by gradient descent. As noted by Martinache et al. 2013, you can only detect the sign of even-order aberrations if your pupil is not inversion-symmetric.</p> <p>We will follow the example in the paper and recover Zernike aberrations using a circular pupil with an additional bar asymmetry.</p> <pre><code># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom matplotlib import colormaps\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>We want to construct a basic optical system with a $2.4\\, \\text{m}$ aperture, along with some Zernike aberrations and a bar mask.</p> <p>We also create a simple <code>PointSource</code> object that we want to model.</p> <p>Let's see how we can do this in \u2202Lux.</p> <pre><code># Wavefront properties\ndiameter = 2.4\nwf_npixels = 256\n\n# Construct an aperture with a single spider as the asymmetry\noversample = 5\ncoords = dlu.pixel_coords(oversample*wf_npixels, diameter)\ncircle = dlu.circle(coords, diameter/2)\nspider = dlu.spider(coords, diameter/6, [90])\ntransmission = dlu.combine([circle, spider], oversample)\n\n# Zernike aberrations\nzernike_indexes = np.arange(4, 11)\ncoeffs = 1e-7*jr.normal(jr.PRNGKey(0), zernike_indexes.shape)\ncoords = dlu.pixel_coords(wf_npixels, diameter)\nbasis = dlu.zernike_basis(zernike_indexes, coords, diameter)\n\nlayers = [\n    ('aperture', dl.layers.BasisOptic(basis, transmission, coeffs, normalise=True))\n]\n\n# psf params\npsf_npixels = 256 \npsf_pixel_scale = 1e-2 # arcseconds\n\n# Construct Optics\noptics = dl.AngularOpticalSystem(wf_npixels, diameter, layers, psf_npixels, psf_pixel_scale)\n\n# Create a point source\nsource = dl.PointSource(flux=1e5, wavelengths=np.linspace(1e-6, 1.5e-6, 5))\n</code></pre> <p>Let's examine the resulting optical system and generate some data.</p> <pre><code># Model the psf and add some photon noise\npsf = optics.model(source)\ndata = jr.poisson(jr.PRNGKey(1), psf)\n\n# Get mask, setting nan values for visualisation\nsupport = optics.aperture.transmission\nsupport_mask = support.at[support &lt; .5].set(np.nan)\n\n# Get aberrations\nopd = optics.aperture.eval_basis()\n\n# Plot\ncmap = colormaps['inferno']\ncmap.set_bad('k',.5)\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(support_mask * opd * 1e6, cmap=cmap)\nplt.title(\"Aberrations\")\nplt.colorbar(label='um')\n\nplt.subplot(1, 2, 2)\nplt.title(\"Data\")\nplt.imshow(data)\nplt.colorbar(label='Photons')\nplt.show()\n</code></pre> <p></p> <p>Excellent! Now we want to try and recover these aberrations. To do this, we create a new optical system with a different set of Zernike aberrations. If we define the path to the optical aberration coefficients, we can use the <code>.set()</code> method to assign newly randomised coefficient values. With this new optical system we will try to recover the original aberration coefficients using gradient descent methods.</p> <pre><code># Define path to the zernikes\nparam = 'aperture.coefficients'\ncoeffs_init = 1e-7*jr.normal(jr.PRNGKey(2), (len(coeffs),))\nmodel = optics.multiply(param, 0)\n</code></pre> <p>Now we need to define our loss function, and specify that we want to optimise the Zernike coefficients. To do this, we pass the string path to the Zernike coefficients into the <code>zdx.filter_value_and_grad()</code> function. Note that we also use the <code>zdx.filter_jit()</code> function in order to compile this function into XLA so that future evaluations will be much faster!</p> <pre><code># Define loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef loss_func(model, source, data):\n    psf = model.model(source)\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, psf))\n</code></pre> <p>Compiling the function into XLA:</p> <pre><code>%%time\nloss, initial_grads = loss_func(model, source, data) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</code></pre> <pre><code>Initial Loss: 157710.6875\nCPU times: user 257 ms, sys: 18.3 ms, total: 275 ms\nWall time: 203 ms\n</code></pre> <p>Now, we begin the optimisation loop using <code>optax</code> with a low learning rate.</p> <pre><code>optim, opt_state = zdx.get_optimiser(model, param, optax.adam(1e-8))\n\nlosses, models_out = [], []\nwith tqdm(range(100), desc='Gradient Descent') as t:\n    for i in t: \n        # calculate the loss and gradient\n        loss, grads = loss_func(model, source, data) \n\n        # apply the update\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n\n        # save results\n        models_out.append(model) \n        losses.append(loss)\n\n        t.set_description('Loss %.5f' % (loss)) # update the progress bar\n</code></pre> <pre><code>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]\n</code></pre> <p>Now, we visualise this: we have great performance, recovering the input Zernike coefficients and PSF accurately.</p> <pre><code>psf = model.model(source)\ncoeffs_found = np.array([model_out.get(param) for model_out in models_out])\n\nmosaic = \"\"\"\n    AABB\n    CDEF\n    \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['B','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Training History\")\naxes['A'].set_xlabel('Training Epoch')\naxes['A'].set_ylabel('Poisson Log-Likelihood')\n\naxes['B'].plot(coeffs*1e9, coeffs_found[-1]*1e9,'.', markersize=12,color='C0',label='Recovered')\naxes['B'].plot(coeffs*1e9, coeffs_init*1e9,'.', markersize=12,color='C1',label='Initial')\n\naxes['B'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               '-',color='C2',label='1:1')\naxes['B'].legend()\naxes['B'].set_title('Correlation Plot ')\naxes['B'].set_xlabel('True Zernike Coefficients (nm)')\naxes['B'].set_ylabel('Model Zernike Coefficients (nm)')\n\naxes['C'].imshow(data)\naxes['C'].set_title('Data')\n\naxes['D'].imshow(psf)\naxes['D'].set_title('Recovered PSF')\n\naxes['E'].imshow(support_mask*opd, cmap=cmap)\naxes['E'].set_title('Input Aberrations')\n\naxes['F'].imshow(support_mask*model.aperture.eval_basis(), cmap=cmap)\naxes['F'].set_title('Recovered Aberrations')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/howtos/custom_apertures/","title":"Custom Apertures","text":"<p>dLux provides the tools required to let users create their own custom apertures, both static and dynamic. This tutorial will show users all the tools they need to create their own custom apertures.</p> <pre><code># Basic imports\nimport jax.numpy as np\n\n# dLux imports\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Visualisation imports\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre>"},{"location":"tutorials/howtos/custom_apertures/#overview","title":"Overview","text":"<p>Designed to be inference engine, dLux provides a large amount of flexibilty for aperture creation. There are two main components, the coordinates and the shapes. Each aperture shape is calcaulted on a set of coordinates, which can can be transformed arbitrarily before the shape is calculated. dLux implements four affine transformations, translation, rotation, compression, and shearing, however, users can implement their own transformations as well.</p> <p>Lets start by looking at the tools available for creating static apertures, ie ones that are calcaulted as an array of transmission values once and don't change througout optimisation. </p>"},{"location":"tutorials/howtos/custom_apertures/#hst-like-aperture","title":"HST-like Aperture","text":"<pre><code># General parameters\nnpix = 512\ndiam = 2.4 # m\noversample = 5\n\n# Generate a set of coordinates\ncoords = dlu.pixel_coords(npix * oversample, diam)\n\n# Generate outer aperture\nprimary = dlu.circle(coords, diam)\n\n# Generate secondary mirror occultation\nm2_diam = 0.305 # 30.5 cm\nsecondary = dlu.circle(coords, m2_diam, invert=True)\n\n# Generate spiders\nspider_width = 0.038 # 38 mm\nangles = [0, 90, 180, 270]\nspiders = dlu.spider(coords, spider_width, angles)\n\n# Combine and downsample\naperture = dlu.combine([primary, secondary, spiders], oversample)\n\n# Plot\nextent = (-diam/2, diam/2, -diam/2, diam/2)\nplt.figure(figsize=(5, 4))\nplt.title(\"HST-like aperture\")\nplt.imshow(aperture, extent=extent)\nplt.colorbar()\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre> <p>Nice and simple, now we have a nice anti-aliased static HST-like aperture that we can use in our optical model! But that was a relatively simple case, what if we want to create a more complex aperture, like a segmented aperture? Lets see how we can create our own JWST-like aperture.</p>"},{"location":"tutorials/howtos/custom_apertures/#jwst-like-aperture","title":"JWST-like Aperture","text":"<p>So what if we want to do something more compelx like a JWST-like aperture? The code cell below are just some simple function used to calculate the centers of each segment, eventually an optimised version of this will be included in dLux. Untill then, dont worry too much about the details. </p> <pre><code># This is just some code used to calculate the hexagon centers. Down the line, an\n# optimised version of this will be integrated into dLux.\n\ndef hex_cens(rmax):\n    r = np.sqrt(3) * rmax\n    xys = []\n    for i in range(6):\n        angle_rad = dlu.deg2rad(60 * i + 30)\n        xy = r * np.array([np.cos(angle_rad), np.sin(angle_rad)])\n        xys.append(xy)\n    return np.array(xys)\n\ndef evenly_spaced_points(point1, point2, n):\n    x = np.linspace(point1[0], point2[0], n+2)[1:-1]\n    y = np.linspace(point1[1], point2[1], n+2)[1:-1]\n    return np.squeeze(np.column_stack((x, y)))\n\ndef segmented_hex_cens(nrings, rmax, gap=0.0, has_central=False):\n    rseg = rmax + (gap / np.sqrt(3))\n\n    cens = []\n    if has_central:\n        cens.append(np.zeros((1, 2)))\n    inner = hex_cens(rseg)\n    cens.append(inner)\n\n    for i in range(2, nrings):\n        outer = hex_cens(i*rseg)\n        cens.append(outer)\n\n        mids = []\n        for j in range(len(outer)):\n            m = evenly_spaced_points(outer[j], outer[(j+1)%6], i - 1)\n            mids.append(m)\n        shaped = np.array(mids).reshape([6 * (i-1), 2])\n        cens.append(shaped)\n    return np.concatenate(cens)\n</code></pre> <p>Note that the code cell below can be slow (~10s for me), as the above code is not optimised, although it will be later!</p> <pre><code># General parameters\nnpix = 1024\ndiam = 6.6 # m\noversample = 3\nflat_to_flat = 1.32 # m\nair_gap = 0.007 # m\n\n# Generate a set of coordinates\ncoords = dlu.pixel_coords(npix * oversample, diam)\n\n# Calculate the centers of each heaxgon\nrmax = flat_to_flat / np.sqrt(3)\ncens = segmented_hex_cens(3, rmax, air_gap)\n\n# Translate them to each position and calculate the hexagon\nhexes = []\nfor cen in cens:\n    coords_in = dlu.translate_coords(coords, cen)\n    hexes.append(dlu.reg_polygon(coords_in, rmax, 6))\n\n# Sum the heaxgons into a primary\nprimary = np.array(hexes).sum(0)\n\n# Gerenate spiders\nspider_width = 0.1 # m\nangles = [180, 30, -30]\nspider = dlu.spider(coords, spider_width, angles)\n\n# Combine and downsample\naperture = dlu.combine([primary, spider])\n\n# Plot\nextent = (-diam/2, diam/2, -diam/2, diam/2)\nplt.figure(figsize=(5, 4))\nplt.title(\"JWST-like aperture\")\nplt.imshow(aperture, extent=extent)\nplt.colorbar()\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/howtos/custom_apertures/#abstractly-transformed-apertures","title":"Abstractly Transformed Apertures","text":"<p>Since dLux apertures are calculated anaytically on a set of coordinates, we can perform various transformations to the coordinates in order to generate abstractly shaped apertures. Lets see how we can do this.</p> <p>For an example, we will look at how we can apply a shear and rotation to the JWST AMI mask.</p> <pre><code># General parameters\nnpix = 1024\ndiam = 6.6 # m\noversample = 3\nflat_to_flat = 1. # m\nair_gap = 0.32 # m\n\n# Calculate the centers of each heaxgon\nrmax = flat_to_flat / np.sqrt(3)\ncens = segmented_hex_cens(3, rmax, air_gap)\n\n# Get the AMI segments\nindexes = [6, 8, 9, 10, 12, 13, 17]\ncens = cens[indexes, ...]\n\n# Generate a set of coordinates and shear them\ncoords = dlu.pixel_coords(npix * oversample, diam)\ncoords = dlu.rotate_coords(coords, np.pi)\ncoords = dlu.shear_coords(coords, np.array([0.15, 0.]))\n\n# Translate them to each position and calculate the hexagon\nhexes = []\nfor cen in cens:\n    coords_in = dlu.translate_coords(coords, cen)\n    hexes.append(dlu.reg_polygon(coords_in, rmax, 6))\n\n# Combine and downsample\nami = dlu.combine(hexes, sum=True)\n\n# Plot\nextent = (-diam/2, diam/2, -diam/2, diam/2)\nplt.figure(figsize=(5, 4))\nplt.title(\"Transformed AMI-like aperture\")\nplt.imshow(ami, extent=extent)\nplt.colorbar()\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/howtos/custom_apertures/#dynamic-apertures","title":"Dynamic Apertures","text":"<p>As an inference engine, dLux is designed to be able to handle dynamic apertures, ie apertures that change througout the optimisation process. This is useful for calibrating miss-alignments in the optical system. The fundamentals are more or less the same as the static apertures, so lets see how we could recover a miss-aligned JWST AMI mask.</p> <pre><code># General parameters\nnpix = 1024\ndiam = 6.6 # m\noversample = 3\nflat_to_flat = 1. # m\nair_gap = 0.32 # m\n\n# Calculate the centers of each heaxgon\nrmax = flat_to_flat / np.sqrt(3)\ncens = segmented_hex_cens(3, rmax, air_gap)\n\n# Get the AMI segments\nindexes = [6, 8, 9, 10, 12, 13, 17]\ncens = cens[indexes, ...]\n\n# Calculate the dynamic hexagonal apertures\nhexes = []\nfor cen in cens:\n    tf = dl.CoordTransform(translation=cen)\n    hexes.append(dl.RegPolyAperture(6, rmax, tf))\n\n# We want to recover the rotation and shear, so we initialise a CoordTransform object\n# With a rotation and shear that we can optimise\ntf = dl.CoordTransform(rotation=np.pi, shear=np.array([0.1, 0.]))\n\n# Combine into a multi-aperture\naperture = dl.MultiAperture(hexes, tf)\n\n# Now we calculate the transmission of the aperture\ncoords = dlu.pixel_coords(npix * oversample, diam)\ntrans = aperture.transmission(coords, diam/npix)\n\n# Plot\nextent = (-diam/2, diam/2, -diam/2, diam/2)\nplt.figure(figsize=(5, 4))\nplt.title(\"Transformed AMI-like aperture\")\nplt.imshow(trans, extent=extent)\nplt.colorbar()\nplt.xlabel(\"x (m)\")\nplt.ylabel(\"y (m)\")\nplt.show()\n</code></pre> <p></p> <p>Excellent, as we can see we are able to re-create the miss-aligned JWST AMI mask. Now we can double check that everything is working correctly calculating the gradients of this dynamic aperture (with a slightly different value for shear) wrt the static one we calculated earlier.</p> <pre><code>import zodiax as zdx\n\nparams = ['transformation.rotation', 'transformation.shear']\n@zdx.filter_grad(params)\ndef loss_fn(aperture, data):\n    trans = aperture.transmission(coords, diam/npix)\n    return np.sum(np.square(trans - data))\n\ngrads = loss_fn(aperture, ami)\nprint(grads.get(params))\n</code></pre> <pre><code>[Array(4586134.5, dtype=float32), Array([-4672687. ,   -70895.3], dtype=float32)]\n</code></pre> <p>Excellent, we now have gradients for each of the transformations, which we can use in an optimisation loop to infer these values from some data.</p> <p>Note that these calculations can be slow, especially for large arrays with lots of sub-apertures as the full set of coordinates must be transformed for each sub-aperture individually, and then have its transmission calculated. This is just a consequence of the need to re-calculate the aperture on an arbitrary set of coordinates in order for them to be optimised. However this is a rare-occurrence and 99% of users are unlikely to ever need this.</p>"},{"location":"tutorials/howtos/custom_apertures/#summary","title":"Summary","text":"<p>This should give readers a short overview of the tools available for creating custom apertures in dLux. From here users should be able to create any aperture they need from this and the API docs.</p>"},{"location":"tutorials/howtos/dLux_objects/","title":"Working with dLux Objects","text":"<p>This tutorial is designed to give users a quick overview of how to work with dLux objects. Build using <code>Equinox</code> and <code>Zodiax</code>, dLux objects intuitive and simple to work with, so lets have a look at how to get started.</p> <pre><code># Basic imports\nimport jax.numpy as np\nimport jax.random as jr\n\n# dLux imports\nimport dLux as dl\nimport dLux.utils as dlu\n</code></pre>"},{"location":"tutorials/howtos/dLux_objects/#an-optical-system","title":"An Optical System","text":"<p>First we set up a dLux object to work with, in this case a simple optical system. We will not cover the details of how to build an optical system here, as it is covered elsewhere in the tutorials.</p> <pre><code># Define our wavefront properties\nwf_npix = 512  # Number of pixels in the wavefront\ndiameter = 1.0  # Diameter of the wavefront, meters\n\n# Construct a simple circular aperture\ncoords = dlu.pixel_coords(wf_npix, diameter)\naperture = dlu.circle(coords, 0.5 * diameter)\n\n# Zernike aberrations\nindices = np.array([2, 3, 7, 8, 9, 10])\nbasis = 1e-9 * dlu.zernike_basis(indices, coords, diameter=diameter)\ncoefficients = 50 * jr.normal(jr.PRNGKey(0), indices.shape)\n\n# Define our detector properties\npsf_npix = 64  # Number of pixels in the PSF\npsf_pixel_scale = 50e-3  # 50 mili-arcseconds\noversample = 3  # Oversampling factor for the PSF\n\n# Define the optical layers\n# Note here we can pass in a tuple of (key, layer) paris to be able to\n# access the layer from the optics object with the key!\nlayers = [\n    (\n        \"aperture\",\n        dl.layers.BasisOptic(\n            transmission=aperture,\n            basis=basis,\n            coefficients=coefficients,\n            normalise=True,\n        ),\n    ),\n    dl.layers.Tilt(np.zeros(2)),\n\n]\n\n# Construct the optics object\noptics = dl.AngularOpticalSystem(\n    wf_npix, diameter, layers, psf_npix, psf_pixel_scale, oversample\n)\n\n\n# Let examine the optics object! The dLux framework has in-built\n# pretty-printing, so we can just print the object to see what it contains.\nprint(optics)\n</code></pre> <pre><code>AngularOpticalSystem(\n  wf_npixels=512,\n  diameter=1.0,\n  layers={\n    'aperture':\n    BasisOptic(\n      basis=f32[6,512,512],\n      coefficients=f32[6],\n      as_phase=False,\n      transmission=f32[512,512],\n      normalise=True\n    ),\n    'Tilt':\n    Tilt(angles=f32[2])\n  },\n  psf_npixels=64,\n  oversample=3,\n  psf_pixel_scale=0.05\n)\n</code></pre>"},{"location":"tutorials/howtos/dLux_objects/#paths","title":"Paths","text":"<p>So now that we have our optical system set up and we can see the layout, lets have a look at how to work with them. Being built in <code>Zodiax</code>, dLux gains access to a 'path-based' interface, greatly simplifying how we work with these objects. </p> <p>A path in <code>Zodiax</code> works very similarly to a path in a file system. It is a way of navigating through the object, and accessing the data we want via strings, joined with a dot ('.'). Here are some example paths for our optical system:</p> <ul> <li><code>'diameter'</code></li> <li><code>'layers.Tilt.angles'</code></li> <li><code>'layers.aperture.transmission'</code></li> </ul> <p>dLux also makes extensive use of the <code>__getattr__</code> methods, which allows for the raising of low-level attributes to the top level object. Primarily this means we can skip the <code>'layers'</code> part of these paths, so the above paths become:</p> <ul> <li><code>'diameter'</code></li> <li><code>'Tilt.angles'</code></li> <li><code>'aperture.transmission'</code></li> </ul> <p>Now to access these values at these paths, we can either use the <code>.get(path)</code> method, or just access the via the regular attribute accessors. Lets have a look at this in practice:</p> <pre><code># Using the regular accessors\nprint(\"Diameter: \", optics.diameter)\nprint(\"Angles: \", optics.Tilt.angles)\nprint(\"Transmission\", optics.aperture.transmission)\n</code></pre> <pre><code>Diameter:  1.0\nAngles:  [0. 0.]\nTransmission [[0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n ...\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]]\n</code></pre> <pre><code># Using the .get method\nprint(\"Diameter: \", optics.get('diameter'))\nprint(\"Angles: \", optics.get('Tilt.angles'))\nprint(\"Transmission\", optics.get('aperture.transmission'))\n</code></pre> <pre><code>Diameter:  1.0\nAngles:  [0. 0.]\nTransmission [[0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n ...\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]]\n</code></pre> <p>So, if we can access the attributes with regular accessors, what is the point of the <code>Zodiax</code> <code>.get</code> method? Well the <code>.get</code> method lets us access multiple attributes at once by passing in a list of paths. Lets have a look at this in practice:</p> <pre><code>print(optics.get(['diameter', 'Tilt.angles', 'aperture.transmission']))\n</code></pre> <pre><code>[1.0, Array([0., 0.], dtype=float32), Array([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]], dtype=float32)]\n</code></pre> <p>These paths can actually be simplified further, since dLux also raises attributes from the values of the layers dictionary, so the above paths become:</p> <ul> <li><code>'diameter'</code></li> <li><code>'transmission'</code></li> <li><code>'angles'</code></li> </ul> <p>Lets look at this in practice.</p> <p>NOTE</p> <p>While this level parameter raising can greatly simplify the paths we work with, we need to cognisant that each path is unique. For example if we have two layers that have the same values <code>as_phase</code>, then using <code>'as_phase'</code> as our path will only return one of these values. To distinguish between these two we would need to reference the layer by its dictionary key, ie <code>'layer1.as_phase'</code> or <code>'layer2.as_phase'</code>.</p> <pre><code>print(optics.get(['diameter', 'angles', 'transmission']))\n</code></pre> <pre><code>[1.0, Array([0., 0.], dtype=float32), Array([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]], dtype=float32)]\n</code></pre>"},{"location":"tutorials/howtos/dLux_objects/#zodiax-methods","title":"Zodiax Methods","text":"<p><code>Zodiax</code> gives us access to a series of class methods that are designed to mirror the <code>jax.Array</code> syntax, ie <code>.at</code>, <code>.set</code>, <code>.multiply</code> etc. The syntax a slightly different in that we need to specify a path to the data we want to work with, but the functionality is the same. Here are the main <code>Zodiax</code> methods: some of the zodiax methods:</p> <ul> <li><code>.get(paths)</code></li> <li><code>.set(paths, values)</code></li> <li><code>.add(paths, values)</code></li> <li><code>.multiply(paths, values)</code></li> <li><code>.divide(paths, values)</code></li> <li><code>.min(paths, values)</code></li> <li><code>.max(paths, values)</code></li> </ul> <p>Lets use the <code>.add</code> method to see how we can modify our optical system.</p> <pre><code>paths = ['diameter', 'angles']\nnew_optics = optics.add(paths, [1, 0.5])\nprint(new_optics.get(paths))\n</code></pre> <pre><code>[2.0, Array([0.5, 0.5], dtype=float32)]\n</code></pre>"},{"location":"tutorials/howtos/dLux_objects/#nesting","title":"Nesting","text":"<p>Zodiax goes further here, and allows to 'nest' paths, such that we can operate on mulitple values in the same operation. Lets look at some examples of this in practice:</p> <pre><code># Operate on multiple values simultaneously\npaths = ['diameter', 'angles']\nnew_optics = optics.multiply(paths, 0)\nprint(new_optics.get(paths))\n</code></pre> <pre><code>[0.0, Array([0., 0.], dtype=float32)]\n</code></pre> <p>We can also nest within our path itself, lets see how:</p> <pre><code># Set nested values simulatenously\n# Note that 'paths' here has two entries, so we need to supply a \n# list of values of the same length\npaths = [['diameter', 'angles'], 'transmission']\nvalues = [1, 2]\nnew_optics = optics.set(paths, values)\nprint(new_optics.get(paths))\n</code></pre> <pre><code>[1, 1, 2]\n</code></pre> <p>Excellent! Now some keen readers may have noticed that using the <code>.set</code> method, the <code>transmission</code> values has changes from an array to a float! This is becuase there is no robust way to do runtime type and shape checking, plus sometimes we may want to change the type anyway. Do be cognisant when setting values that you are setting then to valid types for the object.</p> <p>Summary</p> <p>So that is a quick overview of how to work with dLux objects. We have seen how to access the data via paths, and how to modify the data using the <code>Zodiax</code> methods. We have also seen how to nest paths, and how to nest paths within paths. Hopefully this has given you a good overview of how to work with dLux objects, and you can now go and work with the objects with ease!</p> <p>TODO: Add jit to this tutorial?</p> <p>TODO: Add object vectorsation?</p>"},{"location":"tutorials/introductory/optical_systems/","title":"Working with OpticalSystem Objects","text":"<p>This tutorial is designed to give an overview of the main class in dLux - The <code>OpticalSystem</code> class. </p> <pre><code># Basic imports\nimport jax.numpy as np\n\n# dLux imports\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Visualisation imports\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre>"},{"location":"tutorials/introductory/optical_systems/#overview","title":"Overview","text":"<p>There are three <code>OpticalSystem</code>s implemented in dLux:</p> <ol> <li><code>LayeredOpticalSystem</code></li> <li><code>AngularOpticalSystem</code></li> <li><code>CartesianOpticalSystem</code></li> </ol> <p>All are constructed similarly, and share the the following attributes:</p> <ul> <li><code>wf_npixels</code></li> <li><code>diameter</code></li> <li><code>layers</code></li> </ul> <p>The <code>wf_npixls</code> parameter defines the number of pixels used to initialise the wavefront, <code>diameter</code> defines the diameter of the wavefront in meters, and <code>layers</code> is a list of <code>OpticalLayer</code> objects that define the transformations to that wavefront.</p> <p>The <code>AngularOpticalSystem</code> and <code>CartesianOpticalSystem</code> are both subclasses of the <code>LayeredOpticalSystem</code> class, extending it to include three extra attributes:</p> <ul> <li><code>psf_npixels</code></li> <li><code>psf_pixel_scale</code></li> <li><code>oversample</code></li> </ul> <p>These attributes define the size of the PSF, the pixel scale of the PSF, and the oversampling factor used when calculating the PSF. The difference between the two is that the <code>AngularOpticalSystem</code> has <code>psf_pixel_scale</code> in units of arcseconds, while the <code>CartesianOpticalSystem</code> has <code>psf_pixel_scale</code> in units of microns. Note that an oversample of 2 will result in an output psf with shape <code>(2 * psf_npixels, 2 * psf_npixels)</code>, with the idea that the PSF will be downsampled later to the correct size and pixel scale. </p> <p>Beyond this, the <code>CartesianOpticalSystem</code> has an extra attribute <code>focal_length</code>, with units of meters.</p> <p>Now lets create a minimal <code>AnguarOpticalSystem</code> to demonstrate how to use these classes.</p> <pre><code># Define our wavefront properties\nwf_npix = 512  # Number of pixels in the wavefront\ndiameter = 1.0  # Diameter of the wavefront, meters\n\n# Construct a simple circular aperture\ncoords = dlu.pixel_coords(wf_npix, diameter)\naperture = dlu.circle(coords, 0.5 * diameter)\n\n# Define our detector properties\npsf_npix = 64  # Number of pixels in the PSF\npsf_pixel_scale = 50e-3  # 50 mili-arcseconds\noversample = 3  # Oversampling factor for the PSF\n\n# Define the optical layers\nlayers = [('aperture', dl.layers.Optic(aperture, normalise=True))]\n\n# Construct the optics object\noptics = dl.AngularOpticalSystem(\n    wf_npix, diameter, layers, psf_npix, psf_pixel_scale, oversample\n)\n\n# Let examine the optics object! The dLux framework has in-built\n# pretty-printing, so we can just print the object to see what it contains.\nprint(optics)\n</code></pre> <pre><code>AngularOpticalSystem(\n  wf_npixels=512,\n  diameter=1.0,\n  layers={\n    'aperture':\n    Optic(opd=None, phase=None, transmission=f32[512,512], normalise=True)\n  },\n  psf_npixels=64,\n  oversample=3,\n  psf_pixel_scale=0.05\n)\n</code></pre>"},{"location":"tutorials/introductory/optical_systems/#methods","title":"Methods","text":"<p>All three of these object are quite similar, and share the same three primary methods:</p> <ol> <li><code>.propagate_mono</code></li> <li><code>.propagate</code></li> <li><code>.model</code></li> </ol> <p>Lets look at them one-by-one.</p>"},{"location":"tutorials/introductory/optical_systems/#propagate_mono","title":"<code>propagate_mono</code>","text":"<p><code>propagate_mono</code> has the following signature: <code>optics.propagate_mono(wavelength, offset=np.zeros(2), return_wf=False)</code></p> <ul> <li><code>wavelength</code> is the wavelength of the light to propagate, in meters</li> <li><code>offset</code> is the offset of the source from the center of optical system, in radians</li> <li><code>return_wf</code> is a boolean flag that determines whether the wavefront object should be returned, as opposed to the psf array.</li> </ul> <p>Note that the <code>propagate_mono</code> method should generally not be used, as its functionality is superceeded by the <code>propagate</code> method, but lets look at how it works anyway.</p> <pre><code># 1 micron wavelength\nwavelength = 1e-6 \n\n# 5-pixel offset in the x-direction\nshift = np.array([5 * psf_pixel_scale, 0])\noffset = dlu.arcsec2rad(shift)\n\n# Propagate a psf\npsf = optics.propagate_mono(wavelength, offset)\n\n# Plot the results\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture Transmission\")\nplt.imshow(optics.transmission)\nplt.colorbar(label=\"Transmission\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"Sqrt PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label=\"Sqrt Intensity\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>We can also return the <code>Wavefront</code> object too, allowing us to look at the amplitude, phase, and any other properties.</p> <pre><code># Get the Wavefront\nwf = optics.propagate_mono(wavelength, offset, return_wf=True)\n\n# First we examine the wavefront object\nprint(wf)\n</code></pre> <pre><code>Wavefront(\n  wavelength=f32[],\n  pixel_scale=f32[],\n  amplitude=f32[192,192],\n  phase=f32[192,192],\n  plane='Focal',\n  units='Angular'\n)\n</code></pre> <pre><code># Get the amplitude and phase\namplitude = wf.amplitude\nphase = wf.phase\n\n# Get the fov for plotting\nfov = dlu.rad2arcsec(wf.diameter)\nextent = [-fov/2, fov/2, -fov/2, fov/2]\n\n# Plot\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title('Amplitude')\nplt.imshow(amplitude, extent=extent)\nplt.colorbar()\nplt.xlabel('x (arcseconds)')\nplt.ylabel('y (arcseconds)')\n\nplt.subplot(1, 2, 2)\nplt.title('Phase')\nplt.imshow(phase, extent=extent)\nplt.colorbar()\nplt.xlabel('x (arcseconds)')\nplt.ylabel('y (arcseconds)')\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/optical_systems/#propagate","title":"<code>propagate</code>","text":"<p><code>propagate</code> is the core propagation function of optical systems. It has the following signature: <code>optics.propagate(wavelengths, offsets=np.zeros(2), weights=None, return_wf=False, return_psf=False)</code></p> <ul> <li><code>wavelengths</code> is an array of wavelengths to propagate, in meters</li> <li><code>offset</code> is the offset of the source from the center of optical system, in radians</li> <li><code>weights</code> is an array of weights to apply to each wavelength. If <code>None</code>, then all wavelengths are weighted equally.</li> <li><code>return_wf</code> is a boolean flag that determines whether the <code>Wavefront</code> object should be returned, as opposed to the psf array.</li> <li><code>return_psf</code> is a boolean flag that determines whether the <code>PSF</code> object should be returned, as opposed to the psf array.</li> </ul> <p>Lets see how to ues it.</p> <pre><code># Wavelengths array - Note we can also pass in a single float value!\nwavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\n\n# Weights array - Note these are relative weights, the input\n# is automatically normalised\nweights = np.linspace(0.5, 1.5, len(wavelengths))\n\n# 5-pixel offset in the x-direction\nshift = np.array([5 * psf_pixel_scale, 0])\noffset = dlu.arcsec2rad(shift)\n\n# Propagate a psf\npsf = optics.propagate(wavelengths, offset, weights)\n\n# Plot the results\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture Transmission\")\nplt.imshow(optics.transmission)\nplt.colorbar(label=\"Transmission\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"Sqrt PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label=\"Sqrt Intensity\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>Now lets see how the amplitudes and phases look.</p> <pre><code># Get the Wavefront\nwf = optics.propagate(wavelengths, offset, weights, return_wf=True)\n\n# First we examine the wavefront object\nprint(wf)\n</code></pre> <pre><code>Wavefront(\n  wavelength=f32[10],\n  pixel_scale=f32[10],\n  amplitude=f32[10,192,192],\n  phase=f32[10,192,192],\n  plane='Focal',\n  units='Angular'\n)\n</code></pre> <p>Interesting, as we can see the returned <code>Wavefront</code> object in vectorised down its first axis. This is one of the benfits of working within the <code>Equinox</code>/<code>Zodiax</code> framework, as we can vectorise our objects directly meaning we dont need to updack values into arrays to be vectorised. </p> <pre><code># Get the mean amplitude and phase\namplitude = wf.amplitude.mean(0)\nphase = wf.phase.mean(0)\n\n# Get the fov for plotting\nfov = dlu.rad2arcsec(wf.diameter.mean(0))\nextent = [-fov/2, fov/2, -fov/2, fov/2]\n\n# Plot\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title('Mean Amplitude')\nplt.imshow(amplitude, extent=extent)\nplt.colorbar()\nplt.xlabel('x (arcseconds)')\nplt.ylabel('y (arcseconds)')\n\nplt.subplot(1, 2, 2)\nplt.title('Mean Phase')\nplt.imshow(phase, extent=extent)\nplt.colorbar()\nplt.xlabel('x (arcseconds)')\nplt.ylabel('y (arcseconds)')\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>We can also return the <code>PSF</code> object too, allowing us to keep track of the pixel scale and perform operations like downsampling. Lets have a look at that now</p> <pre><code># Get the PSF object\nPSF = optics.propagate(wavelengths, offset, weights, return_psf=True)\n\n# Downsample the PSF to the 'true' pixel scale\ntrue_PSF = PSF.downsample(oversample)\n\n# Lets examine it, and plot it\nprint(true_PSF)\n\n# Plot\nplt.figure(figsize=(5, 4))\nplt.title('True PSF')\nplt.imshow(true_PSF.data**0.5)\nplt.colorbar()\nplt.xlabel('x (pixels)')\nplt.ylabel('y (pixels)')\nplt.show()\n</code></pre> <pre><code>PSF(data=f32[64,64], pixel_scale=f32[])\n</code></pre> <p></p>"},{"location":"tutorials/introductory/optical_systems/#model","title":"<code>model</code>","text":"<p><code>model</code> is the other core function of optical systems. It is designed to be a simple interface between optical systems and <code>Source</code> objects. It has the following signature: <code>optics.model(source, return_wf=False, return_psf=False)</code></p> <ul> <li><code>source</code> is any dLux <code>Source</code> object</li> <li><code>return_wf</code> is a boolean flag that determines whether the <code>Wavefront</code> object should be returned, as opposed to the psf array.</li> <li><code>return_psf</code> is a boolean flag that determines whether the <code>PSF</code> object should be returned, as opposed to the psf array.</li> </ul> <p>Lets see how to ues it, although we will not look at the <code>return_wf</code> and <code>return_psf</code> flags as they behave identically to the above example.</p> <pre><code># Create a simple point-source object\nsource = dl.PointSource(wavelengths=wavelengths, weights=weights)\n\n# Propagate it through the optics\npsf = optics.model(source)\n\n# Plot\nplt.figure(figsize=(5, 4))\nplt.title('Sqrt PSF')\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.xlabel('x (pixels)')\nplt.ylabel('y (pixels)')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/optical_systems/#summary","title":"Summary","text":"<p>Thats all there is to it! These objects are designed to be simple to use, and to be as flexible as possible.</p>"},{"location":"tutorials/introductory/overview/","title":"A Basic overview","text":"<p>This tutorial is designed to give users a basic introduction to the core parts of dLux. We will cover how to create an optical system and its psf, how to work with dLux objects, and show a basic optimisation workflow.</p>"},{"location":"tutorials/introductory/overview/#a-simple-optical-system","title":"A Simple Optical System","text":"<p>Lets start by constructing a very simple Airy-like optical system, and propagating multiple wavelengths through it.</p> <pre><code># Basic imports\nimport jax.numpy as np\nimport jax.random as jr\nimport jax.scipy as jsp\n\n# Optimisation imports\nimport zodiax as zdx\nimport optax\n\n# dLux imports\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Visualisation imports\nfrom tqdm.notebook import tqdm\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <pre><code># Define our wavefront properties\nwf_npix = 512  # Number of pixels in the wavefront\ndiameter = 1.0  # Diameter of the wavefront, meters\n\n# Construct a simple circular aperture\ncoords = dlu.pixel_coords(wf_npix, diameter)\naperture = dlu.circle(coords, 0.5 * diameter)\n\n# Define our detector properties\npsf_npix = 64  # Number of pixels in the PSF\npsf_pixel_scale = 50e-3  # 50 mili-arcseconds\noversample = 3  # Oversampling factor for the PSF\n\n# Define the optical layers\n# Note here we can pass in a tuple of (key, layer) paris to be able to \n# access the layer from the optics object with the key!\nlayers = [\n    (\n        \"aperture\",\n        dl.layers.TransmissiveLayer(transmission=aperture, normalise=True),\n    )\n]\n\n# Construct the optics object\noptics = dl.AngularOpticalSystem(\n    wf_npix, diameter, layers, psf_npix, psf_pixel_scale, oversample\n)\n\n# Models some wavelengths through the system\nwavels = 1e-6 * np.linspace(1, 1.2, 10)\npsf = optics.propagate(wavels)\n\n# Get out aperture transmission for plotting\n# Note we can use the 'aperture' key we supplied in the layers to access \n# that layer directly from the optics object!\ntransmission = optics.aperture.transmission\n\n# Let examine the optics object! The dLux framework has in-built \n# pretty-printing, so we can just print the object to see what it contains.\nprint(optics)\n</code></pre> <pre><code>AngularOpticalSystem(\n  wf_npixels=512,\n  diameter=1.0,\n  layers={\n    'aperture':\n    TransmissiveLayer(transmission=f32[512,512], normalise=True)\n  },\n  psf_npixels=64,\n  oversample=3,\n  psf_pixel_scale=0.05\n)\n</code></pre> <pre><code># Plot the results\nplt.figure(figsize=(10, 4))\nplt.suptitle(\"A Simple Optical System\")\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture Transmission\")\nplt.imshow(transmission)\nplt.colorbar(label=\"Transmission\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"Sqrt PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label=\"Sqrt Intensity\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/overview/#adding-aberrations","title":"Adding Aberrations","text":"<p>It is very common for an optical system to have aberrations that have a significant impact on the psf, so lets see how we can model this!</p> <pre><code># First we define the zernike indices we want to model. In this example\n# we ignore the even indices, as they suffer from a degeneracy that makes\n# them difficult to recover when we have a symmetric aperture, like a circle!\nindices = np.array([2, 3, 7, 8, 9, 10])\n\n# Construct some zernike basis and some coefficients\nbasis = 1e-9 * dlu.zernike_basis(indices, coords, diameter=diameter)\ncoefficients = 50 * jr.normal(jr.PRNGKey(0), indices.shape)\n\n# Re-define our layers to include the aberrations\nlayers = [\n    (\n        \"aperture\",\n        dl.layers.TransmissiveLayer(transmission=aperture, normalise=True),\n    ),\n    (\n        \"aberrations\",\n        dl.layers.BasisLayer(basis=basis, coefficients=coefficients),\n    ),\n]\n\n# Re-construct the optics object and re-propagate our wavelengths\noptics = dl.AngularOpticalSystem(\n    wf_npix, diameter, layers, psf_npix, psf_pixel_scale, oversample\n)\npsf = optics.propagate(wavels)\n\n# Get out aperture aberrations for plotting\naberrations = optics.aberrations.eval_basis()\n\n# Print the new object\nprint(optics)\n</code></pre> <pre><code>AngularOpticalSystem(\n  wf_npixels=512,\n  diameter=1.0,\n  layers={\n    'aperture':\n    TransmissiveLayer(transmission=f32[512,512], normalise=True),\n    'aberrations':\n    BasisLayer(basis=f32[6,512,512], coefficients=f32[6], as_phase=False)\n  },\n  psf_npixels=64,\n  oversample=3,\n  psf_pixel_scale=0.05\n)\n</code></pre> <pre><code># Plot the results\nplt.figure(figsize=(10, 4))\nplt.suptitle(\"A Simple Optical System\")\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture Aberrations\")\nplt.imshow(aberrations * 1e9)\nplt.colorbar(label=\"OPD (nm)\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar(label=\"Intensity\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/overview/#working-with-dlux-objects","title":"Working with dLux objects","text":"<p><code>dLux</code> is build within <code>Zodiax</code>, which gives all classes a simple path-based way to interact with our objects. We will use this to set update the aberrations in our optical system, and then recover the values from the previous example!</p> <p>There are two ways we can do this, either by setting the <code>aberrations.coefficients</code> values to a new array, or multiplying the current value by zero. We will show how to do both of these.</p> <p>Note that we will call the new object <code>model</code> since we will use this object to try and recover the initial values we set.</p> <pre><code># Define our new coefficients and update the optics object\nnew_coefficients = np.zeros(coefficients.shape)\nmodel = optics.set(\"aberrations.coefficients\", new_coefficients)\n\n# Multiply the existing coefficients by zero\nmodel = optics.multiply(\"aberrations.coefficients\", 0.0)\n\n# New we can re-propagate our wavelengths to check that we have an \n# un-aberrated PSF\npsf = model.propagate(wavels)\n\n# Extract out values for plotting\naberrations = model.aberrations.eval_basis()\n</code></pre> <pre><code># Plot the results\nplt.figure(figsize=(10, 4))\nplt.suptitle(\"A Simple Optical System\")\nplt.subplot(1, 2, 1)\nplt.title(\"Aperture Aberrations\")\nplt.imshow(aberrations * 1e9)\nplt.colorbar(label=\"OPD (nm)\")\n\nplt.subplot(1, 2, 2)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar(label=\"Intensity\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/overview/#taking-gradients","title":"Taking Gradients","text":"<p>One of primary benefits of dLux is it is differentiable, meaning we can use autodiff to take gradients of any parameter in out model with respect to an arbitrary loss function.</p> <p>To do this we will use <code>Zodiax</code>, which allows us to take gradients with respect to specific parameters in our model, with a path-based interface. </p> <pre><code># Generate some data to take gradients with respect to\nflux = 1e4\ndata = jr.poisson(jr.PRNGKey(1), flux * optics.propagate(wavels))\n\n\n# Define out loss function, in this case a simple poisson log-likelihood\n@zdx.filter_value_and_grad(\"aberrations.coefficients\")\ndef loss_fn(model, data):\n    psf = flux * model.propagate(wavels)\n    return -jsp.stats.poisson.logpmf(data, psf).mean()\n\n\n# Now we evaluate the loss function and get the gradients\nloss, grads = loss_fn(model, data)\n\n# Note that Zodiax will return the gradients in the same structure as \n# the model, ie, an optics object! This means we can use all the same \n# methods to examine values as we would the normal optics object, so \n# lets have a look.\nprint(f\"Loss: {loss}\\n\")\nprint(f\"Coefficient gradients: {grads.aberrations.coefficients}\\n\")\nprint(f\"Gradients object: {grads}\")\n</code></pre> <pre><code>Loss: 0.288269966840744\n\nCoefficient gradients: [ 3.8819111e-05  1.4264378e-03 -6.6455011e-04 -1.2623395e-03\n -2.2182279e-04 -1.6320724e-05]\n\nGradients object: AngularOpticalSystem(\n  wf_npixels=None,\n  diameter=None,\n  layers={\n    'aperture':\n    TransmissiveLayer(transmission=None, normalise=None),\n    'aberrations':\n    BasisLayer(basis=None, coefficients=f32[6], as_phase=None)\n  },\n  psf_npixels=None,\n  oversample=None,\n  psf_pixel_scale=None\n)\n</code></pre>"},{"location":"tutorials/introductory/overview/#compiling-and-optimisation","title":"Compiling and Optimisation","text":"<p>Working within the <code>jax</code> framework allows us to compile our code to XLA, which can significantly speed up the execution of our code. Lets do this and see how fast out model is able to evaluate! <code>Zodiax</code> provides a simple interface that allows us to compile our whole object to XLA using <code>zdx.filter_jit</code>, which is very convenient.</p> <pre><code># First we start by jit-compiling our loss function\njit_loss = zdx.filter_jit(loss_fn)\n\n# Now lets have a look at the performance of the loss function\n# Note we need to use the block_until_ready() method to ensure \n# the computation is timed correctly, this is because jax uses \n# asynchronous computation by default.\ntime_regular = %timeit -o loss_fn(model, data)[0].block_until_ready()\ntime_jit = %timeit -o jit_loss(model, data)[0].block_until_ready()\n\n# Display timing results\nprint(f\"Regular time: {time_regular.average*1e3:.5} ms\")\nprint(f\"Jit time: {time_jit.average*1e3:.5} ms\")\nprint(f\"Improvement: {time_regular.average/time_jit.average:.3}x faster\")\n</code></pre> <pre><code>113 ms \u00b1 2.49 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n79.8 ms \u00b1 1.33 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nRegular time: 112.59 ms\nJit time: 79.843 ms\nImprovement: 1.41x faster\n</code></pre> <p>Excellent, now that we have our compile loss function, lets optimise our model!</p> <p>To do this we use <code>optax</code>, the gradient processing library developed by Googles DeepMind team. This library provides a number of optimisation algorithms, and we will use the <code>adam</code> optimiser here. <code>Zodiax</code> also provides a simple way to map our optimisation algorithms to our model, using <code>zdx.get_optimiser</code> function.</p> <pre><code># Construct our optimiser objects\noptim, opt_state = zdx.get_optimiser(\n    model, \"aberrations.coefficients\", optax.adam(1e1)\n)\n\n# Set up a progress bar\npbar = tqdm(range(50), desc=\"Loss: \")\n\n# A basic optimisation loop\nlosses, models = [], []\nfor i in pbar:\n    # Calculate the loss gradients, and update the model\n    loss, grads = jit_loss(model, data)\n    updates, opt_state = optim.update(grads, opt_state)\n    model = zdx.apply_updates(model, updates)\n\n    # save results\n    models.append(model)\n    losses.append(loss)\n\n    pbar.set_description(\"Loss %.5f\" % (loss))\n</code></pre> <pre><code>Loss:   0%|          | 0/50 [00:00&lt;?, ?it/s]\n</code></pre> <p>Now we visualise the results of our optimisation!</p> <pre><code>psf = model.propagate(wavels)\ncoeffs_found = np.array([m.get(\"aberrations.coefficients\") for m in models])\ntrue_opd = optics.aberrations.eval_basis()\nfound_opd = model.aberrations.eval_basis()\n\nmosaic = \"\"\"\n    AABB\n    CDEF\n    \"\"\"\n\nfig = plt.figure(constrained_layout=True, figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in [\"B\", \"D\", \"E\", \"F\"]:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes[\"A\"].plot(np.array(losses))\naxes[\"A\"].set_title(\"Training History\")\naxes[\"A\"].set_xlabel(\"Training Epoch\")\naxes[\"A\"].set_ylabel(\"Poisson Log-Likelihood\")\n\naxes[\"B\"].plot(coefficients, coeffs_found[-1], \".\", markersize=12)\naxes[\"B\"].plot(\n    np.array([np.min(coefficients), np.max(coefficients)]),\n    np.array([np.min(coefficients), np.max(coefficients)]),\n    \"-\",\n    color=\"C2\",\n    label=\"1:1\",\n)\naxes[\"B\"].legend()\naxes[\"B\"].set_title(\"Correlation Plot \")\naxes[\"B\"].set_xlabel(\"True Zernike Coefficients\")\naxes[\"B\"].set_ylabel(\"Model Zernike Coefficients\")\n\naxes[\"C\"].imshow(data)\naxes[\"C\"].set_title(\"Data\")\n\naxes[\"D\"].imshow(psf)\naxes[\"D\"].set_title(\"Recovered PSF\")\n\naxes[\"E\"].imshow(true_opd)\naxes[\"E\"].set_title(\"Input Aberrations\")\n\naxes[\"F\"].imshow(found_opd)\naxes[\"F\"].set_title(\"Recovered Aberrations\")\n\nfig.tight_layout()\n</code></pre> <pre><code>/var/folders/28/6s47s91d14ldjdrljs4d1hxw0000gn/T/ipykernel_39605/3478373043.py:48: UserWarning: The figure layout has changed to tight\n  fig.tight_layout()\n</code></pre> <p></p> <p>There we go! We have successfully optimised our model to recover the initial values we set. This is a very simple example, but it shows the basic workflow of how to use dLux to optimise an optical system.</p> <pre><code>\n</code></pre>"},{"location":"tutorials/introductory/sources/","title":"Sources &amp; Spectra","text":"<p>This tutorials is designed to give an overview of both the <code>Source</code> and <code>Spectrum</code> classes within dLux.</p> <pre><code># Basic imports\nimport jax.numpy as np\nimport jax.random as jr\n\n# dLux imports\nimport dLux as dl\nimport dLux.utils as dlu\n\n# Visualisation imports\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 72\n</code></pre> <p>First lets whip up an optical system that we can use to propagate the sources through.</p> <pre><code># Define our wavefront properties\nwf_npix = 512  # Number of pixels in the wavefront\ndiameter = 1.0  # Diameter of the wavefront, meters\n\n# Construct a simple circular aperture\ncoords = dlu.pixel_coords(wf_npix, diameter)\naperture = dlu.circle(coords, 0.5 * diameter)\n\n# Define our detector properties\npsf_npix = 64  # Number of pixels in the PSF\npsf_pixel_scale = 50e-3  # 50 mili-arcseconds\noversample = 3  # Oversampling factor for the PSF\n\n# Define the optical layers\nlayers = [('aperture', dl.layers.Optic(aperture, normalise=True))]\n\n# Construct the optics object\noptics = dl.AngularOpticalSystem(\n    wf_npix, diameter, layers, psf_npix, psf_pixel_scale, oversample\n)\n</code></pre>"},{"location":"tutorials/introductory/sources/#overview","title":"Overview","text":"<p>The <code>Source</code> and <code>Spectrum</code> classes in dLux work in tandem, with all <code>Source</code> objects containing a <code>Spectrum</code> object. There are only two <code>Spectrum</code> classes implemented in dLux:</p> <ol> <li><code>Spectrum</code> is a simple array-based spectrum, contating <code>wavelengths</code> and <code>weights</code>.</li> <li><code>PolySpectrum</code> is a simple polynomial spectrum, containing <code>wavelengths</code> and <code>coefficients</code>.</li> </ol> <p>In general users will not need to intract with the <code>Spectrum</code> objects directly, as they are automatically instatiated when creating a <code>Source</code> object. Lets take a look at the various different <code>Source</code> classes implemented in dLux.</p> <ol> <li><code>PointSource</code></li> <li><code>ResolvedSource</code></li> <li><code>BinarySource</code></li> <li><code>PointResolvedSource</code></li> <li><code>PointSources</code></li> <li><code>Scene</code></li> </ol> <p>They all have a similar interface, having both a <code>.normalise</code> and <code>.model</code> method. The <code>.normalise</code> method takes no inputs and normalises the source and spectrum, which is important during optimisation since the updates during that process can not guarantee that the source remains normalised. The model method has the following signature <code>.model(optical_system, return_wf=False, return_psf=False)</code>, mirroring the <code>OpticalSystem.model</code> method. The <code>return_wf</code> and <code>return_psf</code> flags are used to determine what object is returned. If both are <code>False</code>, the returned psf is an array, if <code>return_wf</code> is <code>True</code> the returned psf is a <code>Wavefront</code> object, and if <code>return_psf</code> is <code>True</code> the returned psf is a <code>PSF</code> object.</p> <p>Ands that about all there is to the <code>Source</code> objects! So lets jump in and have a look at these classes.</p>"},{"location":"tutorials/introductory/sources/#initialising-the-spectrum","title":"Initialising the Spectrum","text":"<p><code>Spectrum</code> objects can be initialised from the <code>Source</code> objects in two ways, either by passing in a <code>wavelengths</code> and (optional) <code>weights</code> array, or by passing in a <code>Spectrum</code> object directly. If a <code>Spectrum</code> object is passed in, the <code>wavelengths</code> and <code>weights</code> arrays are ignored. If only a <code>wavelengths</code> array is passed in, the <code>weights</code> array is initialised to be an array of ones. If both a <code>wavelengths</code> and <code>weights</code> array are passed in, the <code>weights</code> array is normalised to sum to one.</p>"},{"location":"tutorials/introductory/sources/#pointsource","title":"PointSource","text":"<p>The <code>PointSource</code> class is very straightforwards with three attributes:</p> <ol> <li><code>position</code> - the position of the source in the sky, in radians.</li> <li><code>flux</code> - the flux of the source, in photons.</li> <li><code>spectrum</code> - the spectrum of the source.</li> </ol> <p>Lets create one and model it through an optical system. We will also return the <code>PSF</code> object so we can examine both the oversampled and downsampled psfs.</p> <pre><code># Define the source properties\nflux = 1e4\nposition = dlu.arcsec2rad(np.array([1, 0]))\nwavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\n\n# Construct the source object and examine it\npoint = dl.PointSource(wavelengths, position, flux)\nprint(point)\n</code></pre> <pre><code>PointSource(\n  spectrum=Spectrum(wavelengths=f32[10], weights=f32[10]),\n  position=f32[2],\n  flux=10000.0\n)\n</code></pre> <pre><code># Model the source and examine the PSF\npsf_oversample = point.model(optics)\nPSF = point.model(optics, return_psf=True).downsample(oversample)\n\n# Plot\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Oversampled PSF\")\nplt.imshow(psf_oversample**0.5)\nplt.colorbar(label='Sqrt Photons')\n\nplt.subplot(1, 2, 2)\nplt.title(\"'True' PSF\")\nplt.imshow(PSF.data**0.5)\nplt.colorbar(label='Sqrt Photons')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/sources/#resolvedsource","title":"ResolvedSource","text":"<p>The resolved source operates very similarly to the <code>PointSource</code> class, only adding the <code>distribution</code> attribute.</p> <ol> <li><code>position</code> - the position of the source in the sky, in radians.</li> <li><code>flux</code> - the flux of the source, in photons.</li> <li><code>spectrum</code> - the spectrum of the source.</li> <li><code>distribution</code> - the distribution of the source.</li> </ol> <p>Lets create one and model it through an optical system.</p> <pre><code># Define the source properties\nflux = 1e4\nposition = np.zeros(2)\nwavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\ndistribution = np.ones((10, 10))\n\n# Construct the source object and examine it\nresolved = dl.ResolvedSource(wavelengths, position, flux, distribution)\nprint(resolved)\n\n# Model the source\npsf = resolved.model(optics)\n</code></pre> <pre><code>ResolvedSource(\n  spectrum=Spectrum(wavelengths=f32[10], weights=f32[10]),\n  position=f32[2],\n  flux=10000.0,\n  distribution=f32[10,10]\n)\n</code></pre> <pre><code># Plot\nplt.figure(figsize=(5, 4))\nplt.title(\"Resolved Source\")\nplt.imshow(psf**0.5)\nplt.colorbar(label='Sqrt Photons')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/sources/#binarysource","title":"BinarySource","text":"<p>The <code>BinarySource</code> class parametrises two point sources with 6 parameters:</p> <ol> <li><code>position</code> - the mean position of the source in the sky, in radians.</li> <li><code>separation</code> - the separation of the two sources, in radians.</li> <li><code>position_angle</code> - the position angle of the two sources, in radians.</li> <li><code>mean_flux</code> - the mean flux of the sources, in photons.</li> <li><code>contrast</code> - the contrast of the two sources, in photons.</li> <li><code>spectrum</code> - the spectrum of the sources.</li> </ol> <p>We can also pass in an array of <code>weights</code> in order to give them different spectra. Lets create one and model it through an optical system.</p> <pre><code># Define the source properties\nwavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\nweights = np.array([np.linspace(0.5, 1.5, 10), np.linspace(1.5, 0.5, 10)])\n\n# Construct the source object and examine it\nbinary = dl.BinarySource(\n    wavelengths,\n    mean_flux=1e4,\n    contrast=5,\n    weights=weights,\n    separation=dlu.arcsec2rad(1),\n)\nprint(binary)\n\n# Model the source\npsf = binary.model(optics)\n</code></pre> <pre><code>BinarySource(\n  spectrum=Spectrum(wavelengths=f32[10], weights=f32[2,10]),\n  position=f32[2],\n  mean_flux=10000.0,\n  separation=4.84813681109536e-06,\n  position_angle=1.5707963267948966,\n  contrast=5.0\n)\n</code></pre> <pre><code># Plot\nplt.figure(figsize=(5, 4))\nplt.title(\"Binary Source PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label='Sqrt Photons')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/sources/#pointresolvedsource","title":"PointResolvedSource","text":"<p>The PointResolved source is a combination of the <code>PointSource</code> and <code>ResolvedSource</code> classes, allowing for a point source and a resolved component to be modelled simultaneously. It has the following attributes:</p> <ol> <li><code>position</code> - the position of the source in the sky, in radians.</li> <li><code>flux</code> - the mean flux of the point and resolved source, in photons.</li> <li><code>contrast</code> - the contrast of the two sources, in photons.</li> <li><code>spectrum</code> - the spectrum of the source.</li> <li><code>distribution</code> - the distribution of the resolved source.</li> </ol> <p>Lets create one and model it through an optical system.</p> <pre><code># Define the source properties\nwavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\ndistribution = np.ones((1, 100))\n\n# Construct the source object and examine it\npoint_resolved = dl.PointResolvedSource(\n    wavelengths, flux=1e6, contrast=5, distribution=distribution\n)\nprint(point_resolved)\n\n# Model the source\npsf = point_resolved.model(optics)\n</code></pre> <pre><code>PointResolvedSource(\n  spectrum=Spectrum(wavelengths=f32[10], weights=f32[2,10]),\n  position=f32[2],\n  flux=1000000.0,\n  distribution=f32[1,100],\n  contrast=5.0\n)\n</code></pre> <pre><code># Plot\nplt.figure(figsize=(5, 4))\nplt.title(\"Point Resolved Source PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label='Sqrt Photons')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/sources/#pointsources","title":"PointSources","text":"<p>The <code>PointSources</code> class is very similar to the <code>PointSource</code> class, simple expanding the first axes of all the <code>PointSource</code> attributes in order to model multiple point sources simultaneously. It has the following attributes:</p> <ol> <li><code>position</code> - the positions of the sources in the sky, in radians.</li> <li><code>flux</code> - the fluxes of the sources, in photons.</li> <li><code>spectrum</code> - the spectrum of the sources.</li> </ol> <p>Lets create one and model it through an optical system.</p> <pre><code>wavelengths = 1e-6 * np.linspace(0.9, 1.1, 10)\ndr = dlu.arcsec2rad(1.5)\npositions = jr.uniform(jr.PRNGKey(0), (20, 2), minval=-dr, maxval=dr)\nfluxes = jr.uniform(jr.PRNGKey(1), (20,), minval=1e3, maxval=1e4)\n\n# Construct the source object and examine it\npoints = dl.PointSources(wavelengths, positions, fluxes)\nprint(points)\n\n# Model the source\npsf = points.model(optics)\n</code></pre> <pre><code>PointSources(\n  spectrum=Spectrum(wavelengths=f32[10], weights=f32[10]),\n  position=f32[20,2],\n  flux=f32[20]\n)\n</code></pre> <pre><code># Plot\nplt.figure(figsize=(5, 4))\nplt.title(\"Point Sources PSF\")\nplt.imshow(psf)\nplt.colorbar(label='Photons')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/introductory/sources/#scene","title":"Scene","text":"<p>The <code>Scene</code> class is a simple container class for <code>Source</code> objects, allowing for multiple sources to be modelled simultaneously. It behaves similarly to optical systems in dLux, taking in a list of <code>Source</code> objects that are stored in a dictionary. Lets model a series of the sources we just created through an optical system.</p> <pre><code># Define the sources\nsources = [(\"resolved\", point_resolved), (\"points\", points)]\n\n# Construct the scene object and examine it\nscene = dl.Scene(sources)\nprint(scene)\n\n# Model the scene\npsf = scene.model(optics)\n</code></pre> <pre><code>Scene(\n  sources={\n    'resolved':\n    PointResolvedSource(\n      spectrum=Spectrum(wavelengths=f32[10], weights=f32[2,10]),\n      position=f32[2],\n      flux=1000000.0,\n      distribution=f32[1,100],\n      contrast=5.0\n    ),\n    'points':\n    PointSources(\n      spectrum=Spectrum(wavelengths=f32[10], weights=f32[10]),\n      position=f32[20,2],\n      flux=f32[20]\n    )\n  }\n)\n</code></pre> <pre><code># Plot\nplt.figure(figsize=(5, 4))\nplt.title(\"Scene PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar(label='Photons')\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2010-2018, Space Telescope Science Institute, AURA All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guide","text":"<p>dLux is an open-source framework and as such is very welcoming to contributions via pull requests! If you would like to contribute but are unfamiliar with any of this process, as I imagine many coming from a science background will be, please feel free to reach out to me at my email or on twitter and I will be happy to help you through the process!</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<p>Firstly, you will need to fork the repository to your own github account. This will allow you to make changes to the code and then submit a pull request to the main repository. To do this, click the fork button in the top right of the repository page. This will create a copy of the repository in your own account that you can make changes to and then request to merge with the main repository.</p> <p>Next, you will need to clone the repository to your local machine. To do this, open a terminal and navigate to the directory you would like to clone the repository to. Then run the following command:</p> <pre><code>https://github.com/your-username-here/dLux.git \ncd dLux\npip install '.[dev]'\n</code></pre> <p>Then you will need to install the pre-commit hooks. This will ensure that the code is formatted correctly and that the unit tests pass before you can commit your changes. To do this, run the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will ensure that any changes you make will adhere to the code style and formatting guidelines of the rest of the package!</p>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":"<p>Next you can start to make any changes you desire!</p> <p>Unit Tests</p> <p>It is important that any changes you make are tested to ensure that they work as intended and do not break any existing functionality. If you are creating new functionality you will need to create some new unit tests, otherwise you should be able to modify the existing tests.</p> <p>To ensure that everything is working as expected, you can run the unit tests by running the following command:</p> <pre><code>pytest tests/*\n</code></pre> <p>This will run all the scripts labelled with <code>test_</code> in the <code>tests</code> directory. If you would like to run a specific test, you can run the following command:</p> <pre><code>pytest tests/test_file.py\n</code></pre> <p>Note that just because the tests pass on your local machine, that does not mean that it will necessarily pass on all others! This can be due to a number of reasons such a different operating system, different python version, or different dependencies. This is why github actions are used to run the unit tests on a number of different operating systems and python versions. This should help ensure that the code works as expected on all platforms.</p> <p>Documentation</p> <p>Any changes you make should also be appropriately documented! For small API changes this shouldn't require any changes, however if you are adding new functionality you will need to add some documentation. This can be done by modifying the appropriates files in the <code>docs</code> directory.</p> <p>To build the documentation locally and make sure everything is working correctly, you can run the following command:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will build the documentation and serve it on a local server. You can then navigate to <code>localhost:8000</code> in your browser to view the documentation.</p>"},{"location":"CONTRIBUTING/#contributing-the-changes","title":"Contributing the Changes","text":"<p>After these steps have been completed, you can commit your changes and push them to your forked repository. These changes should have its formatting and linting checked by the pre-commit hooks. If there are any issues, you will need to fix them before you can commit your changes. Once you have pushed your changes to your forked repository, you can submit a pull request to the main repository. This will allow the maintainers to review your changes and merge them into the main repository!</p>"},{"location":"","title":"Home","text":""},{"location":"#lux","title":"\u2202Lux","text":"<p>Differentiable Optical Models as Parameterised Neural Networks in Jax using Zodiax</p> <p>Contributors: Louis Desdoigts, Jordan Dennis, Adam Taras, Max Charles, Benjamin Pope, Peter Tuthill</p> <p>\u2202Lux is an open-source differentiable optical modelling framework harnessing the structural isomorphism between optical systems and neural networks, giving forwards models of optical systems as parametric neural networks.</p> <p>\u2202Lux is built in Zodiax, which is an open-source object-oriented Jax framework built as an extension of Equinox for scientific programming. This framework allows for the creation of complex optical systems involving many planes, phase and amplitude screens in each, and propagates between them in the Fraunhofer or Fresnel regimes. This enables fast phase retrieval, image deconvolution, and hardware design in high dimensions. Because \u2202Lux models are fully differentiable, you can optimize them by gradient descent over millions of parameters; or use Hamiltonian Monte Carlo to accelerate MCMC sampling. Our code is fully open-source under a 3-clause BSD license, and we encourage you to use it and build on it to solve problems in astronomy and beyond.</p> <p>The \u2202Lux framework is built in Zodiax, which gives it a deep range of capabilities from both Jax and Equinox:</p> <ul> <li> <p>Accelerated Numpy: a Numpy-like API that can run on GPU and TPU</p> </li> <li> <p>Automatic Differentiation: Allows for optimisation and inference in extremely high-dimensional spaces</p> </li> <li> <p>Just-In-Time Compilation: Compiles code into XLA at runtime and optimising execution across hardware</p> </li> <li> <p>Automatic Vectorisation: Allows for simple parallelism across hardware and asynchronous execution </p> </li> </ul> <p>For an overview of these capabilities and different optimisation methods in Zodiax, please go through this Zodiax Tutorial.</p> <p>Documentation: https://louisdesdoigts.github.io/dLux/</p> <p>Requires: Python 3.10+, Jax 0.4.13+, Zodiax 0.4+</p> <p>Installation: <code>pip install dLux</code></p> <p>If you want to run the tutorials locally, you can install the 'extra' dependencies like so: <code>pip install 'dLux[extras]'</code></p>"},{"location":"#collaboration-development","title":"Collaboration &amp; Development","text":"<p>We are always looking to collaborate and further develop this software! We have focused on flexibility and ease of development, so if you have a project you want to use \u2202Lux for, but it currently does not have the required capabilities, have general questions, thoughts or ideas, don't hesitate to email me or contact me on twitter! More details about contributing can be found in our contributing guide.</p>"},{"location":"#publications","title":"Publications","text":"<p>We have a multitude of publications in the pipeline using dLux, some built from our tutorials. To start we would recommend looking at this invited talk on \u2202Lux which gives a good overview and has an attached recording of it being presented! We also have this poster!</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CHANGELOG/","title":"ChangeLog","text":"<p>Project changes will be tracked here once the 1.0 version is released. We will not track changes during the development phase.</p>"}]}