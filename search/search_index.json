{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#lux","title":"\u2202Lux","text":"<p>Differentiable Optical Models as Parameterised Neural Networks in Jax using Zodiax</p> <p>Contributors: Louis Desdoigts, Benjamin Pope, Jordan Dennis, Adam Taras, Peter Tuthill</p> <p>\u2202Lux is an open-source differentiable optical modelling framework harnessing the structural isomorphism between optical systems and neural networks, giving forwards models of optical system as a parametric neural network.</p> <p>\u2202Lux is built in Zodiax which is an open-source object-orineted Jax framework built as an extension of Equinox for scientific programming. This framework allows for the creation of complex optical systems involving many planes, phase and amplitude screens in each, and propagate between them in the Fraunhofer or Fresnel regimes. This enables fast phase retrieval, image deconvolution, and hardware design in high dimensions. Because \u2202Lux models are fully differentiable, you can optimize them by gradient descent over millions of parameters; or use Hamiltonian Monte Carlo to accelerate MCMC sampling. Our code is fully open-source under an MIT license, and we encourage you to use it and build on it to solve problems in astronomy and beyond.</p> <p>The \u2202Lux framwork is built in Zodiax, which gives it a deep range of capabilities from both Jax and Equinox:</p> <ul> <li> <p>Accelerated Numpy: a Numpy like API that can run on GPU and TPU</p> </li> <li> <p>Automatic Differentiation: Allows for optimisation and inference in extremely high dimensional spaces</p> </li> <li> <p>Just-In-Time Compilation: Compliles code into XLA at runtime and optimising execution across hardware</p> </li> <li> <p>Automatic Vectorisation: Allows for simple parallelism across hardware and asynchronys execution</p> </li> <li> <p>Object Oriented Jax: Allows for differentiable classes that are recognised as a valid Jax type</p> </li> <li> <p>Inbuilt Neural Networks: Has pre-built neural network layers classes</p> </li> <li> <p>Path-Based Pytree Interface: Path based indexing allows for easy interfacing with large and highly nested physical models</p> </li> <li> <p>Leaf Manipulation Methods: Inbuilt methods allow for easy manipulation of Pytrees mirroring the Jax Array API</p> </li> </ul> <p>For an overview of these capabilities and different optimisation methods in Zodiax, please go through this Zodiax Tutorial.</p> <p>Doccumentataion: https://louisdesdoigts.github.io/dLux/</p> <p>Installation: <code>pip install dLux</code></p> <p>Requires: Python 3.8+, Jax 0.4.3+, Zodiax 0.3.1+</p>"},{"location":"#collaboration-development","title":"Collaboration &amp; Development","text":"<p>We are always looking to collaborate and further develop this software! We have focused on flexibility and ease of development, so if you have a project you want to use \u2202Lux for, but it currently does not have the required capabilities, don't hesitate to email me and we can discuss how to implement and merge it! Similarly you can take a look at the <code>CONTRIBUTING.md</code> file.</p>"},{"location":"#publications","title":"Publications","text":"<p>We have a multitude of publications in the pipeline using dLux, some built from our tutorials. To start we would recommend looking at this invited talk on \u2202Lux which gives a good overview and has an attatched recording of it being presented! We also have this poster!</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing Guide!","text":""},{"location":"CONTRIBUTING/#-","title":"---","text":""},{"location":"CONTRIBUTING/#units","title":"Units:","text":"<p>All units wihin dLux are SI!</p>"},{"location":"CONTRIBUTING/#adding-to-doccumentation","title":"Adding to doccumentation","text":"<p>When adding to the doccumentation, there are a few steps that need to be done: 1. Create the class or function and add the docstring 2. Create a .md file in the docs/ directory 3. Point to the class/function as so <code>::: dLux.module.new_class</code> 4. Edit the mkdocs.yml file to add the new class 5. Run <code>mkdocs serve</code> to deploy the docs locally at <code>localhost:8000</code> (put this into a browser)</p>"},{"location":"CONTRIBUTING/#building-and-running-unit-tests","title":"Building and running unit-tests","text":"<p>Any added functionality should be unit-tested! This is done with pytest in the tests/ directory. Please have a look at the testing module and try to create tests the match the style!</p> <p>There are three main things we want to test: 1. Constructor assert statements and input types. Ensure that the correct error is thrown and that classes cant be constructed with non compatiable inputs. 2. Test that the different run time logic branches evaluate. 3. Test that the different run time logic branches do not return nan or infinite values.</p>"},{"location":"CONTRIBUTING/#typing-conventions","title":"Typing conventions","text":"<p>So we have worked out a general typing convention for the software. There are two main data-types we care about, Jax data types and others. We denote any jax-types with the <code>Array</code> typing hint. This is simply defined as as a<code>jax.numpy.ndarray</code>, so at the start of any files one should have <code>Array = np.ndarray</code>. Any jax arrays should use this type-hit, regardless of data-type. All other type-hints for dLux type objects should refer to the base object type assuming it is not defined inside that script, ie:</p> <p>dLux.wavefronts.Wavefront dLux.propagators.Propagator dLux.optics.OpticalLayer dLux.base.Instrument</p> <p>For classes defined in the script, add <code>from __future__ import annotations</code> to the first line of the script in order to be able to reference these types within the script.</p>"},{"location":"CONTRIBUTING/#class-inheritance","title":"Class Inheritance","text":"<p>dLux classes are built from <code>Equinox</code> and <code>Zodiax</code>. Any new class types should inherit from either the <code>zodiax.Base</code> or <code>zodiax.ExtendedBase</code> classes, which inherit from <code>equinox.Module</code>, giving the full functionality from both of these packages.</p>"},{"location":"CONTRIBUTING/#code-style-formatting","title":"Code Style &amp; Formatting","text":"<p>All imported functionality should inport the specific method used, as opposed to an full package.</p> <p>For example rather than importing whole package: <pre><code>import abc\n\nclass Foo(abc.ABC):\n    pass\n</code></pre></p> <p>We want to specfically import the function used: <pre><code>from abc import ABC\n\nclass Foo(ABC):\n    pass\n</code></pre></p> <p>Functions and methods with more than two input should spread those inputs over multiple lines, using spaces to format alignment of type hints and default values to help with code readability</p> <p>For example rather than this: <pre><code>def Foo(self: Foo, a: Array = None, b: Array=np.ones(2), c: int=2) -&gt; float:\n    pass\n</code></pre></p> <p>Format like this: <pre><code>def Foo(self : Foo,\n        a    : Array = None,\n        b    : Array = np.ones(2),\n        c    : int   = 2) -&gt; float:\n    pass\n</code></pre></p>"},{"location":"CONTRIBUTING/#constructors","title":"Constructors","text":"<p>Data type enforcing for jax-type arrays: Constructors should be able to take in lists, numpy arrays and python floats, but ensure that they are correctly formatted into jax type arrays like follows:</p> <pre><code>self.parameter = np.asarray(input_parameter, dtype=float)\n</code></pre> <p>This ensures that there is flexibilty in the inputs types and that all data type will match the defauly jax 32 or 64 bit types.</p> <p>All constructor methods should use assert statements to ensure that inputs are correctly formatted at init time. The goal should be if no errors are thrown at init time then all the class methods should work as intended and have correct dimensionality. For \u2202Lux this would typically be testing jax-type and array dimensionality. Do be sure that these enforce correct dimensionality, not just that errors are not thrown.</p> <p>For example if an attribute is a scalar, most methods will work identically if it is zero or one dimenional. For example, enforcing zero-dimensionality for scalars: <pre><code>input_parameter = [1e3]\n\nself.parameter = np.asarray(input_parameter, dtype=float)\nassert self.parameter.ndim == 0, \\\n(\"input_parameter must a scalar array, ie zero dimensional\")\n</code></pre></p>"},{"location":"CONTRIBUTING/#non-differentiable-parameters","title":"Non-differentiable parameters","text":"<p>By default, all parameters should be jax-types. However, parameters that define array shapes or logical flow can be python types (ie int, bool). This prevents issues with jax tracing through arrays of integers which can cause jax errors at runtime.</p>"},{"location":"CONTRIBUTING/#internal-logic-flow","title":"Internal logic flow","text":"<p>Most internal logic within \u2202Lux should be acheived using regular python logic. In some rare cases, <code>jax.lax.cond</code> should be used, but only if the internal logical flow can change during run time. Ie any logic that uses a boolean class attribute can not change during run time, and so should use regular python logic. This helps jax trace through the code and reduces compile time.</p>"},{"location":"CONTRIBUTING/#setter-and-getters","title":"Setter and Getters","text":"<p>By default, getters and setter should be avoided. Most getting and setting can be acheived with nice syntax using the <code>Zodaix</code> methods. There are however some exceptions.</p> <p>Setter: Some class types such as <code>Wavefronts</code> track a lot of parameters that change a lot throughout runtime and so the setter methods are used in conjunction with assert statements to ensure that parameters are not set incorrectly and that the errors are raised at the point where the issue arises, as opposed to some other method recieving an incorrectly shaped array.</p> <p>Getters: For some classes we want to have parameterised values, ie binary stars using sepration and field angle. However, optical modelling methods use cartesian position inputs, so the base <code>Source</code> class implements an abstract <code>.get_position()</code> method to be overwritten by all child classes. In the case of the <code>BinarySource</code> class this method uses the separation and field angle to generate these cartesian values at run time. This means that all other classes in \u2202Lux can assume cartesian positional values and use a single method when working with any <code>Source</code> class. Futhermore, getters can be used to generate useful values. For example wavefronts are store pixel scale and npixles, but implement a class property method for the diameter, which is much more usefull for the <code>Propagator</code> classes.</p>"},{"location":"CONTRIBUTING/#hidden-methods","title":"Hidden methods","text":"<p>In general hidden class methods should be avoided and classes should try to implement methods that allow for them to used stand-alone. For example the <code>CompoundAperture</code> class implements the <code>construct_combined_aperture</code> and <code>get_aperture</code> methods that allow for users to dirctly construct and output the internally stored apertures, or use the <code>make_aperture</code> method to construcut individual apertures.</p>"},{"location":"CONTRIBUTING/#non-circular-imports","title":"Non-Circular imports","text":"<p>To prevent circular imports, you can not import any specific classes or methods within the package, you instead need to import the whole packge (ie <code>import dLux</code>) and then in the code, refer to specific function (ie <code>dLux.sources.Source</code>). This is inconvenient, but just the way python works.</p> <p>exception: The utils package The utils package is the collection of functions that operate independently of the package, and so so can be imported as normal, ie <code>from dLux.utils.coordinates import radians_to_arcseconds</code> etc.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2010-2018, Space Telescope Science Institute, AURA All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"setup/","title":"Setup","text":"In\u00a0[\u00a0]: Copied! <pre>import setuptools\nimport os\nimport codecs\nimport re\n</pre> import setuptools import os import codecs import re In\u00a0[\u00a0]: Copied! <pre>long_description = \"Taking derivatives through Light\"\n</pre> long_description = \"Taking derivatives through Light\" In\u00a0[\u00a0]: Copied! <pre>here = os.path.abspath(os.path.dirname(__file__))\ndef read(*parts):\n    with codecs.open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n</pre> here = os.path.abspath(os.path.dirname(__file__)) def read(*parts):     with codecs.open(os.path.join(here, *parts), 'r') as fp:         return fp.read() In\u00a0[\u00a0]: Copied! <pre>def find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n</pre> def find_version(*file_paths):     version_file = read(*file_paths)     version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)     if version_match:         return version_match.group(1)     raise RuntimeError(\"Unable to find version string.\") In\u00a0[\u00a0]: Copied! <pre># DEPENDENCIES\n# 1. What are the required dependencies?\nwith open('requirements.txt') as f:\n    install_requires = f.read().splitlines()\n# 2. What dependencies required to run the unit tests? (i.e. `pytest --remote-data`)\n# tests_require = ['pytest', 'pytest-cov', 'pytest-remotedata']\n</pre> # DEPENDENCIES # 1. What are the required dependencies? with open('requirements.txt') as f:     install_requires = f.read().splitlines() # 2. What dependencies required to run the unit tests? (i.e. `pytest --remote-data`) # tests_require = ['pytest', 'pytest-cov', 'pytest-remotedata'] In\u00a0[\u00a0]: Copied! <pre>setuptools.setup(\n    python_requires='&gt;=3.7,&lt;4.0',\n    name=\"dLux\",\n    version=find_version(\"dLux\", \"__init__.py\"),\n    description=\"A fully differentiable optical simulator build in Jax\",\n    long_description=long_description,\n\n    author=\"Louis Desdoigts\",\n    author_email=\"Louis.Desdoigts@sydney.edu.au\",\n    url=\"https://github.com/LouisDesdoigts/dLux\",\n\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/LouisDesdoigts/dLux/issues\",\n    },\n\n    install_requires=install_requires,\n\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",\n    ],\n\n    packages = [\"dLux\", \"dLux/utils\"]\n)\n</pre> setuptools.setup(     python_requires='&gt;=3.7,&lt;4.0',     name=\"dLux\",     version=find_version(\"dLux\", \"__init__.py\"),     description=\"A fully differentiable optical simulator build in Jax\",     long_description=long_description,      author=\"Louis Desdoigts\",     author_email=\"Louis.Desdoigts@sydney.edu.au\",     url=\"https://github.com/LouisDesdoigts/dLux\",      project_urls={         \"Bug Tracker\": \"https://github.com/LouisDesdoigts/dLux/issues\",     },      install_requires=install_requires,      classifiers=[         \"Programming Language :: Python :: 3\",         \"Operating System :: OS Independent\",     ],      packages = [\"dLux\", \"dLux/utils\"] )"},{"location":"dLux/__init__/","title":"init","text":"In\u00a0[\u00a0]: Copied! <pre>name = \"dLux\"\n__version__ = \"0.12.0\"\n</pre> name = \"dLux\" __version__ = \"0.12.0\" In\u00a0[\u00a0]: Copied! <pre># Import as modules\nfrom . import core\nfrom . import detectors\nfrom . import optics\nfrom . import wavefronts\nfrom . import propagators\nfrom . import utils\nfrom . import apertures\nfrom . import aberrations\nfrom . import observations\nfrom . import sources\nfrom . import spectrums\nfrom . import exceptions\n</pre> # Import as modules from . import core from . import detectors from . import optics from . import wavefronts from . import propagators from . import utils from . import apertures from . import aberrations from . import observations from . import sources from . import spectrums from . import exceptions In\u00a0[\u00a0]: Copied! <pre># Import core functions from modules\nfrom .core         import *\nfrom .detectors    import *\nfrom .optics       import *\nfrom .wavefronts   import *\nfrom .propagators  import *\nfrom .apertures    import *\nfrom .aberrations  import *\nfrom .observations import *\nfrom .sources      import *\nfrom .spectrums    import *\nfrom .exceptions   import *\n</pre> # Import core functions from modules from .core         import * from .detectors    import * from .optics       import * from .wavefronts   import * from .propagators  import * from .apertures    import * from .aberrations  import * from .observations import * from .sources      import * from .spectrums    import * from .exceptions   import * In\u00a0[\u00a0]: Copied! <pre># Add to __all__\n__all__ = core.__all__ + detectors.__all__ + optics.__all__ + \\\n    wavefronts.__all__ + propagators.__all__ + sources.__all__ + \\\n    spectrums.__all__ + apertures.__all__ + aberrations.__all__ + \\\n    observations.__all__\n</pre> # Add to __all__ __all__ = core.__all__ + detectors.__all__ + optics.__all__ + \\     wavefronts.__all__ + propagators.__all__ + sources.__all__ + \\     spectrums.__all__ + apertures.__all__ + aberrations.__all__ + \\     observations.__all__ In\u00a0[\u00a0]: Copied! <pre># Check for 64-bit\nfrom jax import config\nif not config.x64_enabled:\n    print(\"dLux: Jax is running in 32-bit, to enable 64-bit visit: \"\n          \"https://jax.readthedocs.io/en/latest/notebooks/\"\n          \"Common_Gotchas_in_JAX.html#double-64bit-precision\")\n</pre> # Check for 64-bit from jax import config if not config.x64_enabled:     print(\"dLux: Jax is running in 32-bit, to enable 64-bit visit: \"           \"https://jax.readthedocs.io/en/latest/notebooks/\"           \"Common_Gotchas_in_JAX.html#double-64bit-precision\")"},{"location":"dLux/aberrations/","title":"Aberrations","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom zodiax import Base\nimport jax.numpy as np\nfrom jax import lax\nimport jax.tree_util as jtu\nimport dLux\nfrom dLux.utils.math import factorial\nfrom dLux.utils.coordinates import cartesian_to_polar, get_pixel_positions\n</pre> from __future__ import annotations from zodiax import Base import jax.numpy as np from jax import lax import jax.tree_util as jtu import dLux from dLux.utils.math import factorial from dLux.utils.coordinates import cartesian_to_polar, get_pixel_positions In\u00a0[\u00a0]: Copied! <pre>__all__ = ['Zernike', 'ZernikeBasis', 'AberrationFactory']\n</pre> __all__ = ['Zernike', 'ZernikeBasis', 'AberrationFactory'] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>zernike_names = {\n    # 0th Radial\n    1: 'Piston',\n\n    # 1st Radial\n    2: 'Tilt X',\n    3: 'Tilt Y',\n    \n    # Second Radial\n    4: 'Defocus',\n    5: 'Astig X',\n    6: 'Astig Y',\n    \n    # Third Radial\n    7: 'Coma X',\n    8: 'Coma Y',\n    9: 'Trefoil X',\n    10: 'Trefoil Y',\n\n    # Fourth Radial\n    11: 'Spherical',\n    12: '2nd Astig X',\n    13: '2nd Astig Y',\n    14: 'Quadrafoil X',\n    15: 'Quadrafoil Y',\n    \n    # Fifth Radial\n    16: '2nd Coma X',\n    17: '2nd Coma Y',\n    18: '2nd Trefoil X',\n    19: '2nd Trefoil Y',\n    20: 'Pentafoil X',\n    21: 'Pentafoil Y',\n    \n    # Sixth Radial\n    22: '2nd Spherical',\n    23: '3rd Coma X',\n    24: '3rd Coma Y',\n    25: '3rd Astig X',\n    26: '3rd Astig Y',\n    27: 'Hexafoil X',\n    28: 'Hexafoil Y',\n    \n    # Seventh Radial\n    29: '4th Coma X',\n    30: '4th Coma Y',\n    31: '4th Astig X',\n    32: '4th Astig Y',\n    33: '3rd Trefoil X',\n    34: '3rd Trefoil Y',\n    35: 'Heptafoil X',\n    36: 'Heptafoil Y',\n}\n</pre> zernike_names = {     # 0th Radial     1: 'Piston',      # 1st Radial     2: 'Tilt X',     3: 'Tilt Y',          # Second Radial     4: 'Defocus',     5: 'Astig X',     6: 'Astig Y',          # Third Radial     7: 'Coma X',     8: 'Coma Y',     9: 'Trefoil X',     10: 'Trefoil Y',      # Fourth Radial     11: 'Spherical',     12: '2nd Astig X',     13: '2nd Astig Y',     14: 'Quadrafoil X',     15: 'Quadrafoil Y',          # Fifth Radial     16: '2nd Coma X',     17: '2nd Coma Y',     18: '2nd Trefoil X',     19: '2nd Trefoil Y',     20: 'Pentafoil X',     21: 'Pentafoil Y',          # Sixth Radial     22: '2nd Spherical',     23: '3rd Coma X',     24: '3rd Coma Y',     25: '3rd Astig X',     26: '3rd Astig Y',     27: 'Hexafoil X',     28: 'Hexafoil Y',          # Seventh Radial     29: '4th Coma X',     30: '4th Coma Y',     31: '4th Astig X',     32: '4th Astig Y',     33: '3rd Trefoil X',     34: '3rd Trefoil Y',     35: 'Heptafoil X',     36: 'Heptafoil Y', } In\u00a0[\u00a0]: Copied! <pre>class Zernike(Base):\n\"\"\"\n    A class to generate Zernike polynomials dynamically.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    j : int\n        The Zernike (noll) index.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    name : str\n        The name of the Zernike polynomial.\n    _k : Array\n        The array of powers using the radial calculation. This is a \n        pre-calculated parameter and should not be changed.\n    _c : Array\n        The array of normalisaton coefficients used in the radial calculation.\n        This is a pre-calculated parameter and should not be changed.\n    \"\"\"\n    j    : int\n    n    : int\n    m    : int\n    name : str\n    _k    : Array\n    _c    : Array\n\n    def __init__(self : Zernike, j : int):\n\"\"\"\n        Construct for the Zernike class.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n        \"\"\"\n        if int(j) &lt; 1:\n            raise ValueError('The Zernike index must be greater than 0.')\n        self.j = int(j)\n        self.n, self.m = self._noll_index(self.j)\n        self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n                    else f'Zernike {int(self.j)}'\n\n        # Calcualte values\n        self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n        sign = lax.pow(-1., self._k)\n        _fact_1 = factorial(np.abs(self.n - self._k))\n        _fact_2 = factorial(self._k)\n        _fact_3 = factorial(((self.n + self.m) // 2) - self._k)\n        _fact_4 = factorial(((self.n - self.m) // 2) - self._k)\n        self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4 \n\n\n    def _noll_index(self : Zernike, j : int) -&gt; tuple[int]:\n\"\"\"\n        Calculate the radial and azimuthal orders of the Zernike polynomial.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n\n        Returns\n        -------\n        n, m : tuple[int]\n            The radial and azimuthal orders of the Zernike polynomial.\n        \"\"\"\n        n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)\n        smallest_j_in_row = n * (n + 1) / 2 + 1 \n        number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2\n        sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2\n        base_case = (n &amp; 1)\n        m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)\n        return int(n), int(m)\n    \n\n    def _calculate_radial(self : Zernike, rho : Array) -&gt; Array:\n\"\"\"\n        Calculates the radial component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        rho : Array\n            The radial coordinate of the Zernike polynomial.\n        Returns\n        -------\n        radial : Array\n            The radial component of the Zernike polynomial.\n        \"\"\"\n        rads = lax.pow(rho[:, :, None], \n            (np.abs(self.n) - 2 * self._k)[None, None, :])\n        return (self._c * rads).sum(axis = 2)\n\n\n    def _calculate_azimuthal(self : Zernike, theta : Array) -&gt; Array:\n\"\"\"\n        Calculates the azimuthal component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        theta : Array\n            The azimuthal coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        azimuthal : Array\n            The azimuthal component of the Zernike polynomial.\n        \"\"\"\n        norm_coeff = np.sqrt(self.n + 1)\n        if self.m != 0:\n            norm_coeff *= 1 + (np.sqrt(2) - 1)\n        \n        if self.m &gt;= 0:\n            return norm_coeff * np.cos(np.abs(self.m) * theta)\n        else:\n            return norm_coeff * np.sin(np.abs(self.m) * theta)\n        \n\n    def calculate_zernike(self : Zernike, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        polar_coordinates = cartesian_to_polar(coordinates)\n        rho = polar_coordinates[0]\n        theta = polar_coordinates[1]\n        aperture = rho &lt;= 1.\n        return aperture * self._calculate_radial(rho) * \\\n            self._calculate_azimuthal(theta)\n    \n\n    def calculate_polike(self        : Zernike, \n                         coordinates : Array, \n                         nsides      : int) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial on an nsided aperture.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture.\n\n        Returns\n        -------\n        polike : Array\n            The Zernike polynomial on an nsided aperture.\n        \"\"\"\n        if nsides &lt; 3:\n            raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n        theta = cartesian_to_polar(coordinates)[1]\n        alpha = np.pi / nsides\n        phi = theta + alpha  \n        wedge = np.floor((phi + alpha) / (2. * alpha))\n        u_alpha = phi - wedge * (2 * alpha)\n        r_alpha = np.cos(alpha) / np.cos(u_alpha)\n        return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n\n\n    def calculate(self        : Zernike, \n                  coordinates : Array, \n                  nsides      : int = 0) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike polynomial\n            is calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        if nsides == 0:\n            return self.calculate_zernike(coordinates)\n        else:\n            return self.calculate_polike(coordinates, nsides)\n</pre> class Zernike(Base):     \"\"\"     A class to generate Zernike polynomials dynamically.      The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).     The basic translation between the noll index and the pair of numbers is     shown below:      1 -&gt; (0, 0)      2, 3 -&gt; (1, -1), (1, 1)      4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)      7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)           Attributes     ----------     j : int         The Zernike (noll) index.     n : int         The radial order of the Zernike polynomial.     m : int         The azimuthal order of the Zernike polynomial.     name : str         The name of the Zernike polynomial.     _k : Array         The array of powers using the radial calculation. This is a          pre-calculated parameter and should not be changed.     _c : Array         The array of normalisaton coefficients used in the radial calculation.         This is a pre-calculated parameter and should not be changed.     \"\"\"     j    : int     n    : int     m    : int     name : str     _k    : Array     _c    : Array      def __init__(self : Zernike, j : int):         \"\"\"         Construct for the Zernike class.          Parameters         ----------         j : int             The Zernike (noll) index.         \"\"\"         if int(j) &lt; 1:             raise ValueError('The Zernike index must be greater than 0.')         self.j = int(j)         self.n, self.m = self._noll_index(self.j)         self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\                     else f'Zernike {int(self.j)}'          # Calcualte values         self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)         sign = lax.pow(-1., self._k)         _fact_1 = factorial(np.abs(self.n - self._k))         _fact_2 = factorial(self._k)         _fact_3 = factorial(((self.n + self.m) // 2) - self._k)         _fact_4 = factorial(((self.n - self.m) // 2) - self._k)         self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4        def _noll_index(self : Zernike, j : int) -&gt; tuple[int]:         \"\"\"         Calculate the radial and azimuthal orders of the Zernike polynomial.          Parameters         ----------         j : int             The Zernike (noll) index.          Returns         -------         n, m : tuple[int]             The radial and azimuthal orders of the Zernike polynomial.         \"\"\"         n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)         smallest_j_in_row = n * (n + 1) / 2 + 1          number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2         sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2         base_case = (n &amp; 1)         m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)         return int(n), int(m)           def _calculate_radial(self : Zernike, rho : Array) -&gt; Array:         \"\"\"         Calculates the radial component of the Zernike polynomial.          Parameters         ----------         rho : Array             The radial coordinate of the Zernike polynomial.                  Returns         -------         radial : Array             The radial component of the Zernike polynomial.         \"\"\"         rads = lax.pow(rho[:, :, None],              (np.abs(self.n) - 2 * self._k)[None, None, :])         return (self._c * rads).sum(axis = 2)       def _calculate_azimuthal(self : Zernike, theta : Array) -&gt; Array:         \"\"\"         Calculates the azimuthal component of the Zernike polynomial.          Parameters         ----------         theta : Array             The azimuthal coordinate of the Zernike polynomial.          Returns         -------         azimuthal : Array             The azimuthal component of the Zernike polynomial.         \"\"\"         norm_coeff = np.sqrt(self.n + 1)         if self.m != 0:             norm_coeff *= 1 + (np.sqrt(2) - 1)                  if self.m &gt;= 0:             return norm_coeff * np.cos(np.abs(self.m) * theta)         else:             return norm_coeff * np.sin(np.abs(self.m) * theta)               def calculate_zernike(self : Zernike, coordinates : Array) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The cartesian coordinates to calcualte the Zernike polynomial upon.                  Returns         -------         zernike : Array             The Zernike polynomial.         \"\"\"         polar_coordinates = cartesian_to_polar(coordinates)         rho = polar_coordinates[0]         theta = polar_coordinates[1]         aperture = rho &lt;= 1.         return aperture * self._calculate_radial(rho) * \\             self._calculate_azimuthal(theta)           def calculate_polike(self        : Zernike,                           coordinates : Array,                           nsides      : int) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial on an nsided aperture.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The cartesian coordinates to calcualte the Zernike polynomial upon.         nsides : int             The number of sides of the aperture.          Returns         -------         polike : Array             The Zernike polynomial on an nsided aperture.         \"\"\"         if nsides &lt; 3:             raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')         theta = cartesian_to_polar(coordinates)[1]         alpha = np.pi / nsides         phi = theta + alpha           wedge = np.floor((phi + alpha) / (2. * alpha))         u_alpha = phi - wedge * (2 * alpha)         r_alpha = np.cos(alpha) / np.cos(u_alpha)         return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)       def calculate(self        : Zernike,                    coordinates : Array,                    nsides      : int = 0) -&gt; Array:         \"\"\"         Calculates the Zernike polynomial.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Array             The cartesian coordinates to calcualte the Zernike polynomial upon.         nsides : int             The number of sides of the aperture. If 0, the Zernike polynomial             is calculated on a circular aperture.          Returns         -------         zernike : Array             The Zernike polynomial.         \"\"\"         if nsides == 0:             return self.calculate_zernike(coordinates)         else:             return self.calculate_polike(coordinates, nsides) In\u00a0[\u00a0]: Copied! <pre>class ZernikeBasis(Base):\n\"\"\"\n    A class to calculate a set of Zernike polynomials on a dynamic set of\n    coordiantes.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n    1 -&gt; (0, 0)\n    2, 3 -&gt; (1, -1), (1, 1)\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    zernikes : list[Zernike]\n        The list of Zernike polynomial classes to calculate.\n    \"\"\"\n    zernikes : list[Zernike]\n\n\n    def __init__(self : ZernikeBasis, js : list[int]):\n\"\"\"\n        Constructor for the DynamicZernike class.\n\n        Parameters\n        ----------\n        js : list[int]\n            The list of Zernike (noll) indices to calculate.\n        \"\"\"\n        self.zernikes = [Zernike(j) for j in js]\n    \n\n    def calculate_basis(self        : ZernikeBasis, \n                        coordinates : Array, \n                        nsides      : int = 0) -&gt; Array:\n\"\"\"\n        Calculates the full Zernike polynomial basis.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Arraya\n            The cartesian coordinates to calcualte the Zernike basis upon.\n        Returns\n        -------\n        zernike_basis : Array\n            The Zernike polynomial basis.\n        \"\"\"\n        leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n        calculate_fn = lambda z: z.calculate(coordinates, nsides)\n        return np.array(jtu.tree_map(calculate_fn, self.zernikes, \n                                     is_leaf=leaf_fn))\n</pre> class ZernikeBasis(Base):     \"\"\"     A class to calculate a set of Zernike polynomials on a dynamic set of     coordiantes.      The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).     The basic translation between the noll index and the pair of numbers is     shown below:          1 -&gt; (0, 0)          2, 3 -&gt; (1, -1), (1, 1)          4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)          7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)      Attributes     ----------     zernikes : list[Zernike]         The list of Zernike polynomial classes to calculate.     \"\"\"     zernikes : list[Zernike]       def __init__(self : ZernikeBasis, js : list[int]):         \"\"\"         Constructor for the DynamicZernike class.          Parameters         ----------         js : list[int]             The list of Zernike (noll) indices to calculate.         \"\"\"         self.zernikes = [Zernike(j) for j in js]           def calculate_basis(self        : ZernikeBasis,                          coordinates : Array,                          nsides      : int = 0) -&gt; Array:         \"\"\"         Calculates the full Zernike polynomial basis.          Note: The zernike polynomial is defined on the coordinates up to a         radial value of 1.          Parameters         ----------         coordinates : Arraya             The cartesian coordinates to calcualte the Zernike basis upon.                  Returns         -------         zernike_basis : Array             The Zernike polynomial basis.         \"\"\"         leaf_fn = lambda leaf: isinstance(leaf, Zernike)         calculate_fn = lambda z: z.calculate(coordinates, nsides)         return np.array(jtu.tree_map(calculate_fn, self.zernikes,                                       is_leaf=leaf_fn)) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class AberrationFactory():\n\"\"\"\n    This class is not actually ever instatiated, but is rather a class used to \n    give a simple constructor interface that is used to construct the most\n    commonly used aberrations. It is able to construct hard-edged circular or \n    regular poygonal aberrations. \n\n    Lets look at an example of how to construct a simple circular aberration \n    class. Let calcualte this for a 512x512 array with the aperture spanning\n    the full array.\n\n    ```python\n    from dLux import AberrationFactory\n    import jax.numpy as np\n    import jax.random as jr\n    # Construct Zernikes\n    zernikes = np.arange(4, 11)\n    coefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n    # Construct aberrations\n    aberrations = AberrationFactory(512, zernikes=zernikes, \n                                    coefficients=coefficients)\n    ```\n    The resulting aperture class has two parameters, `.basis` and \n    `.coefficients`. We can then examine the opd like so:\n\n    ```python\n    import matplotlib.pyplot as plt\n    plt.figure(figsize=(5, 4))\n    plt.imshow(aberrations.get_opd())\n    plt.colorbar()\n    plt.show()\n    ```\n\n    We can also easily change this to a hexagonal aperture:\n\n    ```python\n    # Construct aberrations\n    aberrations = AberrationFactory(512, nsides=6, zernikes=zernikes, \n                                    coefficients=coefficients)\n    # Examine\n    plt.figure(figsize=(5, 4))\n    plt.imshow(aberrations.get_opd())\n    plt.colorbar()\n    plt.show()\n    ```\n    \"\"\"\n    def __new__(cls              : AberrationFactory, \n                npixels          : int, \n                nsides           : int   = 0,\n                rotation         : float = 0., \n\n                # Sizing\n                aperutre_ratio   : float = 1.0,\n\n                # Aberrations\n                zernikes         : Array = None, \n                coefficients     : Array = None, \n\n                # name\n                name             : str = None):\n\"\"\"\n        Constructs a basic single static aberration class.\n\n        TODO: Add link to the zenike noll indicies\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperutre_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n        Returns\n        -------\n        aperture : ApplyBasisOPD\n            Returns an appropriately constructed ApplyBasisOPD.\n        \"\"\"\n        # Check vaid inputs\n        if nsides &lt; 3 and nsides != 0:\n            raise ValueError(\"nsides must be either 0 or &gt;=3\")\n        \n        # Auto-name\n        if name is None:\n            if nsides &gt; 8:\n                raise ValueError(\"Warning: Auto-naming not supported for \" + \\\n                \"nsides &gt; 8. Please provide a name.\")\n            sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\", \n                \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]\n            name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"\n\n\n        # Construct coordinates\n        coords = get_pixel_positions((npixels, npixels), (1/npixels, 1/npixels))\n\n        # Circular Primary\n        if nsides == 0:\n            ap = dLux.apertures.CircularAperture\n            dyn_aperture = ap(aperutre_ratio/2, softening=0)\n            coordinates = dyn_aperture._normalised_coordinates(coords)\n\n        # Polygonal Primary\n        else: \n            ap = dLux.apertures.RegularPolygonalAperture\n            dyn_aperture = ap(nsides, aperutre_ratio/2, softening=0, \n                          rotation=rotation)\n            coordinates = dyn_aperture._normalised_coordinates(coords, nsides)\n\n        # Construct Aberrations\n        basis = ZernikeBasis(zernikes).calculate_basis(coordinates)\n        return dLux.optics.ApplyBasisOPD(basis, coefficients, name=name)\n\n\n    def __init__(self              : AberrationFactory, \n                npixels          : int, \n                nsides           : int   = 0,\n                rotation         : float = 0., \n\n                # Sizing\n                aperutre_ratio   : float = 1.0,\n\n                # Aberrations\n                zernikes         : Array = None, \n                coefficients     : Array = None, \n\n                # name\n                name             : str = None):\n\"\"\"\n        Constructs a basic single static aberration class.\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperutre_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n        Returns\n        -------\n        aperture : ApplyBasisOPD\n            Returns an appropriately constructed ApplyBasisOPD.\n        \"\"\"\n</pre> class AberrationFactory():     \"\"\"     This class is not actually ever instatiated, but is rather a class used to      give a simple constructor interface that is used to construct the most     commonly used aberrations. It is able to construct hard-edged circular or      regular poygonal aberrations.       Lets look at an example of how to construct a simple circular aberration      class. Let calcualte this for a 512x512 array with the aperture spanning     the full array.      ```python     from dLux import AberrationFactory     import jax.numpy as np     import jax.random as jr          # Construct Zernikes     zernikes = np.arange(4, 11)     coefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))      # Construct aberrations     aberrations = AberrationFactory(512, zernikes=zernikes,                                      coefficients=coefficients)     ```          The resulting aperture class has two parameters, `.basis` and      `.coefficients`. We can then examine the opd like so:      ```python     import matplotlib.pyplot as plt     plt.figure(figsize=(5, 4))     plt.imshow(aberrations.get_opd())     plt.colorbar()     plt.show()     ```      We can also easily change this to a hexagonal aperture:      ```python     # Construct aberrations     aberrations = AberrationFactory(512, nsides=6, zernikes=zernikes,                                      coefficients=coefficients)          # Examine     plt.figure(figsize=(5, 4))     plt.imshow(aberrations.get_opd())     plt.colorbar()     plt.show()     ```     \"\"\"     def __new__(cls              : AberrationFactory,                  npixels          : int,                  nsides           : int   = 0,                 rotation         : float = 0.,                   # Sizing                 aperutre_ratio   : float = 1.0,                  # Aberrations                 zernikes         : Array = None,                  coefficients     : Array = None,                   # name                 name             : str = None):         \"\"\"         Constructs a basic single static aberration class.          TODO: Add link to the zenike noll indicies          Parameters         ----------         npixels : int             Number of pixels used to represent the aperture.         nsides : int = 0             Number of sides of the aperture. A zero input results in a circular             aperture. All other other values of three and above are supported.         rotation : float, radians = 0             The global rotation of the aperture in radians.         aperutre_ratio : float = 1.             The ratio of the aperture size to the array size. A value of 1.              results in an aperture that fully spans the array, a value of 0.5              retuls in an aperure that is half the size of the array, which is              equivilent to a padding factor of 2.         zernikes : Array = None             The zernike noll indices to be used for the aberrations. Please              refer to (this)[Add this link] docstring to see which indicides              correspond to which aberrations. Typical values are range(4, 11).         coefficients : Array = None             The zernike cofficients to be applied to the aberrations. Defaults              to an array of zeros.         name : str = None             The name of the aperture used to index the layers dictionary. If              not supplied, the aperture will be named based on the number of             sides. However this is only supported up to 8 sides, and a name             must be supplied for apertures with more than 8 sides.                  Returns         -------         aperture : ApplyBasisOPD             Returns an appropriately constructed ApplyBasisOPD.         \"\"\"         # Check vaid inputs         if nsides &lt; 3 and nsides != 0:             raise ValueError(\"nsides must be either 0 or &gt;=3\")                  # Auto-name         if name is None:             if nsides &gt; 8:                 raise ValueError(\"Warning: Auto-naming not supported for \" + \\                 \"nsides &gt; 8. Please provide a name.\")             sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\",                  \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]             name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"           # Construct coordinates         coords = get_pixel_positions((npixels, npixels), (1/npixels, 1/npixels))          # Circular Primary         if nsides == 0:             ap = dLux.apertures.CircularAperture             dyn_aperture = ap(aperutre_ratio/2, softening=0)             coordinates = dyn_aperture._normalised_coordinates(coords)          # Polygonal Primary         else:              ap = dLux.apertures.RegularPolygonalAperture             dyn_aperture = ap(nsides, aperutre_ratio/2, softening=0,                            rotation=rotation)             coordinates = dyn_aperture._normalised_coordinates(coords, nsides)          # Construct Aberrations         basis = ZernikeBasis(zernikes).calculate_basis(coordinates)         return dLux.optics.ApplyBasisOPD(basis, coefficients, name=name)       def __init__(self              : AberrationFactory,                  npixels          : int,                  nsides           : int   = 0,                 rotation         : float = 0.,                   # Sizing                 aperutre_ratio   : float = 1.0,                  # Aberrations                 zernikes         : Array = None,                  coefficients     : Array = None,                   # name                 name             : str = None):         \"\"\"         Constructs a basic single static aberration class.          Parameters         ----------         npixels : int             Number of pixels used to represent the aperture.         nsides : int = 0             Number of sides of the aperture. A zero input results in a circular             aperture. All other other values of three and above are supported.         rotation : float, radians = 0             The global rotation of the aperture in radians.         aperutre_ratio : float = 1.             The ratio of the aperture size to the array size. A value of 1.              results in an aperture that fully spans the array, a value of 0.5              retuls in an aperure that is half the size of the array, which is              equivilent to a padding factor of 2.         zernikes : Array = None             The zernike noll indices to be used for the aberrations. Please              refer to (this)[Add this link] docstring to see which indicides              correspond to which aberrations. Typical values are range(4, 11).         coefficients : Array = None             The zernike cofficients to be applied to the aberrations. Defaults              to an array of zeros.         name : str = None             The name of the aperture used to index the layers dictionary. If              not supplied, the aperture will be named based on the number of             sides. However this is only supported up to 8 sides, and a name             must be supplied for apertures with more than 8 sides.                  Returns         -------         aperture : ApplyBasisOPD             Returns an appropriately constructed ApplyBasisOPD.         \"\"\""},{"location":"dLux/apertures/","title":"Apertures","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport dLux\nfrom abc import ABC, abstractmethod\nfrom jax import numpy as np, lax, vmap\nfrom jax.tree_util import tree_map, tree_flatten\nfrom equinox import filter\nfrom dLux.utils import get_pixel_positions, coordinates as c, opd_to_phase, \\\n    list_to_dictionary\nfrom dLux.utils.units import convert_angular, convert_cartesian\n\n\nArray = np.ndarray\nWavefront = dLux.wavefronts.Wavefront\nOpticalLayer = dLux.optics.OpticalLayer\n\n\n__all__ = [\"CircularAperture\", \"SquareAperture\", \"HexagonalAperture\", \n           \"RegularPolygonalAperture\", \"IrregularPolygonalAperture\", \n           \"StaticAperture\", \"AberratedAperture\", \"StaticAberratedAperture\", \n           \"AnnularAperture\", \"RectangularAperture\", \"CompoundAperture\", \n           \"MultiAperture\", \"UniformSpider\", \"ApertureFactory\"]\n\n\ntwo_pi = 2. * np.pi\n\n\nclass ApertureLayer(OpticalLayer, ABC):\n\"\"\"\n    The abstract base class that all aperture layers inherit from. This \n    instatiates the OpticalLayer class, intialising the name and providing\n    the correct functionality for the `__call__` method.\n    Attributes\n    ----------\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n    \n    def __init__(self : OpticalLayer, \n                 name : str = \"ApertureLayer\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the ApertureLayer class, instatiating the OpticalLayer \n        class.\n\n        Parameters\n        ----------\n        name : str = 'ApertureLayer'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n\n\n    @abstractmethod\n    def _aperture(self        : ApertureLayer, \n                  coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n\n\n    def get_aperture(self     : ApertureLayer, \n                     npixels  : int, \n                     diameter : float) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on a set of coordinates \n        with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._aperture(coordinates)\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture to an incoming wavefront.\n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront before encountering the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after encountering the aperture.\n        \"\"\"\n        coordinates = wavefront.pixel_coordinates\n        aperture = self._aperture(coordinates)\n        return wavefront.multiply_amplitude(aperture)\n\n\nclass AbstractDynamicAperture(ApertureLayer, ABC):\n\"\"\"\n    Abstract base class instatiating a series of methods designed to generate\n    apertures differentiably at run-time. This class primarily implements the \n    coordinate transformations that can be applied to each aperture in order to \n    have fully control over the aperture shape, and apply global transformations\n    to the apertures.\n    Attributes\n    ----------\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    centre      : Array\n    shear       : Array\n    compression : Array\n    rotation    : Array\n    \n\n    def __init__(self        : ApertureLayer, \n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = 'AbstractDynamicAperture'\n                 ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the AbstractDynamicAperture class.\n\n        Parameters\n        ----------\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'AbstractDynamicAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n\n        self.centre = np.asarray(centre).astype(float)\n        self.shear = np.asarray(shear).astype(float)\n        self.compression = np.asarray(compression).astype(float)\n        self.rotation = np.asarray(rotation).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims(self.centre.shape, (2,), \"centre\")\n        dLux.exceptions.validate_eq_attr_dims(self.shear.shape, (2,), \"shear\")\n        dLux.exceptions.validate_eq_attr_dims(\n            self.compression.shape, (2,), \"compression\")\n        dLux.exceptions.validate_eq_attr_dims(\n            self.rotation.shape, (), \"rotation\")\n\n\n    def _coordinates(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Transform the input coordinates into the coordinate system of the \n        aperture. \n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to transform.\n\n        Returns\n        -------\n        coordinates: Array, meters\n            The coordinates of the `Aperture`.\n        \"\"\"\n        is_trans = (self.centre != np.zeros((2,), float)).any()\n        coordinates = lax.cond(is_trans,\n            lambda: c.translate(coordinates, self.centre),\n            lambda: coordinates)\n\n        is_compr = (self.compression != np.ones((2,), float)).any()\n        coordinates = lax.cond(is_compr,\n            lambda: c.compress(coordinates, \\\n                self.compression),\n            lambda: coordinates)\n\n        is_shear = (self.shear != np.zeros((2,), float)).any()\n        coordinates = lax.cond(is_shear,\n            lambda: c.shear(coordinates, self.shear),\n            lambda: coordinates)\n\n        is_rot = (self.rotation != 0.)\n        coordinates = lax.cond(is_rot,\n            lambda: c.rotate(coordinates, self.rotation),\n            lambda: coordinates)\n\n        return coordinates\n\n\nclass DynamicAperture(AbstractDynamicAperture, ABC):\n\"\"\"\n    An abstract base class that implements the methods required to provide soft\n    edges to the apertures and generate either transmissive or occulting \n    apertures.\n\n    Attributes\n    ----------\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    occulting : bool \n    softening : Array\n    \n\n    def __init__(self        : ApertureLayer, \n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = 'DynamicAperture') -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the DynamicAperture class.\n\n        Parameters\n        ----------\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'DynamicAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre,\n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n        self.occulting = bool(occulting)\n        self.softening = np.asarray(softening).astype(float) \n        dLux.exceptions.validate_eq_attr_dims((), self.softening.shape, \n                                              \"softening\")\n\n\n    @abstractmethod\n    def _extent(self : ApertureLayer) -&gt; Array: # pragma: no cover\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre. For inherited classes, consider implementing analytically for \n        speed.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n\n\n    @abstractmethod\n    def _soft_edged(self        : ApertureLayer, \n                    coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n\n\n    @abstractmethod\n    def _hard_edged(self        : ApertureLayer, \n                    coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n\n\n    def _soften(self : ApertureLayer, distances : Array) -&gt; Array:\n\"\"\"\n        Converts the distances from an edge into a soft edged transmission array\n        using a tanh function.\n\n        Parameters\n        ----------\n        distances: Array\n            The distances from an edge the the aperture.\n\n        Returns\n        -------\n        transmission: Array\n            The softened transmission of the aperture edge based on the input\n            distances.\n        \"\"\"\n        steepness = 3. / self.softening * distances.shape[-1]\n        return (np.tanh(steepness * distances) + 1.) / 2.\n\n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        coordinates = self._coordinates(coordinates) \n\n        aperture = lax.cond(\n            (self.softening != 0.).any(),\n            lambda coords: self._soft_edged(coords),\n            lambda coords: self._hard_edged(coords).astype(float),\n            coordinates)\n\n        # TODO: Workout how to recast this using raw logic and see \n        #       if it is faster or not. Need to lok at the `jaxpr` \n        #       for python if statements like this and to try \n        #       work-out if extra stuff is getting done.\n        if self.occulting:\n            aperture = (1. - aperture)\n\n        return aperture\n\n\n    def _normalised_coordinates(self        : ApertureLayer, \n                                coordinates : Array) -&gt; Array:\n\"\"\"\n        Shift a set of coodinates to be centered on the aperture and scaled such\n        that the radial distance is 1 to the edge of the aperture.\n\n        ### Here\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n        Returns\n        -------\n        coordinates : Array, meters\n            The coordinate system centered on the aperture with radius \n            normalised the maximum distance of an edge from the center.\n        \"\"\"\n        return self._coordinates(coordinates) / self._extent()\n</pre> from __future__ import annotations import dLux from abc import ABC, abstractmethod from jax import numpy as np, lax, vmap from jax.tree_util import tree_map, tree_flatten from equinox import filter from dLux.utils import get_pixel_positions, coordinates as c, opd_to_phase, \\     list_to_dictionary from dLux.utils.units import convert_angular, convert_cartesian   Array = np.ndarray Wavefront = dLux.wavefronts.Wavefront OpticalLayer = dLux.optics.OpticalLayer   __all__ = [\"CircularAperture\", \"SquareAperture\", \"HexagonalAperture\",             \"RegularPolygonalAperture\", \"IrregularPolygonalAperture\",             \"StaticAperture\", \"AberratedAperture\", \"StaticAberratedAperture\",             \"AnnularAperture\", \"RectangularAperture\", \"CompoundAperture\",             \"MultiAperture\", \"UniformSpider\", \"ApertureFactory\"]   two_pi = 2. * np.pi   class ApertureLayer(OpticalLayer, ABC):     \"\"\"     The abstract base class that all aperture layers inherit from. This      instatiates the OpticalLayer class, intialising the name and providing     the correct functionality for the `__call__` method.          Attributes     ----------     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"           def __init__(self : OpticalLayer,                   name : str = \"ApertureLayer\") -&gt; ApertureLayer:         \"\"\"         Constructor for the ApertureLayer class, instatiating the OpticalLayer          class.          Parameters         ----------         name : str = 'ApertureLayer'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)       @abstractmethod     def _aperture(self        : ApertureLayer,                    coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"       def get_aperture(self     : ApertureLayer,                       npixels  : int,                       diameter : float) -&gt; Array:         \"\"\"         Compute the array representing the aperture on a set of coordinates          with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._aperture(coordinates)       def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the aperture to an incoming wavefront.          Parameters         ----------         wavefront: Wavefront             The wavefront before encountering the aperture.          Returns         -------         wavefront: Wavefront             The wavefront after encountering the aperture.         \"\"\"         coordinates = wavefront.pixel_coordinates         aperture = self._aperture(coordinates)         return wavefront.multiply_amplitude(aperture)   class AbstractDynamicAperture(ApertureLayer, ABC):     \"\"\"     Abstract base class instatiating a series of methods designed to generate     apertures differentiably at run-time. This class primarily implements the      coordinate transformations that can be applied to each aperture in order to      have fully control over the aperture shape, and apply global transformations     to the apertures.          Attributes     ----------     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     centre      : Array     shear       : Array     compression : Array     rotation    : Array           def __init__(self        : ApertureLayer,                   centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  name        : str   = 'AbstractDynamicAperture'                  ) -&gt; ApertureLayer:         \"\"\"         Constructor for the AbstractDynamicAperture class.          Parameters         ----------         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         name: str = 'AbstractDynamicAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)          self.centre = np.asarray(centre).astype(float)         self.shear = np.asarray(shear).astype(float)         self.compression = np.asarray(compression).astype(float)         self.rotation = np.asarray(rotation).astype(float)          dLux.exceptions.validate_eq_attr_dims(self.centre.shape, (2,), \"centre\")         dLux.exceptions.validate_eq_attr_dims(self.shear.shape, (2,), \"shear\")         dLux.exceptions.validate_eq_attr_dims(             self.compression.shape, (2,), \"compression\")         dLux.exceptions.validate_eq_attr_dims(             self.rotation.shape, (), \"rotation\")       def _coordinates(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Transform the input coordinates into the coordinate system of the          aperture.           Parameters         ----------         coordinates: Array, meters             The coordinates to transform.          Returns         -------         coordinates: Array, meters             The coordinates of the `Aperture`.         \"\"\"         is_trans = (self.centre != np.zeros((2,), float)).any()         coordinates = lax.cond(is_trans,             lambda: c.translate(coordinates, self.centre),             lambda: coordinates)          is_compr = (self.compression != np.ones((2,), float)).any()         coordinates = lax.cond(is_compr,             lambda: c.compress(coordinates, \\                 self.compression),             lambda: coordinates)          is_shear = (self.shear != np.zeros((2,), float)).any()         coordinates = lax.cond(is_shear,             lambda: c.shear(coordinates, self.shear),             lambda: coordinates)          is_rot = (self.rotation != 0.)         coordinates = lax.cond(is_rot,             lambda: c.rotate(coordinates, self.rotation),             lambda: coordinates)          return coordinates   class DynamicAperture(AbstractDynamicAperture, ABC):     \"\"\"     An abstract base class that implements the methods required to provide soft     edges to the apertures and generate either transmissive or occulting      apertures.      Attributes     ----------     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     occulting : bool      softening : Array           def __init__(self        : ApertureLayer,                   centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = 'DynamicAperture') -&gt; ApertureLayer:         \"\"\"         Constructor for the DynamicAperture class.          Parameters         ----------         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'DynamicAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                          shear = shear,                          compression = compression,                          rotation = rotation,                          name = name)         self.occulting = bool(occulting)         self.softening = np.asarray(softening).astype(float)          dLux.exceptions.validate_eq_attr_dims((), self.softening.shape,                                                \"softening\")       @abstractmethod     def _extent(self : ApertureLayer) -&gt; Array: # pragma: no cover         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre. For inherited classes, consider implementing analytically for          speed.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"       @abstractmethod     def _soft_edged(self        : ApertureLayer,                      coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"       @abstractmethod     def _hard_edged(self        : ApertureLayer,                      coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"       def _soften(self : ApertureLayer, distances : Array) -&gt; Array:         \"\"\"         Converts the distances from an edge into a soft edged transmission array         using a tanh function.          Parameters         ----------         distances: Array             The distances from an edge the the aperture.          Returns         -------         transmission: Array             The softened transmission of the aperture edge based on the input             distances.         \"\"\"         steepness = 3. / self.softening * distances.shape[-1]         return (np.tanh(steepness * distances) + 1.) / 2.       def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         coordinates = self._coordinates(coordinates)           aperture = lax.cond(             (self.softening != 0.).any(),             lambda coords: self._soft_edged(coords),             lambda coords: self._hard_edged(coords).astype(float),             coordinates)          # TODO: Workout how to recast this using raw logic and see          #       if it is faster or not. Need to lok at the `jaxpr`          #       for python if statements like this and to try          #       work-out if extra stuff is getting done.         if self.occulting:             aperture = (1. - aperture)          return aperture       def _normalised_coordinates(self        : ApertureLayer,                                  coordinates : Array) -&gt; Array:         \"\"\"         Shift a set of coodinates to be centered on the aperture and scaled such         that the radial distance is 1 to the edge of the aperture.          ### Here          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.                  Returns         -------         coordinates : Array, meters             The coordinate system centered on the aperture with radius              normalised the maximum distance of an edge from the center.         \"\"\"         return self._coordinates(coordinates) / self._extent()    In\u00a0[\u00a0]: Copied! <pre>class CircularAperture(DynamicAperture):\n\"\"\"\n    A circular aperture parameterised by its radius.\n\n    Attributes\n    ----------\n    radius: Array, meters\n        The radius of the aperture. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    radius : Array\n\n \n    def __init__(self        : ApertureLayer, \n                 radius      : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 occulting   : bool = False, \n                 softening   : Array = np.array(1.),\n                 name        : str = \"CircularAperture\",\n                 ) -&gt; Array:\n\"\"\"\n        Constructor for the CircularAperture class.\n\n        Parameters\n        ----------\n        radius: Array, meters \n            The radius of the aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'CircularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name) \n\n        self.radius = np.asarray(radius).astype(float)\n        dLux.exceptions.validate_eq_attr_dims((), self.radius.shape, \"radius\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(- coordinates + self.radius)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return (coordinates &lt; self.radius).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.radius\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        radius = convert_cartesian(self.radius, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Circular Aperture with radius \"\n                   f\"{radius} {cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass AnnularAperture(DynamicAperture):\n\"\"\"\n    An annular aperture defined by its inner and outer radii.\n\n    Attributes\n    ----------\n    rmax: Array, meters\n        Outer radius of aperture.\n    rmin: Array, meters\n        Inner radius of aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    rmin : Array\n    rmax : Array\n\n    \n    def __init__(self        : ApertureLayer, \n                 rmax        : Array, \n                 rmin        : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"AnnularAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the AnnularAperture class.\n\n        Parameters\n        ----------\n        rmax : Array, meters\n            The outer radius of the aperture. \n        rmin : Array, meters\n            The inner radius of the aperture. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'AnnularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.rmax = np.asarray(rmax).astype(float)\n        self.rmin = np.asarray(rmin).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n        dLux.exceptions.validate_eq_attr_dims((), self.rmin.shape, \"rmin\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(coordinates - self.rmin) * \\\n            self._soften(- coordinates + self.rmax)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return ((coordinates &gt; self.rmin) * \\\n            (coordinates &lt; self.rmax)).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmin = convert_cartesian(self.rmin, 'meters', cartesian_units)\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Annular Aperture with inner \"\n                   f\"radius {rmin} {cartesian_units} and outer radius {rmax} \"\n                   f\"{cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass RectangularAperture(DynamicAperture):\n\"\"\"\n    A rectangular aperture parameterised by it height and width.\n\n    Attributes\n    ----------\n    height: Array, meters\n        The length of the aperture in the y-direction. \n    width: Array, meters\n        The length of the aperture in the x-direction. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    height : Array\n    width  : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 height      : Array, \n                 width       : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"RectangularAperture\") -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the RectangularAperture class.\n\n        Parameters\n        ----------\n        height: Array, meters \n            The length of the aperture in the y-direction.\n        width: Array, meters\n            The length of the aperture in the x-direction.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'RectangularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.height = np.asarray(height).astype(float)\n        self.width = np.asarray(width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.height.shape, \"height\")\n        dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        y_mask = self._soften(- np.abs(coordinates[1]) + self.height / 2.)\n        x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)\n        return x_mask * y_mask\n\n    \n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        y_mask = np.abs(coordinates[1]) &lt; self.height / 2.\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.\n        return (x_mask * y_mask).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.hypot(self.height / 2., self.width / 2.)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        height = convert_cartesian(self.height, 'meters', cartesian_units)\n        width = convert_cartesian(self.width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Rectangular Aperture with height \"\n                   f\"{height} {cartesian_units} and width {width} \"\n                   f\"{cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass SquareAperture(DynamicAperture):\n\"\"\"\n    A square aperture parameterised by its width.\n\n    Attributes\n    ----------\n    width: Array, meters\n        The side length of the aperture. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    width : Array\n\n \n    def __init__(self        : ApertureLayer, \n                 width       : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"SquareAperture\") -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the SquareAperture class.\n\n        Parameters\n        ----------\n        width: Array, meters\n            The side length of the aperture. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'SquareAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.width = np.asarray(width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)\n        y_mask = self._soften(- np.abs(coordinates[1]) + self.width / 2.)\n        return x_mask * y_mask\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.\n        y_mask = np.abs(coordinates[1]) &lt; self.width / 2.\n        return (x_mask * y_mask).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.sqrt(2) * self.width / 2.\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        width = convert_cartesian(self.width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Rectangular Aperture with width \"\n                   f\"{width} {cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass PolygonalAperture(DynamicAperture, ABC):\n\"\"\"\n    Abstract base class for all polygonal apertures, from which both regular \n    and irregular polygonal apertures inherit from, implementing some shared \n    methods.\n    Implementation Notes: A lot of the code that is provided was carefully hand \n    vectorised. In general, where a shape change is applied to an array the new \n    array is given the prefix `bc` standing for \"broadcastable\".\n\n    Attributes\n    ----------\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    \n\n    def __init__(self        : ApertureLayer, \n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = 'PolygonalAperture') -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the PolygonalAperture class.\n\n        Parameters\n        ----------\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'PolygonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n    \n    \n    def _perp_dists_from_lines(self : ApertureLayer, \n                               m    : float, \n                               x1   : float, \n                               y1   : float,\n                               xs   : Array, \n                               ys   : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the perpendicular distance of the cartesian (x, y) \n        coordaintes from a line. The line is parameteried by its gradient m and\n        a point (x1, y1) that lies on the line.\n        Parameters\n        ----------\n        m: float \n            The gradient of the line.\n        x1: float, meters\n            The x coordinate the point that lies on the line.\n        y1: float, meters\n            The y coordinate the point that lies on the line.\n        xs: Array, meters\n            The x coordinates to calculate the distance on.\n        ys: Array, meters\n            The y coordinates to calculate the distance on.\n        Returns\n        -------\n        distances: Array, meters\n            The distance of the points (xs, ys) from the line.\n        \"\"\"\n        inf_case = (xs - x1)\n        gen_case = (m * inf_case - (ys - y1)) / np.sqrt(1 + m ** 2)\n        return np.where(np.isinf(m), inf_case, gen_case)\n    \n    \n    def _grad_from_two_points(self : ApertureLayer, \n                              xs   : float, \n                              ys   : float) -&gt; float:\n\"\"\"\n        Calculate the gradient of the chord that connects two points. \n        Note: This is distinct from `_grads_from_many_points` in that\n        it does not wrap arround.\n        Parameters\n        ----------\n        xs: float, meters\n            The x coordinates of the two points.\n        ys: float, meters\n            The y coordinates of the two points.\n        Returns\n        -------\n        m: float\n            The gradient of the chord that connects the two points.\n        \"\"\"\n        return (ys[1] - ys[0]) / (xs[1] - xs[0])\n    \n    \n    def _offset(self      : ApertureLayer, \n                theta     : float, \n                threshold : float) -&gt; float:\n\"\"\"\n        Transform the angular range of polar coordinates so that the new lowest \n        angle is offset. The final range should be $[\\\\phi, \\\\phi + 2 \\\\pi]$ \n        where $\\\\phi$ represents the `threshold`. \n        Parameters\n        ----------\n        theta: float, radians\n            The angular coordinates.\n        threshold: float\n            The amount to offset the coordinates by.\n        Returns\n        -------\n        theta: float, radians \n            The offset coordinate system.\n        \"\"\"\n        comps = (theta &lt; threshold).astype(float)\n        return theta + comps * two_pi\n    \n    \n    def _is_orig_left_of_edge(self : ApertureLayer, \n                              ms   : float, \n                              xs   : float, \n                              ys   : float) -&gt; int:\n\"\"\"\n        Determines whether the origin is to the left or the right of the edge. \n        The edge(s) are defined by a set of gradients, ms and points (xs, ys).\n        Parameters\n        ----------\n        ms: float\n            The gradient of the edge(s).\n        xs: float, meters\n            The set of x coordinates that lie along the edges. \n        ys: float, meters\n            The set of y coordinates that lie along the edges.\n        Returns\n        -------\n        is_left: int\n            1 if the origin is to the left else -1.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_orig = np.array([[0.]])\n        dist_from_orig = self._perp_dists_from_lines(ms, xs, ys, bc_orig, \\\n            bc_orig)\n        return np.sign(dist_from_orig)\n    \n    \nclass IrregularPolygonalAperture(PolygonalAperture):\n\"\"\"\n    An arbitrary aperture parameterised by a set of vertices.\n\n    TODO: Check if the verticies need to be defined in a specific way, based on\n    the methods this looks like the case (ie, ordered).\n\n    Attributes\n    ----------\n    vertices: Array, meters\n        The location of the vertices of the aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    vertices : Array\n    \n    \n    def __init__(self        : ApertureLayer, \n                 vertices    : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"IrregularPolygonalAperture\"\n                 ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the IrregularPolygonalAperture class.\n\n        Parameters\n        ----------\n        vertices: Array, meters\n            The location of the vertices of the aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'IrregularPolygonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n        \n        self.vertices = np.array(vertices).astype(float)\n        dLux.exceptions.validate_bc_attr_dims(\n            (1, 2), self.vertices.shape, \"vertices\")\n            \n    \n    def _grads_from_many_points(self : ApertureLayer, \n                                xs   : float, \n                                ys   : float) -&gt; float:\n\"\"\"\n        Given a set of points, calculate the gradient of the line that connects \n        those points. This function assumes that the points are provided in the \n        order they are to be connected together. Notice that we also assume \n        there are more than two points, but more can be provided in which case \n        the shape is assumed to be closed. The output has the same shape as the \n        input and does not check for infinite (vertical) gradients.\n        Note: Due to the intensly vectorised nature of this code it is ofen \n        necessary to provide the parameters with expanded dimensions. This may \n        be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or \n        `np.expand_dims(x1, (1, 2))`.\n        Parameters\n        ----------\n        xs: float, meters\n            The x coordinates of the points that are to be connected. \n        ys: float, meters\n            The y coordinates of the points that are to be connected. \n            Must have the same shape as x. \n        Returns\n        -------\n        ms: float\n            The gradients of the lines that connect the vertices. The vertices \n            wrap around to form a closed shape whatever it may look like. \n        \"\"\"\n        x_diffs = xs - np.roll(xs, -1)\n        y_diffs = ys - np.roll(ys, -1)\n        return y_diffs / x_diffs\n    \n    \n    def _extent(self : ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        verts = self.vertices\n        dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])\n        return np.max(dist_to_verts)\n    \n    \n    def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\\n            sorted_y1, bc_x, bc_y)  \n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        soft_edges = self._soften(dist_sgn * dist_from_edges)\n\n        return (soft_edges).prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\\n            sorted_y1, bc_x, bc_y)  \n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        edges = (dist_from_edges * dist_sgn) &gt; 0.\n\n        return (edges).prod(axis=0)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = f\"Applies a {transmissive} Irregular Polygonal Aperture\"\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass RegularPolygonalAperture(PolygonalAperture):\n\"\"\"\n    A regular polygonal aperture defined by its number of sides and the maximum \n    radius to the vertices from its center.\n    Attributes\n    ----------\n    nsides: int\n        The number of sides of the aperture. \n    rmax: Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    nsides : int\n    rmax   : Array\n        \n    \n    def __init__(self        : ApertureLayer, \n                 nsides      : int,\n                 rmax        : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"RegularPolygonalAperture\"\n                 ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RegularPolygonalAperture class.\n\n        Parameters\n        ----------\n        nsides: int\n            The number of sides of the aperture.  \n        rmax: Array, meters\n            The maximum radius to the vertices from its center.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'RegularPolygonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n\n        self.nsides = int(nsides)\n        self.rmax = np.array(rmax).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n\n        \n    def _extent(self : ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n        \n    \n    def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x) \n        alpha = np.pi / self.nsides\n            \n        i = np.arange(self.nsides)[:, None, None] # Dummy index\n        bounds = 2. * i * alpha\n            \n        ms = -1 / np.tan(2. * i * alpha + alpha)\n        xs = self.rmax * np.cos(2. * i * alpha)\n        ys = self.rmax * np.sin(2. * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n         \n        dist = self._soften(inside * dists)\n        return dist.prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x) \n        alpha = np.pi / self.nsides\n            \n        i = np.arange(self.nsides)[:, None, None] # Dummy index\n        bounds = 2. * i * alpha\n            \n        ms = -1 / np.tan(2. * i * alpha + alpha)\n        xs = self.rmax * np.cos(2. * i * alpha)\n        ys = self.rmax * np.sin(2. * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n         \n        dist = (inside * dists) &gt; 0.\n        return dist.prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} {self.nsides} sided Regular \"\n                   f\"Polygonal Aperture of max radius {rmax:.{sigfigs}} \"\n                   f\"{cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\nclass HexagonalAperture(RegularPolygonalAperture):\n\"\"\"\n    A hexagonal aperture parameterised by the maximum radius to the vertices \n    from its center.\n    Attributes\n    ----------\n    rmax : Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    rmax : Array\n\n    \n    def __init__(self        : ApertureLayer, \n                 rmax        : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"HexagonalAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the HexagonalAperture class.\n\n        Parameters\n        ----------\n        rmax : Array, meters\n            The maximum radius to the vertices from its center.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'HexagonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(nsides = 6,\n                         rmax = rmax,\n                         centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Hexagonal Aperture of max radius \"\n                   f\"{rmax:.{sigfigs}} {cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\n###############\n### Spiders ###\n###############\nclass Spider(DynamicAperture, ABC):\n\"\"\"\n    An abstract class for generating aperture spiders struts.\n\n    Attributes\n    ----------\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    \n    \n    def __init__(self        : ApertureLayer, \n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.), \n                 softening   : Array = np.array(1.),\n                 name        : str   = 'Spider') -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the Spider class.\n\n        Parameters\n        ----------\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'Spider'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = False,\n                         softening = softening,\n                         name = name)\n \n \n    def _strut(self        : ApertureLayer, \n               angle       : float, \n               coordinates : Array) -&gt; Array:\n\"\"\"\n        Generates a representation of a single strut in the spider. \n        Parameters\n        ----------\n        angle: float, radians\n            The angle that this strut points from the positive x-axis.\n        Returns\n        -------\n        distance: float\n            The distance from the center of the strut.\n        \"\"\"\n        x, y = coordinates[0], coordinates[1]\n        gradient = np.tan(angle)\n        dist = np.abs(y - gradient * x) / np.sqrt(1 + gradient ** 2)\n        theta = np.arctan2(y, x) + np.pi \n        theta = np.where(theta &gt; angle, theta - angle, theta + 2 * np.pi - \\\n            angle)\n        theta = np.where(theta &gt; 2 * np.pi, theta - 2 * np.pi, theta)\n        strut = np.where((theta &gt; np.pi / 2.) &amp; (theta &lt; 3. * np.pi / 2.), 1., \\\n            dist)\n        return strut\n\n\n    def _extent(self : ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        raise NotImplementedError(\"The `Spider` class and its derivatives \" +\\\n            \"are not designed to be used with the `AberatedAperture` class. \" +\\\n            \"If this is part of a `CompoundAperture` place the \" +\\\n            \"`AberratedAperture`s into the `CompoundAperture` not the \" +\\\n            \"other way arround.\")\n\n\nclass UniformSpider(Spider):\n\"\"\"\n    A set of spider struts with equally-spaced, equal-width struts.\n    Attributes\n    ----------\n    nstruts: int \n        The number of spider struts.\n    strut_width: Array, meters\n        The width of each strut. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    nstruts     : int\n    strut_width : Array\n\n    \n    def __init__(self         : ApertureLayer, \n                 nstruts      : int,\n                 strut_width  : Array,\n                 centre       : Array = np.array([0., 0.]), \n                 shear        : Array = np.array([0., 0.]),\n                 compression  : Array = np.array([1., 1.]),\n                 rotation     : Array = np.array(0.),\n                 softening    : Array = np.array(1.),\n                 name         : str   = \"UniformSpider\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the UniformSpider class.\n\n        Parameters\n        ----------\n        nstruts: int \n            The number of struts to equally space around the circle. This is not \n            a differentiable parameter. \n        strut_width: Array, meters\n            The width of each strut. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'UniformSpider'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\" \n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         softening = softening,\n                         name = name)\n\n        self.nstruts = int(nstruts)\n        self.strut_width = np.asarray(strut_width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims(\n            (), self.strut_width.shape, \"Width_of_struts\")\n\n\n    def _stacked_struts(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calculates an array of individual struts comprising the full spider \n        aperture on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinate system to calculate the struts on.\n\n        Returns\n        -------\n        struts: Array\n            The array of all the individual struts.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n        angles = np.linspace(0, two_pi, self.nstruts, endpoint=False)\n        angles += self.rotation\n        return vmap(self._strut, in_axes=(0, None))(angles, coordinates) \n\n \n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) - self.strut_width / 2.\n        softened = self._soften(struts)\n        return softened.prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) &gt; self.strut_width / 2. \n        return struts.prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        width = convert_cartesian(self.strut_width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n\n        summary = (f\"Applies a {self.nstrut} strut spider with widths {width} \"\n                   f\"{cartesian_units}\")\n        \n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n\n\n\n###################\n### Aberrations ###\n###################\nclass AbstractAberratedAperture(ApertureLayer, ABC):\n\"\"\"\n    An abstract class for generating apertures with aberrations. This \n    instantiates the coefficients parameter, defining the amplitude of each \n    basis vector of the aberrations.\n    Attributes\n    ----------\n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    \"\"\"\n    coefficients : Array\n\n\n    def __init__(self         : ApertureLayer, \n                 coefficients : Array, \n                 name         : str = \"AbstractAberratedAperture\",\n                 **kwargs) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the AbstractAberratedAperture class.\n\n        Parameters\n        ----------\n        coefficients: Array\n            The amplitude of each basis vector of the aberrations.\n        name: str = \"AbstractAberratedAperture\"\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name = name, **kwargs)\n\n        self.coefficients = np.asarray(coefficients).astype(float)\n        # NOTE: Dimension checking is complex here becuase AberratedApertures\n        # and CompoundApertures must always have 1d coefficeints, but \n        # MultiApertures can have 2d coefficients.\n\n\n    @abstractmethod\n    def _basis(self        : ApertureLayer, \n               coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n\n\n    @abstractmethod\n    def get_basis(self     : ApertureLayer, \n                  npixels  : int, \n                  diameter : float) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n \n\n    @abstractmethod\n    def _opd(self        : ApertureLayer, \n             coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n\n\n    @abstractmethod\n    def get_opd(self     : ApertureLayer, \n                npixels  : int, \n                diameter : float) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates with the specified number of pixels and \n        diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n\n\nclass AberratedAperture(AbstractAberratedAperture):\n\"\"\"\n    A class for generating apertures with aberrations. This class generates the\n    basis vectors of the aberrations at run time, allowing for the aperture and\n    aberrations to be recovered simultaneously.\n    Attributes\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    basis: list[Zernike]\n        A list of basis functions that represent the basis. The exact \n        polynomials that are represented will depend on the aperture shape. \n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    aperture : ApertureLayer\n    basis    : dLux.aberrations.ZernikeBasis\n\n    \n    def __init__(self         : ApertureLayer, \n                 aperture     : ApertureLayer, \n                 noll_inds    : Array,\n                 coefficients : Array = None,\n                 name         : str   = \"AberratedAperture\",\n                 **kwargs) -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the AberratedAperture class.\n\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture on which the aberration basis is defined.\n        noll_inds: List[int]\n            The noll indices are a scheme for indexing the Zernike\n            polynomials. Normally these polynomials have two \n            indices but the noll indices prevent an order to \n            these pairs. All basis can be indexed using the noll\n            indices based on `n` and `m`. \n        coefficients: Array = None\n            The amplitude of each basis vector of the aberrations. If nothing \n            is provided, then the coefficients are set to zero.\n        name: str = 'AberratedAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        if aperture.occulting:\n            raise ValueError(\"AberratedApertures can not be occulting.\")\n        \n        if not isinstance(aperture, DynamicAperture):\n            raise ValueError(\"AberratedApertures can not contain Static, \" + \\\n                \"Compound or Multi Apertures. AberratedApertures can be \" + \\\n                \"placed in Compound or Multi Apertures, which can then be \" + \\\n                \"promoted to Static.\")\n\n        # Set Aperture\n        self.aperture = aperture\n\n        # Set Basis\n        self.basis = dLux.aberrations.ZernikeBasis(noll_inds)\n\n        # Initialise the coefficinets\n        coefficients = np.zeros(len(noll_inds)) if coefficients is None \\\n            else np.asarray(coefficients).astype(float)\n\n        super().__init__(coefficients=coefficients, name=name, **kwargs)\n        \n        # Dimensionality check\n        dLux.exceptions.validate_bc_attr_dims(\n            noll_inds.shape, self.coefficients.shape, \"coefficients\")\n \n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture and the abberations to the wavefront.  \n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront that is passing through the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after passing through the aperture.\n        \"\"\"\n        # Calculate aperture and opd\n        coordinates = wavefront.pixel_coordinates\n        opd = self._opd(coordinates)\n        aperture = self.aperture._aperture(coordinates)\n\n        # Calculate and update amplitude and phase\n        phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)\n        amplitude = wavefront.amplitude * aperture\n        return wavefront.set_phasor(amplitude, phase)\n \n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self.aperture._aperture(coordinates)\n        \n\n    def get_aperture(self     : ApertureLayer, \n                     npixels  : int, \n                     diameter : float) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on a set of coordinates \n        with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self.aperture._aperture(coordinates)\n\n\n    def _basis(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        coordinates = self.aperture._normalised_coordinates(coordinates)\n\n        if isinstance(self.aperture, RegularPolygonalAperture):\n            ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)\n        else:\n            ikes = self.basis.calculate_basis(coordinates)\n\n        is_reg_pol = isinstance(self.aperture, RegularPolygonalAperture)\n        is_circ = isinstance(self.aperture, CircularAperture)\n\n        if is_circ or is_reg_pol:\n            return ikes\n\n        aperture = self.aperture._aperture(coordinates)\n        ikes = self._orthonormalise(aperture, ikes)\n\n        return ikes \n\n\n    def get_basis(self     : ApertureLayer, \n                  npixels  : int, \n                  diameter : float) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._basis(coordinates)\n \n\n    def _opd(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        basis = self._basis(coordinates)\n        return (basis * self.coefficients[:, None, None]).sum(axis=0)\n\n\n    def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates with the specified number of pixels and \n        diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._opd(coordinates)\n\n\n    def _orthonormalise(self     : ApertureLayer, \n                        aperture : Array, \n                        zernikes : Array) -&gt; Array:\n\"\"\"\n        Orthonomalises the zernike polynomials on the aperture.\n        Parameters\n        ----------\n        aperture : Array\n            An array representing the aperture.\n        zernikes : Array\n            The zernike polynomials to orthonormalise on the aperture.\n        Returns\n        -------\n        basis : Array\n            The orthonormalised zernike polynomials evaluated on the aperture.\n        \"\"\"\n        pixel_area = aperture.sum()\n        shape = zernikes.shapediameter\n        basis = np.zeros(shape).at[0].set(aperture)\n \n        for j in np.arange(1, self.nterms):\n            intermediate = zernikes[j] * aperture\n            coefficient = np.zeros((self.nterms, 1, 1), dtype=float)\n            mask = (np.arange(1, self.nterms) &gt; j + 1).reshape((-1, 1, 1))\n \n            coefficient = -1 / pixel_area * \\\n                (zernikes[j] * basis[1:] * aperture * mask)\\\n                .sum(axis = (1, 2))\\\n                .reshape(-1, 1, 1) \n\n            intermediate += (coefficient * basis[1:] * mask).sum(axis = 0)\n            \n            basis = basis\\\n                .at[j]\\\n                .set(intermediate / \\\n                    np.sqrt((intermediate ** 2).sum() / pixel_area))\n        \n        return basis\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = super().summary(angular_units, cartesian_units, sigfigs)\n        return summary[:-1] + f\" with {len(self.coefficients)} aberrations.\"\n</pre> class CircularAperture(DynamicAperture):     \"\"\"     A circular aperture parameterised by its radius.      Attributes     ----------     radius: Array, meters         The radius of the aperture.      centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     radius : Array        def __init__(self        : ApertureLayer,                   radius      : Array,                   centre      : Array = np.array([0., 0.]),                  shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  occulting   : bool = False,                   softening   : Array = np.array(1.),                  name        : str = \"CircularAperture\",                  ) -&gt; Array:         \"\"\"         Constructor for the CircularAperture class.          Parameters         ----------         radius: Array, meters              The radius of the aperture.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'CircularAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                           occulting = occulting,                           softening = softening,                          name = name)           self.radius = np.asarray(radius).astype(float)         dLux.exceptions.validate_eq_attr_dims((), self.radius.shape, \"radius\")       def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         coordinates = np.hypot(coordinates[0], coordinates[1])         return self._soften(- coordinates + self.radius)       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         coordinates = np.hypot(coordinates[0], coordinates[1])         return (coordinates &lt; self.radius).astype(float)       def _extent(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return self.radius           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         radius = convert_cartesian(self.radius, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} Circular Aperture with radius \"                    f\"{radius} {cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class AnnularAperture(DynamicAperture):     \"\"\"     An annular aperture defined by its inner and outer radii.      Attributes     ----------     rmax: Array, meters         Outer radius of aperture.     rmin: Array, meters         Inner radius of aperture.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     rmin : Array     rmax : Array           def __init__(self        : ApertureLayer,                   rmax        : Array,                   rmin        : Array,                   centre      : Array = np.array([0., 0.]),                  shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"AnnularAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the AnnularAperture class.          Parameters         ----------         rmax : Array, meters             The outer radius of the aperture.          rmin : Array, meters             The inner radius of the aperture.          centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'AnnularAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                           occulting = occulting,                           softening = softening,                          name = name)          self.rmax = np.asarray(rmax).astype(float)         self.rmin = np.asarray(rmin).astype(float)          dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")         dLux.exceptions.validate_eq_attr_dims((), self.rmin.shape, \"rmin\")       def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         coordinates = np.hypot(coordinates[0], coordinates[1])         return self._soften(coordinates - self.rmin) * \\             self._soften(- coordinates + self.rmax)       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         coordinates = np.hypot(coordinates[0], coordinates[1])         return ((coordinates &gt; self.rmin) * \\             (coordinates &lt; self.rmax)).astype(float)       def _extent(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return self.rmax           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         rmin = convert_cartesian(self.rmin, 'meters', cartesian_units)         rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} Annular Aperture with inner \"                    f\"radius {rmin} {cartesian_units} and outer radius {rmax} \"                    f\"{cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class RectangularAperture(DynamicAperture):     \"\"\"     A rectangular aperture parameterised by it height and width.      Attributes     ----------     height: Array, meters         The length of the aperture in the y-direction.      width: Array, meters         The length of the aperture in the x-direction.      centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     height : Array     width  : Array       def __init__(self        : ApertureLayer,                   height      : Array,                   width       : Array,                   centre      : Array = np.array([0., 0.]),                  shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"RectangularAperture\") -&gt; ApertureLayer:          \"\"\"         Constructor for the RectangularAperture class.          Parameters         ----------         height: Array, meters              The length of the aperture in the y-direction.         width: Array, meters             The length of the aperture in the x-direction.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'RectangularAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                          compression = compression,                          rotation = rotation,                           occulting = occulting,                           softening = softening,                          name = name)          self.height = np.asarray(height).astype(float)         self.width = np.asarray(width).astype(float)          dLux.exceptions.validate_eq_attr_dims((), self.height.shape, \"height\")         dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")       def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         y_mask = self._soften(- np.abs(coordinates[1]) + self.height / 2.)         x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)         return x_mask * y_mask           def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         y_mask = np.abs(coordinates[1]) &lt; self.height / 2.         x_mask = np.abs(coordinates[0]) &lt; self.width / 2.         return (x_mask * y_mask).astype(float)       def _extent(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return np.hypot(self.height / 2., self.width / 2.)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         height = convert_cartesian(self.height, 'meters', cartesian_units)         width = convert_cartesian(self.width, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} Rectangular Aperture with height \"                    f\"{height} {cartesian_units} and width {width} \"                    f\"{cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class SquareAperture(DynamicAperture):     \"\"\"     A square aperture parameterised by its width.      Attributes     ----------     width: Array, meters         The side length of the aperture.      centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     width : Array        def __init__(self        : ApertureLayer,                   width       : Array,                   centre      : Array = np.array([0., 0.]),                  shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"SquareAperture\") -&gt; ApertureLayer:          \"\"\"         Constructor for the SquareAperture class.          Parameters         ----------         width: Array, meters             The side length of the aperture.          centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'SquareAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                          compression = compression,                          rotation = rotation,                           occulting = occulting,                           softening = softening,                          name = name)          self.width = np.asarray(width).astype(float)          dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")       def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)         y_mask = self._soften(- np.abs(coordinates[1]) + self.width / 2.)         return x_mask * y_mask       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         x_mask = np.abs(coordinates[0]) &lt; self.width / 2.         y_mask = np.abs(coordinates[1]) &lt; self.width / 2.         return (x_mask * y_mask).astype(float)       def _extent(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return np.sqrt(2) * self.width / 2.           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         width = convert_cartesian(self.width, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} Rectangular Aperture with width \"                    f\"{width} {cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class PolygonalAperture(DynamicAperture, ABC):     \"\"\"     Abstract base class for all polygonal apertures, from which both regular      and irregular polygonal apertures inherit from, implementing some shared      methods.          Implementation Notes: A lot of the code that is provided was carefully hand      vectorised. In general, where a shape change is applied to an array the new      array is given the prefix `bc` standing for \"broadcastable\".      Attributes     ----------     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"           def __init__(self        : ApertureLayer,                   centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = 'PolygonalAperture') -&gt; ApertureLayer:         \"\"\"         Constructor for the PolygonalAperture class.          Parameters         ----------         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'PolygonalAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          occulting = occulting,                          softening = softening,                          name = name)               def _perp_dists_from_lines(self : ApertureLayer,                                 m    : float,                                 x1   : float,                                 y1   : float,                                xs   : Array,                                 ys   : Array) -&gt; Array:         \"\"\"         Calcualtes the perpendicular distance of the cartesian (x, y)          coordaintes from a line. The line is parameteried by its gradient m and         a point (x1, y1) that lies on the line.                  Parameters         ----------         m: float              The gradient of the line.         x1: float, meters             The x coordinate the point that lies on the line.         y1: float, meters             The y coordinate the point that lies on the line.         xs: Array, meters             The x coordinates to calculate the distance on.         ys: Array, meters             The y coordinates to calculate the distance on.                  Returns         -------         distances: Array, meters             The distance of the points (xs, ys) from the line.         \"\"\"         inf_case = (xs - x1)         gen_case = (m * inf_case - (ys - y1)) / np.sqrt(1 + m ** 2)         return np.where(np.isinf(m), inf_case, gen_case)               def _grad_from_two_points(self : ApertureLayer,                                xs   : float,                                ys   : float) -&gt; float:         \"\"\"         Calculate the gradient of the chord that connects two points.          Note: This is distinct from `_grads_from_many_points` in that         it does not wrap arround.                  Parameters         ----------         xs: float, meters             The x coordinates of the two points.         ys: float, meters             The y coordinates of the two points.                      Returns         -------         m: float             The gradient of the chord that connects the two points.         \"\"\"         return (ys[1] - ys[0]) / (xs[1] - xs[0])               def _offset(self      : ApertureLayer,                  theta     : float,                  threshold : float) -&gt; float:         \"\"\"         Transform the angular range of polar coordinates so that the new lowest          angle is offset. The final range should be $[\\\\phi, \\\\phi + 2 \\\\pi]$          where $\\\\phi$ represents the `threshold`.                   Parameters         ----------         theta: float, radians             The angular coordinates.         threshold: float             The amount to offset the coordinates by.                  Returns         -------         theta: float, radians              The offset coordinate system.         \"\"\"         comps = (theta &lt; threshold).astype(float)         return theta + comps * two_pi               def _is_orig_left_of_edge(self : ApertureLayer,                                ms   : float,                                xs   : float,                                ys   : float) -&gt; int:         \"\"\"         Determines whether the origin is to the left or the right of the edge.          The edge(s) are defined by a set of gradients, ms and points (xs, ys).                  Parameters         ----------         ms: float             The gradient of the edge(s).         xs: float, meters             The set of x coordinates that lie along the edges.          ys: float, meters             The set of y coordinates that lie along the edges.                      Returns         -------         is_left: int             1 if the origin is to the left else -1.         \"\"\"         # NOTE: see class docs.         bc_orig = np.array([[0.]])         dist_from_orig = self._perp_dists_from_lines(ms, xs, ys, bc_orig, \\             bc_orig)         return np.sign(dist_from_orig)           class IrregularPolygonalAperture(PolygonalAperture):     \"\"\"     An arbitrary aperture parameterised by a set of vertices.      TODO: Check if the verticies need to be defined in a specific way, based on     the methods this looks like the case (ie, ordered).      Attributes     ----------     vertices: Array, meters         The location of the vertices of the aperture.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     vertices : Array               def __init__(self        : ApertureLayer,                   vertices    : Array,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"IrregularPolygonalAperture\"                  ) -&gt; ApertureLayer:         \"\"\"         Constructor for the IrregularPolygonalAperture class.          Parameters         ----------         vertices: Array, meters             The location of the vertices of the aperture.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'IrregularPolygonalAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          occulting = occulting,                          softening = softening,                          name = name)                  self.vertices = np.array(vertices).astype(float)         dLux.exceptions.validate_bc_attr_dims(             (1, 2), self.vertices.shape, \"vertices\")                       def _grads_from_many_points(self : ApertureLayer,                                  xs   : float,                                  ys   : float) -&gt; float:         \"\"\"         Given a set of points, calculate the gradient of the line that connects          those points. This function assumes that the points are provided in the          order they are to be connected together. Notice that we also assume          there are more than two points, but more can be provided in which case          the shape is assumed to be closed. The output has the same shape as the          input and does not check for infinite (vertical) gradients.                  Note: Due to the intensly vectorised nature of this code it is ofen          necessary to provide the parameters with expanded dimensions. This may          be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or          `np.expand_dims(x1, (1, 2))`.                  Parameters         ----------         xs: float, meters             The x coordinates of the points that are to be connected.          ys: float, meters             The y coordinates of the points that are to be connected.              Must have the same shape as x.                       Returns         -------         ms: float             The gradients of the lines that connect the vertices. The vertices              wrap around to form a closed shape whatever it may look like.          \"\"\"         x_diffs = xs - np.roll(xs, -1)         y_diffs = ys - np.roll(ys, -1)         return y_diffs / x_diffs               def _extent(self : ApertureLayer) -&gt; float:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         verts = self.vertices         dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])         return np.max(dist_to_verts)               def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         # NOTE: see class docs.         bc_x1 = self.vertices[:, 0][:, None, None]         bc_y1 = self.vertices[:, 1][:, None, None]          bc_x = coordinates[0][None, :, :]         bc_y = coordinates[1][None, :, :]          theta = np.arctan2(bc_y1, bc_x1)         offset_theta = self._offset(theta, 0.)          sorted_inds = np.argsort(offset_theta.flatten())          sorted_x1 = bc_x1[sorted_inds]         sorted_y1 = bc_y1[sorted_inds]         sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)          dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\             sorted_y1, bc_x, bc_y)           dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)         soft_edges = self._soften(dist_sgn * dist_from_edges)          return (soft_edges).prod(axis=0)       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         # NOTE: see class docs.         bc_x1 = self.vertices[:, 0][:, None, None]         bc_y1 = self.vertices[:, 1][:, None, None]          bc_x = coordinates[0][None, :, :]         bc_y = coordinates[1][None, :, :]          theta = np.arctan2(bc_y1, bc_x1)         offset_theta = self._offset(theta, 0.)          sorted_inds = np.argsort(offset_theta.flatten())          sorted_x1 = bc_x1[sorted_inds]         sorted_y1 = bc_y1[sorted_inds]         sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)          dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\             sorted_y1, bc_x, bc_y)           dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)         edges = (dist_from_edges * dist_sgn) &gt; 0.          return (edges).prod(axis=0)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = f\"Applies a {transmissive} Irregular Polygonal Aperture\"                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class RegularPolygonalAperture(PolygonalAperture):     \"\"\"     A regular polygonal aperture defined by its number of sides and the maximum      radius to the vertices from its center.          Attributes     ----------     nsides: int         The number of sides of the aperture.      rmax: Array, meters         The maximum radius to the vertices from its center.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     nsides : int     rmax   : Array                   def __init__(self        : ApertureLayer,                   nsides      : int,                  rmax        : Array,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"RegularPolygonalAperture\"                  ) -&gt; ApertureLayer:         \"\"\"         Constructor for the RegularPolygonalAperture class.          Parameters         ----------         nsides: int             The number of sides of the aperture.           rmax: Array, meters             The maximum radius to the vertices from its center.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'RegularPolygonalAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          occulting = occulting,                          softening = softening,                          name = name)          self.nsides = int(nsides)         self.rmax = np.array(rmax).astype(float)          dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")               def _extent(self : ApertureLayer) -&gt; float:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         return self.rmax                   def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         x = coordinates[0]         y = coordinates[1]          neg_pi_to_pi_phi = np.arctan2(y, x)          alpha = np.pi / self.nsides                      i = np.arange(self.nsides)[:, None, None] # Dummy index         bounds = 2. * i * alpha                      ms = -1 / np.tan(2. * i * alpha + alpha)         xs = self.rmax * np.cos(2. * i * alpha)         ys = self.rmax * np.sin(2. * i * alpha)         dists = self._perp_dists_from_lines(ms, xs, ys, x, y)         inside = self._is_orig_left_of_edge(ms, xs, ys)                   dist = self._soften(inside * dists)         return dist.prod(axis=0)       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         x = coordinates[0]         y = coordinates[1]          neg_pi_to_pi_phi = np.arctan2(y, x)          alpha = np.pi / self.nsides                      i = np.arange(self.nsides)[:, None, None] # Dummy index         bounds = 2. * i * alpha                      ms = -1 / np.tan(2. * i * alpha + alpha)         xs = self.rmax * np.cos(2. * i * alpha)         ys = self.rmax * np.sin(2. * i * alpha)         dists = self._perp_dists_from_lines(ms, xs, ys, x, y)         inside = self._is_orig_left_of_edge(ms, xs, ys)                   dist = (inside * dists) &gt; 0.         return dist.prod(axis=0)       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} {self.nsides} sided Regular \"                    f\"Polygonal Aperture of max radius {rmax:.{sigfigs}} \"                    f\"{cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   class HexagonalAperture(RegularPolygonalAperture):     \"\"\"     A hexagonal aperture parameterised by the maximum radius to the vertices      from its center.          Attributes     ----------     rmax : Array, meters         The maximum radius to the vertices from its center.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     occulting: bool         Is the aperture occulting or tranmissive. False results in a tranmissive         aperture, and True results in an occulting aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     rmax : Array           def __init__(self        : ApertureLayer,                   rmax        : Array,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  occulting   : bool  = False,                   softening   : Array = np.array(1.),                  name        : str   = \"HexagonalAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the HexagonalAperture class.          Parameters         ----------         rmax : Array, meters             The maximum radius to the vertices from its center.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         occulting: bool = False             Is the aperture occulting or tranmissive. False results in a              tranmissive aperture, and True results in an occulting aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'HexagonalAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(nsides = 6,                          rmax = rmax,                          centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          occulting = occulting,                          softening = softening,                          name = name)       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)         transmissive = \"transmissive\" if not self.occulting else \"occulting\"          summary = (f\"Applies a {transmissive} Hexagonal Aperture of max radius \"                    f\"{rmax:.{sigfigs}} {cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"   ############### ### Spiders ### ############### class Spider(DynamicAperture, ABC):     \"\"\"     An abstract class for generating aperture spiders struts.      Attributes     ----------     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"               def __init__(self        : ApertureLayer,                   centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                   softening   : Array = np.array(1.),                  name        : str   = 'Spider') -&gt; ApertureLayer:         \"\"\"         Constructor for the Spider class.          Parameters         ----------         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'Spider'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          occulting = False,                          softening = softening,                          name = name)         def _strut(self        : ApertureLayer,                 angle       : float,                 coordinates : Array) -&gt; Array:         \"\"\"         Generates a representation of a single strut in the spider.            Parameters         ----------         angle: float, radians             The angle that this strut points from the positive x-axis.           Returns         -------         distance: float             The distance from the center of the strut.         \"\"\"         x, y = coordinates[0], coordinates[1]         gradient = np.tan(angle)         dist = np.abs(y - gradient * x) / np.sqrt(1 + gradient ** 2)         theta = np.arctan2(y, x) + np.pi          theta = np.where(theta &gt; angle, theta - angle, theta + 2 * np.pi - \\             angle)         theta = np.where(theta &gt; 2 * np.pi, theta - 2 * np.pi, theta)         strut = np.where((theta &gt; np.pi / 2.) &amp; (theta &lt; 3. * np.pi / 2.), 1., \\             dist)         return strut       def _extent(self : ApertureLayer) -&gt; float:         \"\"\"         Returns the largest distance to the outer edge of the aperture from the         centre.          Returns         -------         extent : float             The maximum distance from the centre to edge of aperture.         \"\"\"         raise NotImplementedError(\"The `Spider` class and its derivatives \" +\\             \"are not designed to be used with the `AberatedAperture` class. \" +\\             \"If this is part of a `CompoundAperture` place the \" +\\             \"`AberratedAperture`s into the `CompoundAperture` not the \" +\\             \"other way arround.\")   class UniformSpider(Spider):     \"\"\"     A set of spider struts with equally-spaced, equal-width struts.       Attributes     ----------     nstruts: int          The number of spider struts.     strut_width: Array, meters         The width of each strut.      centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     softening: Array, pixels         The approximate pixel width of the soft boundary applied to the          aperture. Hard edges can be achieved by setting the softening to 0.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     nstruts     : int     strut_width : Array           def __init__(self         : ApertureLayer,                   nstruts      : int,                  strut_width  : Array,                  centre       : Array = np.array([0., 0.]),                   shear        : Array = np.array([0., 0.]),                  compression  : Array = np.array([1., 1.]),                  rotation     : Array = np.array(0.),                  softening    : Array = np.array(1.),                  name         : str   = \"UniformSpider\") -&gt; ApertureLayer:         \"\"\"         Constructor for the UniformSpider class.          Parameters         ----------         nstruts: int              The number of struts to equally space around the circle. This is not              a differentiable parameter.          strut_width: Array, meters             The width of each strut.          centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         softening: Array, pixels = np.array(1.)             The approximate pixel width of the soft boundary applied to the              aperture. Hard edges can be achieved by setting the softening to 0.         name: str = 'UniformSpider'             The name of the layer, which is used to index the layers dictionary.         \"\"\"          super().__init__(centre = centre,                           shear = shear,                           compression = compression,                          rotation = rotation,                          softening = softening,                          name = name)          self.nstruts = int(nstruts)         self.strut_width = np.asarray(strut_width).astype(float)          dLux.exceptions.validate_eq_attr_dims(             (), self.strut_width.shape, \"Width_of_struts\")       def _stacked_struts(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calculates an array of individual struts comprising the full spider          aperture on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinate system to calculate the struts on.          Returns         -------         struts: Array             The array of all the individual struts.         \"\"\"         coordinates = self._coordinates(coordinates)         angles = np.linspace(0, two_pi, self.nstruts, endpoint=False)         angles += self.rotation         return vmap(self._strut, in_axes=(0, None))(angles, coordinates)         def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the soft edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The softed edged aperture shape.         \"\"\"         struts = self._stacked_struts(coordinates) - self.strut_width / 2.         softened = self._soften(struts)         return softened.prod(axis=0)       def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calcualtes the hard edged aperture shape on the input coordinates.          Parameters         ----------         coordinates: Array, meters             The coordinates to calculate the aperture shape on.          Returns         -------         aperture: Array             The hard edged aperture shape.         \"\"\"         struts = self._stacked_struts(coordinates) &gt; self.strut_width / 2.          return struts.prod(axis=0)       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         width = convert_cartesian(self.strut_width, 'meters', cartesian_units)         center = convert_cartesian(self.center, 'meters', cartesian_units)         rotation = convert_angular(self.rotation, 'radians', angular_units)          summary = (f\"Applies a {self.nstrut} strut spider with widths {width} \"                    f\"{cartesian_units}\")                  if self.softening != np.array(0):             summary += f\" softened by ~{self.softening} pixels\"         if self.center != np.array([0., 0.]):             summary += f\" centred at {center}\"         if self.rotation != np.array(0.):             summary += f\" rotated by {rotation} {angular_units}\"         if self.shear != np.array([0., 0.]):             summary += f\" sheared by {self.shear}\"         if self.compression != np.array([1., 1.]):             summary += f\" compressed by {self.compression}\"         return summary + \".\"    ################### ### Aberrations ### ################### class AbstractAberratedAperture(ApertureLayer, ABC):     \"\"\"     An abstract class for generating apertures with aberrations. This      instantiates the coefficients parameter, defining the amplitude of each      basis vector of the aberrations.          Attributes     ----------     coefficients: Array         The amplitude of each basis vector of the aberrations.     \"\"\"     coefficients : Array       def __init__(self         : ApertureLayer,                   coefficients : Array,                   name         : str = \"AbstractAberratedAperture\",                  **kwargs) -&gt; ApertureLayer:                  \"\"\"         Constructor for the AbstractAberratedAperture class.          Parameters         ----------         coefficients: Array             The amplitude of each basis vector of the aberrations.         name: str = \"AbstractAberratedAperture\"             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name = name, **kwargs)          self.coefficients = np.asarray(coefficients).astype(float)         # NOTE: Dimension checking is complex here becuase AberratedApertures         # and CompoundApertures must always have 1d coefficeints, but          # MultiApertures can have 2d coefficients.       @abstractmethod     def _basis(self        : ApertureLayer,                 coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the basis vectors on.          Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"       @abstractmethod     def get_basis(self     : ApertureLayer,                    npixels  : int,                    diameter : float) -&gt; Array: # pragma: no cover         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"        @abstractmethod     def _opd(self        : ApertureLayer,               coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the opd on.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"       @abstractmethod     def get_opd(self     : ApertureLayer,                  npixels  : int,                  diameter : float) -&gt; Array: # pragma: no cover         \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates with the specified number of pixels and          diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"   class AberratedAperture(AbstractAberratedAperture):     \"\"\"     A class for generating apertures with aberrations. This class generates the     basis vectors of the aberrations at run time, allowing for the aperture and     aberrations to be recovered simultaneously.       Attributes     ----------     aperture: ApertureLayer         The aperture on which the aberration basis is defined.     basis: list[Zernike]         A list of basis functions that represent the basis. The exact          polynomials that are represented will depend on the aperture shape.      coefficients: Array         The amplitude of each basis vector of the aberrations.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     aperture : ApertureLayer     basis    : dLux.aberrations.ZernikeBasis           def __init__(self         : ApertureLayer,                   aperture     : ApertureLayer,                   noll_inds    : Array,                  coefficients : Array = None,                  name         : str   = \"AberratedAperture\",                  **kwargs) -&gt; ApertureLayer:          \"\"\"         Constructor for the AberratedAperture class.          Parameters         ----------         aperture: ApertureLayer             The aperture on which the aberration basis is defined.         noll_inds: List[int]             The noll indices are a scheme for indexing the Zernike             polynomials. Normally these polynomials have two              indices but the noll indices prevent an order to              these pairs. All basis can be indexed using the noll             indices based on `n` and `m`.          coefficients: Array = None             The amplitude of each basis vector of the aberrations. If nothing              is provided, then the coefficients are set to zero.         name: str = 'AberratedAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         if aperture.occulting:             raise ValueError(\"AberratedApertures can not be occulting.\")                  if not isinstance(aperture, DynamicAperture):             raise ValueError(\"AberratedApertures can not contain Static, \" + \\                 \"Compound or Multi Apertures. AberratedApertures can be \" + \\                 \"placed in Compound or Multi Apertures, which can then be \" + \\                 \"promoted to Static.\")          # Set Aperture         self.aperture = aperture          # Set Basis         self.basis = dLux.aberrations.ZernikeBasis(noll_inds)          # Initialise the coefficinets         coefficients = np.zeros(len(noll_inds)) if coefficients is None \\             else np.asarray(coefficients).astype(float)          super().__init__(coefficients=coefficients, name=name, **kwargs)                  # Dimensionality check         dLux.exceptions.validate_bc_attr_dims(             noll_inds.shape, self.coefficients.shape, \"coefficients\")        def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the aperture and the abberations to the wavefront.             Parameters         ----------         wavefront: Wavefront             The wavefront that is passing through the aperture.          Returns         -------         wavefront: Wavefront             The wavefront after passing through the aperture.         \"\"\"         # Calculate aperture and opd         coordinates = wavefront.pixel_coordinates         opd = self._opd(coordinates)         aperture = self.aperture._aperture(coordinates)          # Calculate and update amplitude and phase         phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)         amplitude = wavefront.amplitude * aperture         return wavefront.set_phasor(amplitude, phase)        def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         return self.aperture._aperture(coordinates)               def get_aperture(self     : ApertureLayer,                       npixels  : int,                       diameter : float) -&gt; Array:         \"\"\"         Compute the array representing the aperture on a set of coordinates          with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self.aperture._aperture(coordinates)       def _basis(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the basis vectors on.          Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         coordinates = self.aperture._normalised_coordinates(coordinates)          if isinstance(self.aperture, RegularPolygonalAperture):             ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)         else:             ikes = self.basis.calculate_basis(coordinates)          is_reg_pol = isinstance(self.aperture, RegularPolygonalAperture)         is_circ = isinstance(self.aperture, CircularAperture)          if is_circ or is_reg_pol:             return ikes          aperture = self.aperture._aperture(coordinates)         ikes = self._orthonormalise(aperture, ikes)          return ikes        def get_basis(self     : ApertureLayer,                    npixels  : int,                    diameter : float) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._basis(coordinates)        def _opd(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the opd on.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         basis = self._basis(coordinates)         return (basis * self.coefficients[:, None, None]).sum(axis=0)       def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:         \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates with the specified number of pixels and          diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._opd(coordinates)       def _orthonormalise(self     : ApertureLayer,                          aperture : Array,                          zernikes : Array) -&gt; Array:         \"\"\"         Orthonomalises the zernike polynomials on the aperture.                  Parameters         ----------         aperture : Array             An array representing the aperture.         zernikes : Array             The zernike polynomials to orthonormalise on the aperture.           Returns         -------         basis : Array             The orthonormalised zernike polynomials evaluated on the aperture.         \"\"\"         pixel_area = aperture.sum()         shape = zernikes.shapediameter         basis = np.zeros(shape).at[0].set(aperture)           for j in np.arange(1, self.nterms):             intermediate = zernikes[j] * aperture             coefficient = np.zeros((self.nterms, 1, 1), dtype=float)             mask = (np.arange(1, self.nterms) &gt; j + 1).reshape((-1, 1, 1))               coefficient = -1 / pixel_area * \\                 (zernikes[j] * basis[1:] * aperture * mask)\\                 .sum(axis = (1, 2))\\                 .reshape(-1, 1, 1)               intermediate += (coefficient * basis[1:] * mask).sum(axis = 0)                          basis = basis\\                 .at[j]\\                 .set(intermediate / \\                     np.sqrt((intermediate ** 2).sum() / pixel_area))                  return basis           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         summary = super().summary(angular_units, cartesian_units, sigfigs)         return summary[:-1] + f\" with {len(self.coefficients)} aberrations.\"   In\u00a0[\u00a0]: Copied! <pre>class CompositeAperture(AbstractDynamicAperture, ABC):\n\"\"\"\n    An abstract class used to combine multiple apertures so that more complex\n    apertures can have global transformations applied to them. Two examples \n    would be a pupil with spiders holding the secondary mirror or an aperture\n    mask.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n       The sub-apertures that make up the full aperture. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    apertures : dict\n\n\n    def __init__(self        : ApertureLayer, \n                 apertures   : list,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = 'CompositeAperture') -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompositeAperture class.\n\n        Parameters\n        ----------\n        apertures: dict(str, Aperture)\n            The sub-apertures that make up the full aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'CompositeAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre,\n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n        \n        for aperture in apertures:\n            if not isinstance(aperture, ApertureLayer):\n                raise ValueError(\"All the apertures should be ApertureLayers.\")\n            if isinstance(aperture, AbstractStaticAperture):\n                raise ValueError(\"StaticApertures cannot be put into \" + \\\n                    \"Compound or Multi Apertures. Please promote the \" + \\\n                    \"Compound or Multi Aperture to a StaticAperture.\")\n\n        self.apertures = list_to_dictionary(apertures, ordered=False)\n\n\n    def _stacked_apertures(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calculates an array of individual apertures comprising the compound \n        aperture on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the apertures on.\n\n        Returns\n        -------\n        apertures: Array\n            The array of all the individual apertures.\n        \"\"\"\n        # Get coordinates and define leaf function\n        coordinates = self._coordinates(coordinates)\n        _leaf = lambda ap: isinstance(ap, ApertureLayer)\n\n        # Get Apertures\n        get_aperture = lambda ap: ap._aperture(coordinates)\n        aps = tree_map(get_aperture, self.apertures, is_leaf=_leaf)\n\n        # Construct Aperture\n        return np.array(list(aps.values()))\n\n\n    @abstractmethod\n    def _aperture(self        : ApertureLayer, \n                  coordinates : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n    \n\n    def get_aperture(self     : ApertureLayer, \n                     npixels  : int, \n                     diameter : float) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on a set of coordinates \n        with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._aperture(coordinates)\n\n\n    def _basis(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n        aberrated = self._aberrated_apertures()\n        _leaf = lambda ap: isinstance(ap, ApertureLayer)\n        get_basis = lambda ap: ap._basis(coordinates)\n        basis = tree_map(get_basis, aberrated, is_leaf=_leaf)\n        return np.squeeze(np.array(tree_flatten(basis)[0]))\n\n    \n    def get_basis(self     : ApertureLayer, \n                  npixels  : int, \n                  diameter : float) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._basis(coordinates)\n\n\n    def _coefficients(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the coefficients of the stored aberrated apertures.\n\n        Returns \n        -------\n        coefficients : Array\n           The coefficients of the aberrated sub-aperture/apertures\n        \"\"\"\n        aberrated = self._aberrated_apertures()\n        _leaf = lambda ap: isinstance(ap, ApertureLayer)\n        get_coeffs = lambda ap: ap.coefficients\n        coeffs = tree_map(get_coeffs, aberrated, is_leaf=_leaf)\n        return np.squeeze(np.array(tree_flatten(coeffs)[0]))\n\n    \n    @property\n    def coefficients(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the coefficinets of the stored aberrated apertures.\n\n        Returns\n        -------\n        coefficients : Array\n           The coefficients of the aberrated sub-aperture/apertures\n        \"\"\"\n        return self._coefficients()\n\n\n    def _opd(self : ApertureLayer, coordinates : Array) -&gt; Array:        \n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        # Get the aberrated aperture in a list\n        aberrated = self._aberrated_apertures()\n\n        # Check for an aberrated aperture\n        if not any(aberrated):\n            return np.array(0)\n        \n        # Define leaf and get coordinates\n        _leaf = lambda ap: isinstance(ap, ApertureLayer)\n        coordinates = self._coordinates(coordinates)\n\n        # Get basis\n        get_basis = lambda ap: ap._basis(coordinates)\n        basis = tree_map(get_basis, aberrated, is_leaf=_leaf)\n        basis = np.array(tree_flatten(basis)[0])\n\n        # Get coeffs\n        get_coeffs = lambda ap: ap.coefficients\n        coeffs = tree_map(get_coeffs, aberrated, is_leaf=_leaf)\n        coeffs = np.array(tree_flatten(coeffs)[0])\n\n        # Calculate opd\n        return (basis * coeffs[:, :, None, None]).sum((0, 1))\n        \n\n    def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates with the specified number of pixels and \n        diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._opd(coordinates)\n\n\n    def _aberrated_apertures(self : ApertureLayer) -&gt; list:\n\"\"\"\n        Returns the individual apertures with aberrations.\n\n        Returns\n        -------\n        apertures: list[AberratedApertures]\n            The list of apertures with aberrations.\n        \"\"\"\n        # Define leaf fn\n        is_aberrated = lambda leaf: isinstance(leaf, AberratedAperture)\n\n        # Get aberrated apertures\n        filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)\n        aberrated = filter(self.apertures, filter_map)\n        return tree_flatten(aberrated, is_leaf=is_aberrated)[0]\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture to an incoming wavefront.\n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The incoming wavefront.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The outgoing wavefront.\n        \"\"\"\n        coordinates = wavefront.pixel_coordinates\n        aper = self._aperture(coordinates)\n        opd = self._opd(coordinates)\n\n        # Calcualte and update amplitude and phase\n        phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)\n        amplitude = wavefront.amplitude * aper\n        return wavefront.set_phasor(amplitude, phase)\n    \n    def __getattr__(self : ApertureLayer, key : str) -&gt; Any:\n\"\"\"\n        Get the attribute of the aberrated apertures.\n\n        TODO: Needs testing\n\n        Parameters\n        ----------\n        key: str\n            The attribute to get.\n        Returns\n        -------\n        attribute: Any\n            The attribute of the aberrated apertures.\n        \"\"\"\n        if key in self.apertures:\n            return self.apertures[key]\n        else:\n            raise AttributeError(f\"{key} not in {self.apertures.keys()}\")\n\n\nclass CompoundAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture with spiders holding a secondary mirror.\n    This class is distinct from the MultiAperture class in that the \n    sub-apertures are combined by mulitplying their respective tranmissions \n    together, ie the sub-apertures are overlapping.\n\n    This class should not contain a MulitAperture, but MultiApertures can \n    contain CompoundApertures.\n\n    A single aberrated aperture can be placed into the set of apertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self        : ApertureLayer,\n                 apertures   : list,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = \"CompoundAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompoundAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'CompoundAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        # Check for more than one aberration\n        naberrated = 0\n        for aperture in apertures:\n            if isinstance(aperture, CompositeAperture):\n                raise ValueError(\"CompositeApertures cannot be nested. To \" +\\\n                    \"combine multiple CompositeApertures, use MultiAperture.\")\n            if isinstance(aperture, AberratedAperture):\n                naberrated += 1\n        if naberrated &gt; 1:\n            raise ValueError(\"CompoundAperture can only have one \" + \\\n                             \"AberratedAperture.\")\n            \n        super().__init__(apertures,\n                         centre = centre,\n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n        \n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n        aps = self._stacked_apertures(coordinates)\n        return aps.prod(axis=0)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = (\"Applies a Compound Aperture with the following \"\n                   \"sub-apertures: \\n\")\n        for ap in self.apertures.values():\n            ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n            summary += ap_summary + \"\\n\"\n        return summary\n\n\nclass MultiAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture mask.\n    This class is distinct from the CompoundAperture class in that the \n    sub-apertures are combined by adding their respective tranmissions \n    together, ie the sub-apertures are not overlapping.\n\n    This class can contain multiple CompoundApertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n    \n    def __init__(self        : ApertureLayer,\n                 apertures   : list,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = \"MultiAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the MultiAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'MultiAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(apertures,\n                         centre = centre,\n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n\n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n        aps = self._stacked_apertures(coordinates)\n        return aps.sum(axis=0)\n\n\n    def _aberrated_apertures(self : ApertureLayer) -&gt; list:\n\"\"\"\n        Returns the individual apertures with aberrations.\n        Note: This method returns CompoundApertures if it contains apertures\n        with aberrations in them.\n\n        Returns\n        -------\n        apertures: list[Union[AberratedAperture, CompoundAperture]]\n            The list of apertures with aberrations.\n        \"\"\"\n        # Define leaf fn\n        def is_aberrated(leaf):\n            if isinstance(leaf, AberratedAperture):\n                return True\n            elif isinstance(leaf, CompoundAperture):\n                if len(leaf._aberrated_apertures()) &gt; 0:\n                    return True\n            return False\n\n        # Get aberrated apertures\n        filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)\n        aberrated = filter(self.apertures, filter_map)\n        return tree_flatten(aberrated, is_leaf=is_aberrated)[0]\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = (\"Applies a Multi Aperture with the following \"\n                   \"sub-apertures: \\n\")\n        for ap in self.apertures.values():\n            ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n            summary += ap_summary + \"\\n\"\n        return summary\n</pre> class CompositeAperture(AbstractDynamicAperture, ABC):     \"\"\"     An abstract class used to combine multiple apertures so that more complex     apertures can have global transformations applied to them. Two examples      would be a pupil with spiders holding the secondary mirror or an aperture     mask.      Attributes     ----------     apertures: dict(str, Aperture)        The sub-apertures that make up the full aperture.      centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     apertures : dict       def __init__(self        : ApertureLayer,                   apertures   : list,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  name        : str   = 'CompositeAperture') -&gt; ApertureLayer:         \"\"\"         Constructor for the CompositeAperture class.          Parameters         ----------         apertures: dict(str, Aperture)             The sub-apertures that make up the full aperture.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         name: str = 'CompositeAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(centre = centre,                          shear = shear,                           compression = compression,                          rotation = rotation,                          name = name)                  for aperture in apertures:             if not isinstance(aperture, ApertureLayer):                 raise ValueError(\"All the apertures should be ApertureLayers.\")             if isinstance(aperture, AbstractStaticAperture):                 raise ValueError(\"StaticApertures cannot be put into \" + \\                     \"Compound or Multi Apertures. Please promote the \" + \\                     \"Compound or Multi Aperture to a StaticAperture.\")          self.apertures = list_to_dictionary(apertures, ordered=False)       def _stacked_apertures(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Calculates an array of individual apertures comprising the compound          aperture on the input coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the apertures on.          Returns         -------         apertures: Array             The array of all the individual apertures.         \"\"\"         # Get coordinates and define leaf function         coordinates = self._coordinates(coordinates)         _leaf = lambda ap: isinstance(ap, ApertureLayer)          # Get Apertures         get_aperture = lambda ap: ap._aperture(coordinates)         aps = tree_map(get_aperture, self.apertures, is_leaf=_leaf)          # Construct Aperture         return np.array(list(aps.values()))       @abstractmethod     def _aperture(self        : ApertureLayer,                    coordinates : Array) -&gt; Array: # pragma: no cover         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the combined              sub-apertures.          \"\"\"           def get_aperture(self     : ApertureLayer,                       npixels  : int,                       diameter : float) -&gt; Array:         \"\"\"         Compute the array representing the aperture on a set of coordinates          with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._aperture(coordinates)       def _basis(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the basis vectors on.          Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         coordinates = self._coordinates(coordinates)         aberrated = self._aberrated_apertures()         _leaf = lambda ap: isinstance(ap, ApertureLayer)         get_basis = lambda ap: ap._basis(coordinates)         basis = tree_map(get_basis, aberrated, is_leaf=_leaf)         return np.squeeze(np.array(tree_flatten(basis)[0]))           def get_basis(self     : ApertureLayer,                    npixels  : int,                    diameter : float) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations on the provided          coordinates with the specified number of pixels and diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._basis(coordinates)       def _coefficients(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the coefficients of the stored aberrated apertures.          Returns          -------         coefficients : Array            The coefficients of the aberrated sub-aperture/apertures         \"\"\"         aberrated = self._aberrated_apertures()         _leaf = lambda ap: isinstance(ap, ApertureLayer)         get_coeffs = lambda ap: ap.coefficients         coeffs = tree_map(get_coeffs, aberrated, is_leaf=_leaf)         return np.squeeze(np.array(tree_flatten(coeffs)[0]))           @property     def coefficients(self : ApertureLayer) -&gt; Array:         \"\"\"         Returns the coefficinets of the stored aberrated apertures.          Returns         -------         coefficients : Array            The coefficients of the aberrated sub-aperture/apertures         \"\"\"         return self._coefficients()       def _opd(self : ApertureLayer, coordinates : Array) -&gt; Array:                 \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the opd on.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         # Get the aberrated aperture in a list         aberrated = self._aberrated_apertures()          # Check for an aberrated aperture         if not any(aberrated):             return np.array(0)                  # Define leaf and get coordinates         _leaf = lambda ap: isinstance(ap, ApertureLayer)         coordinates = self._coordinates(coordinates)          # Get basis         get_basis = lambda ap: ap._basis(coordinates)         basis = tree_map(get_basis, aberrated, is_leaf=_leaf)         basis = np.array(tree_flatten(basis)[0])          # Get coeffs         get_coeffs = lambda ap: ap.coefficients         coeffs = tree_map(get_coeffs, aberrated, is_leaf=_leaf)         coeffs = np.array(tree_flatten(coeffs)[0])          # Calculate opd         return (basis * coeffs[:, :, None, None]).sum((0, 1))               def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:         \"\"\"         Compute the total optical path difference of the aperture aberrations          on the provided coordinates with the specified number of pixels and          diameter.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)         return self._opd(coordinates)       def _aberrated_apertures(self : ApertureLayer) -&gt; list:         \"\"\"         Returns the individual apertures with aberrations.          Returns         -------         apertures: list[AberratedApertures]             The list of apertures with aberrations.         \"\"\"         # Define leaf fn         is_aberrated = lambda leaf: isinstance(leaf, AberratedAperture)          # Get aberrated apertures         filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)         aberrated = filter(self.apertures, filter_map)         return tree_flatten(aberrated, is_leaf=is_aberrated)[0]       def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the aperture to an incoming wavefront.          Parameters         ----------         wavefront: Wavefront             The incoming wavefront.          Returns         -------         wavefront: Wavefront             The outgoing wavefront.         \"\"\"         coordinates = wavefront.pixel_coordinates         aper = self._aperture(coordinates)         opd = self._opd(coordinates)          # Calcualte and update amplitude and phase         phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)         amplitude = wavefront.amplitude * aper         return wavefront.set_phasor(amplitude, phase)          def __getattr__(self : ApertureLayer, key : str) -&gt; Any:         \"\"\"         Get the attribute of the aberrated apertures.          TODO: Needs testing          Parameters         ----------         key: str             The attribute to get.                  Returns         -------         attribute: Any             The attribute of the aberrated apertures.         \"\"\"         if key in self.apertures:             return self.apertures[key]         else:             raise AttributeError(f\"{key} not in {self.apertures.keys()}\")   class CompoundAperture(CompositeAperture):     \"\"\"     A  class used to combine multiple apertures into a single coherent aperture.     An example would be an aperture with spiders holding a secondary mirror.          This class is distinct from the MultiAperture class in that the      sub-apertures are combined by mulitplying their respective tranmissions      together, ie the sub-apertures are overlapping.      This class should not contain a MulitAperture, but MultiApertures can      contain CompoundApertures.      A single aberrated aperture can be placed into the set of apertures.      Attributes     ----------     apertures: dict(str, Aperture)         The sub-apertures that make up the full aperture.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"       def __init__(self        : ApertureLayer,                  apertures   : list,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  name        : str   = \"CompoundAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the CompoundAperture class.          Parameters         ----------         apertures: list[Aperture]             The sub-apertures that make up the full aperture.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         name: str = 'CompoundAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         # Check for more than one aberration         naberrated = 0         for aperture in apertures:             if isinstance(aperture, CompositeAperture):                 raise ValueError(\"CompositeApertures cannot be nested. To \" +\\                     \"combine multiple CompositeApertures, use MultiAperture.\")             if isinstance(aperture, AberratedAperture):                 naberrated += 1         if naberrated &gt; 1:             raise ValueError(\"CompoundAperture can only have one \" + \\                              \"AberratedAperture.\")                      super().__init__(apertures,                          centre = centre,                          shear = shear,                          compression = compression,                          rotation = rotation,                          name = name)               def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the combined              sub-apertures.          \"\"\"         aps = self._stacked_apertures(coordinates)         return aps.prod(axis=0)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         summary = (\"Applies a Compound Aperture with the following \"                    \"sub-apertures: \\n\")         for ap in self.apertures.values():             ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)             summary += ap_summary + \"\\n\"         return summary   class MultiAperture(CompositeAperture):     \"\"\"     A  class used to combine multiple apertures into a single coherent aperture.     An example would be an aperture mask.          This class is distinct from the CompoundAperture class in that the      sub-apertures are combined by adding their respective tranmissions      together, ie the sub-apertures are not overlapping.      This class can contain multiple CompoundApertures.      Attributes     ----------     apertures: dict(str, Aperture)         The sub-apertures that make up the full aperture.     centre: Array, meters         The (x, y) coordinates of the centre of the aperture.     shear: Array         The (x, y) linear shear of the aperutre.     compression: Array          The (x, y) compression of the aperture.      rotation: Array, radians         The clockwise rotation of the aperture.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"           def __init__(self        : ApertureLayer,                  apertures   : list,                  centre      : Array = np.array([0., 0.]),                   shear       : Array = np.array([0., 0.]),                  compression : Array = np.array([1., 1.]),                  rotation    : Array = np.array(0.),                  name        : str   = \"MultiAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the MultiAperture class.          Parameters         ----------         apertures: list[Aperture]             The sub-apertures that make up the full aperture.         centre: Array, meters = np.array([0., 0.])             The (x, y) coordinates of the centre of the aperture.         shear: Array = np.array([0., 0.])             The (x, y) linear shear of the aperutre.         compression: Array  = np.array([1., 1.])              The (x, y) compression of the aperture.          rotation: Array, radians = np.array(0.)             The clockwise rotation of the aperture.         name: str = 'MultiAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(apertures,                          centre = centre,                          shear = shear,                          compression = compression,                          rotation = rotation,                          name = name)       def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:         \"\"\"         Compute the array representing the aperture on the provided coordinates.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the combined              sub-apertures.          \"\"\"         aps = self._stacked_apertures(coordinates)         return aps.sum(axis=0)       def _aberrated_apertures(self : ApertureLayer) -&gt; list:         \"\"\"         Returns the individual apertures with aberrations.         Note: This method returns CompoundApertures if it contains apertures         with aberrations in them.          Returns         -------         apertures: list[Union[AberratedAperture, CompoundAperture]]             The list of apertures with aberrations.         \"\"\"         # Define leaf fn         def is_aberrated(leaf):             if isinstance(leaf, AberratedAperture):                 return True             elif isinstance(leaf, CompoundAperture):                 if len(leaf._aberrated_apertures()) &gt; 0:                     return True             return False          # Get aberrated apertures         filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)         aberrated = filter(self.apertures, filter_map)         return tree_flatten(aberrated, is_leaf=is_aberrated)[0]       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         summary = (\"Applies a Multi Aperture with the following \"                    \"sub-apertures: \\n\")         for ap in self.apertures.values():             ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)             summary += ap_summary + \"\\n\"         return summary  In\u00a0[\u00a0]: Copied! <pre>class AbstractStaticAperture(ApertureLayer):\n\"\"\"\n    An abstract class used to represent static apertures. Static apertures \n    pre-calcualte the aperture array on the specified init time cooridantes and\n    can not have its parameters optimised. \n\n    Attributes\n    ----------\n    aperture: Array\n        The aperture represented as an array.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    aperture : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 aperture    : ApertureLayer, \n                 npixels     : int   = None, \n                 diameter    : float = None,\n                 coordinates : Array = None,\n                 name        : str   = \"AbstractStaticAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the AbstractStaticAperture class.\n\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture to be pre-calculated and represented as an array.\n        npixels : int = None\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters = None\n            The diameter of the aperture in meters. \n        coordinates : Array, meters = None\n            The coordinate system to calculate the aperture on.\n        name: str = 'AbstractStaticAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        # Input check: Coordinates provided\n        if coordinates is not None and \\\n            (npixels is not None or diameter is not None):\n            raise ValueError(\"If coordinates is specified npixels and \" + \\\n                \"diameter can not be provided.\")\n        # Input check: Coordinates not provided\n        elif coordinates is None and \\\n            (npixels is None or diameter is None):\n            raise ValueError(\"both npixels and diameter must be provided.\")\n        \n        # Generate coordinates if not provided\n        if coordinates is None:\n            npixels_in = (npixels, npixels)\n            pixel_scales = (diameter / npixels, diameter / npixels)\n            coordinates = get_pixel_positions(npixels_in, pixel_scales)\n\n        super().__init__(name = name)\n        self.aperture = aperture._aperture(coordinates)\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture to the wavefront.\n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront that is passing through the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after passing through the aperture.\n        \"\"\"\n        return wavefront.multiply_amplitude(self.aperture)\n    \n\n    def _aperture(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n        return self.aperture\n\n    def get_aperture(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self._aperture()\n\n\nclass StaticAperture(AbstractStaticAperture):\n\"\"\"\n    A class for static pre-calculated apertures, without aberrations. Static\n    apertures with aberrations can be instantiated using the \n    StaticAberratedAberrated class.\n\n    Attributes\n    ----------\n    aperture: Array\n        The aperture represented as an array.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self        : ApertureLayer, \n                 aperture    : ApertureLayer, \n                 npixels     : int   = None, \n                 diameter    : float = None,\n                 coordinates : Array = None,\n                 name        : str   = \"StaticAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the StaticAperture class.\n\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            An instance of DynamicAperture. \n        npixels : int = None\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters = None\n            The diameter of the aperture in meters. \n        coordinates : Array, meters = None\n            The coordinate system to calculate the aperture on.\n        name: str = 'StaticAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        if isinstance(aperture, AbstractStaticAperture):\n            raise ValueError(\"This Aperture is already static, please \" + \\\n                \"provide a dynamic aperture.\")\n        \n        if isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n            len(aperture._aberrated_apertures()) &gt; 0 or \\\n                isinstance(aperture, AberratedAperture):\n            raise ValueError(\"This Aperture contains aberrated apertures, \" + \\\n                \"please use the StaticAberratedAperture class.\")\n        \n        super().__init__(aperture = aperture, \n                         npixels = npixels, \n                         diameter = diameter, \n                         coordinates = coordinates, \n                         name = name)\n        \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return \"Applies a pre-calculated Static Aperture.\"\n\n\n\nclass StaticAberratedAperture(AbstractAberratedAperture, AbstractStaticAperture):\n\"\"\"\n    A class for static pre-calculated apertures with aberrations. This \n    pre-calcaultes both the aperture and the basis at init time and can not \n    have the aperture properties optimised.\n\n    Attributes\n    ----------\n    aperture: Array\n        The aperture represented as an array.\n    basis: Array \n        The basis represented as an array.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 aperture    : ApertureLayer, \n                 npixels     : int   = None, \n                 diameter    : float = None,\n                 coordinates : Array = None,\n                 name        : str   = \"StaticAberratedAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the StaticAberratedAperture class.\n\n        Parameters\n        ----------\n        aperture: AberratedAperture\n            An instance of AberratedAperture. \n        npixels : int = None\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters = None\n            The diameter of the aperture in meters. \n        coordinates : Array, meters = None\n            The coordinate system to calculate the aperture on.\n        name: str = 'StaticAberratedAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        # Ensure correct aperture types\n        if not isinstance(aperture, \n            (AberratedAperture, CompoundAperture, MultiAperture)) and \\\n                (isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n                    len(aperture._aberrated_apertures()) == 0):\n            raise ValueError(\"The provided aperture must have aberrations.\")\n        \n        # Input check: Coordinates provided\n        if coordinates is not None and \\\n            (npixels is not None or diameter is not None):\n            raise ValueError(\"If coordinates is specified npixels and \" + \\\n                \"diameter can not be provided.\")\n        # Input check: Coordinates not provided\n        elif coordinates is None and \\\n            (npixels is None or diameter is None):\n            raise ValueError(\"both npixels and diameter must be provided.\")\n        \n        # Generate coordinates if not provided\n        if coordinates is None:\n            npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n\n        super().__init__(aperture=aperture, coordinates=coordinates, \n            coefficients=aperture.coefficients, name=name)\n        \n        self.basis = aperture._basis(coordinates)\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture to the wavefront.\n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront that is passing through the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after passing through the aperture\n        \"\"\"\n        # Calculate and update amplitude and phase\n        phase = wavefront.phase + opd_to_phase(self._opd(), \n                                               wavefront.wavelength)\n        amplitude = wavefront.amplitude * self.aperture\n        return wavefront.set_phasor(amplitude, phase)\n\n\n    def _basis(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        return self.basis\n\n\n    def get_basis(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        return self._basis()\n\n\n    def _opd(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        if self.coefficients.ndim == 1:\n            return (self.basis * self.coefficients[:, None, None]).sum(0)\n        else:\n            return (self.basis * self.coefficients[:, :, None, None]).sum((0, 1))\n\n\n    def get_opd(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        return self._opd()\n    \n\n    @property\n    def opd(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Return the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        return self._opd()\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"Applies a pre-calculated Static Aperture with \"\n                f\"{len(self.coefficients)} aberrations.\")\n</pre> class AbstractStaticAperture(ApertureLayer):     \"\"\"     An abstract class used to represent static apertures. Static apertures      pre-calcualte the aperture array on the specified init time cooridantes and     can not have its parameters optimised.       Attributes     ----------     aperture: Array         The aperture represented as an array.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     aperture : Array       def __init__(self        : ApertureLayer,                   aperture    : ApertureLayer,                   npixels     : int   = None,                   diameter    : float = None,                  coordinates : Array = None,                  name        : str   = \"AbstractStaticAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the AbstractStaticAperture class.          Parameters         ----------         aperture: ApertureLayer             The aperture to be pre-calculated and represented as an array.         npixels : int = None             The number of pixels accross one edge of the aperture.           diameter : float, meters = None             The diameter of the aperture in meters.          coordinates : Array, meters = None             The coordinate system to calculate the aperture on.         name: str = 'AbstractStaticAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         # Input check: Coordinates provided         if coordinates is not None and \\             (npixels is not None or diameter is not None):             raise ValueError(\"If coordinates is specified npixels and \" + \\                 \"diameter can not be provided.\")         # Input check: Coordinates not provided         elif coordinates is None and \\             (npixels is None or diameter is None):             raise ValueError(\"both npixels and diameter must be provided.\")                  # Generate coordinates if not provided         if coordinates is None:             npixels_in = (npixels, npixels)             pixel_scales = (diameter / npixels, diameter / npixels)             coordinates = get_pixel_positions(npixels_in, pixel_scales)          super().__init__(name = name)         self.aperture = aperture._aperture(coordinates)       def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the aperture to the wavefront.          Parameters         ----------         wavefront: Wavefront             The wavefront that is passing through the aperture.          Returns         -------         wavefront: Wavefront             The wavefront after passing through the aperture.         \"\"\"         return wavefront.multiply_amplitude(self.aperture)           def _aperture(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the array representing the aperture.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the aperture on.          Returns         -------         aperture : Array              The array representing the transmission of the combined              sub-apertures.          \"\"\"         return self.aperture      def get_aperture(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the array representing the aperture.          Parameters         ----------         npixels : int             The number of pixels accross one edge of the aperture.           diameter : float, meters             The diameter of the aperture in meters.           Returns         -------         aperture : Array              The array representing the transmission of the aperture.         \"\"\"         return self._aperture()   class StaticAperture(AbstractStaticAperture):     \"\"\"     A class for static pre-calculated apertures, without aberrations. Static     apertures with aberrations can be instantiated using the      StaticAberratedAberrated class.      Attributes     ----------     aperture: Array         The aperture represented as an array.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"       def __init__(self        : ApertureLayer,                   aperture    : ApertureLayer,                   npixels     : int   = None,                   diameter    : float = None,                  coordinates : Array = None,                  name        : str   = \"StaticAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the StaticAperture class.          Parameters         ----------         aperture: ApertureLayer             An instance of DynamicAperture.          npixels : int = None             The number of pixels accross one edge of the aperture.           diameter : float, meters = None             The diameter of the aperture in meters.          coordinates : Array, meters = None             The coordinate system to calculate the aperture on.         name: str = 'StaticAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         if isinstance(aperture, AbstractStaticAperture):             raise ValueError(\"This Aperture is already static, please \" + \\                 \"provide a dynamic aperture.\")                  if isinstance(aperture, (CompoundAperture, MultiAperture)) and \\             len(aperture._aberrated_apertures()) &gt; 0 or \\                 isinstance(aperture, AberratedAperture):             raise ValueError(\"This Aperture contains aberrated apertures, \" + \\                 \"please use the StaticAberratedAperture class.\")                  super().__init__(aperture = aperture,                           npixels = npixels,                           diameter = diameter,                           coordinates = coordinates,                           name = name)               def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return \"Applies a pre-calculated Static Aperture.\"    class StaticAberratedAperture(AbstractAberratedAperture, AbstractStaticAperture):     \"\"\"     A class for static pre-calculated apertures with aberrations. This      pre-calcaultes both the aperture and the basis at init time and can not      have the aperture properties optimised.      Attributes     ----------     aperture: Array         The aperture represented as an array.     basis: Array          The basis represented as an array.     name: str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     basis : Array       def __init__(self        : ApertureLayer,                   aperture    : ApertureLayer,                   npixels     : int   = None,                   diameter    : float = None,                  coordinates : Array = None,                  name        : str   = \"StaticAberratedAperture\") -&gt; ApertureLayer:         \"\"\"         Constructor for the StaticAberratedAperture class.          Parameters         ----------         aperture: AberratedAperture             An instance of AberratedAperture.          npixels : int = None             The number of pixels accross one edge of the aperture.           diameter : float, meters = None             The diameter of the aperture in meters.          coordinates : Array, meters = None             The coordinate system to calculate the aperture on.         name: str = 'StaticAberratedAperture'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         # Ensure correct aperture types         if not isinstance(aperture,              (AberratedAperture, CompoundAperture, MultiAperture)) and \\                 (isinstance(aperture, (CompoundAperture, MultiAperture)) and \\                     len(aperture._aberrated_apertures()) == 0):             raise ValueError(\"The provided aperture must have aberrations.\")                  # Input check: Coordinates provided         if coordinates is not None and \\             (npixels is not None or diameter is not None):             raise ValueError(\"If coordinates is specified npixels and \" + \\                 \"diameter can not be provided.\")         # Input check: Coordinates not provided         elif coordinates is None and \\             (npixels is None or diameter is None):             raise ValueError(\"both npixels and diameter must be provided.\")                  # Generate coordinates if not provided         if coordinates is None:             npixels_in = (npixels, npixels)         pixel_scales = (diameter / npixels, diameter / npixels)         coordinates = get_pixel_positions(npixels_in, pixel_scales)          super().__init__(aperture=aperture, coordinates=coordinates,              coefficients=aperture.coefficients, name=name)                  self.basis = aperture._basis(coordinates)       def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the aperture to the wavefront.          Parameters         ----------         wavefront: Wavefront             The wavefront that is passing through the aperture.          Returns         -------         wavefront: Wavefront             The wavefront after passing through the aperture         \"\"\"         # Calculate and update amplitude and phase         phase = wavefront.phase + opd_to_phase(self._opd(),                                                 wavefront.wavelength)         amplitude = wavefront.amplitude * self.aperture         return wavefront.set_phasor(amplitude, phase)       def _basis(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations.          Parameters         ----------         coordinates : Array, meters             The coordinate system to calculate the basis vectors on.          Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         return self.basis       def get_basis(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the basis vectors of the aperture aberrations.          Returns         -------         basis : Array              The array of the basis vectors of the aperture aberrations.         \"\"\"         return self._basis()       def _opd(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the total optical path difference of the aperture aberrations.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         if self.coefficients.ndim == 1:             return (self.basis * self.coefficients[:, None, None]).sum(0)         else:             return (self.basis * self.coefficients[:, :, None, None]).sum((0, 1))       def get_opd(self : ApertureLayer, **kwargs) -&gt; Array:         \"\"\"         Compute the total optical path difference of the aperture aberrations.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         return self._opd()           @property     def opd(self : ApertureLayer) -&gt; Array:         \"\"\"         Return the total optical path difference of the aperture aberrations.          Returns         -------         basis : Array              The array of the total opd of the aperture aberrations.         \"\"\"         return self._opd()           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"Applies a pre-calculated Static Aperture with \"                 f\"{len(self.coefficients)} aberrations.\")    In\u00a0[\u00a0]: Copied! <pre>class ApertureFactory():\n\"\"\"\n    This class is not actually ever instatiated, but is rather a class used to \n    give a simple constructor interface that is used to construct the most\n    commonly used apertures. It is able to construct hard-edged circular or \n    regular poygonalal apertures. Secondary mirrors obscurations with the same\n    aperture shape can be constructed, along with uniformly spaced struts. \n    Aberrations can also be applied to the aperture. The ratio of the primary\n    aperture opening to the array size is determined by the `aperture_ratio`\n    parameter, with secondary mirror obscurations and struts being scaled\n    relative to the aperture diameter. \n\n    Lets look at an example of how to construct a simple circular aperture with\n    a secondary mirror obscurtion held by 4 struts and some low-order \n    aberrations. For this example lets take a 2m diameter aperutre, with a 20cm \n    secondary mirror held by 3 struts with a width of 2cm. In this example the\n    secondary mirror is 10% of the primary aperture diameter and the struts are\n    1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for\n    the `secondary_ratio` and `strut_ratio` parameters. Let calcualte this for\n    a 512x512 array with the aperture spanning the full array.\n\n    ```python\n    from dLux import SimpleAperture\n    import jax.numpy as np\n    import jax.random as jr\n    # Construct Zernikes\n    zernikes = np.arange(4, 11)\n    coefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n    # Construct aperture\n    aperture = SimpleAperture(512, secondary_ratio=0.1, nstruts=4, \n                              strut_ratio=0.01, zernikes=zernikes, \n                              coefficients=coefficients)\n    ```\n    The resulting aperture class has three parameters, `.aperture`, `.basis`\n    and `.coefficients`. We can examine the aperture and opd like so:\n\n    ```python\n    import matplotlib.pyplot as plt\n\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.aperture)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(aperture.opd)\n    plt.colorbar()\n    plt.show()\n    ```\n\n    We can also easily change this to a hexagonal aperture with 3 struts:\n\n    ```python\n    # Make aperture\n    aperture = SimpleAperture(512, nsides=6, secondary_ratio=0.1, nstruts=3, \n                              strut_ratio=0.01, zernikes=zernikes, \n                              coefficients=coefficients)\n    # Examine\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.aperture)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(aperture.opd)\n    plt.colorbar()\n    plt.show()\n    ```\n    \"\"\"\n    def __new__(cls              : ApertureFactory, \n                npixels          : int, \n                nsides           : int   = 0,\n                rotation         : float = 0., \n\n                # Sizing\n                aperture_ratio   : float = 1.0,\n                secondary_ratio  : float = 0.,\n                secondary_nsides : int = 0,\n\n                # Spiders\n                nstruts          : int   = 0,\n                strut_ratio      : float = 0.,\n                strut_rotation   : float = 0.,\n                \n                # Aberrations\n                zernikes         : Array = None, \n                coefficients     : Array = None, \n\n                # name\n                name             : str = None):\n\"\"\"\n        Constructs a basic single static aperture, either with or without \n        aberrations.\n\n        TODO: Add link to the zenike noll indicies\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperture_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        secondary_ratio : float = 0.\n            The ratio of the secondary mirror obsuration diameter to the \n            aperture diameter. A value of 0. results in no secondary mirror \n            obsuration.\n        secondary_nsides : int = 0\n            The number of sides of the secondary mirror obsuration. A zero input\n            results in a circular aperture. All other other values of three and \n            above are supported.\n        nstruts : int = 0\n            The number of uniformly spaced struts holding the secondary mirror. \n        strut_ratio : float = 0.\n            The ratio of the width of the strut to the aperture diameter.\n        strut_rotation : float = 0\n            The rotation of the struts in radians.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n        Returns\n        -------\n        aperture : Union[StaticAperture, StaticAberratedAperture]\n            Returns an appropriately constructed StaticAperture or \n            StaticAberratedAperture, depending on if zernikes are provided.\n        \"\"\"\n        # Check vaid inputs\n        if nsides &lt; 3 and nsides != 0:\n            raise ValueError(\"nsides must be either 0 or &gt;=3\")\n        \n        if secondary_nsides &lt; 3 and secondary_nsides != 0:\n            raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")\n        \n        if aperture_ratio &lt;= 0:\n            raise ValueError(\"aperture_ratio must be &gt; 0\")\n        \n        if secondary_ratio &lt; 0:\n            raise ValueError(\"secondary_ratio must be &gt;= 0\")\n        \n        if strut_ratio &lt; 0:\n            raise ValueError(\"strut_ratio must be &gt;= 0\")\n\n        \n        # Auto-name\n        if name is None:\n            if nsides &gt; 8:\n                raise ValueError(\"Warning: Auto-naming not supported for \" + \\\n                \"nsides &gt; 8. Please provide a name.\")\n            sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\", \n                \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]\n            name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"\n\n\n        # Construct components\n        apertures = []\n\n        # Circular Primary\n        if nsides == 0:\n            apertures.append(CircularAperture(aperture_ratio/2, softening=0))\n        # Polygonal Primary\n        else: \n            apertures.append(RegularPolygonalAperture(\n                nsides, aperture_ratio/2, softening=0, rotation=rotation))\n\n        # Secondary\n        if secondary_ratio != 0:\n            secondary_rel = aperture_ratio * secondary_ratio\n\n            # Circular\n            if secondary_nsides == 0: \n                apertures.append(CircularAperture(\n                    secondary_rel/2, softening=0, occulting=True))\n            # Polygonal\n            else: \n                apertures.append(RegularPolygonalAperture(secondary_nsides, \n                    secondary_rel/2, softening=0, rotation=rotation, \n                        occulting=True))\n        \n        # Spiders\n        if nstruts &gt; 0:\n            if strut_ratio == 0:\n                raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")\n            strut_rel = aperture_ratio * strut_ratio\n            full_rotation = strut_rotation + rotation\n            apertures.append(UniformSpider(\n                nstruts, strut_rel, rotation=full_rotation, softening=0))\n\n\n        # Add aberrations and make static\n        if zernikes is not None:\n            # Construct Aberrations\n            apertures[0] = AberratedAperture(apertures[0], zernikes, \n                                                coefficients)\n\n            # Construct CompoundAperture\n            full_aperture = CompoundAperture(apertures)\n            static = StaticAberratedAperture(full_aperture, npixels, 1, \n                                                name=name)\n        else:\n            # Construct CompoundAperture\n            full_aperture = CompoundAperture(apertures)\n            static = StaticAperture(full_aperture, npixels, 1, name=name)\n\n        return static\n\n\n    def __init__(self             : ApertureFactory, \n                 npixels          : int, \n                 nsides           : int   = 0,\n                 rotation         : float = 0., \n\n                 # Sizing\n                 aperture_ratio   : float = 1.0,\n                 secondary_ratio  : float = 0.,\n                 secondary_nsides : int = 0,\n\n                 # Spiders\n                 nstruts          : int   = 0,\n                 strut_ratio      : float = 0.,\n                 strut_rotation   : float = 0.,\n                \n                 # Aberrations\n                 zernikes         : Array = None, \n                 coefficients     : Array = None, \n\n                 # name\n                 name             : str = None):\n\"\"\"\n        Constructs a basic single static aperture, either with or without \n        aberrations.\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperture_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        secondary_ratio : float = 0.\n            The ratio of the secondary mirror obsuration diameter to the \n            aperture diameter. A value of 0. results in no secondary mirror \n            obsuration.\n        nstruts : int = 0\n            The number of uniformly spaced struts holding the secondary mirror. \n        strut_ratio : float = 0.\n            The ratio of the width of the strut to the aperture diameter.\n        strut_rotation : float = 0\n            The rotation of the struts in radians.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n        Returns\n        -------\n        aperture : Union[StaticAperture, StaticAberratedAperture]\n            Returns an appropriately constructed StaticAperture or \n            StaticAberratedAperture, depending on if zernikes are provided.\n        \"\"\"\n</pre> class ApertureFactory():     \"\"\"     This class is not actually ever instatiated, but is rather a class used to      give a simple constructor interface that is used to construct the most     commonly used apertures. It is able to construct hard-edged circular or      regular poygonalal apertures. Secondary mirrors obscurations with the same     aperture shape can be constructed, along with uniformly spaced struts.      Aberrations can also be applied to the aperture. The ratio of the primary     aperture opening to the array size is determined by the `aperture_ratio`     parameter, with secondary mirror obscurations and struts being scaled     relative to the aperture diameter.       Lets look at an example of how to construct a simple circular aperture with     a secondary mirror obscurtion held by 4 struts and some low-order      aberrations. For this example lets take a 2m diameter aperutre, with a 20cm      secondary mirror held by 3 struts with a width of 2cm. In this example the     secondary mirror is 10% of the primary aperture diameter and the struts are     1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for     the `secondary_ratio` and `strut_ratio` parameters. Let calcualte this for     a 512x512 array with the aperture spanning the full array.      ```python     from dLux import SimpleAperture     import jax.numpy as np     import jax.random as jr          # Construct Zernikes     zernikes = np.arange(4, 11)     coefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))      # Construct aperture     aperture = SimpleAperture(512, secondary_ratio=0.1, nstruts=4,                                strut_ratio=0.01, zernikes=zernikes,                                coefficients=coefficients)     ```          The resulting aperture class has three parameters, `.aperture`, `.basis`     and `.coefficients`. We can examine the aperture and opd like so:      ```python     import matplotlib.pyplot as plt      plt.figure(figsize=(10, 5))     plt.subplot(1, 2, 1)     plt.imshow(aperture.aperture)     plt.colorbar()      plt.subplot(1, 2, 2)     plt.imshow(aperture.opd)     plt.colorbar()     plt.show()     ```      We can also easily change this to a hexagonal aperture with 3 struts:      ```python     # Make aperture     aperture = SimpleAperture(512, nsides=6, secondary_ratio=0.1, nstruts=3,                                strut_ratio=0.01, zernikes=zernikes,                                coefficients=coefficients)          # Examine     plt.figure(figsize=(10, 5))     plt.subplot(1, 2, 1)     plt.imshow(aperture.aperture)     plt.colorbar()      plt.subplot(1, 2, 2)     plt.imshow(aperture.opd)     plt.colorbar()     plt.show()     ```     \"\"\"     def __new__(cls              : ApertureFactory,                  npixels          : int,                  nsides           : int   = 0,                 rotation         : float = 0.,                   # Sizing                 aperture_ratio   : float = 1.0,                 secondary_ratio  : float = 0.,                 secondary_nsides : int = 0,                  # Spiders                 nstruts          : int   = 0,                 strut_ratio      : float = 0.,                 strut_rotation   : float = 0.,                                  # Aberrations                 zernikes         : Array = None,                  coefficients     : Array = None,                   # name                 name             : str = None):         \"\"\"         Constructs a basic single static aperture, either with or without          aberrations.          TODO: Add link to the zenike noll indicies          Parameters         ----------         npixels : int             Number of pixels used to represent the aperture.         nsides : int = 0             Number of sides of the aperture. A zero input results in a circular             aperture. All other other values of three and above are supported.         rotation : float, radians = 0             The global rotation of the aperture in radians.         aperture_ratio : float = 1.             The ratio of the aperture size to the array size. A value of 1.              results in an aperture that fully spans the array, a value of 0.5              retuls in an aperure that is half the size of the array, which is              equivilent to a padding factor of 2.         secondary_ratio : float = 0.             The ratio of the secondary mirror obsuration diameter to the              aperture diameter. A value of 0. results in no secondary mirror              obsuration.         secondary_nsides : int = 0             The number of sides of the secondary mirror obsuration. A zero input             results in a circular aperture. All other other values of three and              above are supported.         nstruts : int = 0             The number of uniformly spaced struts holding the secondary mirror.          strut_ratio : float = 0.             The ratio of the width of the strut to the aperture diameter.         strut_rotation : float = 0             The rotation of the struts in radians.         zernikes : Array = None             The zernike noll indices to be used for the aberrations. Please              refer to (this)[Add this link] docstring to see which indicides              correspond to which aberrations. Typical values are range(4, 11).         coefficients : Array = None             The zernike cofficients to be applied to the aberrations. Defaults              to an array of zeros.         name : str = None             The name of the aperture used to index the layers dictionary. If              not supplied, the aperture will be named based on the number of             sides. However this is only supported up to 8 sides, and a name             must be supplied for apertures with more than 8 sides.                  Returns         -------         aperture : Union[StaticAperture, StaticAberratedAperture]             Returns an appropriately constructed StaticAperture or              StaticAberratedAperture, depending on if zernikes are provided.         \"\"\"         # Check vaid inputs         if nsides &lt; 3 and nsides != 0:             raise ValueError(\"nsides must be either 0 or &gt;=3\")                  if secondary_nsides &lt; 3 and secondary_nsides != 0:             raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")                  if aperture_ratio &lt;= 0:             raise ValueError(\"aperture_ratio must be &gt; 0\")                  if secondary_ratio &lt; 0:             raise ValueError(\"secondary_ratio must be &gt;= 0\")                  if strut_ratio &lt; 0:             raise ValueError(\"strut_ratio must be &gt;= 0\")                   # Auto-name         if name is None:             if nsides &gt; 8:                 raise ValueError(\"Warning: Auto-naming not supported for \" + \\                 \"nsides &gt; 8. Please provide a name.\")             sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\",                  \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]             name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"           # Construct components         apertures = []          # Circular Primary         if nsides == 0:             apertures.append(CircularAperture(aperture_ratio/2, softening=0))         # Polygonal Primary         else:              apertures.append(RegularPolygonalAperture(                 nsides, aperture_ratio/2, softening=0, rotation=rotation))          # Secondary         if secondary_ratio != 0:             secondary_rel = aperture_ratio * secondary_ratio              # Circular             if secondary_nsides == 0:                  apertures.append(CircularAperture(                     secondary_rel/2, softening=0, occulting=True))             # Polygonal             else:                  apertures.append(RegularPolygonalAperture(secondary_nsides,                      secondary_rel/2, softening=0, rotation=rotation,                          occulting=True))                  # Spiders         if nstruts &gt; 0:             if strut_ratio == 0:                 raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")             strut_rel = aperture_ratio * strut_ratio             full_rotation = strut_rotation + rotation             apertures.append(UniformSpider(                 nstruts, strut_rel, rotation=full_rotation, softening=0))           # Add aberrations and make static         if zernikes is not None:             # Construct Aberrations             apertures[0] = AberratedAperture(apertures[0], zernikes,                                                  coefficients)              # Construct CompoundAperture             full_aperture = CompoundAperture(apertures)             static = StaticAberratedAperture(full_aperture, npixels, 1,                                                  name=name)         else:             # Construct CompoundAperture             full_aperture = CompoundAperture(apertures)             static = StaticAperture(full_aperture, npixels, 1, name=name)          return static       def __init__(self             : ApertureFactory,                   npixels          : int,                   nsides           : int   = 0,                  rotation         : float = 0.,                    # Sizing                  aperture_ratio   : float = 1.0,                  secondary_ratio  : float = 0.,                  secondary_nsides : int = 0,                   # Spiders                  nstruts          : int   = 0,                  strut_ratio      : float = 0.,                  strut_rotation   : float = 0.,                                   # Aberrations                  zernikes         : Array = None,                   coefficients     : Array = None,                    # name                  name             : str = None):         \"\"\"         Constructs a basic single static aperture, either with or without          aberrations.          Parameters         ----------         npixels : int             Number of pixels used to represent the aperture.         nsides : int = 0             Number of sides of the aperture. A zero input results in a circular             aperture. All other other values of three and above are supported.         rotation : float, radians = 0             The global rotation of the aperture in radians.         aperture_ratio : float = 1.             The ratio of the aperture size to the array size. A value of 1.              results in an aperture that fully spans the array, a value of 0.5              retuls in an aperure that is half the size of the array, which is              equivilent to a padding factor of 2.         secondary_ratio : float = 0.             The ratio of the secondary mirror obsuration diameter to the              aperture diameter. A value of 0. results in no secondary mirror              obsuration.         nstruts : int = 0             The number of uniformly spaced struts holding the secondary mirror.          strut_ratio : float = 0.             The ratio of the width of the strut to the aperture diameter.         strut_rotation : float = 0             The rotation of the struts in radians.         zernikes : Array = None             The zernike noll indices to be used for the aberrations. Please              refer to (this)[Add this link] docstring to see which indicides              correspond to which aberrations. Typical values are range(4, 11).         coefficients : Array = None             The zernike cofficients to be applied to the aberrations. Defaults              to an array of zeros.         name : str = None             The name of the aperture used to index the layers dictionary. If              not supplied, the aperture will be named based on the number of             sides. However this is only supported up to 8 sides, and a name             must be supplied for apertures with more than 8 sides.                  Returns         -------         aperture : Union[StaticAperture, StaticAberratedAperture]             Returns an appropriately constructed StaticAperture or              StaticAberratedAperture, depending on if zernikes are provided.         \"\"\""},{"location":"dLux/apertures/#concrete-aperture-classes","title":"Concrete Aperture Classes\u00b6","text":"<p>################################</p>"},{"location":"dLux/apertures/#composite-apertures","title":"Composite Apertures\u00b6","text":"<p>##########################</p>"},{"location":"dLux/apertures/#static-apertures","title":"Static Apertures\u00b6","text":"<p>#######################</p>"},{"location":"dLux/apertures/#aperture-construction","title":"Aperture Construction\u00b6","text":"<p>############################ class SimpleAperture():</p>"},{"location":"dLux/core/","title":"Core","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax import vmap\nfrom jax.tree_util import tree_map, tree_flatten\nfrom equinox import tree_at\nfrom zodiax import Base\nfrom collections import OrderedDict\nfrom copy import deepcopy\nfrom inspect import signature\nfrom typing import Union\nimport dLux\n</pre> from __future__ import annotations import jax.numpy as np from jax import vmap from jax.tree_util import tree_map, tree_flatten from equinox import tree_at from zodiax import Base from collections import OrderedDict from copy import deepcopy from inspect import signature from typing import Union import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"model\", \"Instrument\", \"Optics\", \"Detector\"]\n</pre> __all__ = [\"model\", \"Instrument\", \"Optics\", \"Detector\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\nObservation = lambda : dLux.observations.AbstractObservation\nSource = lambda : dLux.sources.Source\n</pre> Array = np.ndarray Observation = lambda : dLux.observations.AbstractObservation Source = lambda : dLux.sources.Source In\u00a0[\u00a0]: Copied! <pre>###############\n### Methods ###\n###############\ndef model(optics      : Optics,\n          sources     : Union[dict, list, Source],\n          detector    : Detector = None,\n          normalise   : bool     = True,\n          flatten     : bool     = False,\n          return_tree : bool     = False) -&gt; Array:\n\"\"\"\n    A base level modelling function designed to robustly handle the different\n    combinations of inputs. Models the sources through the instrument optics\n    and detector. Users must provide optics and source.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n    sources : Union[dict, list, Source]\n        The sources to observe.\n    detector : Detector = None\n        The detector to use with the observation.\n    normalise : bool = None\n        Whether to normalise the sources before modelling. Default is True.\n    flatten : bool = False\n        Whether the output image should be flattened. Default is False.\n    return_tree : bool = False\n        Whether to return a Pytree like object with matching tree structure as\n        the input scene/sources/source. Default is False.\n\n    Returns\n    -------\n    image : Array, Pytree\n        The image of the scene modelled through the optics with detector and\n        filter effects applied if they are supplied. Returns either as a single\n        array (if return_tree is false), or a pytree like object with matching\n        tree strucutre as the input scene/sources/source.\n    \"\"\"\n'''Input checking and formatting'''\n    # Check that optics input is an Optics object.\n    assert isinstance(optics, (Optics)), (\"optics must be an Optics object.\")\n\n    # Check that detector input is a Detector object if specified.\n    assert isinstance(detector, (Detector, type(None))), \\\n    (\"detector must be a Detector object.\")\n\n    # Check that sources is a dict object.\n    assert isinstance(sources, (dict, list, tuple, Source())), \\\n    (\"sources must be a Source object, dict, list, or tuple object.\")\n\n    # Check that all inputs are Source objects\n    if not isinstance(sources, Source()):\n        source_vals = sources.values() if isinstance(sources, dict) else sources\n        for source in source_vals:\n            assert isinstance(source, Source()), \\\n            (\"All entries within sources must be a Source object.\")\n    \n    # Turn single source object into a list for mapping\n    else:\n        sources = [sources]\n\n    # Normalise Sources\n    if normalise:\n        # Define the normalisation function\n        normalise_fn = lambda source: source.normalise()\n\n        # Map the normalisation function across the sources\n        sources_in = tree_map(normalise_fn, sources, \\\n                is_leaf = lambda leaf: isinstance(leaf, Source()))\n    else:\n        sources_in = sources\n\n        # Get sources\n        sources_in = source.normalise() if normalise else source\n\n'''Begin modelling'''\n    # Apply optional inputs\n    model_fn = lambda source: source.model(optics)\n\n    # Map the model_source function across the sources\n    psf_tree = tree_map(model_fn, sources_in, \n            is_leaf = lambda leaf: isinstance(leaf, Source()))\n\n    # Return psfs in the same structure as the sources\n    if return_tree:\n\n        # Apply detector if required\n        if detector is not None:\n            detector_fn = lambda psf: detector.apply_detector(psf)\n            image_tree = tree_map(detector_fn, psf_tree, \n                is_leaf = lambda leaf: isinstance(leaf, np.ndarray))\n        else:\n            image_tree = psf_tree\n\n        # flatten if required\n        if flatten:\n            flatten_fn = lambda image: image.flatten()\n            tree_out = tree_map(flatten_fn, image_tree,\n                is_leaf = lambda leaf: isinstance(leaf, np.ndarray))\n        else:\n            tree_out = image_tree\n\n        # Return psfs with matching tree strucutre as input\n        return tree_out\n\n\n    # Return a single summed psf\n    else:\n        # Get flatten tree and sum to single psf\n        psf = np.array(tree_flatten(psf_tree)[0]).sum(0)\n\n        # Apply detector\n        image = detector.apply_detector(psf) if detector is not None else psf\n\n        # Flatten\n        return image.flatten() if flatten else image\n</pre> ############### ### Methods ### ############### def model(optics      : Optics,           sources     : Union[dict, list, Source],           detector    : Detector = None,           normalise   : bool     = True,           flatten     : bool     = False,           return_tree : bool     = False) -&gt; Array:     \"\"\"     A base level modelling function designed to robustly handle the different     combinations of inputs. Models the sources through the instrument optics     and detector. Users must provide optics and source.      Parameters     ----------     optics : Optics         The optics through which to model the source objects.     sources : Union[dict, list, Source]         The sources to observe.     detector : Detector = None         The detector to use with the observation.     normalise : bool = None         Whether to normalise the sources before modelling. Default is True.     flatten : bool = False         Whether the output image should be flattened. Default is False.     return_tree : bool = False         Whether to return a Pytree like object with matching tree structure as         the input scene/sources/source. Default is False.      Returns     -------     image : Array, Pytree         The image of the scene modelled through the optics with detector and         filter effects applied if they are supplied. Returns either as a single         array (if return_tree is false), or a pytree like object with matching         tree strucutre as the input scene/sources/source.     \"\"\"     '''Input checking and formatting'''     # Check that optics input is an Optics object.     assert isinstance(optics, (Optics)), (\"optics must be an Optics object.\")      # Check that detector input is a Detector object if specified.     assert isinstance(detector, (Detector, type(None))), \\     (\"detector must be a Detector object.\")      # Check that sources is a dict object.     assert isinstance(sources, (dict, list, tuple, Source())), \\     (\"sources must be a Source object, dict, list, or tuple object.\")      # Check that all inputs are Source objects     if not isinstance(sources, Source()):         source_vals = sources.values() if isinstance(sources, dict) else sources         for source in source_vals:             assert isinstance(source, Source()), \\             (\"All entries within sources must be a Source object.\")          # Turn single source object into a list for mapping     else:         sources = [sources]      # Normalise Sources     if normalise:         # Define the normalisation function         normalise_fn = lambda source: source.normalise()          # Map the normalisation function across the sources         sources_in = tree_map(normalise_fn, sources, \\                 is_leaf = lambda leaf: isinstance(leaf, Source()))     else:         sources_in = sources          # Get sources         sources_in = source.normalise() if normalise else source      '''Begin modelling'''     # Apply optional inputs     model_fn = lambda source: source.model(optics)      # Map the model_source function across the sources     psf_tree = tree_map(model_fn, sources_in,              is_leaf = lambda leaf: isinstance(leaf, Source()))      # Return psfs in the same structure as the sources     if return_tree:          # Apply detector if required         if detector is not None:             detector_fn = lambda psf: detector.apply_detector(psf)             image_tree = tree_map(detector_fn, psf_tree,                  is_leaf = lambda leaf: isinstance(leaf, np.ndarray))         else:             image_tree = psf_tree          # flatten if required         if flatten:             flatten_fn = lambda image: image.flatten()             tree_out = tree_map(flatten_fn, image_tree,                 is_leaf = lambda leaf: isinstance(leaf, np.ndarray))         else:             tree_out = image_tree          # Return psfs with matching tree strucutre as input         return tree_out       # Return a single summed psf     else:         # Get flatten tree and sum to single psf         psf = np.array(tree_flatten(psf_tree)[0]).sum(0)          # Apply detector         image = detector.apply_detector(psf) if detector is not None else psf          # Flatten         return image.flatten() if flatten else image In\u00a0[\u00a0]: Copied! <pre>class Instrument(Base):\n\"\"\"\n    A high level class desgined to model the behaviour of a telescope. It\n    stores a series different \u2202Lux objects, and primarily passes the relevant\n    information between these objects in order to coherently model some\n    telescope observation.\n\n    Attributes\n    ----------\n    optics : Optics\n        A Optics object that defines some optical configuration.\n    sources : dict\n        A dictionary of the various source objects that the instrument is\n        observing.\n    detector : Detector\n        A Detector object that is used to model the various\n        instrumental effects on a psf.\n    observation : Observation\n        An class that inherits from Observation. This is to allow flexibility\n        in the different kind of observations, ie applying dithers, switching\n        filters, etc.\n    \"\"\"\n    optics      : Optics\n    sources     : dict\n    detector    : Detector\n    observation : Observation\n\n    \n    def __init__(self        : Instrument,\n                 optics      : Optics,\n                 sources     : Union[list, Source],\n                 detector    : Detector    = None,\n                 observation : Observation = None,\n                 ) -&gt; Instrument:\n\"\"\"\n        Constructor for the Instrument class.\n\n        Parameters\n        ----------\n        optics : Optics\n            A pre-configured Optics object.\n        sources : Union[list, Source]\n            Either a list of sources or an individual Source object.\n        detector : Detector = None\n            A pre-configured Detector object.\n        observation : Observation = None\n            An class that inherits from Observation. This is to allow\n            flexibility in the different kind of observations, ie applying\n            dithers, switching filters, etc.\n        \"\"\"\n        # Optics\n        if not isinstance(optics, Optics):\n            raise ValueError(\"optics must be an Optics object.\")\n        self.optics = optics\n        \n        # Sources\n        if isinstance(sources, Source()):\n            sources = [sources]\n        elif isinstance(sources, list):\n            for source in sources:\n                if not isinstance(source, Source()):\n                    raise ValueError(\n                        \"sources must be a list of Source objects.\")\n        self.sources = dLux.utils.list_to_dictionary(sources, ordered=False)\n\n        # Detector\n        if not isinstance(detector, (Detector, type(None))):\n            raise ValueError(\"detector must be an Detector object. \"\n                f\"Got type {type(detector)}\")\n        self.detector = detector\n\n        # Observation\n        if not isinstance(observation, (Observation(), type(None))):\n            raise ValueError(\"observation must be an Observation object.\")\n        self.observation = observation\n\n\n    def observe(self : Instrument, **kwargs) -&gt; Any:\n\"\"\"\n        Calls the `observe` method of the stored observation class, passing in\n        any extra keyword arguments.\n\n        Returns\n        -------\n         : Any\n            The output of the stored observation class.\n        \"\"\"\n        return self.observation.observe(self, **kwargs)\n\n\n    def __getattr__(self : Instrument, key : str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the sub-dictionaries of this class via the 'class.attribute' method.\n        It is recommended that each dictionary key in the optical layers,\n        detector layers, and scene sources are unique to prevent unexpected\n        behaviour. In the case they there are idenitcal keys across the\n        dictionaries This method prioritises searching for keys in the optical\n        layers, then detector layers, and then the scene sources.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the sub-dictionaries.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the sub-dictionaries.\n        \"\"\"\n        if key in self.optics.layers.keys():\n            return self.optics.layers[key]\n        elif key in self.sources.keys():\n            return self.sources[key]\n        elif self.detector is not None and key in self.detector.layers.keys():\n            return self.detector.layers[key]\n        elif self.observation is not None and hasattr(self.observation, key):\n            return getattr(self.observation, key)\n        else:\n            raise AttributeError(\"'{}' object has no attribute '{}'\"\\\n                                 .format(type(self), key))\n\n\n    def normalise(self : Instrument) -&gt; Instrument:\n\"\"\"\n        Normalises the internally stored scene by calling the scene.normalise()\n        method.\n\n        Returns\n        -------\n        instrument : Instrument\n            A new version of the instrument with the interally stored scene\n            normalised.\n        \"\"\"\n        leaf_fn = lambda source: isinstance(source, Source())\n        normalise_fn = lambda source: source.normalise()\n        return tree_at(lambda instrument: instrument.sources, self,\n            tree_map(normalise_fn, self.sources, is_leaf=leaf_fn))\n    \n\n    def summarise(self : Instrument) -&gt; None:\n\"\"\"\n        Prints a summary of all instrument\n        \"\"\"\n        print(\"Sources summary:\")\n        summary_fn = lambda source: source.summarise()\n        tree_map(summary_fn, self.sources)\n\n        print(\"Optics summary:\")\n        self.optics.summarise()\n        \n        if self.detector is not None:\n            print(\"Detector summary:\")\n            self.detector.summarise()\n\n\n    def plot(self       : Optics, \n             wavelength : Array, \n             offset     : Array = np.zeros(2)) -&gt; None:\n\"\"\"\n        Prints the summary of all the planes and then plots a wavefront as it\n        propagates through the optics.\n\n        Parameters\n        ----------\n        wavelength : Array, meters\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        \"\"\"\n        wf = self.optics.plot(wavelength, offset)\n        self.detector.plot(wf.psf)\n\n\n    def model(self              : Instrument,\n              normalise_sources : bool = True,\n              flatten           : bool = False,\n              return_tree       : bool = False) -&gt; Union(Array, dict):\n\"\"\"\n        A base level modelling function designed to robustly handle the\n        different combinations of inputs. Models the sources through the\n        instrument optics and detector.\n\n        Parameters\n        ----------\n        normalise_sources : bool = True\n            Whether to normalise the sources before modelling.\n        flatten : bool = False\n            Whether the output image should be flattened.\n        return_tree : bool = False\n            Whether to return a Pytree like object with matching tree structure\n            as the input sources (ie dict).\n\n        Returns\n        -------\n        image : Array, dict\n            The image of the scene modelled through the optics with detector and\n            filter effects applied if they are supplied. Returns either as a\n            single array (if return_tree is false), or a dict of the output for\n            each source.\n        \"\"\"\n        return model(self.optics, self.sources, self.detector, \n            normalise_sources, flatten, return_tree)\n</pre> class Instrument(Base):     \"\"\"     A high level class desgined to model the behaviour of a telescope. It     stores a series different \u2202Lux objects, and primarily passes the relevant     information between these objects in order to coherently model some     telescope observation.      Attributes     ----------     optics : Optics         A Optics object that defines some optical configuration.     sources : dict         A dictionary of the various source objects that the instrument is         observing.     detector : Detector         A Detector object that is used to model the various         instrumental effects on a psf.     observation : Observation         An class that inherits from Observation. This is to allow flexibility         in the different kind of observations, ie applying dithers, switching         filters, etc.     \"\"\"     optics      : Optics     sources     : dict     detector    : Detector     observation : Observation           def __init__(self        : Instrument,                  optics      : Optics,                  sources     : Union[list, Source],                  detector    : Detector    = None,                  observation : Observation = None,                  ) -&gt; Instrument:         \"\"\"         Constructor for the Instrument class.          Parameters         ----------         optics : Optics             A pre-configured Optics object.         sources : Union[list, Source]             Either a list of sources or an individual Source object.         detector : Detector = None             A pre-configured Detector object.         observation : Observation = None             An class that inherits from Observation. This is to allow             flexibility in the different kind of observations, ie applying             dithers, switching filters, etc.         \"\"\"         # Optics         if not isinstance(optics, Optics):             raise ValueError(\"optics must be an Optics object.\")         self.optics = optics                  # Sources         if isinstance(sources, Source()):             sources = [sources]         elif isinstance(sources, list):             for source in sources:                 if not isinstance(source, Source()):                     raise ValueError(                         \"sources must be a list of Source objects.\")         self.sources = dLux.utils.list_to_dictionary(sources, ordered=False)          # Detector         if not isinstance(detector, (Detector, type(None))):             raise ValueError(\"detector must be an Detector object. \"                 f\"Got type {type(detector)}\")         self.detector = detector          # Observation         if not isinstance(observation, (Observation(), type(None))):             raise ValueError(\"observation must be an Observation object.\")         self.observation = observation       def observe(self : Instrument, **kwargs) -&gt; Any:         \"\"\"         Calls the `observe` method of the stored observation class, passing in         any extra keyword arguments.          Returns         -------          : Any             The output of the stored observation class.         \"\"\"         return self.observation.observe(self, **kwargs)       def __getattr__(self : Instrument, key : str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the sub-dictionaries of this class via the 'class.attribute' method.         It is recommended that each dictionary key in the optical layers,         detector layers, and scene sources are unique to prevent unexpected         behaviour. In the case they there are idenitcal keys across the         dictionaries This method prioritises searching for keys in the optical         layers, then detector layers, and then the scene sources.          Parameters         ----------         key : str             The key of the item to be searched for in the sub-dictionaries.          Returns         -------         item : object             The item corresponding to the supplied key in the sub-dictionaries.         \"\"\"         if key in self.optics.layers.keys():             return self.optics.layers[key]         elif key in self.sources.keys():             return self.sources[key]         elif self.detector is not None and key in self.detector.layers.keys():             return self.detector.layers[key]         elif self.observation is not None and hasattr(self.observation, key):             return getattr(self.observation, key)         else:             raise AttributeError(\"'{}' object has no attribute '{}'\"\\                                  .format(type(self), key))       def normalise(self : Instrument) -&gt; Instrument:         \"\"\"         Normalises the internally stored scene by calling the scene.normalise()         method.          Returns         -------         instrument : Instrument             A new version of the instrument with the interally stored scene             normalised.         \"\"\"         leaf_fn = lambda source: isinstance(source, Source())         normalise_fn = lambda source: source.normalise()         return tree_at(lambda instrument: instrument.sources, self,             tree_map(normalise_fn, self.sources, is_leaf=leaf_fn))           def summarise(self : Instrument) -&gt; None:         \"\"\"         Prints a summary of all instrument         \"\"\"         print(\"Sources summary:\")         summary_fn = lambda source: source.summarise()         tree_map(summary_fn, self.sources)          print(\"Optics summary:\")         self.optics.summarise()                  if self.detector is not None:             print(\"Detector summary:\")             self.detector.summarise()       def plot(self       : Optics,               wavelength : Array,               offset     : Array = np.zeros(2)) -&gt; None:         \"\"\"         Prints the summary of all the planes and then plots a wavefront as it         propagates through the optics.          Parameters         ----------         wavelength : Array, meters             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians = np.zeros(2)             The (x, y) offset from the optical axis of the source.         \"\"\"         wf = self.optics.plot(wavelength, offset)         self.detector.plot(wf.psf)       def model(self              : Instrument,               normalise_sources : bool = True,               flatten           : bool = False,               return_tree       : bool = False) -&gt; Union(Array, dict):         \"\"\"         A base level modelling function designed to robustly handle the         different combinations of inputs. Models the sources through the         instrument optics and detector.          Parameters         ----------         normalise_sources : bool = True             Whether to normalise the sources before modelling.         flatten : bool = False             Whether the output image should be flattened.         return_tree : bool = False             Whether to return a Pytree like object with matching tree structure             as the input sources (ie dict).          Returns         -------         image : Array, dict             The image of the scene modelled through the optics with detector and             filter effects applied if they are supplied. Returns either as a             single array (if return_tree is false), or a dict of the output for             each source.         \"\"\"         return model(self.optics, self.sources, self.detector,              normalise_sources, flatten, return_tree) In\u00a0[\u00a0]: Copied! <pre>class Optics(Base):\n\"\"\"\n    A high level class desgined to model the behaviour of some optical systems\n    response to wavefronts.\n\n    Attributes\n    ----------\n    layers: dict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input wavefront through an optical system.\n    \"\"\"\n    layers : OrderedDict\n\n\n    def __init__(self : Optics, layers : list) -&gt; Optics:\n\"\"\"\n        Constructor for the Optics class.\n\n        Parameters\n        ----------\n        layers : list\n            A list of \u2202Lux 'layers' that define the transformations and\n            operations upon some input wavefront through an optical system.\n        \"\"\"\n        # Ensure input is a list\n        assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\\n        \" automatically converted to a dictionary\")\n\n        # Ensure all entries are dLux layers\n        for layer in layers:\n            assert isinstance(layer, dLux.optics.OpticalLayer), (\"All entries\" \\\n            \" within layers must be an dLux.optics.OpticalLayer object\")\n\n        self.layers = dLux.utils.list_to_dictionary(layers)\n\n\n    def __getattr__(self : Optics, key : str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        else:\n            raise AttributeError(\"'{}' object has no attribute '{}'\"\\\n                                 .format(type(self), key))\n\n\n    def propagate_mono(self       : Optics,\n                       wavelength : Array,\n                       offset     : Array = np.zeros(2),\n                       weight     : Array = np.array(1.)) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelength : Array, meters\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians, = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        weight : Array, = np.array(1.)\n            The relative weighting of the wavelength. Simply scales the output\n            psf.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        \"\"\"\n        # Ensure jax arrays\n        wavelength = np.asarray(wavelength, dtype=float) \\\n                    if not isinstance(wavelength, np.ndarray) else wavelength\n        offset = np.asarray(offset, dtype=float) \\\n                    if not isinstance(offset, np.ndarray) else offset\n        weight = np.asarray(weight, dtype=float) \\\n                    if not isinstance(weight, np.ndarray) else weight\n\n        # Ensure dimensionality\n        assert wavelength.shape == (), \"wavelength must be a scalar.\"\n        assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"\n        assert weight.shape == (), \"weight must be a scalar.\"\n\n        # Construct parameters dictionary\n        params_dict = {\"Wavefront\"  : None,\n                       \"optics\"     : self,\n                       \"wavelength\" : wavelength,\n                       \"offset\"     : offset}\n\n        # Propagate though layers\n        for key, layer in self.layers.items():\n            params_dict = layer.apply(params_dict)\n        psf = params_dict[\"Wavefront\"].wavefront_to_psf()\n        return weight * psf\n\n\n    def propagate(self        : Optics,\n                  wavelengths : Array,\n                  offset      : Array = np.zeros(2),\n                  weights     : Array = None) -&gt; Array:\n\"\"\"\n        Propagates a broadband point source through the optical layers.\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The wavelengths of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        weights : Array = None\n            The relative weighting of the wavelengths. Simply scales the output\n            psf.\n\n        Returns\n        -------\n        psf : Array\n            The broadband point spread function after being propagated\n            though the optical layers.\n        \"\"\"\n        # Format weights input\n        wavelengths = np.asarray(wavelengths, dtype=float) \\\n                  if not isinstance(wavelengths, np.ndarray) else wavelengths\n        assert wavelengths.ndim == 1, \"wavelengths must be 1 dimensional..\"\n\n        # Format weights input\n        if weights is None:\n            weights = np.ones(len(wavelengths))/len(wavelengths)\n        elif not isinstance(weights, np.ndarray):\n            weights = np.asarray(weights, dtype=float)\n        assert weights.ndim == 1, \"weights must be 1 dimensional.\"\n\n        # Ensure matching dimensionality\n        assert wavelengths.shape == weights.shape, \\\n        (\"wavelengths and weights must have the same shape.\")\n\n        # Offset checking\n        offset = np.asarray(offset, dtype=float) \\\n                 if not isinstance(offset, np.ndarray) else offset\n        assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"\n\n        # Propagate\n        propagator = vmap(self.propagate_mono, in_axes=(0, None, 0))\n        psfs = propagator(wavelengths, offset, weights)\n        return psfs.sum(0)\n\n\n    def debug_prop(self       : Optics,\n                   wavelength : Array,\n                   offset     : Array = np.zeros(2),\n                   weight     : Array = np.array(1.)) -&gt; Array:\n\"\"\"\n        Propagates a monochromatic point source through the optical layers,\n        while also returning the intermediate state of the parameter dictionary\n        and layers after each layer application.\n\n        Parameters\n        ----------\n        wavelength : Array, meters\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source. Default\n            value is (0, 0), on axis.\n        weight : Array, = np.array(1.)\n            The relative weighting of the wavelength. Simply scales the output\n            psf.\n\n        Returns\n        -------\n        psf : Array\n            The monochromatic point spread function after being propagated\n            though the optical layers.\n        intermediate_dicts : list\n            The intermediate states of the parameters dictionary.\n        intermediate_layers : list\n            The intermediate states of each layer after being applied to the\n            wavefront.\n        \"\"\"\n        # Ensure jax arrays\n        wavelength = np.asarray(wavelength, dtype=float) \\\n                    if not isinstance(wavelength, np.ndarray) else wavelength\n        offset = np.asarray(offset, dtype=float) \\\n                    if not isinstance(offset, np.ndarray) else offset\n        weight = np.asarray(weight, dtype=float) \\\n                    if not isinstance(weight, np.ndarray) else weight\n\n        # Ensure dimensionality\n        assert wavelength.shape == (), \"wavelength must be a scalar.\"\n        assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"\n        assert weight.shape == (), \"weight must be a scalar.\"\n\n        # Construct parameters dictionary\n        params_dict = {\"Wavefront\"  : None,\n                       \"optics\"     : self,\n                       \"wavelength\" : wavelength,\n                       \"offset\"     : offset}\n\n        intermediate_dicts = []\n        intermediate_layers = []\n        for key, layer in self.layers.items():\n            params_dict = layer.apply(params_dict)\n            intermediate_dicts.append(params_dict.copy())\n            intermediate_layers.append(deepcopy(layer))\n\n        return params_dict[\"Wavefront\"].wavefront_to_psf(), \\\n                                intermediate_dicts, intermediate_layers\n    \n\n    def get_planes(self : Optics) -&gt; list:\n\"\"\"\n        Breaks the optical layers into planes, where each plane is a list of\n        layers.\n\n        Returns\n        -------\n        planes : list\n            A list of lists, with the inner lists being optical layers, and the\n            outer list being planes.\n        \"\"\"\n        planes = []\n        plane = []\n        keys = self.layers.keys()\n        for key in keys:\n            layer = self.layers[key]\n            plane.append(layer)\n            if isinstance(layer, dLux.propagators.Propagator):\n                planes.append(plane)\n                plane = []\n        return planes\n\n\n    def summarise(self : Optics) -&gt; None:\n\"\"\"\n        Prints a summary of all the planes in the optical system.\n        \"\"\"\n        planes = self.get_planes()\n        # TODO: Add plane type (Plane 0: Pupil)\n        print(\"Text summary:\")\n        for i in range(len(planes)):\n            print(f'Plane {i}')\n            for layer in planes[i]:\n                print(f\"  {layer.summary(angular_units='arcseconds')}\")\n        print('\\n')\n\n\n    def plot(self       : Optics, \n             wavelength : Array, \n             offset     : Array = np.zeros(2)) -&gt; None:\n\"\"\"\n        Prints the summary of all the planes and then plots a wavefront as it\n        propagates through the optics.\n\n        Parameters\n        ----------\n        wavelength : Array, meters\n            The wavelength of the wavefront to propagate through the optical\n            layers.\n        offset : Array, radians = np.zeros(2)\n            The (x, y) offset from the optical axis of the source.\n        Returns\n        -------\n        wf : Wavefront\n            The final wavefront after being propagated through the optical\n            layers.\n        \"\"\"\n        planes = self.get_planes()\n        self.summarise()\n\n        for i in range(len(planes)):\n            print(f'Plane {i}')\n            for layer in planes[i]:\n                print(f\"  {layer.summary()}\")\n                if isinstance(layer, dLux.CreateWavefront):\n                    wf, parameters = layer(None, \n                                  {\"wavelength\": wavelength, 'offset': offset},returns_parameters=True)\n                else:\n                    # Inspect apply function to see if it takes/returns the parameters dict\n                    input_parameters = signature(layer).parameters\n\n                    # Method does not take in the parameters, update in place\n                    if 'parameters' not in input_parameters:\n                        wf = layer(wf)\n\n                    # Method takes and return updated parameters\n                    elif input_parameters['returns_parameters'].default == True:\n                        wf, parameters = layer(wf, parameters)\n\n                    # Method takes but does not return parameters\n                    else:\n                        wf = layer(wf, parameters)\n                layer.display(wf)\n        return wf\n\n\n    def model(self              : Optics,\n              sources           : Union[Source, dict, list],\n              normalise_sources : bool = True,\n              flatten           : bool = False,\n              return_tree       : bool = False) -&gt; Union(Array, dict):\n\"\"\"\n        A base level modelling function for modelling the optical system.\n        Models the source or sources through the optics.\n\n        Parameters\n        ----------\n        sources : Union[Source, dict, list]\n            The source or sources to observe.\n        normalise_sources : bool = True\n            Whether to normalise the sources before modelling.\n        flatten : bool = False\n            Whether the output image should be flattened.\n        return_tree : bool = False\n            Whether to return a Pytree like object with matching tree structure\n            as the input sources (ie dict).\n\n        Returns\n        -------\n        image : Array, dict\n            The image of the scene modelled through the optics. Returns either\n            as a single array (if return_tree is false), or a dict of the output\n            for each source.\n        \"\"\"\n        # None input is for the detector\n        return model(self, sources, None, normalise_sources, flatten,\n            return_tree)\n</pre> class Optics(Base):     \"\"\"     A high level class desgined to model the behaviour of some optical systems     response to wavefronts.      Attributes     ----------     layers: dict         A collections.OrderedDict of 'layers' that define the transformations         and operations upon some input wavefront through an optical system.     \"\"\"     layers : OrderedDict       def __init__(self : Optics, layers : list) -&gt; Optics:         \"\"\"         Constructor for the Optics class.          Parameters         ----------         layers : list             A list of \u2202Lux 'layers' that define the transformations and             operations upon some input wavefront through an optical system.         \"\"\"         # Ensure input is a list         assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\         \" automatically converted to a dictionary\")          # Ensure all entries are dLux layers         for layer in layers:             assert isinstance(layer, dLux.optics.OpticalLayer), (\"All entries\" \\             \" within layers must be an dLux.optics.OpticalLayer object\")          self.layers = dLux.utils.list_to_dictionary(layers)       def __getattr__(self : Optics, key : str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the layers dictionary of this class via the 'class.attribute' method.          Parameters         ----------         key : str             The key of the item to be searched for in the layers dictionary.          Returns         -------         item : object             The item corresponding to the supplied key in the layers dictionary.         \"\"\"         if key in self.layers.keys():             return self.layers[key]         else:             raise AttributeError(\"'{}' object has no attribute '{}'\"\\                                  .format(type(self), key))       def propagate_mono(self       : Optics,                        wavelength : Array,                        offset     : Array = np.zeros(2),                        weight     : Array = np.array(1.)) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers.          Parameters         ----------         wavelength : Array, meters             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians, = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         weight : Array, = np.array(1.)             The relative weighting of the wavelength. Simply scales the output             psf.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         \"\"\"         # Ensure jax arrays         wavelength = np.asarray(wavelength, dtype=float) \\                     if not isinstance(wavelength, np.ndarray) else wavelength         offset = np.asarray(offset, dtype=float) \\                     if not isinstance(offset, np.ndarray) else offset         weight = np.asarray(weight, dtype=float) \\                     if not isinstance(weight, np.ndarray) else weight          # Ensure dimensionality         assert wavelength.shape == (), \"wavelength must be a scalar.\"         assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"         assert weight.shape == (), \"weight must be a scalar.\"          # Construct parameters dictionary         params_dict = {\"Wavefront\"  : None,                        \"optics\"     : self,                        \"wavelength\" : wavelength,                        \"offset\"     : offset}          # Propagate though layers         for key, layer in self.layers.items():             params_dict = layer.apply(params_dict)         psf = params_dict[\"Wavefront\"].wavefront_to_psf()         return weight * psf       def propagate(self        : Optics,                   wavelengths : Array,                   offset      : Array = np.zeros(2),                   weights     : Array = None) -&gt; Array:         \"\"\"         Propagates a broadband point source through the optical layers.          Parameters         ----------         wavelengths : Array, meters             The wavelengths of the wavefront to propagate through the optical             layers.         offset : Array, radians = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         weights : Array = None             The relative weighting of the wavelengths. Simply scales the output             psf.          Returns         -------         psf : Array             The broadband point spread function after being propagated             though the optical layers.         \"\"\"         # Format weights input         wavelengths = np.asarray(wavelengths, dtype=float) \\                   if not isinstance(wavelengths, np.ndarray) else wavelengths         assert wavelengths.ndim == 1, \"wavelengths must be 1 dimensional..\"          # Format weights input         if weights is None:             weights = np.ones(len(wavelengths))/len(wavelengths)         elif not isinstance(weights, np.ndarray):             weights = np.asarray(weights, dtype=float)         assert weights.ndim == 1, \"weights must be 1 dimensional.\"          # Ensure matching dimensionality         assert wavelengths.shape == weights.shape, \\         (\"wavelengths and weights must have the same shape.\")          # Offset checking         offset = np.asarray(offset, dtype=float) \\                  if not isinstance(offset, np.ndarray) else offset         assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"          # Propagate         propagator = vmap(self.propagate_mono, in_axes=(0, None, 0))         psfs = propagator(wavelengths, offset, weights)         return psfs.sum(0)       def debug_prop(self       : Optics,                    wavelength : Array,                    offset     : Array = np.zeros(2),                    weight     : Array = np.array(1.)) -&gt; Array:         \"\"\"         Propagates a monochromatic point source through the optical layers,         while also returning the intermediate state of the parameter dictionary         and layers after each layer application.          Parameters         ----------         wavelength : Array, meters             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians = np.zeros(2)             The (x, y) offset from the optical axis of the source. Default             value is (0, 0), on axis.         weight : Array, = np.array(1.)             The relative weighting of the wavelength. Simply scales the output             psf.          Returns         -------         psf : Array             The monochromatic point spread function after being propagated             though the optical layers.         intermediate_dicts : list             The intermediate states of the parameters dictionary.         intermediate_layers : list             The intermediate states of each layer after being applied to the             wavefront.         \"\"\"         # Ensure jax arrays         wavelength = np.asarray(wavelength, dtype=float) \\                     if not isinstance(wavelength, np.ndarray) else wavelength         offset = np.asarray(offset, dtype=float) \\                     if not isinstance(offset, np.ndarray) else offset         weight = np.asarray(weight, dtype=float) \\                     if not isinstance(weight, np.ndarray) else weight          # Ensure dimensionality         assert wavelength.shape == (), \"wavelength must be a scalar.\"         assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"         assert weight.shape == (), \"weight must be a scalar.\"          # Construct parameters dictionary         params_dict = {\"Wavefront\"  : None,                        \"optics\"     : self,                        \"wavelength\" : wavelength,                        \"offset\"     : offset}          intermediate_dicts = []         intermediate_layers = []         for key, layer in self.layers.items():             params_dict = layer.apply(params_dict)             intermediate_dicts.append(params_dict.copy())             intermediate_layers.append(deepcopy(layer))          return params_dict[\"Wavefront\"].wavefront_to_psf(), \\                                 intermediate_dicts, intermediate_layers           def get_planes(self : Optics) -&gt; list:         \"\"\"         Breaks the optical layers into planes, where each plane is a list of         layers.          Returns         -------         planes : list             A list of lists, with the inner lists being optical layers, and the             outer list being planes.         \"\"\"         planes = []         plane = []         keys = self.layers.keys()         for key in keys:             layer = self.layers[key]             plane.append(layer)             if isinstance(layer, dLux.propagators.Propagator):                 planes.append(plane)                 plane = []         return planes       def summarise(self : Optics) -&gt; None:         \"\"\"         Prints a summary of all the planes in the optical system.         \"\"\"         planes = self.get_planes()         # TODO: Add plane type (Plane 0: Pupil)         print(\"Text summary:\")         for i in range(len(planes)):             print(f'Plane {i}')             for layer in planes[i]:                 print(f\"  {layer.summary(angular_units='arcseconds')}\")         print('\\n')       def plot(self       : Optics,               wavelength : Array,               offset     : Array = np.zeros(2)) -&gt; None:         \"\"\"         Prints the summary of all the planes and then plots a wavefront as it         propagates through the optics.          Parameters         ----------         wavelength : Array, meters             The wavelength of the wavefront to propagate through the optical             layers.         offset : Array, radians = np.zeros(2)             The (x, y) offset from the optical axis of the source.                  Returns         -------         wf : Wavefront             The final wavefront after being propagated through the optical             layers.         \"\"\"         planes = self.get_planes()         self.summarise()          for i in range(len(planes)):             print(f'Plane {i}')             for layer in planes[i]:                 print(f\"  {layer.summary()}\")                 if isinstance(layer, dLux.CreateWavefront):                     wf, parameters = layer(None,                                    {\"wavelength\": wavelength, 'offset': offset},returns_parameters=True)                 else:                     # Inspect apply function to see if it takes/returns the parameters dict                     input_parameters = signature(layer).parameters                      # Method does not take in the parameters, update in place                     if 'parameters' not in input_parameters:                         wf = layer(wf)                      # Method takes and return updated parameters                     elif input_parameters['returns_parameters'].default == True:                         wf, parameters = layer(wf, parameters)                      # Method takes but does not return parameters                     else:                         wf = layer(wf, parameters)                 layer.display(wf)         return wf       def model(self              : Optics,               sources           : Union[Source, dict, list],               normalise_sources : bool = True,               flatten           : bool = False,               return_tree       : bool = False) -&gt; Union(Array, dict):         \"\"\"         A base level modelling function for modelling the optical system.         Models the source or sources through the optics.          Parameters         ----------         sources : Union[Source, dict, list]             The source or sources to observe.         normalise_sources : bool = True             Whether to normalise the sources before modelling.         flatten : bool = False             Whether the output image should be flattened.         return_tree : bool = False             Whether to return a Pytree like object with matching tree structure             as the input sources (ie dict).          Returns         -------         image : Array, dict             The image of the scene modelled through the optics. Returns either             as a single array (if return_tree is false), or a dict of the output             for each source.         \"\"\"         # None input is for the detector         return model(self, sources, None, normalise_sources, flatten,             return_tree) In\u00a0[\u00a0]: Copied! <pre>class Detector(Base):\n\"\"\"\n    A high level class desgined to model the behaviour of some detectors\n    response to some psf.\n\n    Attributes\n    ----------\n    layers: dict\n        A collections.OrderedDict of 'layers' that define the transformations\n        and operations upon some input psf as it interacts with the detector.\n    \"\"\"\n    layers : OrderedDict\n\n\n    def __init__(self : Detector, layers : list) -&gt; Instrument:\n\"\"\"\n        Constructor for the Detector class.\n\n        Parameters\n        ----------\n        layers : list\n            An list of dLux detector layer classes that define the instrumental\n            effects for some detector.\n        \"\"\"\n        # Ensure input is a list\n        assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\\n        \" automatically converted to a dictionary.\")\n\n        # Ensure all entries are dLux layers\n        for layer in layers:\n            assert isinstance(layer, dLux.detectors.DetectorLayer), \\\n            (\"All entries within layers must be a \"\n             \"dLux.detectors.DetectorLayer object.\")\n\n        # Construct layers\n        self.layers = dLux.utils.list_to_dictionary(layers)\n\n\n    def __getattr__(self : Detector, key : str) -&gt; object:\n\"\"\"\n        Magic method designed to allow accessing of the various items within\n        the layers dictionary of this class via the 'class.attribute' method.\n\n        Parameters\n        ----------\n        key : str\n            The key of the item to be searched for in the layers dictionary.\n\n        Returns\n        -------\n        item : object\n            The item corresponding to the supplied key in the layers dictionary.\n        \"\"\"\n        if key in self.layers.keys():\n            return self.layers[key]\n        else:\n            raise AttributeError(\"'{}' object has no attribute '{}'\"\\\n                                 .format(type(self), key))\n\n\n    def apply_detector(self : Instrument, image : Array) -&gt; Array:\n\"\"\"\n        Applied the stored detector layers to the input image.\n\n        Parameters\n        ----------\n        image : Array\n            The input 'image' to the detector to be transformed.\n\n        Returns\n        -------\n        image : Array\n            The ouput 'image' after being transformed by the detector layers.\n        \"\"\"\n        # Input type checking\n        assert isinstance(image, np.ndarray), \"Input must be a jax array.\"\n        assert image.ndim == 2, \"Input image must a 2d array.\"\n\n        # Apply detector layers\n        for key, layer in self.layers.items():\n            image = layer(image)\n        return image\n\n\n    def debug_apply_detector(self  : Instrument, \n                             image : Array) -&gt; Array:\n\"\"\"\n        Applied the stored detector layers to the input image, storing and\n        returning the intermediate states of the image and layers.\n\n        Parameters\n        ----------\n        image : Array\n            The input 'image' to the detector to be transformed.\n\n        Returns\n        -------\n        image : Array\n            The ouput 'image' after being transformed by the detector layers.\n        intermediate_images : list\n            The intermediate states of the image.\n        intermediate_layers : list\n            The intermediate states of each layer after being applied to the\n            image.\n        \"\"\"\n        # Input type checking\n        assert isinstance(image, np.ndarray), \"Input must be a jax array.\"\n        assert image.ndim == 2, \"Input image must a 2d array.\"\n\n        # Apply detector layers\n        intermediate_images = []\n        intermediate_layers = []\n        for key, layer in self.layers.items():\n            image = layer(image)\n            intermediate_images.append(image.copy())\n            intermediate_layers.append(deepcopy(layer))\n        return image, intermediate_images, intermediate_layers\n    \n\n    def summarise(self : Detector) -&gt; None:\n\"\"\"\n        Prints a summary of all the layers in the detector.\n        \"\"\"\n        print(\"Text summary:\")\n        keys = self.layers.keys()\n        for key in keys:\n            layer = self.layers[key]\n            print(f\"  {layer.summary()}\")\n        print('\\n')\n\n\n    def plot(self : Optics, image : Array) -&gt; None:\n\"\"\"\n        Prints the summary of all the layers and then plots a image as it\n        propagates through the detector layer.\n\n        Parameters\n        ----------\n        iamge : Array\n            The image to propagate through the detector.\n        \"\"\"\n        self.summarise()\n        keys = self.layers.keys()\n        for key in keys:\n            layer = self.layers[key]\n            print(f\"{layer.summary()}\")\n            image = layer(image)\n            layer.display(image)\n\n\n    def model(self : Detector, image: Array) -&gt; Array:\n\"\"\"\n        A function to apply the detector layers to the input image.\n\n        Parameters\n        ----------\n        image: Array\n            The image to be transformed by the detector layers.\n\n        Returns\n        -------\n        image : Array\n            The image after being transformed by the detector layers.\n        \"\"\"\n        return self.apply_detector(image)\n</pre> class Detector(Base):     \"\"\"     A high level class desgined to model the behaviour of some detectors     response to some psf.      Attributes     ----------     layers: dict         A collections.OrderedDict of 'layers' that define the transformations         and operations upon some input psf as it interacts with the detector.     \"\"\"     layers : OrderedDict       def __init__(self : Detector, layers : list) -&gt; Instrument:         \"\"\"         Constructor for the Detector class.          Parameters         ----------         layers : list             An list of dLux detector layer classes that define the instrumental             effects for some detector.         \"\"\"         # Ensure input is a list         assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\         \" automatically converted to a dictionary.\")          # Ensure all entries are dLux layers         for layer in layers:             assert isinstance(layer, dLux.detectors.DetectorLayer), \\             (\"All entries within layers must be a \"              \"dLux.detectors.DetectorLayer object.\")          # Construct layers         self.layers = dLux.utils.list_to_dictionary(layers)       def __getattr__(self : Detector, key : str) -&gt; object:         \"\"\"         Magic method designed to allow accessing of the various items within         the layers dictionary of this class via the 'class.attribute' method.          Parameters         ----------         key : str             The key of the item to be searched for in the layers dictionary.          Returns         -------         item : object             The item corresponding to the supplied key in the layers dictionary.         \"\"\"         if key in self.layers.keys():             return self.layers[key]         else:             raise AttributeError(\"'{}' object has no attribute '{}'\"\\                                  .format(type(self), key))       def apply_detector(self : Instrument, image : Array) -&gt; Array:         \"\"\"         Applied the stored detector layers to the input image.          Parameters         ----------         image : Array             The input 'image' to the detector to be transformed.          Returns         -------         image : Array             The ouput 'image' after being transformed by the detector layers.         \"\"\"         # Input type checking         assert isinstance(image, np.ndarray), \"Input must be a jax array.\"         assert image.ndim == 2, \"Input image must a 2d array.\"          # Apply detector layers         for key, layer in self.layers.items():             image = layer(image)         return image       def debug_apply_detector(self  : Instrument,                               image : Array) -&gt; Array:         \"\"\"         Applied the stored detector layers to the input image, storing and         returning the intermediate states of the image and layers.          Parameters         ----------         image : Array             The input 'image' to the detector to be transformed.          Returns         -------         image : Array             The ouput 'image' after being transformed by the detector layers.         intermediate_images : list             The intermediate states of the image.         intermediate_layers : list             The intermediate states of each layer after being applied to the             image.         \"\"\"         # Input type checking         assert isinstance(image, np.ndarray), \"Input must be a jax array.\"         assert image.ndim == 2, \"Input image must a 2d array.\"          # Apply detector layers         intermediate_images = []         intermediate_layers = []         for key, layer in self.layers.items():             image = layer(image)             intermediate_images.append(image.copy())             intermediate_layers.append(deepcopy(layer))         return image, intermediate_images, intermediate_layers           def summarise(self : Detector) -&gt; None:         \"\"\"         Prints a summary of all the layers in the detector.         \"\"\"         print(\"Text summary:\")         keys = self.layers.keys()         for key in keys:             layer = self.layers[key]             print(f\"  {layer.summary()}\")         print('\\n')       def plot(self : Optics, image : Array) -&gt; None:         \"\"\"         Prints the summary of all the layers and then plots a image as it         propagates through the detector layer.          Parameters         ----------         iamge : Array             The image to propagate through the detector.         \"\"\"         self.summarise()         keys = self.layers.keys()         for key in keys:             layer = self.layers[key]             print(f\"{layer.summary()}\")             image = layer(image)             layer.display(image)       def model(self : Detector, image: Array) -&gt; Array:         \"\"\"         A function to apply the detector layers to the input image.          Parameters         ----------         image: Array             The image to be transformed by the detector layers.          Returns         -------         image : Array             The image after being transformed by the detector layers.         \"\"\"         return self.apply_detector(image) In\u00a0[\u00a0]: Copied! <pre>class Filter(Base):\n\"\"\"\n    NOTE: This class is under development.\n\n    A class for modelling optical filters.\n\n    Attributes\n    ----------\n    wavelengths : Array\n        The wavelengths at which the filter is defined.\n    throughput : Array\n        The throughput of the filter at the corresponding wavelength.\n    filter_name : str\n        A string identifier that can be used to initialise specific filters.\n    \"\"\"\n    wavelengths  : Array\n    throughput   : Array\n    filter_name  : str\n\n\n    def __init__(self        : Filter,\n                 wavelengths : Array = None,\n                 throughput  : Array = None,\n                 filter_name : str   = None) -&gt; Filter:\n\"\"\"\n        Constructor for the Filter class. All inputs are optional and defaults\n        to uniform unitary throughput. If filter_name is specified then\n        wavelengths and weights must not be specified.\n\n        Parameters\n        ----------\n        wavelengths : Array = None\n            The wavelengths at which the filter is defined.\n        throughput : Array = None\n            The throughput of the filter at the corresponding wavelength.\n        filter_name : str = None\n            A string identifier that can be used to initialise specific filters.\n            Currently no pre-built filters are implemented.\n        \"\"\"\n        # Take the filter name as the priority input\n        if filter_name is not None:\n            # TODO: Pre load filters\n            raise NotImplementedError(\"You know what this means.\")\n            pass\n\n            # Check that wavelengths and throughput are not specified\n            if wavelengths is not None or throughput is not None:\n                raise ValueError(\"If filter_name is specified, wavelengths \"\n                \"and throughput can not be specified.\")\n\n        # Check that both wavelengths and throughput are specified\n        elif (wavelengths is     None and throughput is not None) or \\\n             (wavelengths is not None and throughput is     None):\n            raise ValueError(\"If either wavelengths or throughput is \"\n            \"specified, then both must be specified.\")\n\n        # Neither is specified\n        elif wavelengths is None and throughput is None:\n            self.wavelengths = np.array([0., np.inf])\n            self.throughput  = np.array([1., 1.])\n            self.filter_name = 'Unitary'\n\n        # Both wavelengths and throughputs are specified\n        else:\n            self.wavelengths = np.asarray(wavelengths, dtype=float)\n            self.throughput  = np.asarray(throughput,  dtype=float)\n            self.filter_name = 'Custom'\n\n            # Check bounds\n            assert self.wavelengths.ndim == 1 and self.throughput.ndim == 1, \\\n            \"Both wavelengths and throughput must be 1 dimensional.\"\n            assert self.wavelengths.shape == self.throughput.shape, \\\n            (\"wavelengths and throughput must have the same length.\")\n            assert np.min(self.wavelengths) &gt;= 0, \\\n            (\"wavelengths can not be less than 0.\")\n            assert (self.throughput &gt;= 0).all() and \\\n            (self.throughput &lt;= 1).all(), (\"throughput must be between 0-1.\")\n            assert np.min(wavelengths) &lt; np.max(wavelengths), \\\n            (\"wavelengths must be in-order from small to large.\")\n\n\n    def get_throughput(self : Filter, sample_wavelenghts : Array) -&gt; Array:\n\"\"\"\n        Gets the average throughput of the bandpass defined the the differences\n        between each sample wavelength, ie if sample wavelengths are:\n            [10, 20, 30, 40],\n        the bandpasses for each sample wavelength will be\n            [5-15, 15-25, 25-30, 35-40].\n        The throughput is calculated as the average throughput over that\n        bandpass.\n\n        Parameters\n        ----------\n        sample_wavelengths : Array, meters\n            The wavelengths at which to sample the filter. Must contain at\n            least two values.\n\n        Returns\n        -------\n        throughputs : Array\n            The average throughput for each bandpass defined by\n            sample_wavelengths.\n        \"\"\"\n        mids = (sample_wavelenghts[1:] + sample_wavelenghts[:-1]) / 2\n        diffs = np.diff(sample_wavelenghts)\n\n        start = np.array([sample_wavelenghts[0] - diffs[0]/2])\n        end = np.array([sample_wavelenghts[-1] + diffs[-1]/2])\n        min_val = np.array([self.wavelengths.min()])\n        max_val = np.array([self.wavelengths.max()])\n        bounds = np.concatenate([start, mids, end])\n\n        # Translate input wavelengths to indexes\n        min_wavelength = self.wavelengths.min()\n        max_wavelength = self.wavelengths.max()\n        num_wavelength = len(self.wavelengths)\n        wavelength_range = max_wavelength - min_wavelength\n        bnd_indxs = num_wavelength * (bounds - min_wavelength)/wavelength_range\n        bnd_indxs = np.clip(bnd_indxs, a_min=0, a_max=len(self.wavelengths))\n        bnd_inds = np.round(bnd_indxs, decimals=0).astype(int)\n\n        def nan_div(y, x):\n            x_new = np.where(x == 0, 1, x)\n            return np.where(x == 0, 0., y/x_new)\n\n        def get_tp(start, end, weights, indexes):\n            size = (end - start)\n            val = np.where((indexes &lt;= start) | (indexes &gt;= end), \\\n                           0., weights).sum()\n            return nan_div(val, size)\n\n        starts = bnd_inds[:-1]\n        ends   = bnd_inds[1:]\n        # dwavelength = self.wavelengths[1] - self.wavelengths[0]\n        indexes = np.arange(len(self.wavelengths))\n\n        # weights = self.throughput/self.throughput.sum()\n        weights = self.throughput\n        out = vmap(get_tp, in_axes=(0, 0, None, None))(starts, ends, weights, indexes)\n        return out\n\n\n    def model(self : Filter, optics : Optics, **kwargs):\n\"\"\"\n        A base level modelling function designed to robustly handle the\n        different combinations of inputs. Models the sources through the\n        instrument optics and detector. Users must provide optics and some form\n        of source, either via a scene, sources or single source input, but not\n        multiple.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector to use with the observation. Defaults to the\n            internally stored value.\n        scene : Scene = None\n            The scene to observe. Defaults to the internally stored value.\n        sources : Union[dict, list, tuple) = None\n            The sources to observe.\n        source : dLux.sources.Source = None\n            The source to observe.\n        normalise_sources : bool = True\n            Whether to normalise the sources before modelling. Default is True.\n        flatten : bool = False\n            Whether the output image should be flattened. Default is False.\n        return_tree : bool = False\n            Whether to return a Pytree like object with matching tree structure\n            as the input scene/sources/source. Default is False.\n\n        Returns\n        -------\n        image : Array, Pytree\n            The image of the scene modelled through the optics with detector and\n            filter effects applied if they are supplied. Returns either as a\n            single array (if return_tree is false), or a pytree like object\n            with matching tree strucutre as the input scene/sources/source.\n        \"\"\"\n        return model(optics, filter=self, **kwargs)\n</pre> class Filter(Base):     \"\"\"     NOTE: This class is under development.      A class for modelling optical filters.      Attributes     ----------     wavelengths : Array         The wavelengths at which the filter is defined.     throughput : Array         The throughput of the filter at the corresponding wavelength.     filter_name : str         A string identifier that can be used to initialise specific filters.     \"\"\"     wavelengths  : Array     throughput   : Array     filter_name  : str       def __init__(self        : Filter,                  wavelengths : Array = None,                  throughput  : Array = None,                  filter_name : str   = None) -&gt; Filter:         \"\"\"         Constructor for the Filter class. All inputs are optional and defaults         to uniform unitary throughput. If filter_name is specified then         wavelengths and weights must not be specified.          Parameters         ----------         wavelengths : Array = None             The wavelengths at which the filter is defined.         throughput : Array = None             The throughput of the filter at the corresponding wavelength.         filter_name : str = None             A string identifier that can be used to initialise specific filters.             Currently no pre-built filters are implemented.         \"\"\"         # Take the filter name as the priority input         if filter_name is not None:             # TODO: Pre load filters             raise NotImplementedError(\"You know what this means.\")             pass              # Check that wavelengths and throughput are not specified             if wavelengths is not None or throughput is not None:                 raise ValueError(\"If filter_name is specified, wavelengths \"                 \"and throughput can not be specified.\")          # Check that both wavelengths and throughput are specified         elif (wavelengths is     None and throughput is not None) or \\              (wavelengths is not None and throughput is     None):             raise ValueError(\"If either wavelengths or throughput is \"             \"specified, then both must be specified.\")          # Neither is specified         elif wavelengths is None and throughput is None:             self.wavelengths = np.array([0., np.inf])             self.throughput  = np.array([1., 1.])             self.filter_name = 'Unitary'          # Both wavelengths and throughputs are specified         else:             self.wavelengths = np.asarray(wavelengths, dtype=float)             self.throughput  = np.asarray(throughput,  dtype=float)             self.filter_name = 'Custom'              # Check bounds             assert self.wavelengths.ndim == 1 and self.throughput.ndim == 1, \\             \"Both wavelengths and throughput must be 1 dimensional.\"             assert self.wavelengths.shape == self.throughput.shape, \\             (\"wavelengths and throughput must have the same length.\")             assert np.min(self.wavelengths) &gt;= 0, \\             (\"wavelengths can not be less than 0.\")             assert (self.throughput &gt;= 0).all() and \\             (self.throughput &lt;= 1).all(), (\"throughput must be between 0-1.\")             assert np.min(wavelengths) &lt; np.max(wavelengths), \\             (\"wavelengths must be in-order from small to large.\")       def get_throughput(self : Filter, sample_wavelenghts : Array) -&gt; Array:         \"\"\"         Gets the average throughput of the bandpass defined the the differences         between each sample wavelength, ie if sample wavelengths are:             [10, 20, 30, 40],         the bandpasses for each sample wavelength will be             [5-15, 15-25, 25-30, 35-40].         The throughput is calculated as the average throughput over that         bandpass.          Parameters         ----------         sample_wavelengths : Array, meters             The wavelengths at which to sample the filter. Must contain at             least two values.          Returns         -------         throughputs : Array             The average throughput for each bandpass defined by             sample_wavelengths.         \"\"\"         mids = (sample_wavelenghts[1:] + sample_wavelenghts[:-1]) / 2         diffs = np.diff(sample_wavelenghts)          start = np.array([sample_wavelenghts[0] - diffs[0]/2])         end = np.array([sample_wavelenghts[-1] + diffs[-1]/2])         min_val = np.array([self.wavelengths.min()])         max_val = np.array([self.wavelengths.max()])         bounds = np.concatenate([start, mids, end])          # Translate input wavelengths to indexes         min_wavelength = self.wavelengths.min()         max_wavelength = self.wavelengths.max()         num_wavelength = len(self.wavelengths)         wavelength_range = max_wavelength - min_wavelength         bnd_indxs = num_wavelength * (bounds - min_wavelength)/wavelength_range         bnd_indxs = np.clip(bnd_indxs, a_min=0, a_max=len(self.wavelengths))         bnd_inds = np.round(bnd_indxs, decimals=0).astype(int)          def nan_div(y, x):             x_new = np.where(x == 0, 1, x)             return np.where(x == 0, 0., y/x_new)          def get_tp(start, end, weights, indexes):             size = (end - start)             val = np.where((indexes &lt;= start) | (indexes &gt;= end), \\                            0., weights).sum()             return nan_div(val, size)          starts = bnd_inds[:-1]         ends   = bnd_inds[1:]         # dwavelength = self.wavelengths[1] - self.wavelengths[0]         indexes = np.arange(len(self.wavelengths))          # weights = self.throughput/self.throughput.sum()         weights = self.throughput         out = vmap(get_tp, in_axes=(0, 0, None, None))(starts, ends, weights, indexes)         return out       def model(self : Filter, optics : Optics, **kwargs):         \"\"\"         A base level modelling function designed to robustly handle the         different combinations of inputs. Models the sources through the         instrument optics and detector. Users must provide optics and some form         of source, either via a scene, sources or single source input, but not         multiple.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector to use with the observation. Defaults to the             internally stored value.         scene : Scene = None             The scene to observe. Defaults to the internally stored value.         sources : Union[dict, list, tuple) = None             The sources to observe.         source : dLux.sources.Source = None             The source to observe.         normalise_sources : bool = True             Whether to normalise the sources before modelling. Default is True.         flatten : bool = False             Whether the output image should be flattened. Default is False.         return_tree : bool = False             Whether to return a Pytree like object with matching tree structure             as the input scene/sources/source. Default is False.          Returns         -------         image : Array, Pytree             The image of the scene modelled through the optics with detector and             filter effects applied if they are supplied. Returns either as a             single array (if return_tree is false), or a pytree like object             with matching tree strucutre as the input scene/sources/source.         \"\"\"         return model(optics, filter=self, **kwargs)"},{"location":"dLux/detectors/","title":"Detectors","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom abc import ABC, abstractmethod\nfrom jax.scipy.signal import convolve\nfrom jax.scipy.stats import norm\nfrom zodiax import Base\nfrom dLux.utils.interpolation import rotate, fourier_rotate\nfrom dLux.utils.units import convert_angular\nfrom dLux.utils.helpers import single_image_plot\n</pre> from __future__ import annotations import jax.numpy as np from abc import ABC, abstractmethod from jax.scipy.signal import convolve from jax.scipy.stats import norm from zodiax import Base from dLux.utils.interpolation import rotate, fourier_rotate from dLux.utils.units import convert_angular from dLux.utils.helpers import single_image_plot In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"ApplyPixelResponse\", \"ApplyJitter\", \"ApplySaturation\",\n           \"AddConstant\", \"IntegerDownsample\", \"Rotate\"]\n</pre> __all__ = [\"ApplyPixelResponse\", \"ApplyJitter\", \"ApplySaturation\",            \"AddConstant\", \"IntegerDownsample\", \"Rotate\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class DetectorLayer(Base, ABC):\n\"\"\"\n    A base Detector layer class to help with type checking throuhgout the rest\n    of the software.\n\n    Attributes\n    ----------\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    name : str\n\n\n    def __init__(self : DetectorLayer,\n                 name : str = 'DetectorLayer') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the DetectorLayer class.\n\n        Parameters\n        ----------\n        name : str = 'DetectorLayer'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        self.name = str(name)\n\n\n    @abstractmethod\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array: # pragma: no cover\n\"\"\"\n        Abstract method for Detector Layers\n        \"\"\"\n        return\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name} layer has no summary method yet.\"\n    \n\n    def display(self            : DetectorLayer, \n                image           : Array,\n                figsize         : tuple = (5, 4),\n                dpi             : int = 120,\n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; None:\n\"\"\"\n        Displays a plot of the image propagating through the layer.\n\n        Parameters\n        ----------\n        image : Array\n            The dummy image to propagate though the detector.\n        figsize : tuple = (10, 4)\n            The size of the figure to display.\n        cmap : str = 'inferno'\n            The colour map to use.\n        dpi : int = 120\n            The resolution of the figure.\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n        \"\"\"\n        single_image_plot(image, figsize=figsize, title=\"PSF\", \n                          cbar_label=\"Counts\", cmap='inferno', dpi=dpi)\n</pre> class DetectorLayer(Base, ABC):     \"\"\"     A base Detector layer class to help with type checking throuhgout the rest     of the software.      Attributes     ----------     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     name : str       def __init__(self : DetectorLayer,                  name : str = 'DetectorLayer') -&gt; DetectorLayer:         \"\"\"         Constructor for the DetectorLayer class.          Parameters         ----------         name : str = 'DetectorLayer'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         self.name = str(name)       @abstractmethod     def __call__(self : DetectorLayer, image : Array) -&gt; Array: # pragma: no cover         \"\"\"         Abstract method for Detector Layers         \"\"\"         return           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name} layer has no summary method yet.\"           def display(self            : DetectorLayer,                  image           : Array,                 figsize         : tuple = (5, 4),                 dpi             : int = 120,                 angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; None:         \"\"\"         Displays a plot of the image propagating through the layer.          Parameters         ----------         image : Array             The dummy image to propagate though the detector.         figsize : tuple = (10, 4)             The size of the figure to display.         cmap : str = 'inferno'             The colour map to use.         dpi : int = 120             The resolution of the figure.         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.         \"\"\"         single_image_plot(image, figsize=figsize, title=\"PSF\",                            cbar_label=\"Counts\", cmap='inferno', dpi=dpi) In\u00a0[\u00a0]: Copied! <pre>class ApplyPixelResponse(DetectorLayer):\n\"\"\"\n    Applies a pixel response array to the the input image, via a multiplication.\n\n    Attributes\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    pixel_response : Array\n\n\n    def __init__(self           : DetectorLayer,\n                 pixel_response : Array,\n                 name           : str = 'ApplyPixelResponse') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplyPixelResponse class.\n\n        Parameters\n        ----------\n        pixel_response : Array\n            The pixel_response to apply to the input image. Must be a 2\n            dimensional array equal to size of the image at time of application.\n        name : str = 'ApplyPixelResponse'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.pixel_response = np.asarray(pixel_response, dtype=float)\n        assert self.pixel_response.ndim == 2, \\\n        (\"pixel_response must be a 2 dimensional array.\")\n\n\n    def __call__(self : DetectorLayer, image) -&gt; Array:\n\"\"\"\n        Applies the pixel response to the input image, via a multiplication.\n\n        Parameters\n        ----------\n        image : Array\n            The image to apply the pixel_response to.\n\n        Returns\n        -------\n        image : Array\n            The image with the pixel_response applied.\n        \"\"\"\n        return image * self.pixel_response\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Applies the pixel response to the image.\"\n</pre> class ApplyPixelResponse(DetectorLayer):     \"\"\"     Applies a pixel response array to the the input image, via a multiplication.      Attributes     ----------     pixel_response : Array         The pixel_response to apply to the input image.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     pixel_response : Array       def __init__(self           : DetectorLayer,                  pixel_response : Array,                  name           : str = 'ApplyPixelResponse') -&gt; DetectorLayer:         \"\"\"         Constructor for the ApplyPixelResponse class.          Parameters         ----------         pixel_response : Array             The pixel_response to apply to the input image. Must be a 2             dimensional array equal to size of the image at time of application.         name : str = 'ApplyPixelResponse'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.pixel_response = np.asarray(pixel_response, dtype=float)         assert self.pixel_response.ndim == 2, \\         (\"pixel_response must be a 2 dimensional array.\")       def __call__(self : DetectorLayer, image) -&gt; Array:         \"\"\"         Applies the pixel response to the input image, via a multiplication.          Parameters         ----------         image : Array             The image to apply the pixel_response to.          Returns         -------         image : Array             The image with the pixel_response applied.         \"\"\"         return image * self.pixel_response           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name}: Applies the pixel response to the image.\" In\u00a0[\u00a0]: Copied! <pre>class ApplyJitter(DetectorLayer):\n\"\"\"\n    Convolves the image with a gaussian kernel parameterised by the standard\n    deviation (sigma).\n\n    Attributes\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the guassian kernel, in units of pixels.\n    kernel_size : int\n        The size of the convolution kernel to use.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    kernel_size : int\n    sigma       : Array\n\n\n    def __init__(self        : DetectorLayer,\n                 sigma       : Array,\n                 kernel_size : int = 10,\n                 name        : str = 'ApplyJitter') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplyJitter class.\n\n        Parameters\n        ----------\n        sigma : Array, pixels\n            The standard deviation of the guassian kernel, in units of pixels.\n        kernel_size : int = 10\n            The size of the convolution kernel to use.\n        name : str = 'ApplyJitter'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.kernel_size = int(kernel_size)\n        self.sigma       = np.asarray(sigma, dtype=float)\n        assert self.sigma.ndim == 0, (\"sigma must be scalar array.\")\n\n\n    def generate_kernel(self : DetectorLayer) -&gt; Array:\n\"\"\"\n        Generates the normalised guassian kernel.\n\n        Returns\n        -------\n        kernel : Array\n            The gaussian kernel.\n        \"\"\"\n        # Generate distribution\n        x = np.linspace(-10, 10, self.kernel_size)\n        kernel = norm.pdf(x,          scale=self.sigma) * \\\n                 norm.pdf(x[:, None], scale=self.sigma)\n        return kernel/np.sum(kernel)\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Convolves the input image with the generate gaussian kernel.\n\n        Parameters\n        ----------\n        image : Array\n            The image to convolve with the gussian kernel.\n\n        Returns\n        -------\n        image : Array\n            The image with the gaussian kernel convolution applied.\n        \"\"\"\n        kernel = self.generate_kernel()\n        return convolve(image, kernel, mode='same')\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a jitter of {self.jitter:.{sigfigs}} \"\n                \"pixels.\")\n</pre> class ApplyJitter(DetectorLayer):     \"\"\"     Convolves the image with a gaussian kernel parameterised by the standard     deviation (sigma).      Attributes     ----------     sigma : Array, pixels         The standard deviation of the guassian kernel, in units of pixels.     kernel_size : int         The size of the convolution kernel to use.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     kernel_size : int     sigma       : Array       def __init__(self        : DetectorLayer,                  sigma       : Array,                  kernel_size : int = 10,                  name        : str = 'ApplyJitter') -&gt; DetectorLayer:         \"\"\"         Constructor for the ApplyJitter class.          Parameters         ----------         sigma : Array, pixels             The standard deviation of the guassian kernel, in units of pixels.         kernel_size : int = 10             The size of the convolution kernel to use.         name : str = 'ApplyJitter'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.kernel_size = int(kernel_size)         self.sigma       = np.asarray(sigma, dtype=float)         assert self.sigma.ndim == 0, (\"sigma must be scalar array.\")       def generate_kernel(self : DetectorLayer) -&gt; Array:         \"\"\"         Generates the normalised guassian kernel.          Returns         -------         kernel : Array             The gaussian kernel.         \"\"\"         # Generate distribution         x = np.linspace(-10, 10, self.kernel_size)         kernel = norm.pdf(x,          scale=self.sigma) * \\                  norm.pdf(x[:, None], scale=self.sigma)         return kernel/np.sum(kernel)       def __call__(self : DetectorLayer, image : Array) -&gt; Array:         \"\"\"         Convolves the input image with the generate gaussian kernel.          Parameters         ----------         image : Array             The image to convolve with the gussian kernel.          Returns         -------         image : Array             The image with the gaussian kernel convolution applied.         \"\"\"         kernel = self.generate_kernel()         return convolve(image, kernel, mode='same')           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a jitter of {self.jitter:.{sigfigs}} \"                 \"pixels.\") In\u00a0[\u00a0]: Copied! <pre>class ApplySaturation(DetectorLayer):\n\"\"\"\n    Applies a simple saturation model to the input image, by clipping any\n    values above saturation, to saturation.\n\n    Attributes\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    saturation : Array\n\n\n    def __init__(self       : DetectorLayer,\n                 saturation : Array,\n                 name       : str = 'ApplySaturation') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplySaturation class.\n\n        Parameters\n        ----------\n        saturation : Array\n            The value at which the saturation is applied.\n        name : str = 'ApplySaturation'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.saturation = np.asarray(saturation, dtype=float)\n        assert self.saturation.ndim == 0, (\"saturation must be a scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Applies the satuation effect by reducing all values in the image above\n        saturation, to the saturation value.\n\n        Parameters\n        ----------\n        image : Array\n            The image to apply the saturation to.\n\n        Returns\n        -------\n        image : Array\n            The image with the saturation applied.\n        \"\"\"\n        return np.minimum(image, self.saturation)\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a saturation of \"\n                f\"{self.saturation:.{sigfigs}} counts.\")\n</pre> class ApplySaturation(DetectorLayer):     \"\"\"     Applies a simple saturation model to the input image, by clipping any     values above saturation, to saturation.      Attributes     ----------     saturation : Array         The value at which the saturation is applied.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     saturation : Array       def __init__(self       : DetectorLayer,                  saturation : Array,                  name       : str = 'ApplySaturation') -&gt; DetectorLayer:         \"\"\"         Constructor for the ApplySaturation class.          Parameters         ----------         saturation : Array             The value at which the saturation is applied.         name : str = 'ApplySaturation'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.saturation = np.asarray(saturation, dtype=float)         assert self.saturation.ndim == 0, (\"saturation must be a scalar array.\")       def __call__(self : DetectorLayer, image : Array) -&gt; Array:         \"\"\"         Applies the satuation effect by reducing all values in the image above         saturation, to the saturation value.          Parameters         ----------         image : Array             The image to apply the saturation to.          Returns         -------         image : Array             The image with the saturation applied.         \"\"\"         return np.minimum(image, self.saturation)           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a saturation of \"                 f\"{self.saturation:.{sigfigs}} counts.\") In\u00a0[\u00a0]: Copied! <pre>class AddConstant(DetectorLayer):\n\"\"\"\n    Add a constant to the output image. This is typically used to model the\n    mean value of the detector noise.\n\n    Attributes\n    ----------\n    value : Array\n        The value to add to the image.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    value : Array\n\n\n    def __init__(self  : DetectorLayer,\n                 value : Array,\n                 name  : str = 'AddConstant') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the AddConstant class.\n\n        Parameters\n        ----------\n        value : Array\n            The value to add to the image.\n        name : str = 'AddConstant'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.value = np.asarray(value, dtype=float)\n        assert self.value.ndim == 0, (\"value must be a scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Adds the value to the input image.\n\n        Parameters\n        ----------\n        image : Array\n            The image to add the value to.\n\n        Returns\n        -------\n        image : Array\n            The image with the value added.\n        \"\"\"\n        return image + self.value\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Adds a constant value of \"\n                f\"{self.value:.{sigfigs}} counts.\")\n</pre> class AddConstant(DetectorLayer):     \"\"\"     Add a constant to the output image. This is typically used to model the     mean value of the detector noise.      Attributes     ----------     value : Array         The value to add to the image.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     value : Array       def __init__(self  : DetectorLayer,                  value : Array,                  name  : str = 'AddConstant') -&gt; DetectorLayer:         \"\"\"         Constructor for the AddConstant class.          Parameters         ----------         value : Array             The value to add to the image.         name : str = 'AddConstant'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.value = np.asarray(value, dtype=float)         assert self.value.ndim == 0, (\"value must be a scalar array.\")       def __call__(self : DetectorLayer, image : Array) -&gt; Array:         \"\"\"         Adds the value to the input image.          Parameters         ----------         image : Array             The image to add the value to.          Returns         -------         image : Array             The image with the value added.         \"\"\"         return image + self.value           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Adds a constant value of \"                 f\"{self.value:.{sigfigs}} counts.\") In\u00a0[\u00a0]: Copied! <pre>class IntegerDownsample(DetectorLayer):\n\"\"\"\n    Downsamples an input image by an integer number of pixels via a sum.\n    The number of pixels in the input image must by integer divisible by the\n    kernel_size.\n\n    Attributes\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    kernel_size : int\n\n\n    def __init__(self        : DetectorLayer,\n                 kernel_size : int,\n                 name        : str = 'IntegerDownsample') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the IntegerDownsample class.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the downsampling kernel.\n        name : str = 'IntegerDownsample'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.kernel_size = int(kernel_size)\n\n\n    def downsample(self        : DetectorLayer,\n                   array       : Array,\n                   kernel_size : int) -&gt; Array:\n\"\"\"\n        Downsamples the input array by kernel_size.\n\n        Parameters\n        ----------\n        array : Array\n            The input array to downsample.\n\n        Returns\n        -------\n        kernel_size : int\n            The size of the downsample kernel.\n        \"\"\"\n        size_in = array.shape[0]\n        size_out = size_in//kernel_size\n\n        # Downsample first dimension\n        array = array.reshape((size_in*size_out, kernel_size)).sum(1)\n        array = array.reshape(size_in, size_out).T\n\n        # Downsample second dimension\n        array = array.reshape((size_out*size_out, kernel_size)).sum(1)\n        array = array.reshape(size_out, size_out).T\n        return array\n\n\n    def __call__(self, image):\n\"\"\"\n        Downsamples the input image by the internally stored kernel_size.\n\n        Parameters\n        ----------\n        image : Array\n            The image to downsample.\n\n        Returns\n        -------\n        image : Array\n            The downsampled image.\n        \"\"\"\n        return self.downsample(image, self.kernel_size)\n    \n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Downsamples the image by {self.kernel_size} \"\n                f\"pixels.\")\n</pre> class IntegerDownsample(DetectorLayer):     \"\"\"     Downsamples an input image by an integer number of pixels via a sum.     The number of pixels in the input image must by integer divisible by the     kernel_size.      Attributes     ----------     kernel_size : int         The size of the downsampling kernel.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     kernel_size : int       def __init__(self        : DetectorLayer,                  kernel_size : int,                  name        : str = 'IntegerDownsample') -&gt; DetectorLayer:         \"\"\"         Constructor for the IntegerDownsample class.          Parameters         ----------         kernel_size : int             The size of the downsampling kernel.         name : str = 'IntegerDownsample'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.kernel_size = int(kernel_size)       def downsample(self        : DetectorLayer,                    array       : Array,                    kernel_size : int) -&gt; Array:         \"\"\"         Downsamples the input array by kernel_size.          Parameters         ----------         array : Array             The input array to downsample.          Returns         -------         kernel_size : int             The size of the downsample kernel.         \"\"\"         size_in = array.shape[0]         size_out = size_in//kernel_size          # Downsample first dimension         array = array.reshape((size_in*size_out, kernel_size)).sum(1)         array = array.reshape(size_in, size_out).T          # Downsample second dimension         array = array.reshape((size_out*size_out, kernel_size)).sum(1)         array = array.reshape(size_out, size_out).T         return array       def __call__(self, image):         \"\"\"         Downsamples the input image by the internally stored kernel_size.          Parameters         ----------         image : Array             The image to downsample.          Returns         -------         image : Array             The downsampled image.         \"\"\"         return self.downsample(image, self.kernel_size)           def summary(self            : DetectorLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Downsamples the image by {self.kernel_size} \"                 f\"pixels.\") In\u00a0[\u00a0]: Copied! <pre>class Rotate(DetectorLayer):\n\"\"\"\n    Applies a rotation to the image using interpolation methods.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the image in the clockwise direction.\n    fourier : bool\n        Should the rotation be done using fourier methods or interpolation.\n    padding : int\n        The amount of padding to use if the fourier method is used.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    angle   : Array\n    fourier : bool\n    padding : int\n\n\n    def __init__(self    : DetectorLayer,\n                 angle   : Array,\n                 fourier : bool = False,\n                 padding : int  = None,\n                 name    : str  = 'Rotate') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the image in the clockwise direction.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        padding : int = None\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n        name : str = 'Rotate'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.angle   = np.asarray(angle, dtype=float)\n        self.fourier = bool(fourier)\n        self.padding = padding if padding is None else int(padding)\n        assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Applies the rotation to an image.\n\n        Parameters\n        ----------\n        image : Array\n            The image to rotate.\n\n        Returns\n        -------\n        image : Array\n            The rotated image.\n        \"\"\"\n        if self.fourier:\n            return fourier_rotate(image, self.angle, self.padding)\n        else:\n            return rotate(image, self.angle)\n        \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angle = convert_angular(self.angle, 'radians', angular_units)\n        \n        if self.fourier:\n            method = f\"a Fourier method with padding of {self.padding}\"\n        else:\n            method = \"an Interpolation method of order 1\"\n\n        return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n                f\"rotation to the image using {method}.\")\n</pre> class Rotate(DetectorLayer):     \"\"\"     Applies a rotation to the image using interpolation methods.      Parameters     ----------     angle : Array, radians         The angle by which to rotate the image in the clockwise direction.     fourier : bool         Should the rotation be done using fourier methods or interpolation.     padding : int         The amount of padding to use if the fourier method is used.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     angle   : Array     fourier : bool     padding : int       def __init__(self    : DetectorLayer,                  angle   : Array,                  fourier : bool = False,                  padding : int  = None,                  name    : str  = 'Rotate') -&gt; DetectorLayer:         \"\"\"         Constructor for the Rotate class.          Parameters         ----------         angle: float, radians             The angle by which to rotate the image in the clockwise direction.         fourier : bool = False             Should the fourier rotation method be used (True), or regular             interpolation method be used (False).         padding : int = None             The amount of fourier padding to use. Only applies if fourier is             True.         name : str = 'Rotate'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.angle   = np.asarray(angle, dtype=float)         self.fourier = bool(fourier)         self.padding = padding if padding is None else int(padding)         assert self.angle.ndim == 0, (\"angle must be scalar array.\")       def __call__(self : DetectorLayer, image : Array) -&gt; Array:         \"\"\"         Applies the rotation to an image.          Parameters         ----------         image : Array             The image to rotate.          Returns         -------         image : Array             The rotated image.         \"\"\"         if self.fourier:             return fourier_rotate(image, self.angle, self.padding)         else:             return rotate(image, self.angle)               def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         angle = convert_angular(self.angle, 'radians', angular_units)                  if self.fourier:             method = f\"a Fourier method with padding of {self.padding}\"         else:             method = \"an Interpolation method of order 1\"          return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"                 f\"rotation to the image using {method}.\")"},{"location":"dLux/exceptions/","title":"Exceptions","text":"In\u00a0[\u00a0]: Copied! <pre>from jax import numpy as np\n</pre> from jax import numpy as np  In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"validate_eq_attr_dims\", \"validate_bc_attr_dims\"]\n</pre> __all__ = [\"validate_eq_attr_dims\", \"validate_bc_attr_dims\"] In\u00a0[\u00a0]: Copied! <pre>bc_attr_dims_message = \"\"\"\nExpected dimensions that could be broadcast with\n{}. Recieved dimensions {} when initialising attribute {}.\n\"\"\"\n</pre> bc_attr_dims_message = \"\"\" Expected dimensions that could be broadcast with {}. Recieved dimensions {} when initialising attribute {}. \"\"\" In\u00a0[\u00a0]: Copied! <pre>eq_attr_dims_message = \"\"\"\nExpected dimension {} but recieved {} when initialising the attribute {}.\n\"\"\"\n</pre> eq_attr_dims_message = \"\"\" Expected dimension {} but recieved {} when initialising the attribute {}. \"\"\" In\u00a0[\u00a0]: Copied! <pre>class DimensionError(Exception):\n\"\"\"\n    This error is raised in the place of a ValueError\n    when a user attempts to initialise a dLux object \n    with an attribute that has incorrect or inconsistent\n    dimensions. \n    \"\"\"\n\n\n    def __init__(self: object, message: str) -&gt; object:\n\"\"\"\n        Parameters\n        ----------\n        message: str\n            A detailed, situational error message that is \n            correctly formatted. \n        \"\"\"\n        super().__init__(message)\n</pre> class DimensionError(Exception):     \"\"\"     This error is raised in the place of a ValueError     when a user attempts to initialise a dLux object      with an attribute that has incorrect or inconsistent     dimensions.      \"\"\"       def __init__(self: object, message: str) -&gt; object:         \"\"\"         Parameters         ----------         message: str             A detailed, situational error message that is              correctly formatted.          \"\"\"         super().__init__(message) In\u00a0[\u00a0]: Copied! <pre>def validate_eq_attr_dims(\n        attr_shape: tuple, \n        correct_shape: tuple, \n        attr_name: str) -&gt; None:\n\"\"\"\n    Confirm that an initialised attribute has the correct shape\n    and raise a helpful error if it does not. Correct in this \n    case implies equality between `attr_shape` and `correct_shape`.\n\n    Parameters\n    ----------\n    attr_shape: tuple\n        The shape of the attribute to be initialised.\n    correct_shape: tuple\n        A shape that meets the necessary conditions of\n        the attribute. \n    attr_name: str\n        The name of the attribute that is getting \n        initialised\n    \"\"\"\n    if attr_shape != correct_shape:\n        raise DimensionError(\n            eq_attr_dims_message.format(\n                correct_shape, attr_shape, attr_name))\n</pre> def validate_eq_attr_dims(         attr_shape: tuple,          correct_shape: tuple,          attr_name: str) -&gt; None:     \"\"\"     Confirm that an initialised attribute has the correct shape     and raise a helpful error if it does not. Correct in this      case implies equality between `attr_shape` and `correct_shape`.      Parameters     ----------     attr_shape: tuple         The shape of the attribute to be initialised.     correct_shape: tuple         A shape that meets the necessary conditions of         the attribute.      attr_name: str         The name of the attribute that is getting          initialised     \"\"\"     if attr_shape != correct_shape:         raise DimensionError(             eq_attr_dims_message.format(                 correct_shape, attr_shape, attr_name)) In\u00a0[\u00a0]: Copied! <pre>def validate_bc_attr_dims(\n        attr_shape: tuple, \n        correct_shape: tuple,\n        attr_name: str) -&gt; None:\n\"\"\"\n    Confirm that an initialised attribute has the correct shape\n    and raise a helpful error if it does not. Correct in this \n    case is the relaxed \"broadcastable\" version.\n\n    Parameters\n    ----------\n    attr_shape: tuple\n        The shape of the attribute to be initialised.\n    correct_shape: tuple\n        A shape that meets the necessary conditions of\n        the attribute. \n    attr_name: str\n        The name of the attribute that is getting \n        initialised\n    \"\"\"\n    try:\n        np.broadcast_shapes(attr_shape, correct_shape)\n    except ValueError:\n        raise DimensionError(\n            bc_attr_dims_message.format(\n                correct_shape, attr_shape, attr_name))\n</pre> def validate_bc_attr_dims(         attr_shape: tuple,          correct_shape: tuple,         attr_name: str) -&gt; None:     \"\"\"     Confirm that an initialised attribute has the correct shape     and raise a helpful error if it does not. Correct in this      case is the relaxed \"broadcastable\" version.      Parameters     ----------     attr_shape: tuple         The shape of the attribute to be initialised.     correct_shape: tuple         A shape that meets the necessary conditions of         the attribute.      attr_name: str         The name of the attribute that is getting          initialised     \"\"\"     try:         np.broadcast_shapes(attr_shape, correct_shape)     except ValueError:         raise DimensionError(             bc_attr_dims_message.format(                 correct_shape, attr_shape, attr_name)) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"dLux/observations/","title":"Observations","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom zodiax import Base\nfrom jax.tree_util import tree_map\nimport jax.numpy as np\nfrom jax import vmap\nfrom abc import abstractmethod\nfrom equinox import tree_at\nfrom typing import Any\nimport dLux\n</pre> from __future__ import annotations from zodiax import Base from jax.tree_util import tree_map import jax.numpy as np from jax import vmap from abc import abstractmethod from equinox import tree_at from typing import Any import dLux In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"AbstractObservation\", \"Dither\"]\n</pre> __all__ = [\"AbstractObservation\", \"Dither\"] In\u00a0[\u00a0]: Copied! <pre>class AbstractObservation(Base):\n\"\"\"\n    Abstract base class for observations. All observations should inherit from\n    this class and must implement an `.observe()` method that only takes in a\n    single instance of `dLux.Instrument`.\n\n    Attributes\n    ----------\n    name : str\n        The name of the observation that can be used to access the observation\n        from the `Instrument` class.\n    \"\"\"\n    name : str\n\n\n    def __init__(self : AbstractObservation, \n                 name : str = 'AbstractObservation'):\n\"\"\"\n        Constructor for the AbstractObservation class.\n\n        Parameters\n        ----------\n        name : str = 'AbstractObservation'\n            The name of the observation that can be used to access the\n            observation from the `Instrument` class.\n        \"\"\"\n        self.name = str(name)\n\n\n    @abstractmethod\n    def observe(self       : AbstractObservation, \n                instrument : dLux.core.Instrument) -&gt; Any:\n\"\"\"\n        Abstract method for the observation function.\n        \"\"\"\n        pass\n</pre> class AbstractObservation(Base):     \"\"\"     Abstract base class for observations. All observations should inherit from     this class and must implement an `.observe()` method that only takes in a     single instance of `dLux.Instrument`.      Attributes     ----------     name : str         The name of the observation that can be used to access the observation         from the `Instrument` class.     \"\"\"     name : str       def __init__(self : AbstractObservation,                   name : str = 'AbstractObservation'):         \"\"\"         Constructor for the AbstractObservation class.          Parameters         ----------         name : str = 'AbstractObservation'             The name of the observation that can be used to access the             observation from the `Instrument` class.         \"\"\"         self.name = str(name)       @abstractmethod     def observe(self       : AbstractObservation,                  instrument : dLux.core.Instrument) -&gt; Any:         \"\"\"         Abstract method for the observation function.         \"\"\"         pass In\u00a0[\u00a0]: Copied! <pre>class Dither(AbstractObservation):\n\"\"\"\n    Observation class designed to apply a series of dithers to the insturment\n    and return the corresponding psfs.\n\n    Attributes\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2) where ndithers is the number of dithers\n        and the second dimension is the (x, y) dither in radians.\n    name : str\n        The name of the observation that can be used to access the observation\n        from the `Instrument` class.\n    \"\"\"\n    dithers : Array\n\n\n    def __init__(self : Dither, dithers : Array, name : str = 'Dither'):\n\"\"\"\n        Constructor for the Dither class.\n\n        Parameters\n        ----------\n        dithers : Array, (radians)\n            The array of dithers to apply to the source positions. The shape of\n            the array should be (ndithers, 2) where ndithers is the number of\n            dithers and the second dimension is the (x, y) dither in radians.\n        name : str = 'Dither'\n            The name of the observation that can be used to access the\n            observation from the `Instrument` class.\n        \"\"\"\n        super().__init__(name)\n        self.dithers = np.asarray(dithers, float)\n        dLux.exceptions.validate_bc_attr_dims(self.dithers.shape, (1, 2), \n            'dithers')\n\n\n    def dither_position(self       : Dither, \n                        instrument : Instrument, \n                        dither     : Array) -&gt; Instrument:\n\"\"\"\n        Dithers the position of the source objects by dither.\n\n        Parameters\n        ----------\n        dither : Array, radians\n            The (x, y) dither to apply to the source positions.\n\n        Returns\n        -------\n        instrument : Instrument\n            The instrument with the sources dithered.\n        \"\"\"\n        assert dither.shape == (2,), (\"dither must have shape (2,) ie (x, y)\")\n\n        # Define the dither function\n        dither_fn = lambda source: source.add('position', dither)\n\n        # Map the dithers across the sources\n        dithered_sources = tree_map(dither_fn, instrument.sources, \\\n            is_leaf = lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n        # Apply updates\n        return tree_at(lambda instrument: instrument.sources, instrument, \n            dithered_sources)\n\n\n    def observe(self       : Dither,\n                instrument : Instrument,\n                *args, \n                **kwargs) -&gt; Array:\n\"\"\"\n        Applies a series of dithers to the instrument sources and calls the\n        .model() method after applying each dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The array of dithers to apply to the source positions.\n\n        Returns\n        -------\n        psfs : Array\n            The psfs generated after applying the dithers to the source\n            positions.\n        \"\"\"\n        dith_fn = lambda dither: self.dither_position(instrument, \n            dither).model(*args, **kwargs)\n        return vmap(dith_fn, 0)(self.dithers)\n</pre> class Dither(AbstractObservation):     \"\"\"     Observation class designed to apply a series of dithers to the insturment     and return the corresponding psfs.      Attributes     ----------     dithers : Array, (radians)         The array of dithers to apply to the source positions. The shape of the         array should be (ndithers, 2) where ndithers is the number of dithers         and the second dimension is the (x, y) dither in radians.     name : str         The name of the observation that can be used to access the observation         from the `Instrument` class.     \"\"\"     dithers : Array       def __init__(self : Dither, dithers : Array, name : str = 'Dither'):         \"\"\"         Constructor for the Dither class.          Parameters         ----------         dithers : Array, (radians)             The array of dithers to apply to the source positions. The shape of             the array should be (ndithers, 2) where ndithers is the number of             dithers and the second dimension is the (x, y) dither in radians.         name : str = 'Dither'             The name of the observation that can be used to access the             observation from the `Instrument` class.         \"\"\"         super().__init__(name)         self.dithers = np.asarray(dithers, float)         dLux.exceptions.validate_bc_attr_dims(self.dithers.shape, (1, 2),              'dithers')       def dither_position(self       : Dither,                          instrument : Instrument,                          dither     : Array) -&gt; Instrument:         \"\"\"         Dithers the position of the source objects by dither.          Parameters         ----------         dither : Array, radians             The (x, y) dither to apply to the source positions.          Returns         -------         instrument : Instrument             The instrument with the sources dithered.         \"\"\"         assert dither.shape == (2,), (\"dither must have shape (2,) ie (x, y)\")          # Define the dither function         dither_fn = lambda source: source.add('position', dither)          # Map the dithers across the sources         dithered_sources = tree_map(dither_fn, instrument.sources, \\             is_leaf = lambda leaf: isinstance(leaf, dLux.sources.Source))          # Apply updates         return tree_at(lambda instrument: instrument.sources, instrument,              dithered_sources)       def observe(self       : Dither,                 instrument : Instrument,                 *args,                  **kwargs) -&gt; Array:         \"\"\"         Applies a series of dithers to the instrument sources and calls the         .model() method after applying each dither.          Parameters         ----------         instrument : Instrument             The array of dithers to apply to the source positions.          Returns         -------         psfs : Array             The psfs generated after applying the dithers to the source             positions.         \"\"\"         dith_fn = lambda dither: self.dither_position(instrument,              dither).model(*args, **kwargs)         return vmap(dith_fn, 0)(self.dithers)"},{"location":"dLux/optics/","title":"Optics","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax import vmap\nfrom jax.tree_util import tree_map\nfrom jax.lax import stop_gradient\nfrom zodiax import Base\nfrom abc import ABC, abstractmethod\nfrom inspect import signature\nfrom dLux.utils.helpers import two_image_plot\nfrom dLux.utils.units import convert_angular, convert_cartesian\nimport dLux\n</pre> from __future__ import annotations import jax.numpy as np from jax import vmap from jax.tree_util import tree_map from jax.lax import stop_gradient from zodiax import Base from abc import ABC, abstractmethod from inspect import signature from dLux.utils.helpers import two_image_plot from dLux.utils.units import convert_angular, convert_cartesian import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"CreateWavefront\", \"TiltWavefront\", \"NormaliseWavefront\", \n           \"ApplyBasisOPD\", \"AddPhase\", \"AddOPD\", \"TransmissiveOptic\", \n           \"ApplyBasisCLIMB\", \"Rotate\"]\n</pre> __all__ = [\"CreateWavefront\", \"TiltWavefront\", \"NormaliseWavefront\",             \"ApplyBasisOPD\", \"AddPhase\", \"AddOPD\", \"TransmissiveOptic\",             \"ApplyBasisCLIMB\", \"Rotate\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class OpticalLayer(Base, ABC):\n\"\"\"\n    A base Optical layer class to help with type checking throuhgout the rest\n    of the software. Instantiates the apply method which inspects the function\n    signature of the __call__ method in order to only pass and return the\n    parameters dictionary if it is needed and modified.\n\n    Attributes\n    ----------\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    name : str\n\n\n    def __init__(self : OpticalLayer,\n                 name : str = 'OpticalLayer') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the OpticalLayer class.\n\n        Parameters\n        ----------\n        name : str = 'OpticalLayer'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        self.name = str(name)\n\n\n    @abstractmethod\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront: # pragma: no cover\n\"\"\"\n        Appies the layer to the `Wavefront`.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the optical layer applied.\n        \"\"\"\n        return\n\n\n    def apply(self : OpticalLayer, parameters : dict) -&gt; dict:\n\"\"\"\n        Unpacks the wavefront object from the parameters dictionary and applies\n        the layers __call__ method upon it.\n\n        Parameters\n        ----------\n        parameters : dict\n            A dictionary that must contain a \"Wavefront\" key with a\n            corresponding dLux.wavefronts.Wavefront object.\n\n        Returns\n        -------\n        parameters : dict\n            A dictionary with the updated \"Wavefront\" key with the propagated\n            wavefront object.\n        \"\"\"\n        # Inspect apply function to see if it takes/returns the parameters dict\n        input_parameters = signature(self.__call__).parameters\n\n        # Method does not take in the parameters, update in place\n        if 'parameters' not in input_parameters:\n            parameters[\"Wavefront\"] = self.__call__(parameters[\"Wavefront\"])\n\n        # Method takes and return updated parameters\n        elif input_parameters['returns_parameters'].default == True:\n            wavefront, parameters = self.__call__(parameters[\"Wavefront\"],\n                                                  parameters)\n            parameters[\"Wavefront\"] = wavefront\n\n        # Method takes but does not return parameters\n        else:\n            parameters[\"Wavefront\"] = self.__call__(parameters[\"Wavefront\"],\n                                                    parameters)\n\n        # Return updated parameters dictionary\n        return parameters\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name} layer has no summary method yet.\"\n\n\n    def display(self            : OpticalLayer, \n                wavefront       : Wavefront,\n                figsize         : tuple = (10, 4),\n                dpi             : int = 120,\n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; None:\n\"\"\"\n        Displays a plot of the wavefront amplitude and opd or phase.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The dummy wavefront to propagate though the optics.\n        figsize : tuple = (10, 4)\n            The size of the figure to display.\n        cmap : str = 'inferno'\n            The colour map to use.\n        dpi : int = 120\n            The resolution of the figure.\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n        \"\"\"\n        amplitude = wavefront.amplitude\n        phase = convert_angular(wavefront.phase, \"radians\", angular_units)\n        two_image_plot(amplitude[0], phase[0], figsize=figsize, \n            titles=(\"Amplitude\", \"Phase\"), cbar_labels=(\"Intensity\", \n            f\"Phase ({angular_units})\"), cmaps=('inferno', 'twilight'), \n            bounds=(None, 2*np.pi), dpi=dpi)\n</pre> class OpticalLayer(Base, ABC):     \"\"\"     A base Optical layer class to help with type checking throuhgout the rest     of the software. Instantiates the apply method which inspects the function     signature of the __call__ method in order to only pass and return the     parameters dictionary if it is needed and modified.      Attributes     ----------     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     name : str       def __init__(self : OpticalLayer,                  name : str = 'OpticalLayer') -&gt; OpticalLayer:         \"\"\"         Constructor for the OpticalLayer class.          Parameters         ----------         name : str = 'OpticalLayer'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         self.name = str(name)       @abstractmethod     def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront: # pragma: no cover         \"\"\"         Appies the layer to the `Wavefront`.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the optical layer applied.         \"\"\"         return       def apply(self : OpticalLayer, parameters : dict) -&gt; dict:         \"\"\"         Unpacks the wavefront object from the parameters dictionary and applies         the layers __call__ method upon it.          Parameters         ----------         parameters : dict             A dictionary that must contain a \"Wavefront\" key with a             corresponding dLux.wavefronts.Wavefront object.          Returns         -------         parameters : dict             A dictionary with the updated \"Wavefront\" key with the propagated             wavefront object.         \"\"\"         # Inspect apply function to see if it takes/returns the parameters dict         input_parameters = signature(self.__call__).parameters          # Method does not take in the parameters, update in place         if 'parameters' not in input_parameters:             parameters[\"Wavefront\"] = self.__call__(parameters[\"Wavefront\"])          # Method takes and return updated parameters         elif input_parameters['returns_parameters'].default == True:             wavefront, parameters = self.__call__(parameters[\"Wavefront\"],                                                   parameters)             parameters[\"Wavefront\"] = wavefront          # Method takes but does not return parameters         else:             parameters[\"Wavefront\"] = self.__call__(parameters[\"Wavefront\"],                                                     parameters)          # Return updated parameters dictionary         return parameters           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name} layer has no summary method yet.\"       def display(self            : OpticalLayer,                  wavefront       : Wavefront,                 figsize         : tuple = (10, 4),                 dpi             : int = 120,                 angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; None:         \"\"\"         Displays a plot of the wavefront amplitude and opd or phase.          Parameters         ----------         wavefront : Wavefront             The dummy wavefront to propagate though the optics.         figsize : tuple = (10, 4)             The size of the figure to display.         cmap : str = 'inferno'             The colour map to use.         dpi : int = 120             The resolution of the figure.         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.         \"\"\"         amplitude = wavefront.amplitude         phase = convert_angular(wavefront.phase, \"radians\", angular_units)         two_image_plot(amplitude[0], phase[0], figsize=figsize,              titles=(\"Amplitude\", \"Phase\"), cbar_labels=(\"Intensity\",              f\"Phase ({angular_units})\"), cmaps=('inferno', 'twilight'),              bounds=(None, 2*np.pi), dpi=dpi) In\u00a0[\u00a0]: Copied! <pre>class CreateWavefront(OpticalLayer):\n\"\"\"\n    Initialises the relevant Wavefront class with the specified attributes.\n    Also applies the tilt specified by the source object, defined in the\n    parameters dictionary. All wavefronts are cosntructed in the Pupil plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels used to represent the wavefront.\n    diameter: Array, meters\n        The diameter of the wavefront in the Pupil plane.\n    wavefront_type: str\n        Determines the type of wavefront class to create. Currently supports\n        'Cartesian', 'Angular', 'FarFieldFresnel'.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    npixels        : int\n    diameter       : Array\n    wavefront_type : str\n\n\n    def __init__(self           : OpticalLayer,\n                 npixels        : int,\n                 diameter       : Array,\n                 wavefront_type : str = 'Angular',\n                 name           : str = 'CreateWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the CreateWavefront class.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels used to represent the wavefront.\n        diameter: Array, meters\n            The diameter of the wavefront in the Pupil plane.\n        wavefront_type: str = 'Angular'\n            Determines the type of wavefront class to create. Currently supports\n            'Cartesian', 'Angular', 'FarFieldFresnel'.\n        name : str = 'CreateWavefront'\n            The name of the layer, which is used to index the layers dictionary.\n            Default is 'CreateWavefront'.\n        \"\"\"\n        super().__init__(name)\n        self.npixels        = int(npixels)\n        self.diameter       = np.asarray(diameter, dtype=float)\n        self.wavefront_type = str(wavefront_type)\n\n        # Input checks\n        assert self.diameter.ndim == 0, (\"diameter must be \"\n        \"a scalar array.\")\n        assert wavefront_type in ('Cartesian', 'Angular', 'FarFieldFresnel'), \\\n        (\"wavefront_type must be either 'Cartesian', 'Angular' or \"\n         \"'FarFieldFresnel'\")\n\n\n    def __call__(self               : OpticalLayer,\n                 wavefront          : Wavefront,\n                 parameters         : dict,\n                 returns_parameters : bool = True) -&gt; Wavefront:\n\"\"\"\n        Constructs a wavefront obect based on the parameters of the class and\n        the parameters within the parameters dictionary.\n\n        Parameters\n        ----------\n        wavefront : None\n            Any empty None type input to the class in order to maintain the\n            input conventions determied by the apply method of OpticalLayers.\n        parameters : dict\n            A dictionary of parameters needed to construct the wavefront.\n        returns_parameters : bool = True\n            Determines if the class returns the parameters dictionary.\n\n        Returns\n        -------\n        wavefront, parameters : (Wavefront, dict)\n            Returns the constructed wavefront and the updated parameters\n            dictionary. If returns_parameters is False, only the wavefront is\n            returned.\n        \"\"\"\n        # Get the wavelength\n        wavelength = parameters[\"wavelength\"]\n\n        # Determine the pixel scale\n        pixel_scale = self.diameter/self.npixels\n\n        # Construct normalised Amplitude\n        amplitude = np.ones((1, self.npixels, self.npixels))\n        amplitude /= np.linalg.norm(amplitude)\n\n        # Construct empty phases\n        phase = np.zeros(((1, self.npixels, self.npixels)))\n\n        # Get correct Wavefront type\n        wavefront_constructor = getattr(dLux.wavefronts,\n                                        self.wavefront_type + \"Wavefront\")\n\n        # Construct Wavefront\n        wavefront = wavefront_constructor(wavelength, pixel_scale, amplitude,\n                                      phase, dLux.wavefronts.PlaneType.Pupil)\n\n        # Tilt wavefront from source offset\n        wavefront = wavefront.tilt_wavefront(parameters[\"offset\"])\n\n        # Kill PlaneType Gradients\n        is_leaf = lambda x: isinstance(x, dLux.wavefronts.PlaneType)\n        kill_gradient = lambda x: stop_gradient(x.value) if is_leaf(x) else x\n        wavefront = tree_map(kill_gradient, wavefront, is_leaf=is_leaf)\n\n        # Update the parameters dictionary with the constructed wavefront\n        parameters[\"Wavefront\"] = wavefront\n\n        # Return either the wavefront or wavefront and parameters dictionary\n        if returns_parameters:\n            return wavefront, parameters\n        else:\n            return wavefront\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Creates a {self.wavefront_type} wavefront of \" \n                f\"size {self.npixels} pixels and diameter {self.diameter} m.\")\n</pre> class CreateWavefront(OpticalLayer):     \"\"\"     Initialises the relevant Wavefront class with the specified attributes.     Also applies the tilt specified by the source object, defined in the     parameters dictionary. All wavefronts are cosntructed in the Pupil plane.      Attributes     ----------     npixels : int         The number of pixels used to represent the wavefront.     diameter: Array, meters         The diameter of the wavefront in the Pupil plane.     wavefront_type: str         Determines the type of wavefront class to create. Currently supports         'Cartesian', 'Angular', 'FarFieldFresnel'.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     npixels        : int     diameter       : Array     wavefront_type : str       def __init__(self           : OpticalLayer,                  npixels        : int,                  diameter       : Array,                  wavefront_type : str = 'Angular',                  name           : str = 'CreateWavefront') -&gt; OpticalLayer:         \"\"\"         Constructor for the CreateWavefront class.          Parameters         ----------         npixels : int             The number of pixels used to represent the wavefront.         diameter: Array, meters             The diameter of the wavefront in the Pupil plane.         wavefront_type: str = 'Angular'             Determines the type of wavefront class to create. Currently supports             'Cartesian', 'Angular', 'FarFieldFresnel'.         name : str = 'CreateWavefront'             The name of the layer, which is used to index the layers dictionary.             Default is 'CreateWavefront'.         \"\"\"         super().__init__(name)         self.npixels        = int(npixels)         self.diameter       = np.asarray(diameter, dtype=float)         self.wavefront_type = str(wavefront_type)          # Input checks         assert self.diameter.ndim == 0, (\"diameter must be \"         \"a scalar array.\")         assert wavefront_type in ('Cartesian', 'Angular', 'FarFieldFresnel'), \\         (\"wavefront_type must be either 'Cartesian', 'Angular' or \"          \"'FarFieldFresnel'\")       def __call__(self               : OpticalLayer,                  wavefront          : Wavefront,                  parameters         : dict,                  returns_parameters : bool = True) -&gt; Wavefront:         \"\"\"         Constructs a wavefront obect based on the parameters of the class and         the parameters within the parameters dictionary.          Parameters         ----------         wavefront : None             Any empty None type input to the class in order to maintain the             input conventions determied by the apply method of OpticalLayers.         parameters : dict             A dictionary of parameters needed to construct the wavefront.         returns_parameters : bool = True             Determines if the class returns the parameters dictionary.          Returns         -------         wavefront, parameters : (Wavefront, dict)             Returns the constructed wavefront and the updated parameters             dictionary. If returns_parameters is False, only the wavefront is             returned.         \"\"\"         # Get the wavelength         wavelength = parameters[\"wavelength\"]          # Determine the pixel scale         pixel_scale = self.diameter/self.npixels          # Construct normalised Amplitude         amplitude = np.ones((1, self.npixels, self.npixels))         amplitude /= np.linalg.norm(amplitude)          # Construct empty phases         phase = np.zeros(((1, self.npixels, self.npixels)))          # Get correct Wavefront type         wavefront_constructor = getattr(dLux.wavefronts,                                         self.wavefront_type + \"Wavefront\")          # Construct Wavefront         wavefront = wavefront_constructor(wavelength, pixel_scale, amplitude,                                       phase, dLux.wavefronts.PlaneType.Pupil)          # Tilt wavefront from source offset         wavefront = wavefront.tilt_wavefront(parameters[\"offset\"])          # Kill PlaneType Gradients         is_leaf = lambda x: isinstance(x, dLux.wavefronts.PlaneType)         kill_gradient = lambda x: stop_gradient(x.value) if is_leaf(x) else x         wavefront = tree_map(kill_gradient, wavefront, is_leaf=is_leaf)          # Update the parameters dictionary with the constructed wavefront         parameters[\"Wavefront\"] = wavefront          # Return either the wavefront or wavefront and parameters dictionary         if returns_parameters:             return wavefront, parameters         else:             return wavefront           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Creates a {self.wavefront_type} wavefront of \"                  f\"size {self.npixels} pixels and diameter {self.diameter} m.\") In\u00a0[\u00a0]: Copied! <pre>class TiltWavefront(OpticalLayer):\n\"\"\"\n    Tilts the wavefront by the input tilt_angles.\n\n    Attributes\n    ----------\n    tilt_angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    tilt_angles : Array\n\n\n    def __init__(self        : OpticalLayer,\n                 tilt_angles : Array,\n                 name        : str = 'TiltWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TiltWavefront class.\n\n        Parameters\n        ----------\n        tilt_angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n        name : str = TiltWavefront\n            The name of the layer, which is used to index the layers dictionary.\n            Default is 'TiltWavefront'.\n        \"\"\"\n        super().__init__(name)\n        self.tilt_angles = np.asarray(tilt_angles, dtype=float)\n\n        # Input checks\n        assert self.tilt_angles.shape == (2,), \\\n        (\"tilt_angles must be an array of shape (2,), ie (x, y).\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the tilt_angle to the phase of the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the optical layer applied.\n        \"\"\"\n        return wavefront.tilt_wavefront(self.tilt_angles)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angles = convert_angular(self.tilt_angles, 'radians', angular_units)\n        return (f\"{self.name}: Tilts the wavefront by {angles:.{sigfigs}} \"\n                f\"{angular_units} in the (x, y) dimension.\")\n</pre> class TiltWavefront(OpticalLayer):     \"\"\"     Tilts the wavefront by the input tilt_angles.      Attributes     ----------     tilt_angles : Array, radians         The (x, y) angles by which to tilt the wavefront.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     tilt_angles : Array       def __init__(self        : OpticalLayer,                  tilt_angles : Array,                  name        : str = 'TiltWavefront') -&gt; OpticalLayer:         \"\"\"         Constructor for the TiltWavefront class.          Parameters         ----------         tilt_angles : Array, radians             The (x, y) angles by which to tilt the wavefront.         name : str = TiltWavefront             The name of the layer, which is used to index the layers dictionary.             Default is 'TiltWavefront'.         \"\"\"         super().__init__(name)         self.tilt_angles = np.asarray(tilt_angles, dtype=float)          # Input checks         assert self.tilt_angles.shape == (2,), \\         (\"tilt_angles must be an array of shape (2,), ie (x, y).\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Applies the tilt_angle to the phase of the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the optical layer applied.         \"\"\"         return wavefront.tilt_wavefront(self.tilt_angles)       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         angles = convert_angular(self.tilt_angles, 'radians', angular_units)         return (f\"{self.name}: Tilts the wavefront by {angles:.{sigfigs}} \"                 f\"{angular_units} in the (x, y) dimension.\") In\u00a0[\u00a0]: Copied! <pre>class NormaliseWavefront(OpticalLayer):\n\"\"\"\n    Normalises the input wavefront using the in-built wavefront normalisation\n    method.\n\n    Attributes\n    ----------\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    \n\n    def __init__(self : OpticalLayer,\n                 name : str = 'NormaliseWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the NormaliseWavefront class.\n\n        Parameters\n        ----------\n        name : string = 'NormaliseWavefront'\n            The name of the layer, which is used to index the layers\n            dictionary.\n        \"\"\"\n        super().__init__(name)\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the wavefront normalisation method applied.\n        \"\"\"\n        return wavefront.normalise()\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Normalises the wavefront to unity power.\"\n</pre> class NormaliseWavefront(OpticalLayer):     \"\"\"     Normalises the input wavefront using the in-built wavefront normalisation     method.      Attributes     ----------     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"           def __init__(self : OpticalLayer,                  name : str = 'NormaliseWavefront') -&gt; OpticalLayer:         \"\"\"         Constructor for the NormaliseWavefront class.          Parameters         ----------         name : string = 'NormaliseWavefront'             The name of the layer, which is used to index the layers             dictionary.         \"\"\"         super().__init__(name)       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Normalises the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the wavefront normalisation method applied.         \"\"\"         return wavefront.normalise()           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name}: Normalises the wavefront to unity power.\" In\u00a0[\u00a0]: Copied! <pre>class ApplyBasisOPD(OpticalLayer):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    basis: Array, meters\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis        : Array\n    coefficients : Array\n\n\n    def __init__(self         : OpticalLayer,\n                 basis        : Array,\n                 coefficients : Array = None,\n                 name         : str = 'ApplyBasisOPD') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyBasisOPD class.\n\n        Parameters\n        ----------\n        basis : Array, meters\n            The Array of basis polynomials. This should be a 3 dimensional Array\n            with the first dimension being the number of basis vectors, and the\n            last two dimensions being equal to the wavefront shape at the time\n            of application to the wavefront.\n        coefficients : Array = None\n            The coefficients by which to weight the basis vectors. This must\n            have the same length as the first dimension of the basis Array. If\n            None is supplied an Array of zeros is constructed.\n        name : str = 'ApplyBasisOPD'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.basis        = np.asarray(basis, dtype=float)\n        self.coefficients = np.zeros(basis.shape[0]) if coefficients is None \\\n                            else np.asarray(coefficients, dtype=float)\n\n        # Input checks\n        assert self.basis.ndim == 3, \\\n        (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n        assert self.coefficients.ndim == 1 and \\\n        self.coefficients.shape[0] == self.basis.shape[0], \\\n        (\"coefficients must be a 1 dimensional array with length equal to the \"\n        \"First dimension of the basis array.\")\n\n\n    def get_opd(self : OpticalLayer) -&gt; Array:\n\"\"\"\n        A function to calculate the total OPD from the basis vector and the\n        coefficients.\n\n        Returns\n        -------\n        OPD : Array, meters\n            The total OPD calulated from the basis vectors and coefficients.\n        \"\"\"\n        return np.dot(self.basis.T, self.coefficients)\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\n\"\"\"\n        Calculate and apply the appropriate phase shift to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the appropriate phase applied.\n        \"\"\"\n        return wavefront.add_opd(self.get_opd())\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies an Optical Path Difference (OPD) to the \"\n            f\"wavefront calculated from the basis vectors and coefficients.\")\n</pre> class ApplyBasisOPD(OpticalLayer):     \"\"\"     Adds an array of phase values to the input wavefront calculated from the     Optical Path Difference (OPD). The OPDs are calculated from the basis     arrays, and weighted by the coefficients, and converted to phases by the     wavefront methods.      Attributes     ----------     basis: Array, meters         Arrays holding the pre-calculated basis vectors.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     basis        : Array     coefficients : Array       def __init__(self         : OpticalLayer,                  basis        : Array,                  coefficients : Array = None,                  name         : str = 'ApplyBasisOPD') -&gt; OpticalLayer:         \"\"\"         Constructor for the ApplyBasisOPD class.          Parameters         ----------         basis : Array, meters             The Array of basis polynomials. This should be a 3 dimensional Array             with the first dimension being the number of basis vectors, and the             last two dimensions being equal to the wavefront shape at the time             of application to the wavefront.         coefficients : Array = None             The coefficients by which to weight the basis vectors. This must             have the same length as the first dimension of the basis Array. If             None is supplied an Array of zeros is constructed.         name : str = 'ApplyBasisOPD'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.basis        = np.asarray(basis, dtype=float)         self.coefficients = np.zeros(basis.shape[0]) if coefficients is None \\                             else np.asarray(coefficients, dtype=float)          # Input checks         assert self.basis.ndim == 3, \\         (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")         assert self.coefficients.ndim == 1 and \\         self.coefficients.shape[0] == self.basis.shape[0], \\         (\"coefficients must be a 1 dimensional array with length equal to the \"         \"First dimension of the basis array.\")       def get_opd(self : OpticalLayer) -&gt; Array:         \"\"\"         A function to calculate the total OPD from the basis vector and the         coefficients.          Returns         -------         OPD : Array, meters             The total OPD calulated from the basis vectors and coefficients.         \"\"\"         return np.dot(self.basis.T, self.coefficients)       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:          \"\"\"         Calculate and apply the appropriate phase shift to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the appropriate phase applied.         \"\"\"         return wavefront.add_opd(self.get_opd())           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies an Optical Path Difference (OPD) to the \"             f\"wavefront calculated from the basis vectors and coefficients.\") In\u00a0[\u00a0]: Copied! <pre>class AddPhase(OpticalLayer):\n\"\"\"\n    Adds an array of phase values to the wavefront.\n\n    Attributes\n    ----------\n    phase: Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    phase : Array\n\n\n    def __init__(self  : OpticalLayer,\n                 phase : Array,\n                 name  : str = 'AddPhase') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the AddPhase class.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            Array of phase values to be applied to the input wavefront. This\n            must a 0, 2 or 3 dimensional array with equal to that of the \n            wavefront at time of aplication.\n        name : str = 'AddPhase'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.phase = np.asarray(phase, dtype=float)\n\n        # Input checks\n        assert self.phase.ndim in (0, 2, 3), (\"phase must be either a scalar \"\n        \"array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Adds the phase to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the phase added.\n        \"\"\"\n        return wavefront.add_phase(self.phase)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Add an array of phase values to the wavefront.\"\n</pre> class AddPhase(OpticalLayer):     \"\"\"     Adds an array of phase values to the wavefront.      Attributes     ----------     phase: Array, radians         The Array of phase values to be applied to the input wavefront.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     phase : Array       def __init__(self  : OpticalLayer,                  phase : Array,                  name  : str = 'AddPhase') -&gt; OpticalLayer:         \"\"\"         Constructor for the AddPhase class.          Parameters         ----------         phase : Array, radians             Array of phase values to be applied to the input wavefront. This             must a 0, 2 or 3 dimensional array with equal to that of the              wavefront at time of aplication.         name : str = 'AddPhase'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.phase = np.asarray(phase, dtype=float)          # Input checks         assert self.phase.ndim in (0, 2, 3), (\"phase must be either a scalar \"         \"array, or a 2 or 3 dimensional array.\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Adds the phase to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the phase added.         \"\"\"         return wavefront.add_phase(self.phase)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name}: Add an array of phase values to the wavefront.\" In\u00a0[\u00a0]: Copied! <pre>class AddOPD(OpticalLayer):\n\"\"\"\n    Adds an Optical Path Difference (OPD) to the wavefront.\n\n    Attributes\n    ----------\n    opd : Array, meters\n        Array of OPD values to be applied to the input wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    opd : Array\n\n\n    def __init__(self : OpticalLayer,\n                 opd  : Array,\n                 name : str = 'AddOPD') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyOPD class.\n\n        Parameters\n        ----------\n        opd : float, meters\n            The Array of OPDs to be applied to the input wavefront. This must\n            a 0, 2 or 3 dimensional array with equal to that of the wavefront\n            at time of aplication.\n        name : str = 'AddOPD'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.opd = np.asarray(opd, dtype=float)\n\n        # Input checks\n        assert self.opd.ndim in (0, 2, 3), (\"opd must be either a scalar \"\n        \"array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the OPD array to the input wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the OPD added.\n        \"\"\"\n        return wavefront.add_opd(self.opd)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Add an array of Optical Path Differences (OPD) \"\n                \"to the wavefront.\")\n</pre> class AddOPD(OpticalLayer):     \"\"\"     Adds an Optical Path Difference (OPD) to the wavefront.      Attributes     ----------     opd : Array, meters         Array of OPD values to be applied to the input wavefront.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     opd : Array       def __init__(self : OpticalLayer,                  opd  : Array,                  name : str = 'AddOPD') -&gt; OpticalLayer:         \"\"\"         Constructor for the ApplyOPD class.          Parameters         ----------         opd : float, meters             The Array of OPDs to be applied to the input wavefront. This must             a 0, 2 or 3 dimensional array with equal to that of the wavefront             at time of aplication.         name : str = 'AddOPD'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.opd = np.asarray(opd, dtype=float)          # Input checks         assert self.opd.ndim in (0, 2, 3), (\"opd must be either a scalar \"         \"array, or a 2 or 3 dimensional array.\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Apply the OPD array to the input wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the OPD added.         \"\"\"         return wavefront.add_opd(self.opd)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Add an array of Optical Path Differences (OPD) \"                 \"to the wavefront.\") In\u00a0[\u00a0]: Copied! <pre>class TransmissiveOptic(OpticalLayer):\n\"\"\"\n    Represents an arbitrary transmissive optic.\n\n    Note this class does not normalise the 'transmission' between 0 and 1, but\n    simply multiplies the wavefront amplitude by the transmision array.\n\n    Attributes\n    ----------\n    transmission : Array\n        An array representing the transmission of the optic.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    transmission: Array\n\n\n    def __init__(self         : OpticalLayer,\n                 transmission : Array,\n                 name         : str = 'TransmissiveOptic') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TransmissiveOptic class.\n\n        Parameters\n        ----------\n        transmission : Array\n            The array representing the transmission of the aperture. This must\n            a 0, 2 or 3 dimensional array with equal to that of the wavefront\n            at time of aplication.\n        name : str = 'TransmissiveOptic'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.transmission = np.asarray(transmission, dtype=float)\n\n        # Input checks\n        assert self.transmission.ndim in (0, 2, 3), (\"transmission must be \"\n        \"either a scalar array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the tranmission of the optical to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the tranmission applied.\n        \"\"\"\n        return wavefront.multiply_amplitude(self.transmission)\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies an array of tranmission values to the \"\n                \"Wavefront.\")\n</pre> class TransmissiveOptic(OpticalLayer):     \"\"\"     Represents an arbitrary transmissive optic.      Note this class does not normalise the 'transmission' between 0 and 1, but     simply multiplies the wavefront amplitude by the transmision array.      Attributes     ----------     transmission : Array         An array representing the transmission of the optic.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     transmission: Array       def __init__(self         : OpticalLayer,                  transmission : Array,                  name         : str = 'TransmissiveOptic') -&gt; OpticalLayer:         \"\"\"         Constructor for the TransmissiveOptic class.          Parameters         ----------         transmission : Array             The array representing the transmission of the aperture. This must             a 0, 2 or 3 dimensional array with equal to that of the wavefront             at time of aplication.         name : str = 'TransmissiveOptic'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.transmission = np.asarray(transmission, dtype=float)          # Input checks         assert self.transmission.ndim in (0, 2, 3), (\"transmission must be \"         \"either a scalar array, or a 2 or 3 dimensional array.\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Applies the tranmission of the optical to the wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the tranmission applied.         \"\"\"         return wavefront.multiply_amplitude(self.transmission)           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies an array of tranmission values to the \"                 \"Wavefront.\") In\u00a0[\u00a0]: Copied! <pre>class ApplyBasisCLIMB(OpticalLayer):\n\"\"\"\n    Adds an array of binary phase values to the input wavefront from a set of\n    continuous basis vectors. This uses the CLIMB algorithm in order to\n    generate the binary values in a continous manner as described in the\n    paper Wong et al. 2021. The basis vectors are taken as an Optical Path\n    Difference (OPD), and applied to the phase of the wavefront. The ideal\n    wavelength parameter described the wavelength that will have a perfect\n    anti-phase relationship given by the Optical Path Difference.\n\n    Note: Many of the methods in the class still need doccumentation.\n    Note: This currently only outputs 256 pixel arrays and uses a 3x oversample,\n    therefore requiring a 768 pixel basis array.\n\n    Attributes\n    ----------\n    basis: Array\n        Arrays holding the continous pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    ideal_wavelength : Array\n        The target wavelength at which a perfect anti-phase relationship is\n        applied via the OPD.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis            : Array\n    coefficients     : Array\n    ideal_wavelength : Array\n\n\n    def __init__(self             : OpticalLayer,\n                 basis            : Array,\n                 ideal_wavelength : Array,\n                 coefficients     : Array = None,\n                 name             : str   = 'ApplyBasisCLIMB') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyBasisCLIMB class.\n\n        Parameters\n        ----------\n        basis : Array\n            Arrays holding the continous pre-calculated basis vectors. This must\n            be a 3d array of shape (nterms, npixels, npixels), with the final\n            two dimensions matching that of the wavefront at time of\n            application. This is currently required to be a nx768x768 shaped\n            array. \n        ideal_wavelength : Array\n            The target wavelength at which a perfect anti-phase relationship is\n            applied via the OPD.\n        coefficients : Array = None\n            The Array of coefficients to be applied to each basis vector. This\n            must be a one dimensional array with leading dimension equal to the\n            leading dimension of the basis vectors. Default is None which\n            initialises an array of zeros.\n        name : str = 'ApplyBasisCLIMB'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.basis            = np.asarray(basis, dtype=float)\n        self.ideal_wavelength = np.asarray(ideal_wavelength, dtype=float)\n        self.coefficients     = np.array(coefficients).astype(float) \\\n                    if coefficients is not None else np.zeros(len(self.basis))\n\n        # Inputs checks\n        assert self.basis.ndim == 3, \\\n        (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n        assert self.basis.shape[-1] == 768, \\\n        (\"Basis must have shape (n, 768, 768).\")\n        assert self.coefficients.ndim == 1 and \\\n        self.coefficients.shape[0] == self.basis.shape[0], \\\n        (\"coefficients must be a 1 dimensional array with length equal to the \"\n        \"First dimension of the basis array.\")\n        assert self.ideal_wavelength.ndim == 0, (\"ideal_wavelength must be a \"\n                                                 \"scalar array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Generates and applies the binary OPD array to the wavefront in a\n        differentiable manner.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the binary OPD applied.\n        \"\"\"\n        latent = self.get_opd(self.basis, self.coefficients)\n        binary_phase = np.pi*self.CLIMB(latent, ppsz=wavefront.npixels)\n        opd = self.phase_to_opd(binary_phase, self.ideal_wavelength)\n        return wavefront.add_opd(opd)\n\n\n    def opd_to_phase(self, opd, wavel):\n        return 2*np.pi*opd/wavel\n\n\n    def phase_to_opd(self, phase, wavel):\n        return phase*wavel/(2*np.pi)\n\n\n    def get_opd(self, basis, coefficients):\n        return np.dot(basis.T, coefficients)\n\n\n    def get_total_opd(self):\n        return self.get_opd(self.basis, self.coefficients)\n\n\n    def get_binary_phase(self):\n        latent = self.get_opd(self.basis, self.coefficients)\n        binary_phase = np.pi*self.CLIMB(latent)\n        return binary_phase\n\n\n    def lsq_params(self, img):\n        xx, yy = np.meshgrid(np.linspace(0,1,img.shape[0]),\n                             np.linspace(0,1,img.shape[1]))\n        A = np.vstack([xx.ravel(), yy.ravel(), np.ones_like(xx).ravel()]).T\n        matrix = np.linalg.inv(np.dot(A.T,A)).dot(A.T)\n        return matrix, xx, yy, A\n\n\n    def lsq(self, img):\n        matrix, _, _, _ = self.lsq_params(img)\n        return np.dot(matrix,img.ravel())\n\n\n    def area(self, img, epsilon = 1e-15):\n        a,b,c = self.lsq(img)\n        a = np.where(a==0,epsilon,a)\n        b = np.where(b==0,epsilon,b)\n        c = np.where(c==0,epsilon,c)\n        x1 = (-b-c)/(a) # don't divide by zero\n        x2 = -c/(a) # don't divide by zero\n        x1, x2 = np.min(np.array([x1,x2])), np.max(np.array([x1,x2]))\n        x1, x2 = np.max(np.array([x1,0])), np.min(np.array([x2,1]))\n\n        dummy = x1 + (-c/b)*x2-(0.5*a/b)*x2**2 - (-c/b)*x1+(0.5*a/b)*x1**2\n\n        # Set the regions where there is a defined gradient\n        dummy = np.where(dummy&gt;=0.5,dummy,1-dummy)\n\n        # Colour in regions\n        dummy = np.where(np.mean(img)&gt;=0,dummy,1-dummy)\n\n        # rescale between 0 and 1?\n        dummy = np.where(np.all(img&gt;0),1,dummy)\n        dummy = np.where(np.all(img&lt;=0),0,dummy)\n\n        # undecided region\n        dummy = np.where(np.any(img==0),np.mean(dummy&gt;0),dummy)\n\n        # rescale between 0 and 1\n        dummy = np.clip(dummy, 0, 1)\n\n        return dummy\n\n    def CLIMB(self, wf, ppsz = 256):\n        psz = ppsz * 3\n        dummy = np.array(np.split(wf, ppsz))\n        dummy = np.array(np.split(np.array(dummy), ppsz, axis = 2))\n        subarray = dummy[:,:,0,0]\n\n        flat = dummy.reshape(-1, 3, 3)\n        vmap_mask = vmap(self.area, in_axes=(0))\n\n        soft_bin = vmap_mask(flat).reshape(ppsz, ppsz)\n\n        return soft_bin\n    \n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a binary OPD to the Wavefront using the \"\n                \"CLIMB algorithm.\")\n</pre> class ApplyBasisCLIMB(OpticalLayer):     \"\"\"     Adds an array of binary phase values to the input wavefront from a set of     continuous basis vectors. This uses the CLIMB algorithm in order to     generate the binary values in a continous manner as described in the     paper Wong et al. 2021. The basis vectors are taken as an Optical Path     Difference (OPD), and applied to the phase of the wavefront. The ideal     wavelength parameter described the wavelength that will have a perfect     anti-phase relationship given by the Optical Path Difference.      Note: Many of the methods in the class still need doccumentation.     Note: This currently only outputs 256 pixel arrays and uses a 3x oversample,     therefore requiring a 768 pixel basis array.      Attributes     ----------     basis: Array         Arrays holding the continous pre-calculated basis vectors.     coefficients: Array         The Array of coefficients to be applied to each basis vector.     ideal_wavelength : Array         The target wavelength at which a perfect anti-phase relationship is         applied via the OPD.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     basis            : Array     coefficients     : Array     ideal_wavelength : Array       def __init__(self             : OpticalLayer,                  basis            : Array,                  ideal_wavelength : Array,                  coefficients     : Array = None,                  name             : str   = 'ApplyBasisCLIMB') -&gt; OpticalLayer:         \"\"\"         Constructor for the ApplyBasisCLIMB class.          Parameters         ----------         basis : Array             Arrays holding the continous pre-calculated basis vectors. This must             be a 3d array of shape (nterms, npixels, npixels), with the final             two dimensions matching that of the wavefront at time of             application. This is currently required to be a nx768x768 shaped             array.          ideal_wavelength : Array             The target wavelength at which a perfect anti-phase relationship is             applied via the OPD.         coefficients : Array = None             The Array of coefficients to be applied to each basis vector. This             must be a one dimensional array with leading dimension equal to the             leading dimension of the basis vectors. Default is None which             initialises an array of zeros.         name : str = 'ApplyBasisCLIMB'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.basis            = np.asarray(basis, dtype=float)         self.ideal_wavelength = np.asarray(ideal_wavelength, dtype=float)         self.coefficients     = np.array(coefficients).astype(float) \\                     if coefficients is not None else np.zeros(len(self.basis))          # Inputs checks         assert self.basis.ndim == 3, \\         (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")         assert self.basis.shape[-1] == 768, \\         (\"Basis must have shape (n, 768, 768).\")         assert self.coefficients.ndim == 1 and \\         self.coefficients.shape[0] == self.basis.shape[0], \\         (\"coefficients must be a 1 dimensional array with length equal to the \"         \"First dimension of the basis array.\")         assert self.ideal_wavelength.ndim == 0, (\"ideal_wavelength must be a \"                                                  \"scalar array.\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Generates and applies the binary OPD array to the wavefront in a         differentiable manner.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The wavefront with the binary OPD applied.         \"\"\"         latent = self.get_opd(self.basis, self.coefficients)         binary_phase = np.pi*self.CLIMB(latent, ppsz=wavefront.npixels)         opd = self.phase_to_opd(binary_phase, self.ideal_wavelength)         return wavefront.add_opd(opd)       def opd_to_phase(self, opd, wavel):         return 2*np.pi*opd/wavel       def phase_to_opd(self, phase, wavel):         return phase*wavel/(2*np.pi)       def get_opd(self, basis, coefficients):         return np.dot(basis.T, coefficients)       def get_total_opd(self):         return self.get_opd(self.basis, self.coefficients)       def get_binary_phase(self):         latent = self.get_opd(self.basis, self.coefficients)         binary_phase = np.pi*self.CLIMB(latent)         return binary_phase       def lsq_params(self, img):         xx, yy = np.meshgrid(np.linspace(0,1,img.shape[0]),                              np.linspace(0,1,img.shape[1]))         A = np.vstack([xx.ravel(), yy.ravel(), np.ones_like(xx).ravel()]).T         matrix = np.linalg.inv(np.dot(A.T,A)).dot(A.T)         return matrix, xx, yy, A       def lsq(self, img):         matrix, _, _, _ = self.lsq_params(img)         return np.dot(matrix,img.ravel())       def area(self, img, epsilon = 1e-15):         a,b,c = self.lsq(img)         a = np.where(a==0,epsilon,a)         b = np.where(b==0,epsilon,b)         c = np.where(c==0,epsilon,c)         x1 = (-b-c)/(a) # don't divide by zero         x2 = -c/(a) # don't divide by zero         x1, x2 = np.min(np.array([x1,x2])), np.max(np.array([x1,x2]))         x1, x2 = np.max(np.array([x1,0])), np.min(np.array([x2,1]))          dummy = x1 + (-c/b)*x2-(0.5*a/b)*x2**2 - (-c/b)*x1+(0.5*a/b)*x1**2          # Set the regions where there is a defined gradient         dummy = np.where(dummy&gt;=0.5,dummy,1-dummy)          # Colour in regions         dummy = np.where(np.mean(img)&gt;=0,dummy,1-dummy)          # rescale between 0 and 1?         dummy = np.where(np.all(img&gt;0),1,dummy)         dummy = np.where(np.all(img&lt;=0),0,dummy)          # undecided region         dummy = np.where(np.any(img==0),np.mean(dummy&gt;0),dummy)          # rescale between 0 and 1         dummy = np.clip(dummy, 0, 1)          return dummy      def CLIMB(self, wf, ppsz = 256):         psz = ppsz * 3         dummy = np.array(np.split(wf, ppsz))         dummy = np.array(np.split(np.array(dummy), ppsz, axis = 2))         subarray = dummy[:,:,0,0]          flat = dummy.reshape(-1, 3, 3)         vmap_mask = vmap(self.area, in_axes=(0))          soft_bin = vmap_mask(flat).reshape(ppsz, ppsz)          return soft_bin           def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a binary OPD to the Wavefront using the \"                 \"CLIMB algorithm.\") In\u00a0[\u00a0]: Copied! <pre>class Rotate(OpticalLayer):\n\"\"\"\n    Applies a rotation to the wavefront using interpolation methods.\n\n    Attributes\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in the clockwise direction.\n    real_imaginary : bool\n        Should the rotation be performed on the amplitude and phase array\n        or the real and imaginary arrays.\n    fourier : bool\n        Should the rotation be done using fourier methods or interpolation.\n    order : int = 1\n        The order of the interpolation to use. Only applies if fourier is\n        False. Must be 0, 1, or 3.\n    padding : int\n        The amount of padding to use if the fourier method is used.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    angle          : Array\n    real_imaginary : bool\n    fourier        : bool\n    order          : int\n    padding        : int\n\n\n    def __init__(self           : OpticalLayer,\n                 angle          : Array,\n                 real_imaginary : bool = False,\n                 fourier        : bool = False,\n                 order          : int  = 1,\n                 padding        : int  = None,\n                 name           : str  = 'Rotate') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the wavefront in the clockwise \n            direction.\n        real_imaginary : bool = False\n            Should the rotation be performed on the amplitude and phase array\n            or the real and imaginary arrays.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        order : int = 1\n            The order of the interpolation to use. Only applies if fourier is\n            False. Must be 0, 1, or 3.\n        padding : int = None\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n        name : str = 'Rotate'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.angle          = np.asarray(angle, dtype=float)\n        self.real_imaginary = bool(real_imaginary)\n        if order not in (0, 1, 3):\n            raise ValueError(\"Order must be 0, 1, or 3.\")\n        self.order = int(order)\n        self.fourier        = bool(fourier)\n        self.padding = padding if padding is None else int(padding)\n        assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the rotation to a wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The rotated wavefront.\n        \"\"\"\n        args = [self.angle, self.real_imaginary, self.fourier, self.order]\n        args += [self.padding] if self.padding is not None else []\n        return wavefront.rotate(*args)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angle = convert_angular(self.angle, 'radians', angular_units)\n        \n        if self.fourier:\n            method = f\"a Fourier method with padding of {self.padding}\"\n        else:\n            method = \"an Interpolation method of order 1\"\n\n        if self.real_imaginary:\n            wf_type = \"real and imaginary arrays\"\n        else:\n            wf_type = \"amplitude and phase arrays\"\n\n        return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n                f\"rotation to the wavefront {wf_type} using {method}.\")\n</pre> class Rotate(OpticalLayer):     \"\"\"     Applies a rotation to the wavefront using interpolation methods.      Attributes     ----------     angle : Array, radians         The angle by which to rotate the wavefront in the clockwise direction.     real_imaginary : bool         Should the rotation be performed on the amplitude and phase array         or the real and imaginary arrays.     fourier : bool         Should the rotation be done using fourier methods or interpolation.     order : int = 1         The order of the interpolation to use. Only applies if fourier is         False. Must be 0, 1, or 3.     padding : int         The amount of padding to use if the fourier method is used.     name : str         The name of the layer, which is used to index the layers dictionary.     \"\"\"     angle          : Array     real_imaginary : bool     fourier        : bool     order          : int     padding        : int       def __init__(self           : OpticalLayer,                  angle          : Array,                  real_imaginary : bool = False,                  fourier        : bool = False,                  order          : int  = 1,                  padding        : int  = None,                  name           : str  = 'Rotate') -&gt; OpticalLayer:         \"\"\"         Constructor for the Rotate class.          Parameters         ----------         angle: float, radians             The angle by which to rotate the wavefront in the clockwise              direction.         real_imaginary : bool = False             Should the rotation be performed on the amplitude and phase array             or the real and imaginary arrays.         fourier : bool = False             Should the fourier rotation method be used (True), or regular             interpolation method be used (False).         order : int = 1             The order of the interpolation to use. Only applies if fourier is             False. Must be 0, 1, or 3.         padding : int = None             The amount of fourier padding to use. Only applies if fourier is             True.         name : str = 'Rotate'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name)         self.angle          = np.asarray(angle, dtype=float)         self.real_imaginary = bool(real_imaginary)         if order not in (0, 1, 3):             raise ValueError(\"Order must be 0, 1, or 3.\")         self.order = int(order)         self.fourier        = bool(fourier)         self.padding = padding if padding is None else int(padding)         assert self.angle.ndim == 0, (\"angle must be scalar array.\")       def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Applies the rotation to a wavefront.          Parameters         ----------         wavefront : Wavefront             The wavefront to operate on.          Returns         -------         wavefront : Wavefront             The rotated wavefront.         \"\"\"         args = [self.angle, self.real_imaginary, self.fourier, self.order]         args += [self.padding] if self.padding is not None else []         return wavefront.rotate(*args)       def summary(self            : OpticalLayer,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         angle = convert_angular(self.angle, 'radians', angular_units)                  if self.fourier:             method = f\"a Fourier method with padding of {self.padding}\"         else:             method = \"an Interpolation method of order 1\"          if self.real_imaginary:             wf_type = \"real and imaginary arrays\"         else:             wf_type = \"amplitude and phase arrays\"          return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"                 f\"rotation to the wavefront {wf_type} using {method}.\")"},{"location":"dLux/propagators/","title":"Propagators","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom equinox import tree_at\nfrom abc import ABC, abstractmethod\nfrom dLux.utils.coordinates import get_pixel_positions\nfrom dLux.utils.helpers import two_image_plot\nfrom dLux.utils.units import convert_angular, convert_cartesian\nimport dLux\n\n\n__all__ = [\"CartesianMFT\", \"AngularMFT\", \"CartesianFFT\", \"AngularFFT\",\n           \"CartesianFresnel\"]\n\n\nArray = np.ndarray\n</pre> from __future__ import annotations import jax.numpy as np from equinox import tree_at from abc import ABC, abstractmethod from dLux.utils.coordinates import get_pixel_positions from dLux.utils.helpers import two_image_plot from dLux.utils.units import convert_angular, convert_cartesian import dLux   __all__ = [\"CartesianMFT\", \"AngularMFT\", \"CartesianFFT\", \"AngularFFT\",            \"CartesianFresnel\"]   Array = np.ndarray  In\u00a0[\u00a0]: Copied! <pre>class Propagator(dLux.optics.OpticalLayer, ABC):\n\"\"\"\n    An abstract class to store the various properties of the propagation of\n    some wavefront.\n\n    Attributes\n    ----------\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n    inverse : bool\n\n\n    def __init__(self    : Propagator,\n                 inverse : bool = False,\n                 **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for the Propagator.\n\n        Parameters\n        ----------\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        \"\"\"\n        super().__init__(**kwargs)\n        assert isinstance(inverse, bool), (\"inverse must be a boolean.\")\n        self.inverse = bool(inverse)\n\n\n    @abstractmethod\n    def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array: # pragma: no cover\n\"\"\"\n        Performs the propagation as a directional wrapper to the fourier methods\n        of the class.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The `Wavefront to propagate.\n\n        Returns\n        -------\n        field : Array\n            The normalised electric field of the wavefront after propagation.\n        \"\"\"\n        return\n\n\nclass VariableSamplingPropagator(Propagator, ABC):\n\"\"\"\n    A propagator that implements the Soummer et. al. 2007 MFT algorithm\n    allowing variable sampling in the outuput plane rather than the fixed\n    sampling enforced by Fast Fourier Transforms(FFTs).\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel or radians/pixel\n        The pixel scale in the output plane, measured in meters or radians per\n        pixel for Cartesian or Angular Wavefront respectively.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n    npixels_out     : int\n    pixel_scale_out : Array\n    shift           : Array\n    pixel_shift     : bool\n\n    def __init__(self            : Propagator,\n                 pixel_scale_out : Array,\n                 npixels_out     : int,\n                 shift           : Array = np.array([0., 0.]),\n                 pixel_shift     : bool  = False,\n                 **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for VariableSampling propagators.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels in the output plane.\n        pixel_scale_out : Array, meters/pixel or radians/pixel\n            The pixel scale in the output plane, measured in meters or radians\n            per pixel for Cartesian or Angular Wavefront respectively.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians). =\n            True interprets the shift value in pixel units.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.pixel_scale_out = np.asarray(pixel_scale_out, dtype=float)\n        self.npixels_out     = int(npixels_out)\n        self.shift           = np.asarray(shift, dtype=float)\n        self.pixel_shift     = bool(pixel_shift)\n        assert self.pixel_scale_out.ndim == 0, \\\n        (\"pixel_scale_out must be a scalar.\")\n        assert self.shift.shape == (2,), \\\n        (\"shift must be an array of shape (2,) ie (x, y).\")\n\n\n    @abstractmethod\n    def get_nfringes(self : Propagator, wavefront : Wavefront) -&gt; Array: # pragma: no cover\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        return\n\n\n    def get_shift(self : Propagator) -&gt; Array:\n\"\"\"\n        Accessor for the shift parameter. Converts to units of pixels if the\n        pixel_shift parameter is True.\n\n        Returns\n        -------\n        shift : Array\n            The (x, y) shift to apply to the wavefront throughout the\n            propagation.\n        \"\"\"\n        return self.shift if self.pixel_shift else \\\n               self.shift / self.pixel_scale_out\n\n\n    def _generate_transfer_matrices(self         : Propagator,\n                                    pixel_offset : Array,\n                                    pixel_scales : tuple,\n                                    npixels      : tuple) -&gt; Array:\n\"\"\"\n        The transfer matrices for the fourier transforms.\n\n        Parameters\n        ----------\n        pixel_offset : Array, pixels\n            The offset in units of pixels.\n        pixel_scales : tuple\n            The pixel_scale values at the input and output planes respectively.\n        npixels : tuple\n            The number of pixels at the input and output planes respectively.\n\n        Returns\n        -------\n        transfer_matrices : Array\n            The transfer matrices.\n        \"\"\"\n        input_scale, output_scale = pixel_scales\n        pixels_input, npixels_out = npixels\n        sign = 1 if self.inverse else -1\n\n        input_coordinates = get_pixel_positions(pixels_input, input_scale,\n                                                    pixel_offset * input_scale)\n\n        output_coordinates = get_pixel_positions(npixels_out, output_scale,\n                                                    pixel_offset * output_scale)\n\n        input_to_output = np.outer(input_coordinates, output_coordinates)\n\n        return np.exp(-2. * sign * np.pi * 1j * input_to_output)\n\n\n    def propagate(self      : Propagator,\n                  wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Matrix Fourier Transform.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        field : Array\n            The normalised electric field phasor after the propagation.\n        \"\"\"\n        field = wavefront.phasor\n        nfields = wavefront.nfields\n\n        input_scale = 1.0 / wavefront.npixels\n        output_scale = self.get_nfringes(wavefront) / self.npixels_out\n        npixels_in = wavefront.npixels\n        npixels_out = self.npixels_out\n        x_offset, y_offset = self.get_shift()\n\n        x_matrix = np.tile(self._generate_transfer_matrices(\n                    x_offset, (input_scale, output_scale),\n                    (npixels_in, npixels_out)), (nfields, 1, 1))\n\n        y_matrix = np.tile(self._generate_transfer_matrices(\n                    y_offset, (input_scale, output_scale),\n                    (npixels_in, npixels_out)).T, (nfields, 1, 1))\n\n        output_field = (y_matrix @ field) @ x_matrix\n\n        normalising_factor = np.exp(np.log(self.get_nfringes(wavefront)) - \\\n                            (np.log(npixels_in) + np.log(npixels_out)))\n\n        return output_field * normalising_factor\n\n\n    def __call__(self : Propagator, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Propagates the `Wavefront`.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the optical layer applied.\n        \"\"\"\n        phasor = self.propagate(wavefront)\n\n        new_amplitude  = np.abs(phasor)\n        new_phase      = np.angle(phasor)\n        new_plane_type = dLux.PlaneType.Pupil if self.inverse else \\\n                         dLux.PlaneType.Focal\n\n        return tree_at(lambda wavefront: \\\n                       (wavefront.amplitude,\n                        wavefront.phase,\n                        wavefront.plane_type,\n                        wavefront.pixel_scale),\n                        wavefront,\n                       (new_amplitude,\n                        new_phase,\n                        new_plane_type,\n                        self.pixel_scale_out))\n\n\nclass FixedSamplingPropagator(Propagator, ABC):\n\"\"\"\n    A propagator that implements the Fast Fourier Transform algorithm. This\n    algorith has a fixed sampling in the output plane, at one fringe per pixel.\n    Note the size of the 'fringe' in this context is similar to an optical\n    fringe in that its angular size is calcualted via wavelength/wavefront\n    diameter.\n\n    These propagators are implemented using the jax.numpy.fft package, with the\n    appropriate normalisations and pixel sizes tracked for optical propagation.\n\n    Attributes\n    ----------\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self : Propagator, **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for FixedSampling propagators.\n        \"\"\"\n        super().__init__(**kwargs)\n\n\n    @abstractmethod\n    def get_pixel_scale_out(self     : Propagator,\n                           wavefront : Wavefront) -&gt; Array: # pragma: no cover\n\"\"\"\n        Calculates the pixel scale in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront that is being propagated.\n\n        Returns\n        -------\n        pixel_scale : Array, meters/pixel or radians/pixel\n            The pixel scale in the output plane, measured in meters or radians\n            per pixel for Cartesian or Angular Wavefront respectively.\n        \"\"\"\n        return\n\n\n    def propagate(self       : Propagator,\n                   wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Propagates the wavefront by perfroming a Fast Fourier Transform.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n\n        Returns\n        -------\n        field : Array\n            The normalised electric field phasor after the propagation.\n        \"\"\"\n        if self.inverse:\n            output_field = np.fft.fft2(np.fft.ifftshift(wavefront.phasor))\n        else:\n            output_field = np.fft.fftshift(np.fft.ifft2(wavefront.phasor))\n\n        normalising_factor = self.inverse / wavefront.npixels + \\\n                             (1 - self.inverse) * wavefront.npixels\n\n        return output_field * normalising_factor\n\n\n    def __call__(self : Propagator, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Propagates the `Wavefront`.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the optical layer applied.\n        \"\"\"\n        phasor = self.propagate(wavefront)\n\n        new_amplitude  = np.abs(phasor)\n        new_phase      = np.angle(phasor)\n        new_plane_type = dLux.PlaneType.Pupil if self.inverse else \\\n                         dLux.PlaneType.Focal\n\n        return tree_at(lambda wavefront: \\\n                       (wavefront.amplitude,\n                        wavefront.phase,\n                        wavefront.plane_type,\n                        wavefront.pixel_scale),\n                        wavefront,\n                       (new_amplitude,\n                        new_phase,\n                        new_plane_type,\n                        self.get_pixel_scale_out(wavefront)))\n\n\nclass CartesianPropagator(Propagator, ABC):\n\"\"\"\n    A propagator class to store the focal_length parameter for cartesian\n    propagations defined by a physical propagation distance defined as\n    focal_length.\n\n    Attributes\n    ----------\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n    focal_length : Array\n\n\n    def __init__(self         : Propagator,\n                 focal_length : Array,\n                 **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for Cartesian propagators.\n\n        Parameters\n        ----------\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.focal_length = np.asarray(focal_length, dtype=float)\n        assert self.focal_length.ndim == 0, (\"focal_length must a scalar.\")\n\n\nclass AngularPropagator(Propagator, ABC):\n\"\"\"\n    A simple propagator class designed to be inhereited by propagators that\n    operate on wavefronts defined in angular units in focal planes.\n\n    Attributes\n    ----------\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self : Propagator, **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for Angular propagators.\n        \"\"\"\n        super().__init__(**kwargs)\n\n\nclass FarFieldFresnel(Propagator, ABC):\n\"\"\"\n    A propagator class to store the propagation_shift parameter required for\n    Far-Field fresnel propagations. These classes implement algorithms that use\n    quadratic phase factors to better represent out-of-plane behaviour of\n    wavefronts, close to the focal plane.\n\n    Attributes\n    ----------\n    propagation_shift : Array, meters\n        The shift in the propagation distance of the wavefront.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n    propagation_shift : Array\n\n\n    def __init__(self, propagation_shift, **kwargs) -&gt; Propagator:\n\"\"\"\n        Constructor for FarFieldFresnel propagators.\n\n        Parameters\n        ----------\n        propagation_shift : Array, meters\n            The shift in the propagation distance of the wavefront.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.propagation_shift  = np.asarray(propagation_shift,  dtype=float)\n        assert self.propagation_shift.ndim == 0, \\\n        (\"propagation_shift must be scalar array.\")\n</pre> class Propagator(dLux.optics.OpticalLayer, ABC):     \"\"\"     An abstract class to store the various properties of the propagation of     some wavefront.      Attributes     ----------     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"     inverse : bool       def __init__(self    : Propagator,                  inverse : bool = False,                  **kwargs) -&gt; Propagator:         \"\"\"         Constructor for the Propagator.          Parameters         ----------         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         \"\"\"         super().__init__(**kwargs)         assert isinstance(inverse, bool), (\"inverse must be a boolean.\")         self.inverse = bool(inverse)       @abstractmethod     def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array: # pragma: no cover         \"\"\"         Performs the propagation as a directional wrapper to the fourier methods         of the class.          Parameters         ----------         wavefront : Wavefront             The `Wavefront to propagate.          Returns         -------         field : Array             The normalised electric field of the wavefront after propagation.         \"\"\"         return   class VariableSamplingPropagator(Propagator, ABC):     \"\"\"     A propagator that implements the Soummer et. al. 2007 MFT algorithm     allowing variable sampling in the outuput plane rather than the fixed     sampling enforced by Fast Fourier Transforms(FFTs).      Attributes     ----------     npixels_out : int         The number of pixels in the output plane.     pixel_scale_out : Array, meters/pixel or radians/pixel         The pixel scale in the output plane, measured in meters or radians per         pixel for Cartesian or Angular Wavefront respectively.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel_shift : bool         Should the shift value be considered in units of pixels, or in the         physical units of the output plane (ie pixels or meters, radians). True         interprets the shift value in pixel units.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"     npixels_out     : int     pixel_scale_out : Array     shift           : Array     pixel_shift     : bool      def __init__(self            : Propagator,                  pixel_scale_out : Array,                  npixels_out     : int,                  shift           : Array = np.array([0., 0.]),                  pixel_shift     : bool  = False,                  **kwargs) -&gt; Propagator:         \"\"\"         Constructor for VariableSampling propagators.          Parameters         ----------         npixels_out : int             The number of pixels in the output plane.         pixel_scale_out : Array, meters/pixel or radians/pixel             The pixel scale in the output plane, measured in meters or radians             per pixel for Cartesian or Angular Wavefront respectively.         shift : Array = np.array([0., 0.])             The (x, y) shift to apply to the wavefront in the output plane.         pixel_shift : bool = False             Should the shift value be considered in units of pixel, or in the             physical units of the output plane (ie pixels or meters, radians). =             True interprets the shift value in pixel units.         \"\"\"         super().__init__(**kwargs)         self.pixel_scale_out = np.asarray(pixel_scale_out, dtype=float)         self.npixels_out     = int(npixels_out)         self.shift           = np.asarray(shift, dtype=float)         self.pixel_shift     = bool(pixel_shift)         assert self.pixel_scale_out.ndim == 0, \\         (\"pixel_scale_out must be a scalar.\")         assert self.shift.shape == (2,), \\         (\"shift must be an array of shape (2,) ie (x, y).\")       @abstractmethod     def get_nfringes(self : Propagator, wavefront : Wavefront) -&gt; Array: # pragma: no cover         \"\"\"         The number of diffraction fringes in the output plane.          Parameters         ----------         wavefront : Wavefront             The wavefront being propagated.          Returns         -------         fringes : Array             The number of diffraction fringes in the output plane.         \"\"\"         return       def get_shift(self : Propagator) -&gt; Array:         \"\"\"         Accessor for the shift parameter. Converts to units of pixels if the         pixel_shift parameter is True.          Returns         -------         shift : Array             The (x, y) shift to apply to the wavefront throughout the             propagation.         \"\"\"         return self.shift if self.pixel_shift else \\                self.shift / self.pixel_scale_out       def _generate_transfer_matrices(self         : Propagator,                                     pixel_offset : Array,                                     pixel_scales : tuple,                                     npixels      : tuple) -&gt; Array:         \"\"\"         The transfer matrices for the fourier transforms.          Parameters         ----------         pixel_offset : Array, pixels             The offset in units of pixels.         pixel_scales : tuple             The pixel_scale values at the input and output planes respectively.         npixels : tuple             The number of pixels at the input and output planes respectively.          Returns         -------         transfer_matrices : Array             The transfer matrices.         \"\"\"         input_scale, output_scale = pixel_scales         pixels_input, npixels_out = npixels         sign = 1 if self.inverse else -1          input_coordinates = get_pixel_positions(pixels_input, input_scale,                                                     pixel_offset * input_scale)          output_coordinates = get_pixel_positions(npixels_out, output_scale,                                                     pixel_offset * output_scale)          input_to_output = np.outer(input_coordinates, output_coordinates)          return np.exp(-2. * sign * np.pi * 1j * input_to_output)       def propagate(self      : Propagator,                   wavefront : Wavefront) -&gt; Array:         \"\"\"         Propagates the wavefront from the input plane to the output plane using         a Matrix Fourier Transform.          Parameters         ----------         wavefront : Wavefront             The wavefront being propagated.          Returns         -------         field : Array             The normalised electric field phasor after the propagation.         \"\"\"         field = wavefront.phasor         nfields = wavefront.nfields          input_scale = 1.0 / wavefront.npixels         output_scale = self.get_nfringes(wavefront) / self.npixels_out         npixels_in = wavefront.npixels         npixels_out = self.npixels_out         x_offset, y_offset = self.get_shift()          x_matrix = np.tile(self._generate_transfer_matrices(                     x_offset, (input_scale, output_scale),                     (npixels_in, npixels_out)), (nfields, 1, 1))          y_matrix = np.tile(self._generate_transfer_matrices(                     y_offset, (input_scale, output_scale),                     (npixels_in, npixels_out)).T, (nfields, 1, 1))          output_field = (y_matrix @ field) @ x_matrix          normalising_factor = np.exp(np.log(self.get_nfringes(wavefront)) - \\                             (np.log(npixels_in) + np.log(npixels_out)))          return output_field * normalising_factor       def __call__(self : Propagator, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Propagates the `Wavefront`.          Parameters         ----------         wavefront : Wavefront             The wavefront to propagate.          Returns         -------         wavefront : Wavefront             The wavefront with the optical layer applied.         \"\"\"         phasor = self.propagate(wavefront)          new_amplitude  = np.abs(phasor)         new_phase      = np.angle(phasor)         new_plane_type = dLux.PlaneType.Pupil if self.inverse else \\                          dLux.PlaneType.Focal          return tree_at(lambda wavefront: \\                        (wavefront.amplitude,                         wavefront.phase,                         wavefront.plane_type,                         wavefront.pixel_scale),                         wavefront,                        (new_amplitude,                         new_phase,                         new_plane_type,                         self.pixel_scale_out))   class FixedSamplingPropagator(Propagator, ABC):     \"\"\"     A propagator that implements the Fast Fourier Transform algorithm. This     algorith has a fixed sampling in the output plane, at one fringe per pixel.     Note the size of the 'fringe' in this context is similar to an optical     fringe in that its angular size is calcualted via wavelength/wavefront     diameter.      These propagators are implemented using the jax.numpy.fft package, with the     appropriate normalisations and pixel sizes tracked for optical propagation.      Attributes     ----------     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"       def __init__(self : Propagator, **kwargs) -&gt; Propagator:         \"\"\"         Constructor for FixedSampling propagators.         \"\"\"         super().__init__(**kwargs)       @abstractmethod     def get_pixel_scale_out(self     : Propagator,                            wavefront : Wavefront) -&gt; Array: # pragma: no cover         \"\"\"         Calculates the pixel scale in the output plane.          Parameters         ----------         wavefront : Wavefront             The wavefront that is being propagated.          Returns         -------         pixel_scale : Array, meters/pixel or radians/pixel             The pixel scale in the output plane, measured in meters or radians             per pixel for Cartesian or Angular Wavefront respectively.         \"\"\"         return       def propagate(self       : Propagator,                    wavefront : Wavefront) -&gt; Array:         \"\"\"         Propagates the wavefront by perfroming a Fast Fourier Transform.          Parameters         ----------         wavefront : Wavefront             The wavefront to propagate.          Returns         -------         field : Array             The normalised electric field phasor after the propagation.         \"\"\"         if self.inverse:             output_field = np.fft.fft2(np.fft.ifftshift(wavefront.phasor))         else:             output_field = np.fft.fftshift(np.fft.ifft2(wavefront.phasor))          normalising_factor = self.inverse / wavefront.npixels + \\                              (1 - self.inverse) * wavefront.npixels          return output_field * normalising_factor       def __call__(self : Propagator, wavefront : Wavefront) -&gt; Wavefront:         \"\"\"         Propagates the `Wavefront`.          Parameters         ----------         wavefront : Wavefront             The wavefront to propagate.          Returns         -------         wavefront : Wavefront             The wavefront with the optical layer applied.         \"\"\"         phasor = self.propagate(wavefront)          new_amplitude  = np.abs(phasor)         new_phase      = np.angle(phasor)         new_plane_type = dLux.PlaneType.Pupil if self.inverse else \\                          dLux.PlaneType.Focal          return tree_at(lambda wavefront: \\                        (wavefront.amplitude,                         wavefront.phase,                         wavefront.plane_type,                         wavefront.pixel_scale),                         wavefront,                        (new_amplitude,                         new_phase,                         new_plane_type,                         self.get_pixel_scale_out(wavefront)))   class CartesianPropagator(Propagator, ABC):     \"\"\"     A propagator class to store the focal_length parameter for cartesian     propagations defined by a physical propagation distance defined as     focal_length.      Attributes     ----------     focal_length : Array, meters         The focal_length of the lens/mirror this propagator represents.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"     focal_length : Array       def __init__(self         : Propagator,                  focal_length : Array,                  **kwargs) -&gt; Propagator:         \"\"\"         Constructor for Cartesian propagators.          Parameters         ----------         focal_length : Array, meters             The focal_length of the lens/mirror this propagator represents.         \"\"\"         super().__init__(**kwargs)         self.focal_length = np.asarray(focal_length, dtype=float)         assert self.focal_length.ndim == 0, (\"focal_length must a scalar.\")   class AngularPropagator(Propagator, ABC):     \"\"\"     A simple propagator class designed to be inhereited by propagators that     operate on wavefronts defined in angular units in focal planes.      Attributes     ----------     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"       def __init__(self : Propagator, **kwargs) -&gt; Propagator:         \"\"\"         Constructor for Angular propagators.         \"\"\"         super().__init__(**kwargs)   class FarFieldFresnel(Propagator, ABC):     \"\"\"     A propagator class to store the propagation_shift parameter required for     Far-Field fresnel propagations. These classes implement algorithms that use     quadratic phase factors to better represent out-of-plane behaviour of     wavefronts, close to the focal plane.      Attributes     ----------     propagation_shift : Array, meters         The shift in the propagation distance of the wavefront.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"     propagation_shift : Array       def __init__(self, propagation_shift, **kwargs) -&gt; Propagator:         \"\"\"         Constructor for FarFieldFresnel propagators.          Parameters         ----------         propagation_shift : Array, meters             The shift in the propagation distance of the wavefront.         \"\"\"         super().__init__(**kwargs)         self.propagation_shift  = np.asarray(propagation_shift,  dtype=float)         assert self.propagation_shift.ndim == 0, \\         (\"propagation_shift must be scalar array.\")  In\u00a0[\u00a0]: Copied! <pre>class CartesianMFT(CartesianPropagator, VariableSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in cartesian units (ie meters/pixel), with a variable output\n    sampling in that plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self            : Propagator,\n                 npixels_out     : int,\n                 pixel_scale_out : Array,\n                 focal_length    : Array,\n                 inverse         : bool  = False,\n                 shift           : Array = np.array([0., 0.]),\n                 pixel_shift     : bool  = False,\n                 name            : str   = 'CartesianMFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels in the output plane.\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel.\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'CartesianMFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name            = name,\n                         inverse         = inverse,\n                         shift           = shift,\n                         pixel_shift     = pixel_shift,\n                         focal_length    = focal_length,\n                         pixel_scale_out = pixel_scale_out,\n                         npixels_out     = npixels_out)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        size_in = wavefront.diameter\n        size_out = self.pixel_scale_out * self.npixels_out\n        return size_in * size_out / self.focal_length / wavefront.wavelength\n    \n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                        cartesian_units)\n        focal_length = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n        shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n            if not self.pixel_shift else self.shift\n\n        prop_string = (f\"Propagates the Wavefront {focal_length} \"\n                       f\"{cartesian_units} to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n        \n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  \"using a 2-sided MFT.\"\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + \"using a 2-sided MFT.\"\n        \n\nclass AngularMFT(AngularPropagator, VariableSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate wavefronts, with pixel scale units\n    defined in meters per pixel in pupil planes and radians/pixel in focal\n    planes, with a variable output sampling in the output plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel or radians/pixel\n        The pixel scale in the output plane, measured in meters per pixel in\n        pupil plane and radians per pixel in focal planes.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self            : Propagator,\n                 npixels_out     : int,\n                 pixel_scale_out : Array,\n                 inverse         : bool  = False,\n                 shift           : Array = np.array([0., 0.]),\n                 pixel_shift     : bool  = False,\n                 name            : str   = 'AngularMFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels in the output plane.\n        pixel_scale_out : Array, radians/pixel, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel in\n            pupil planes and radians per pixel in focal planes.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'AngularMFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name            = name,\n                         inverse         = inverse,\n                         shift           = shift,\n                         pixel_shift     = pixel_shift,\n                         pixel_scale_out = pixel_scale_out,\n                         npixels_out     = npixels_out)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        fringe_size = wavefront.wavelength / wavefront.diameter\n        detector_size = self.npixels_out * self.pixel_scale_out\n        return detector_size / fringe_size\n    \n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n            \n        pixel_scale = convert_angular(self.pixel_scale_out, 'radians', \n                                        angular_units)\n        shift = convert_angular(self.shift, 'radians', angular_units) \\\n            if not self.pixel_shift else self.shift\n\n        prop_string = (f\"Propagates the Wavefront to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {angular_units} \")\n        \n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  \"using a 2-sided MFT.\"\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {angular_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + \"using a 2-sided MFT.\"\n\n\nclass CartesianFFT(CartesianPropagator, FixedSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel.\n\n    Attributes\n    ----------\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self         : Propagator,\n                 focal_length : Array,\n                 inverse      : bool = False,\n                 name         : str  = 'CartesianFFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        name : str = 'CartesianFFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name         = name,\n                         inverse      = inverse,\n                         focal_length = focal_length)\n\n\n    def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The pixel scale in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The `Wavefront` that is being propagted.\n\n        Returns\n        -------\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane.\n        \"\"\"\n        return self.focal_length * wavefront.wavelength / wavefront.diameter\n    \n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n        focal_length = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n\n        return (f\"Propagates the Wavefront {focal_length} {cartesian_units} to \"\n                f\"a {plane_out} plane using a FFT.\")\n\n\nclass AngularFFT(AngularPropagator, FixedSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel\n    in pupil planes and radians/pixel in focal planes.\n\n    Attributes\n    ----------\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self    : Propagator,\n                 inverse : bool = False,\n                 name    : str = 'AngularFFT') -&gt; Propagator:\n\"\"\"\n        Constructor for the AngularFFT propagator.\n\n        Parameters\n        ----------\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        name : str = 'AngularFFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name = name, inverse = inverse)\n\n\n    def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Calculate the pixel scale in the output plane in units of radians per\n        pixel.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront that is being propagated.\n\n        Returns\n        -------\n        pixel_scale_out : Array, radians/pixel\n            The pixel scale in the output plane.\n        \"\"\"\n        return wavefront.wavelength / wavefront.diameter\n    \n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        return f\"Propagates the Wavefront to a {plane_out} plane using a FFT.\"\n\n\nclass CartesianFresnel(FarFieldFresnel, CartesianMFT):\n\"\"\"\n    A propagator class to for Far-Field fresnel propagations. This classes\n    implements algorithms that use quadratic phase factors to better represent\n    out-of-plane behaviour of wavefronts, close to the focal plane. This class\n    is designed to work on Cartesian wavefronts, ie pixel units are in\n    meters/pixel in the output plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    propagation_shift : Array, meters\n        The shift in the propagation distance of the wavefront.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self              : Propagator,\n                 npixels_out       : Array,\n                 pixel_scale_out   : Array,\n                 focal_length      : Array,\n                 propagation_shift : Array,\n                 inverse           : bool  = False,\n                 shift             : Array = np.array([0., 0.]),\n                 pixel_shift       : bool  = False,\n                 name              : str   = 'CartesianFresnel') -&gt; Propagator:\n\"\"\"\n        Constructor for the CartesianFresnel propagator\n\n        Parameters\n        ----------\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel.\n        npixels_out : int\n            The number of pixels in the output plane.\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        propagation_shift : Array, meters\n            The shift in the propagation distance of the wavefront.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'CartesianFresnel'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name               = name,\n                         inverse            = inverse,\n                         shift              = shift,\n                         pixel_shift        = pixel_shift,\n                         focal_length       = focal_length,\n                         pixel_scale_out    = pixel_scale_out,\n                         npixels_out        = npixels_out,\n                         propagation_shift  = propagation_shift)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        propagation_distance = self.focal_length + self.propagation_shift\n        size_in = wavefront.diameter\n        size_out = self.pixel_scale_out * self.npixels_out\n        return size_in * size_out / wavefront.wavelength / propagation_distance\n\n\n    def quadratic_phase(self          : Propagator,\n                        x_coordinates : Array,\n                        y_coordinates : Array,\n                        wavelength    : Array,\n                        distance      : Array) -&gt; Array:\n\"\"\"\n        A convinience function for calculating quadratic phase factors.\n\n        Parameters\n        ----------\n        x_coordinates : Array\n            The x coordinates of the pixels in meters. This will be different\n            in the plane of propagation and the initial plane.\n        y_coordinates : Array\n            The y coordinates of the pixels in meters. This will be different\n            in the plane of propagation and the initial plane.\n        wavelength : Array, meters\n            The wavelength of the wavefront.\n        distance : Array, meters\n            The distance that is to be propagated in meters.\n\n        Returns\n        -------\n        quadratic_phase : Array\n            A set of phase factors that are useful in optical calculations.\n        \"\"\"\n        wavenumber = 2 * np.pi / wavelength\n        radial_coordinates = np.hypot(x_coordinates, y_coordinates)\n        return np.exp(0.5j * wavenumber * radial_coordinates ** 2 / distance)\n\n\n    def transfer_function(self      : Propagator,\n                          wavefront : Wavefront,\n                          distance  : Array) -&gt; Array:\n\"\"\"\n        The Optical Transfer Function defining the phase evolution of the\n        wavefront when propagating to a non-conjugate plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n        distance : Array, meters\n            The distance that is being propagated in meters.\n\n        Returns\n        -------\n        field : Array\n            The field that represents the optical transfer.\n        \"\"\"\n        return np.exp(1.0j * wavefront.wavenumber * distance)\n\n\n    def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Matrix Fourier Transform.\n\n        TODO: Set plane type to intermediate\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n\n        Returns\n        -------\n        field : Array\n            The normalised electric field phasor after the propagation.\n        \"\"\"\n        # See gihub issue #52\n        offsets = self.get_shift()\n\n        input_positions = wavefront.pixel_coordinates\n        output_positions = get_pixel_positions(\n                            (self.npixels_out, self.npixels_out), \n                            (self.pixel_scale_out, self.pixel_scale_out))\n\n        propagation_distance = self.focal_length + self.propagation_shift\n\n        field = wavefront.phasor\n        field *= self.quadratic_phase(*input_positions,\n            wavefront.wavelength, - self.focal_length)\n        field *= self.quadratic_phase(*input_positions,\n            wavefront.wavelength, propagation_distance)\n        wavefront = wavefront.set_phasor(np.abs(field), np.angle(field))\n\n        field = super().propagate(wavefront)\n        field *= self.transfer_function(wavefront, propagation_distance)\n        field *= self.quadratic_phase(*output_positions,\n            wavefront.wavelength, propagation_distance)\n        return field\n    \n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                        cartesian_units)\n        prop_distance = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n        defocus = convert_cartesian(self.propagation_shift, 'meters', \n                                        cartesian_units)\n        shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n            if not self.pixel_shift else self.shift\n\n\n        prop_string = (f\"Propagates the Wavefront {prop_distance} \"\n                       f\"{cartesian_units} to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n        \n        defocus_string = (f\"with a defocus of {defocus} {cartesian_units} \"\n                           \"using a 2-sided MFT.\")\n        \n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  defocus_string\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + defocus_string\n\n\n# TODO: Implement eventually\n# class AngularFresnel(FarFieldFresnel, AngularMFT):\n#     \"\"\"\n#     Propagates an AngularWavefront in the Fresnel approximation.\n\n#     Attributes\n#     ----------\n#     \"\"\"\n#     pass\n</pre> class CartesianMFT(CartesianPropagator, VariableSamplingPropagator):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane that is     defined in cartesian units (ie meters/pixel), with a variable output     sampling in that plane.      Attributes     ----------     npixels_out : int         The number of pixels in the output plane.     pixel_scale_out : Array, meters/pixel         The pixel scale in the output plane, measured in meters per pixel.     focal_length : Array, meters         The focal_length of the lens/mirror this propagator represents.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel_shift : bool         Should the shift value be considered in units of pixels, or in the         physical units of the output plane (ie pixels or meters, radians). True         interprets the shift value in pixel units.     name : str         The name for this propagator.     \"\"\"       def __init__(self            : Propagator,                  npixels_out     : int,                  pixel_scale_out : Array,                  focal_length    : Array,                  inverse         : bool  = False,                  shift           : Array = np.array([0., 0.]),                  pixel_shift     : bool  = False,                  name            : str   = 'CartesianMFT') -&gt; Propagator:         \"\"\"         Parameters         ----------         npixels_out : int             The number of pixels in the output plane.         pixel_scale_out : Array, meters/pixel             The pixel scale in the output plane, measured in meters per pixel.         focal_length : Array, meters             The focal_length of the lens/mirror this propagator represents.         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         shift : Array = np.array([0., 0.])             The (x, y) shift to apply to the wavefront in the output plane.         pixel_shift : bool = False             Should the shift value be considered in units of pixel, or in the             physical units of the output plane (ie pixels or meters, radians).         name : str = 'CartesianMFT'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name            = name,                          inverse         = inverse,                          shift           = shift,                          pixel_shift     = pixel_shift,                          focal_length    = focal_length,                          pixel_scale_out = pixel_scale_out,                          npixels_out     = npixels_out)       def get_nfringes(self      : Propagator,                      wavefront : Wavefront) -&gt; Array:         \"\"\"         The number of diffraction fringes in the output plane.          Parameters         ----------         wavefront : Wavefront             The wavefront being propagated.          Returns         -------         fringes : Array             The number of diffraction fringes in the output plane.         \"\"\"         size_in = wavefront.diameter         size_out = self.pixel_scale_out * self.npixels_out         return size_in * size_out / self.focal_length / wavefront.wavelength           def summary(self            : Propagator,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         plane_out = 'pupil' if self.inverse else 'focal'          pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters',                                          cartesian_units)         focal_length = convert_cartesian(self.focal_length, 'meters',                                          cartesian_units)         shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\             if not self.pixel_shift else self.shift          prop_string = (f\"Propagates the Wavefront {focal_length} \"                        f\"{cartesian_units} to a {plane_out} plane \"                        f\"with {self.npixels_out}x{self.npixels_out} pixels of \"                        f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")                  if (self.shift == np.zeros(2)).all():             return prop_string +  \"using a 2-sided MFT.\"         else:             if self.pixel_shift:                 shift_string = (f\"shifted by {shift} pixels in the (x, y) \"                                 \"dimension \")             else:                 shift_string = (f\"shifted by {shift} {cartesian_units} in the \"                                 \"(x, y) dimension \")             return prop_string + shift_string + \"using a 2-sided MFT.\"           class AngularMFT(AngularPropagator, VariableSamplingPropagator):     \"\"\"     A Propagator class designed to propagate wavefronts, with pixel scale units     defined in meters per pixel in pupil planes and radians/pixel in focal     planes, with a variable output sampling in the output plane.      Attributes     ----------     npixels_out : int         The number of pixels in the output plane.     pixel_scale_out : Array, meters/pixel or radians/pixel         The pixel scale in the output plane, measured in meters per pixel in         pupil plane and radians per pixel in focal planes.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel_shift : bool         Should the shift value be considered in units of pixels, or in the         physical units of the output plane (ie pixels or meters, radians). True         interprets the shift value in pixel units.     name : str         The name for this propagator.     \"\"\"       def __init__(self            : Propagator,                  npixels_out     : int,                  pixel_scale_out : Array,                  inverse         : bool  = False,                  shift           : Array = np.array([0., 0.]),                  pixel_shift     : bool  = False,                  name            : str   = 'AngularMFT') -&gt; Propagator:         \"\"\"         Parameters         ----------         npixels_out : int             The number of pixels in the output plane.         pixel_scale_out : Array, radians/pixel, meters/pixel             The pixel scale in the output plane, measured in meters per pixel in             pupil planes and radians per pixel in focal planes.         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         shift : Array = np.array([0., 0.])             The (x, y) shift to apply to the wavefront in the output plane.         pixel_shift : bool = False             Should the shift value be considered in units of pixel, or in the             physical units of the output plane (ie pixels or meters, radians).         name : str = 'AngularMFT'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name            = name,                          inverse         = inverse,                          shift           = shift,                          pixel_shift     = pixel_shift,                          pixel_scale_out = pixel_scale_out,                          npixels_out     = npixels_out)       def get_nfringes(self      : Propagator,                      wavefront : Wavefront) -&gt; Array:         \"\"\"         The number of diffraction fringes in the output plane.          Parameters         ----------         wavefront : Wavefront             The wavefront being propagated.          Returns         -------         fringes : Array             The number of diffraction fringes in the output plane.         \"\"\"         fringe_size = wavefront.wavelength / wavefront.diameter         detector_size = self.npixels_out * self.pixel_scale_out         return detector_size / fringe_size           def summary(self            : Propagator,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         plane_out = 'pupil' if self.inverse else 'focal'                      pixel_scale = convert_angular(self.pixel_scale_out, 'radians',                                          angular_units)         shift = convert_angular(self.shift, 'radians', angular_units) \\             if not self.pixel_shift else self.shift          prop_string = (f\"Propagates the Wavefront to a {plane_out} plane \"                        f\"with {self.npixels_out}x{self.npixels_out} pixels of \"                        f\"size {pixel_scale:.{sigfigs}} {angular_units} \")                  if (self.shift == np.zeros(2)).all():             return prop_string +  \"using a 2-sided MFT.\"         else:             if self.pixel_shift:                 shift_string = (f\"shifted by {shift} pixels in the (x, y) \"                                 \"dimension \")             else:                 shift_string = (f\"shifted by {shift} {angular_units} in the \"                                 \"(x, y) dimension \")             return prop_string + shift_string + \"using a 2-sided MFT.\"   class CartesianFFT(CartesianPropagator, FixedSamplingPropagator):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane using a     Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel.      Attributes     ----------     focal_length : Array, meters         The focal_length of the lens/mirror this propagator represents.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"       def __init__(self         : Propagator,                  focal_length : Array,                  inverse      : bool = False,                  name         : str  = 'CartesianFFT') -&gt; Propagator:         \"\"\"         Parameters         ----------         focal_length : Array, meters             The focal_length of the lens/mirror this propagator represents.         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         name : str = 'CartesianFFT'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name         = name,                          inverse      = inverse,                          focal_length = focal_length)       def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:         \"\"\"         The pixel scale in the output plane.          Parameters         ----------         wavefront : Wavefront             The `Wavefront` that is being propagted.          Returns         -------         pixel_scale_out : Array, meters/pixel             The pixel scale in the output plane.         \"\"\"         return self.focal_length * wavefront.wavelength / wavefront.diameter           def summary(self            : Propagator,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         plane_out = 'pupil' if self.inverse else 'focal'         focal_length = convert_cartesian(self.focal_length, 'meters',                                          cartesian_units)          return (f\"Propagates the Wavefront {focal_length} {cartesian_units} to \"                 f\"a {plane_out} plane using a FFT.\")   class AngularFFT(AngularPropagator, FixedSamplingPropagator):     \"\"\"     A Propagator class designed to propagate a wavefront to a plane using a     Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel     in pupil planes and radians/pixel in focal planes.      Attributes     ----------     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     name : str         The name for this propagator.     \"\"\"       def __init__(self    : Propagator,                  inverse : bool = False,                  name    : str = 'AngularFFT') -&gt; Propagator:         \"\"\"         Constructor for the AngularFFT propagator.          Parameters         ----------         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         name : str = 'AngularFFT'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name = name, inverse = inverse)       def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:         \"\"\"         Calculate the pixel scale in the output plane in units of radians per         pixel.          Parameters         ----------         wavefront : Wavefront             The wavefront that is being propagated.          Returns         -------         pixel_scale_out : Array, radians/pixel             The pixel scale in the output plane.         \"\"\"         return wavefront.wavelength / wavefront.diameter           def summary(self            : Propagator,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         plane_out = 'pupil' if self.inverse else 'focal'          return f\"Propagates the Wavefront to a {plane_out} plane using a FFT.\"   class CartesianFresnel(FarFieldFresnel, CartesianMFT):     \"\"\"     A propagator class to for Far-Field fresnel propagations. This classes     implements algorithms that use quadratic phase factors to better represent     out-of-plane behaviour of wavefronts, close to the focal plane. This class     is designed to work on Cartesian wavefronts, ie pixel units are in     meters/pixel in the output plane.      Attributes     ----------     npixels_out : int         The number of pixels in the output plane.     pixel_scale_out : Array, meters/pixel         The pixel scale in the output plane, measured in meters per pixel.     focal_length : Array, meters         The focal_length of the lens/mirror this propagator represents.     propagation_shift : Array, meters         The shift in the propagation distance of the wavefront.     inverse : bool         Is this an 'inverse' propagation. Non-inverse propagations represents         propagation from a pupil to a focal plane, and inverse represents         propagation from a focal to a pupil plane.     shift : Array         The (x, y) shift to apply to the wavefront in the output plane.     pixel_shift : bool         Should the shift value be considered in units of pixels, or in the         physical units of the output plane (ie pixels or meters, radians). True         interprets the shift value in pixel units.     name : str         The name for this propagator.     \"\"\"       def __init__(self              : Propagator,                  npixels_out       : Array,                  pixel_scale_out   : Array,                  focal_length      : Array,                  propagation_shift : Array,                  inverse           : bool  = False,                  shift             : Array = np.array([0., 0.]),                  pixel_shift       : bool  = False,                  name              : str   = 'CartesianFresnel') -&gt; Propagator:         \"\"\"         Constructor for the CartesianFresnel propagator          Parameters         ----------         pixel_scale_out : Array, meters/pixel             The pixel scale in the output plane, measured in meters per pixel.         npixels_out : int             The number of pixels in the output plane.         focal_length : Array, meters             The focal_length of the lens/mirror this propagator represents.         propagation_shift : Array, meters             The shift in the propagation distance of the wavefront.         inverse : bool = False             Is this an 'inverse' propagation. Non-inverse propagations             represents propagation from a pupil to a focal plane, and inverse             represents propagation from a focal to a pupil plane.         shift : Array = np.array([0., 0.])             The (x, y) shift to apply to the wavefront in the output plane.         pixel_shift : bool = False             Should the shift value be considered in units of pixel, or in the             physical units of the output plane (ie pixels or meters, radians).         name : str = 'CartesianFresnel'             The name of the layer, which is used to index the layers dictionary.         \"\"\"         super().__init__(name               = name,                          inverse            = inverse,                          shift              = shift,                          pixel_shift        = pixel_shift,                          focal_length       = focal_length,                          pixel_scale_out    = pixel_scale_out,                          npixels_out        = npixels_out,                          propagation_shift  = propagation_shift)       def get_nfringes(self      : Propagator,                      wavefront : Wavefront) -&gt; Array:         \"\"\"         The number of diffraction fringes in the output plane.          Parameters         ----------         wavefront : Wavefront             The wavefront being propagated.          Returns         -------         fringes : Array             The number of diffraction fringes in the output plane.         \"\"\"         propagation_distance = self.focal_length + self.propagation_shift         size_in = wavefront.diameter         size_out = self.pixel_scale_out * self.npixels_out         return size_in * size_out / wavefront.wavelength / propagation_distance       def quadratic_phase(self          : Propagator,                         x_coordinates : Array,                         y_coordinates : Array,                         wavelength    : Array,                         distance      : Array) -&gt; Array:         \"\"\"         A convinience function for calculating quadratic phase factors.          Parameters         ----------         x_coordinates : Array             The x coordinates of the pixels in meters. This will be different             in the plane of propagation and the initial plane.         y_coordinates : Array             The y coordinates of the pixels in meters. This will be different             in the plane of propagation and the initial plane.         wavelength : Array, meters             The wavelength of the wavefront.         distance : Array, meters             The distance that is to be propagated in meters.          Returns         -------         quadratic_phase : Array             A set of phase factors that are useful in optical calculations.         \"\"\"         wavenumber = 2 * np.pi / wavelength         radial_coordinates = np.hypot(x_coordinates, y_coordinates)         return np.exp(0.5j * wavenumber * radial_coordinates ** 2 / distance)       def transfer_function(self      : Propagator,                           wavefront : Wavefront,                           distance  : Array) -&gt; Array:         \"\"\"         The Optical Transfer Function defining the phase evolution of the         wavefront when propagating to a non-conjugate plane.          Parameters         ----------         wavefront : Wavefront             The wavefront to propagate.         distance : Array, meters             The distance that is being propagated in meters.          Returns         -------         field : Array             The field that represents the optical transfer.         \"\"\"         return np.exp(1.0j * wavefront.wavenumber * distance)       def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array:         \"\"\"         Propagates the wavefront from the input plane to the output plane using         a Matrix Fourier Transform.          TODO: Set plane type to intermediate          Parameters         ----------         wavefront : Wavefront             The wavefront to propagate.          Returns         -------         field : Array             The normalised electric field phasor after the propagation.         \"\"\"         # See gihub issue #52         offsets = self.get_shift()          input_positions = wavefront.pixel_coordinates         output_positions = get_pixel_positions(                             (self.npixels_out, self.npixels_out),                              (self.pixel_scale_out, self.pixel_scale_out))          propagation_distance = self.focal_length + self.propagation_shift          field = wavefront.phasor         field *= self.quadratic_phase(*input_positions,             wavefront.wavelength, - self.focal_length)         field *= self.quadratic_phase(*input_positions,             wavefront.wavelength, propagation_distance)         wavefront = wavefront.set_phasor(np.abs(field), np.angle(field))          field = super().propagate(wavefront)         field *= self.transfer_function(wavefront, propagation_distance)         field *= self.quadratic_phase(*output_positions,             wavefront.wavelength, propagation_distance)         return field           def summary(self            : Propagator,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         plane_out = 'pupil' if self.inverse else 'focal'          pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters',                                          cartesian_units)         prop_distance = convert_cartesian(self.focal_length, 'meters',                                          cartesian_units)         defocus = convert_cartesian(self.propagation_shift, 'meters',                                          cartesian_units)         shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\             if not self.pixel_shift else self.shift           prop_string = (f\"Propagates the Wavefront {prop_distance} \"                        f\"{cartesian_units} to a {plane_out} plane \"                        f\"with {self.npixels_out}x{self.npixels_out} pixels of \"                        f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")                  defocus_string = (f\"with a defocus of {defocus} {cartesian_units} \"                            \"using a 2-sided MFT.\")                  if (self.shift == np.zeros(2)).all():             return prop_string +  defocus_string         else:             if self.pixel_shift:                 shift_string = (f\"shifted by {shift} pixels in the (x, y) \"                                 \"dimension \")             else:                 shift_string = (f\"shifted by {shift} {cartesian_units} in the \"                                 \"(x, y) dimension \")             return prop_string + shift_string + defocus_string   # TODO: Implement eventually # class AngularFresnel(FarFieldFresnel, AngularMFT): #     \"\"\" #     Propagates an AngularWavefront in the Fresnel approximation.  #     Attributes #     ---------- #     \"\"\" #     pass"},{"location":"dLux/propagators/#abstract-classes","title":"Abstract Classes\u00b6","text":"<p>#######################</p>"},{"location":"dLux/propagators/#concrete-classes","title":"Concrete Classes\u00b6","text":"<p>#######################</p>"},{"location":"dLux/sources/","title":"Sources","text":"In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\n</pre> %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax.scipy.signal import convolve\nfrom jax import vmap\nfrom equinox import tree_at\nfrom zodiax import Base\nfrom abc import ABC, abstractmethod\nfrom dLux.utils.units import convert_angular, convert_cartesian\nimport dLux\n\n\n__all__ = [\"PointSource\", \"MultiPointSource\", \"ArrayDistribution\",\n           \"BinarySource\", \"PointExtendedSource\", \"PointAndExtendedSource\"]\n\n\nArray = np.ndarray\n</pre> from __future__ import annotations import jax.numpy as np from jax.scipy.signal import convolve from jax import vmap from equinox import tree_at from zodiax import Base from abc import ABC, abstractmethod from dLux.utils.units import convert_angular, convert_cartesian import dLux   __all__ = [\"PointSource\", \"MultiPointSource\", \"ArrayDistribution\",            \"BinarySource\", \"PointExtendedSource\", \"PointAndExtendedSource\"]   Array = np.ndarray  In\u00a0[\u00a0]: Copied! <pre>class Source(Base, ABC):\n\"\"\"\n    Base class for source objects. The idea of these source classes is to allow\n    an arbitrary parametrisation of the underlying astrophyical objects. Each\n    source object requires a normalise(), format_inputs(), and model() methods,\n    along with the regular getter and setter methods.\n\n    The normalise() method should return a new instance of the class with all\n    the appropriate attribues normalised (ie spectral weights, resolved source\n    distribution).\n\n    The format_inputs() method should return the relevant wavelengths, weights,\n    positions etc, that are correctly formatted to be used by the model()\n    method. This should primarily interface with the specrum object, and should\n    call the normalise() method.\n\n    The model() method should return a single psf of the source. This is done\n    inside of the source object so that each class can be arbitrarily\n    parameterised as required. This method should call the format_inputs()\n    method.\n\n    A series of parameterisations have been proided to model a series of\n    different astrophysical objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n    position : Array\n    flux     : Array\n    spectrum : Spectrum\n    name     : str\n\n\n    def __init__(self     : Source,\n                 position : Array    = None,\n                 flux     : Array    = None,\n                 spectrum : Spectrum = None,\n                 name     : str      = 'Source') -&gt; Source:\n\"\"\"\n        Constructor for the Source class.\n\n        Parameters\n        ----------\n        position : Array, radians = None\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = None\n            The flux of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        name : str = 'Source'\n            The name for this object.\n        \"\"\"\n        self.position = np.asarray(position, dtype=float)\n        self.flux     = np.asarray(flux,     dtype=float)\n        self.spectrum = spectrum\n        self.name     = name\n\n        # Input position checking\n        if position is not None:\n            assert self.position.ndim == 1, \\\n            (\"position must be a 1d array.\")\n            assert self.position.shape == (2,), \\\n            (\"positions must be shape (2,), ie (x, y).\")\n\n        # Input flux checking\n        if flux is not None:\n            assert self.flux.shape == (), \\\n            (\"flux must be a scalar, (shape == ()).\")\n\n        # Input spectrum checking\n        assert isinstance(self.spectrum, dLux.spectrums.Spectrum), \\\n        (\"Spectrum must be dLux Spectrum object.\")\n\n        # Input name checking\n        assert isinstance(self.name, str), \"Name must be a string.\"\n    \n\n    def __getattr__(self : Source, key : str) -&gt; Any:\n\"\"\"\n        Getter method for the spectrum object.\n\n        Parameters\n        ----------\n        key : str\n            The key to get from the spectrum object.\n\n        Returns\n        -------\n        value : Any\n            The value of the key.\n        \"\"\"\n        if hasattr(self.spectrum, key):\n            return getattr(self.spectrum, key)\n        else:\n            raise AttributeError(f\"{self.name} has no attribute {key}.\")\n\n\n    def get_flux(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the flux.\n\n        Returns\n        -------\n        flux : Array, photons\n            The flux of the object.\n        \"\"\"\n        return self.flux\n\n\n    def get_position(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the position.\n\n        Returns\n        -------\n        position : Array, radians\n            The (x, y) on-sky position of this object.\n        \"\"\"\n        return self.position\n\n\n    def get_wavelengths(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the source internal wavelengths.\n\n        Returns\n        -------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        return self.spectrum.get_wavelengths()\n\n\n    def get_weights(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the source internal weights.\n\n        Returns\n        -------\n        weights : Array\n            The relative weights of each wavelength.\n        \"\"\"\n        return self.spectrum.get_weights()\n\n\n    def normalise(self : Source) -&gt; Source:\n\"\"\"\n        Method for returning a new normalised source object.\n\n        Returns\n        -------\n        source : Source\n            The normalised source object.\n        \"\"\"\n        normalised_spectrum = self.spectrum.normalise()\n        return tree_at(\n            lambda source : source.spectrum, self, normalised_spectrum)\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name} has no summary method yet.\")\n    \n\n    def display(self            : Source, \n                figsize         : tuple = (6, 3),\n                dpi             : int = 120,\n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; None:\n\"\"\"\n        Displays a plot of the wavefront amplitude and opd or phase.\n\n        Parameters\n        ----------\n        figsize : tuple = (6, 3)\n            The size of the figure to display.\n        cmap : str = 'inferno'\n            The colour map to use.\n        dpi : int = 120\n            The resolution of the figure.\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n        \"\"\"\n        self.spectrum.normalise().display(figsize=figsize, dpi=dpi, \n            angular_units=angular_units, cartesian_units=cartesian_units)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self        = self.normalise()\n        wavelengths = self.get_wavelengths()\n        weights     = self.get_weights()\n        position    = self.get_position()\n        flux        = self.get_flux()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator &amp; model\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        psfs = weights[:, None, None] * propagator(wavelengths, position)\n        psf = flux * psfs.sum(0)\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\nclass ResolvedSource(Source, ABC):\n\"\"\"\n    Base class for resolved source objects. This simply extends the base Source\n    class by implementing an abstract get_distribution() method and a concrete\n    model() method.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    @abstractmethod\n    def get_distribution(self): # pragma: no cover\n\"\"\"\n        Abstract method for returning the distribution of the resolved source.\n\n        Returns\n        -------\n        distribution : Array\n            The distribution of the resolved source\n        \"\"\"\n        pass\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics\n        \"\"\"\n        # Normalise and get parameters\n        self         = self.normalise()\n        wavelengths  = self.get_wavelengths()\n        weights      = self.get_weights()\n        position     = self.get_position()\n        flux         = self.get_flux()\n        distribution = self.get_distribution()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator &amp; model\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        psfs = weights[:, None, None] * propagator(wavelengths, position)\n        psf = convolve(flux * psfs.sum(0), distribution, mode='same')\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\nclass RelativeFluxSource(Source, ABC):\n\"\"\"\n    Abstract class that extend the methods of Source to allow for binary-object\n    sources to be parameterised by their relative flux. Classes that inherit\n    from this class must instantiate a contrast attribute.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n    contrast : Array\n\n\n    def __init__(self      : Source,\n                 contrast : Array,\n                 **kwargs) -&gt; Source:\n\"\"\"\n        Constructor for the RelativeFluxSource class.\n\n        Parameters\n        ----------\n        contrast : Array\n            The contrast ratio between the two sources.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.contrast = np.asarray(contrast, dtype=float)\n\n        # Input contrast checking\n        assert self.contrast.shape == (), \\\n        (\"Flux ratio must be a scalar, (shape == ()).\")\n\n\n    def get_flux(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the fluxes. This paramterieses the source such that\n        flux refers to the mean_flux and contrast is defined as the ratio of\n        the flux of the first entry divided by the second entry.\n\n        Returns\n        -------\n        flux : Array, photons\n            The flux (flux1, flux2) of the binary object.\n        \"\"\"\n        flux_A = 2 * self.contrast * self.flux / (1 + self.contrast)\n        flux_B = 2 * self.flux / (1 + self.contrast)\n        return np.array([flux_A, flux_B])\n\n\nclass RelativePositionSource(Source, ABC):\n\"\"\"\n    Abstract class that extend the methods of Source to allow for binary-object\n    sources to be parameterised by their relative position. Classes that\n    inherit from this class must instantiate a separation attribute.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The field angle between the two sources measure from the positive\n        x axis.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n    separation     : Array\n    position_angle : Array\n\n\n    def __init__(self           : Source,\n                 separation     : Array,\n                 position_angle : Array,\n                 **kwargs) -&gt; Source:\n\"\"\"\n        Constructor for the RelativePositionSource class.\n\n        Parameters\n        ----------\n        separation : Array, radians\n            The separation of the two sources in radians.\n        position_angle : Array, radians\n            The field angle between the two sources measure from the positive\n            x axis.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.separation     = np.asarray(separation,     dtype=float)\n        self.position_angle = np.asarray(position_angle, dtype=float)\n\n        assert self.separation.shape == (), \"Separation must be a scalar, \\\n        (shape == ()).\"\n\n        assert self.position_angle.shape == (), \"Field angle must be a scalar, \\\n        (shape == ()).\"\n\n\n    def get_position(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the position.\n\n        Returns\n        -------\n        position : Array, radians\n            The ((x, y), (x, y)) on-sky position of this object.\n        \"\"\"\n        r, phi = self.separation/2, self.position_angle\n        sep_vec = np.array([r*np.sin(phi), r*np.cos(phi)])\n        return np.array([self.position + sep_vec,\n                         self.position - sep_vec])\n</pre> class Source(Base, ABC):     \"\"\"     Base class for source objects. The idea of these source classes is to allow     an arbitrary parametrisation of the underlying astrophyical objects. Each     source object requires a normalise(), format_inputs(), and model() methods,     along with the regular getter and setter methods.      The normalise() method should return a new instance of the class with all     the appropriate attribues normalised (ie spectral weights, resolved source     distribution).      The format_inputs() method should return the relevant wavelengths, weights,     positions etc, that are correctly formatted to be used by the model()     method. This should primarily interface with the specrum object, and should     call the normalise() method.      The model() method should return a single psf of the source. This is done     inside of the source object so that each class can be arbitrarily     parameterised as required. This method should call the format_inputs()     method.      A series of parameterisations have been proided to model a series of     different astrophysical objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"     position : Array     flux     : Array     spectrum : Spectrum     name     : str       def __init__(self     : Source,                  position : Array    = None,                  flux     : Array    = None,                  spectrum : Spectrum = None,                  name     : str      = 'Source') -&gt; Source:         \"\"\"         Constructor for the Source class.          Parameters         ----------         position : Array, radians = None             The (x, y) on-sky position of this object.         flux : Array, photons = None             The flux of the object.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         name : str = 'Source'             The name for this object.         \"\"\"         self.position = np.asarray(position, dtype=float)         self.flux     = np.asarray(flux,     dtype=float)         self.spectrum = spectrum         self.name     = name          # Input position checking         if position is not None:             assert self.position.ndim == 1, \\             (\"position must be a 1d array.\")             assert self.position.shape == (2,), \\             (\"positions must be shape (2,), ie (x, y).\")          # Input flux checking         if flux is not None:             assert self.flux.shape == (), \\             (\"flux must be a scalar, (shape == ()).\")          # Input spectrum checking         assert isinstance(self.spectrum, dLux.spectrums.Spectrum), \\         (\"Spectrum must be dLux Spectrum object.\")          # Input name checking         assert isinstance(self.name, str), \"Name must be a string.\"           def __getattr__(self : Source, key : str) -&gt; Any:         \"\"\"         Getter method for the spectrum object.          Parameters         ----------         key : str             The key to get from the spectrum object.          Returns         -------         value : Any             The value of the key.         \"\"\"         if hasattr(self.spectrum, key):             return getattr(self.spectrum, key)         else:             raise AttributeError(f\"{self.name} has no attribute {key}.\")       def get_flux(self : Source) -&gt; Array:         \"\"\"         Getter method for the flux.          Returns         -------         flux : Array, photons             The flux of the object.         \"\"\"         return self.flux       def get_position(self : Source) -&gt; Array:         \"\"\"         Getter method for the position.          Returns         -------         position : Array, radians             The (x, y) on-sky position of this object.         \"\"\"         return self.position       def get_wavelengths(self : Source) -&gt; Array:         \"\"\"         Getter method for the source internal wavelengths.          Returns         -------         wavelengths : Array, meters             The array of wavelengths at which the spectrum is defined.         \"\"\"         return self.spectrum.get_wavelengths()       def get_weights(self : Source) -&gt; Array:         \"\"\"         Getter method for the source internal weights.          Returns         -------         weights : Array             The relative weights of each wavelength.         \"\"\"         return self.spectrum.get_weights()       def normalise(self : Source) -&gt; Source:         \"\"\"         Method for returning a new normalised source object.          Returns         -------         source : Source             The normalised source object.         \"\"\"         normalised_spectrum = self.spectrum.normalise()         return tree_at(             lambda source : source.spectrum, self, normalised_spectrum)           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name} has no summary method yet.\")           def display(self            : Source,                  figsize         : tuple = (6, 3),                 dpi             : int = 120,                 angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; None:         \"\"\"         Displays a plot of the wavefront amplitude and opd or phase.          Parameters         ----------         figsize : tuple = (6, 3)             The size of the figure to display.         cmap : str = 'inferno'             The colour map to use.         dpi : int = 120             The resolution of the figure.         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.         \"\"\"         self.spectrum.normalise().display(figsize=figsize, dpi=dpi,              angular_units=angular_units, cartesian_units=cartesian_units)       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed.          Returns         -------         psf : Array             The psf of the source source modelled through the optics.         \"\"\"         # Normalise and get parameters         self        = self.normalise()         wavelengths = self.get_wavelengths()         weights     = self.get_weights()         position    = self.get_position()         flux        = self.get_flux()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator &amp; model         propagator = vmap(optics.propagate_mono, in_axes=(0, None))         psfs = weights[:, None, None] * propagator(wavelengths, position)         psf = flux * psfs.sum(0)          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)   class ResolvedSource(Source, ABC):     \"\"\"     Base class for resolved source objects. This simply extends the base Source     class by implementing an abstract get_distribution() method and a concrete     model() method.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"       @abstractmethod     def get_distribution(self): # pragma: no cover         \"\"\"         Abstract method for returning the distribution of the resolved source.          Returns         -------         distribution : Array             The distribution of the resolved source         \"\"\"         pass       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the source through the optics. Implements a         basic convolution with the psf and source distribution.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed.          Returns         -------         psf : Array             The psf of the source modelled through the optics         \"\"\"         # Normalise and get parameters         self         = self.normalise()         wavelengths  = self.get_wavelengths()         weights      = self.get_weights()         position     = self.get_position()         flux         = self.get_flux()         distribution = self.get_distribution()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator &amp; model         propagator = vmap(optics.propagate_mono, in_axes=(0, None))         psfs = weights[:, None, None] * propagator(wavelengths, position)         psf = convolve(flux * psfs.sum(0), distribution, mode='same')          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)   class RelativeFluxSource(Source, ABC):     \"\"\"     Abstract class that extend the methods of Source to allow for binary-object     sources to be parameterised by their relative flux. Classes that inherit     from this class must instantiate a contrast attribute.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     contrast : Array         The contrast ratio between the two sources.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"     contrast : Array       def __init__(self      : Source,                  contrast : Array,                  **kwargs) -&gt; Source:         \"\"\"         Constructor for the RelativeFluxSource class.          Parameters         ----------         contrast : Array             The contrast ratio between the two sources.         \"\"\"         super().__init__(**kwargs)         self.contrast = np.asarray(contrast, dtype=float)          # Input contrast checking         assert self.contrast.shape == (), \\         (\"Flux ratio must be a scalar, (shape == ()).\")       def get_flux(self : Source) -&gt; Array:         \"\"\"         Getter method for the fluxes. This paramterieses the source such that         flux refers to the mean_flux and contrast is defined as the ratio of         the flux of the first entry divided by the second entry.          Returns         -------         flux : Array, photons             The flux (flux1, flux2) of the binary object.         \"\"\"         flux_A = 2 * self.contrast * self.flux / (1 + self.contrast)         flux_B = 2 * self.flux / (1 + self.contrast)         return np.array([flux_A, flux_B])   class RelativePositionSource(Source, ABC):     \"\"\"     Abstract class that extend the methods of Source to allow for binary-object     sources to be parameterised by their relative position. Classes that     inherit from this class must instantiate a separation attribute.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     separation : Array, radians         The separation of the two sources in radians.     position_angle : Array, radians         The field angle between the two sources measure from the positive         x axis.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"     separation     : Array     position_angle : Array       def __init__(self           : Source,                  separation     : Array,                  position_angle : Array,                  **kwargs) -&gt; Source:         \"\"\"         Constructor for the RelativePositionSource class.          Parameters         ----------         separation : Array, radians             The separation of the two sources in radians.         position_angle : Array, radians             The field angle between the two sources measure from the positive             x axis.         \"\"\"         super().__init__(**kwargs)         self.separation     = np.asarray(separation,     dtype=float)         self.position_angle = np.asarray(position_angle, dtype=float)          assert self.separation.shape == (), \"Separation must be a scalar, \\         (shape == ()).\"          assert self.position_angle.shape == (), \"Field angle must be a scalar, \\         (shape == ()).\"       def get_position(self : Source) -&gt; Array:         \"\"\"         Getter method for the position.          Returns         -------         position : Array, radians             The ((x, y), (x, y)) on-sky position of this object.         \"\"\"         r, phi = self.separation/2, self.position_angle         sep_vec = np.array([r*np.sin(phi), r*np.cos(phi)])         return np.array([self.position + sep_vec,                          self.position - sep_vec])  In\u00a0[\u00a0]: Copied! <pre>class PointSource(Source):\n\"\"\"\n    Concrete Class for unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self        : Source,\n                 position    : Array    = np.array([0., 0.]),\n                 flux        : Array    = np.array(1.),\n                 spectrum    : Spectrum = None,\n                 wavelengths : Array    = None,\n                 name        : str      = 'PointSource') -&gt; Source:\n\"\"\"\n        Constructor for the PointSource class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n        super().__init__(position, flux, spectrum, name=name)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        flux = self.flux\n        return (f\"{self.name}: A Point Source with flux {flux:.{sigfigs}} \"\n                f\"photons at offset from the optical axis by {position} \"\n                f\"{angular_units} with spectrum\\n  {spectrum_str}\")\n\n\nclass MultiPointSource(Source):\n\"\"\"\n    Concrete Class for multiple unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky positions of these sources.\n    flux : Array, photons\n        The fluxes of the sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self        : Source,\n                 position    : Array,\n                 flux        : Array    = None,\n                 spectrum    : Spectrum = None,\n                 wavelengths : Array    = None,\n                 name        : str      = 'MultiPointSource') -&gt; Source:\n\"\"\"\n        Constructor for the MultiPointSource class.\n\n        Parameters\n        ----------\n        position : Array, radians\n            The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.\n        flux : Array, photons = None\n            The fluxes of the sources.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n            Every source in this class will have an identical spectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'MultiPointSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n        # Only call super, not __init__ since we are overwriting all the attrs\n        super().__init__(spectrum=spectrum, name=name)\n\n        self.position = np.asarray(position, dtype=float)\n\n        # Input position checking\n        assert self.position.ndim == 2, \\\n        (\"position must be a 2d array.\")\n        assert self.position.shape[-1] == 2, \\\n        (\"positions must be shape (nstars, 2), ie [(x0, y0), (x1, y1), ...].\")\n\n        # Get flux\n        self.flux = np.ones(len(self.positions)) if flux is None else \\\n                    np.asarray(flux, dtype=float)\n\n        # Input flux checking\n        assert self.flux.ndim == 1, \\\n        (\"flux must be a 1d array.\")\n\n        # Ensure same dimensionality\n        assert self.flux.shape[0] == self.position.shape[0], (\"position and \"\n        \"flux must have the same length leading dimension, ie nstars\")\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self        = self.normalise()\n        wavelengths = self.get_wavelengths()\n        weights     = self.get_weights()\n        positions   = self.get_position()\n        fluxes      = self.get_flux()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        propagator = vmap(source_propagator, in_axes=(None, 0))\n\n        # Model Psf\n        psfs = propagator(wavelengths, positions)\n        psfs *= weights[None, :, None, None] * fluxes[:, None, None, None]\n        psf = psfs.sum((0, 1))\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        n = len(self.flux)\n        return (f\"{self.name}: {n} Point Sources with fluxes \"\n                f\"{self.flux:.{sigfigs}} photons at offsets from the optical \"\n                f\"axis by {position} {angular_units} with spectrum\\n  \"\n                f\"{spectrum_str}\")\n\n\nclass ArrayDistribution(ResolvedSource):\n\"\"\"\n    A class for modelling resolved sources that parameterise their resolved\n    component using an array of intensities.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n    distribution : Array\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'ArrayDistribution',\n                 **kwargs) -&gt; Source:\n\"\"\"\n        Constructor for the ArrayDistribution class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'ArrayDistribution'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n        super().__init__(position, flux, spectrum, name=name, **kwargs)\n        distribution = np.asarray(distribution, dtype=float)\n        distribution = np.maximum(distribution, 0.)\n        self.distribution = distribution/distribution.sum()\n\n        # Input checking\n        assert self.distribution.ndim == 2, \\\n        (\"distribution must be a 2d array.\")\n        assert len(self.distribution) &gt; 0, \\\n        (\"Length of distribution must be greater than 1.\")\n\n\n    def get_distribution(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the source distribution.\n\n        Returns\n        -------\n        distribution : Array, intensity\n            The distribution of the source intensity.\n        \"\"\"\n        return self.distribution\n\n\n    def normalise(self : Source) -&gt; Source:\n\"\"\"\n        Method for returning a new source object with a normalised total\n        spectrum and source distribution.\n\n        Returns\n        -------\n        source : Source\n            The source object with the normalised spectrum and distribution.\n        \"\"\"\n        normalised_spectrum = self.spectrum.normalise()\n        distribution_floor = np.maximum(self.distribution, 0.)\n        normalised_distribution = distribution_floor/distribution_floor.sum()\n        return tree_at(\n            lambda source : (source.spectrum, source.distribution), self, \\\n                            (normalised_spectrum, normalised_distribution))\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Resolved Source with flux \"\n                f\"{self.flux:.{sigfigs}} photons at offset from the optical \"\n                f\"axis by {position} {angular_units} with spectrum\\n  \"\n                f\"{spectrum_str}\")\n\n\nclass BinarySource(RelativePositionSource, RelativeFluxSource):\n\"\"\"\n    A parameterised binary source.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the sources.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a CombinedSpectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self           : Source,\n                 position       : Array    = np.array([0., 0.]),\n                 flux           : Array    = np.array(1.),\n                 separation     : Array    = None,\n                 position_angle : Array    = np.pi/2,\n                 contrast       : Array    = np.array(1.),\n                 spectrum       : Spectrum = None,\n                 wavelengths    : Array    = None,\n                 name           : str      = 'BinarySource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the sources.\n        separation : Array, radians = None\n            The separation of the two sources in radians.\n        position_angle : Array, radians = np.pi/2\n            The position angle between the two sources measured clockwise from\n            the vertical axis.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the two sources.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'BinarySource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n            assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n            (\"The input spectrum must be a CombinedSpectrum object.\")\n        else:\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n        # Check separation\n        assert separation is not None, (\"separation must be provided.\")\n\n        super().__init__(position=position,\n                         flux=flux,\n                         spectrum=spectrum,\n                         separation=separation,\n                         position_angle=position_angle,\n                         contrast=contrast,\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self        = self.normalise()\n        wavelengths = self.get_wavelengths()[0]\n        weights     = self.get_weights()\n        positions   = self.get_position()\n        fluxes      = self.get_flux()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        propagator = vmap(source_propagator, in_axes=(None, 0))\n\n        # Model Psf\n        psfs = propagator(wavelengths, positions)\n        psfs *= weights[:, :, None, None] * fluxes[:, None, None, None]\n        psf = psfs.sum((0, 1))\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        separation = convert_angular(self.separation, 'radians', angular_units)\n        position_angle = convert_angular(self.position_angle, 'radians', \n                                         angular_units)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Binary Source with mean flux \"\n                f\"{self.flux:.{sigfigs}} photons and constrast {self.contrast} \"\n                f\"offset from the optical axis by {position} \"\n                f\"{angular_units} with separation {separation:.{sigfigs}} \"\n                f\"{angular_units}, position angle {position_angle:.{sigfigs}} \"\n                f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n\n\nclass PointExtendedSource(RelativeFluxSource, ArrayDistribution):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source. An example would be an unresolved star with\n    a resolved dust shell or debris disk. These two objects share the same\n    spectra but have their fluxes defined by flux (the mean flux) and the flux\n    ratio (contrast) between the point source and resolved distribution. The\n    resolved component is defined by an array (ie this class inherits from\n    ArrayDistribution).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolved source.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 contrast     : Array    = np.array(1.),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'PointExtendedSource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the point and resolved source.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointExtendedSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.Spectrum(wavelengths)\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                         distribution=distribution, contrast=contrast, \\\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the soource objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed. Default is \n            None which is uniform throughput.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self         = self.normalise()\n        wavelengths  = self.get_wavelengths()\n        weights      = self.get_weights()\n        position     = self.get_position()\n        fluxes       = self.get_flux()\n        distribution = self.get_distribution()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n        # Model psfs\n        psfs = propagator(wavelengths, position)\n        single_psf = (weights[:, None, None] * psfs).sum(0)\n        point_psf = fluxes[0] * single_psf\n        extended_psf = fluxes[1] * single_psf\n        convolved = convolve(extended_psf, distribution, mode='same')\n        psf = convolved + point_psf\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n                f\"{self.flux:.{sigfigs}} photons and constrast \"\n                f\"{self.contrast:.{sigfigs}} offset from the optical axis by \"\n                f\"{position} {angular_units} and spectrum\\n  \"\n                f\"{spectrum_str}\")\n\n\nclass PointAndExtendedSource(RelativeFluxSource, ArrayDistribution):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source, but with its own spectra. An example would be\n    an unresolved quasar within a resolved galaxy. These two objects have\n    independent spectra but have their fluxes defined by flux (the mean flux)\n    and the flux ratio (contrast) between the point source and resolved\n    distribution. The resolved component is defined by an array (ie this class\n    inherits from ArrayDistribution).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolves source.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 contrast     : Array    = np.array(1.),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'PointAndExtendedSource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointAndExtendedSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n            assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n            (\"The input spectrum must be a CombinedSpectrum object.\")\n        else:\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                         distribution=distribution, contrast=contrast, \\\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf. Applied a different spectrum to\n        the point source and resolved source.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed. Default is\n            None which is uniform throughput.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self         = self.normalise()\n        wavelengths  = self.get_wavelengths()[0]\n        weights      = self.get_weights()\n        position     = self.get_position()\n        fluxes       = self.get_flux()\n        distribution = self.get_distribution()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n        # Model psfs\n        psfs = propagator(wavelengths, position)\n        point_psf    = fluxes[0] * (weights[0, :, None, None] * psfs).sum(0)\n        extended_psf = fluxes[1] * (weights[1, :, None, None] * psfs).sum(0)\n        convolved = convolve(extended_psf, distribution, mode='same')\n        psf = convolved + point_psf\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n    \n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n                f\"{self.flux} photons and constrast {self.contrast} offset \"\n                f\"from the optical axis by {position} \"\n                f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n</pre> class PointSource(Source):     \"\"\"     Concrete Class for unresolved point source objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"       def __init__(self        : Source,                  position    : Array    = np.array([0., 0.]),                  flux        : Array    = np.array(1.),                  spectrum    : Spectrum = None,                  wavelengths : Array    = None,                  name        : str      = 'PointSource') -&gt; Source:         \"\"\"         Constructor for the PointSource class.          Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The flux of the object.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'PointSource'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")         else:             spectrum = dLux.spectrums.ArraySpectrum(wavelengths)         super().__init__(position, flux, spectrum, name=name)       def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         flux = self.flux         return (f\"{self.name}: A Point Source with flux {flux:.{sigfigs}} \"                 f\"photons at offset from the optical axis by {position} \"                 f\"{angular_units} with spectrum\\n  {spectrum_str}\")   class MultiPointSource(Source):     \"\"\"     Concrete Class for multiple unresolved point source objects.      Attributes     ----------     position : Array, radians         The (x, y) on-sky positions of these sources.     flux : Array, photons         The fluxes of the sources.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.         Every source in this class will have an identical spectrum.     name : str         The name for this object.     \"\"\"       def __init__(self        : Source,                  position    : Array,                  flux        : Array    = None,                  spectrum    : Spectrum = None,                  wavelengths : Array    = None,                  name        : str      = 'MultiPointSource') -&gt; Source:         \"\"\"         Constructor for the MultiPointSource class.          Parameters         ----------         position : Array, radians             The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.         flux : Array, photons = None             The fluxes of the sources.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.             Every source in this class will have an identical spectrum.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'MultiPointSource'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")         else:             spectrum = dLux.spectrums.ArraySpectrum(wavelengths)          # Only call super, not __init__ since we are overwriting all the attrs         super().__init__(spectrum=spectrum, name=name)          self.position = np.asarray(position, dtype=float)          # Input position checking         assert self.position.ndim == 2, \\         (\"position must be a 2d array.\")         assert self.position.shape[-1] == 2, \\         (\"positions must be shape (nstars, 2), ie [(x0, y0), (x1, y1), ...].\")          # Get flux         self.flux = np.ones(len(self.positions)) if flux is None else \\                     np.asarray(flux, dtype=float)          # Input flux checking         assert self.flux.ndim == 1, \\         (\"flux must be a 1d array.\")          # Ensure same dimensionality         assert self.flux.shape[0] == self.position.shape[0], (\"position and \"         \"flux must have the same length leading dimension, ie nstars\")       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed.          Returns         -------         psf : Array             The psf of the source source modelled through the optics.         \"\"\"         # Normalise and get parameters         self        = self.normalise()         wavelengths = self.get_wavelengths()         weights     = self.get_weights()         positions   = self.get_position()         fluxes      = self.get_flux()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator         source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))         propagator = vmap(source_propagator, in_axes=(None, 0))          # Model Psf         psfs = propagator(wavelengths, positions)         psfs *= weights[None, :, None, None] * fluxes[:, None, None, None]         psf = psfs.sum((0, 1))          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         n = len(self.flux)         return (f\"{self.name}: {n} Point Sources with fluxes \"                 f\"{self.flux:.{sigfigs}} photons at offsets from the optical \"                 f\"axis by {position} {angular_units} with spectrum\\n  \"                 f\"{spectrum_str}\")   class ArrayDistribution(ResolvedSource):     \"\"\"     A class for modelling resolved sources that parameterise their resolved     component using an array of intensities.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The flux of the object.     distribution : Array         The array of intensities respresenting the resolved source.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"     distribution : Array       def __init__(self         : Source,                  position     : Array    = np.array([0., 0.]),                  flux         : Array    = np.array(1.),                  distribution : Array    = np.ones((3, 3)),                  spectrum     : Spectrum = None,                  wavelengths  : Array    = None,                  name         : str      = 'ArrayDistribution',                  **kwargs) -&gt; Source:         \"\"\"         Constructor for the ArrayDistribution class.          Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The flux of the object.         distribution : Array = np.ones((3, 3))             The array of intensities respresenting the resolved source.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'ArrayDistribution'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")         else:             spectrum = dLux.spectrums.ArraySpectrum(wavelengths)          super().__init__(position, flux, spectrum, name=name, **kwargs)         distribution = np.asarray(distribution, dtype=float)         distribution = np.maximum(distribution, 0.)         self.distribution = distribution/distribution.sum()          # Input checking         assert self.distribution.ndim == 2, \\         (\"distribution must be a 2d array.\")         assert len(self.distribution) &gt; 0, \\         (\"Length of distribution must be greater than 1.\")       def get_distribution(self : Source) -&gt; Array:         \"\"\"         Getter method for the source distribution.          Returns         -------         distribution : Array, intensity             The distribution of the source intensity.         \"\"\"         return self.distribution       def normalise(self : Source) -&gt; Source:         \"\"\"         Method for returning a new source object with a normalised total         spectrum and source distribution.          Returns         -------         source : Source             The source object with the normalised spectrum and distribution.         \"\"\"         normalised_spectrum = self.spectrum.normalise()         distribution_floor = np.maximum(self.distribution, 0.)         normalised_distribution = distribution_floor/distribution_floor.sum()         return tree_at(             lambda source : (source.spectrum, source.distribution), self, \\                             (normalised_spectrum, normalised_distribution))           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         return (f\"{self.name}: A Resolved Source with flux \"                 f\"{self.flux:.{sigfigs}} photons at offset from the optical \"                 f\"axis by {position} {angular_units} with spectrum\\n  \"                 f\"{spectrum_str}\")   class BinarySource(RelativePositionSource, RelativeFluxSource):     \"\"\"     A parameterised binary source.      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The mean flux of the sources.     separation : Array, radians         The separation of the two sources in radians.     position_angle : Array, radians         The position angle between the two sources measured clockwise from         the vertical axis.     contrast : Array         The contrast ratio between the two sources.     spectrum : Spectrum         The spectrum of this object, represented by a CombinedSpectrum object.     name : str         The name for this object.     \"\"\"       def __init__(self           : Source,                  position       : Array    = np.array([0., 0.]),                  flux           : Array    = np.array(1.),                  separation     : Array    = None,                  position_angle : Array    = np.pi/2,                  contrast       : Array    = np.array(1.),                  spectrum       : Spectrum = None,                  wavelengths    : Array    = None,                  name           : str      = 'BinarySource') -&gt; Source:         \"\"\"         Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The mean flux of the sources.         separation : Array, radians = None             The separation of the two sources in radians.         position_angle : Array, radians = np.pi/2             The position angle between the two sources measured clockwise from             the vertical axis.         contrast : Array = np.array(1.)             The contrast ratio between the two sources.         spectrum : CombinedSpectrum = None             The spectrum of this object, represented by a CombinedSpectrum.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'BinarySource'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")             assert isinstance(spectrum, dLux.CombinedSpectrum), \\             (\"The input spectrum must be a CombinedSpectrum object.\")         else:             spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)          # Check separation         assert separation is not None, (\"separation must be provided.\")          super().__init__(position=position,                          flux=flux,                          spectrum=spectrum,                          separation=separation,                          position_angle=position_angle,                          contrast=contrast,                          name=name)       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the point source through the optics.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed.          Returns         -------         psf : Array             The psf of the source source modelled through the optics.         \"\"\"         # Normalise and get parameters         self        = self.normalise()         wavelengths = self.get_wavelengths()[0]         weights     = self.get_weights()         positions   = self.get_position()         fluxes      = self.get_flux()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator         source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))         propagator = vmap(source_propagator, in_axes=(None, 0))          # Model Psf         psfs = propagator(wavelengths, positions)         psfs *= weights[:, :, None, None] * fluxes[:, None, None, None]         psf = psfs.sum((0, 1))          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         separation = convert_angular(self.separation, 'radians', angular_units)         position_angle = convert_angular(self.position_angle, 'radians',                                           angular_units)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         return (f\"{self.name}: A Binary Source with mean flux \"                 f\"{self.flux:.{sigfigs}} photons and constrast {self.contrast} \"                 f\"offset from the optical axis by {position} \"                 f\"{angular_units} with separation {separation:.{sigfigs}} \"                 f\"{angular_units}, position angle {position_angle:.{sigfigs}} \"                 f\"{angular_units} and spectrum\\n  {spectrum_str}\")   class PointExtendedSource(RelativeFluxSource, ArrayDistribution):     \"\"\"     A class for modelling a point source and a resolved source that is defined     relative to the point source. An example would be an unresolved star with     a resolved dust shell or debris disk. These two objects share the same     spectra but have their fluxes defined by flux (the mean flux) and the flux     ratio (contrast) between the point source and resolved distribution. The     resolved component is defined by an array (ie this class inherits from     ArrayDistribution).      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The mean flux of the point and resolved source.     distribution : Array         The array of intensities respresenting the resolved source.     contrast : Array         The contrast ratio between the point source and the resolved         source.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"       def __init__(self         : Source,                  position     : Array    = np.array([0., 0.]),                  flux         : Array    = np.array(1.),                  distribution : Array    = np.ones((3, 3)),                  contrast     : Array    = np.array(1.),                  spectrum     : Spectrum = None,                  wavelengths  : Array    = None,                  name         : str      = 'PointExtendedSource') -&gt; Source:         \"\"\"         Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The mean flux of the point and resolved source.         distribution : Array = np.ones((3, 3))             The array of intensities respresenting the resolved source.         contrast : Array = np.array(1.)             The contrast ratio between the point source and the resolved             source.         spectrum : Spectrum = None             The spectrum of this object, represented by a Spectrum object.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'PointExtendedSource'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")         else:             spectrum = dLux.spectrums.Spectrum(wavelengths)          super().__init__(position=position, flux=flux, spectrum=spectrum, \\                          distribution=distribution, contrast=contrast, \\                          name=name)       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the source through the optics. Implements a         basic convolution with the psf and source distribution, while also         modelling the single point source psf.          Parameters         ----------         optics : Optics             The optics through which to model the soource objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed. Default is              None which is uniform throughput.          Returns         -------         psf : Array             The psf of the source modelled through the optics.         \"\"\"         # Normalise and get parameters         self         = self.normalise()         wavelengths  = self.get_wavelengths()         weights      = self.get_weights()         position     = self.get_position()         fluxes       = self.get_flux()         distribution = self.get_distribution()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator         propagator = vmap(optics.propagate_mono, in_axes=(0, None))          # Model psfs         psfs = propagator(wavelengths, position)         single_psf = (weights[:, None, None] * psfs).sum(0)         point_psf = fluxes[0] * single_psf         extended_psf = fluxes[1] * single_psf         convolved = convolve(extended_psf, distribution, mode='same')         psf = convolved + point_psf          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         return (f\"{self.name}: A Point and Resolved Source with mean flux \"                 f\"{self.flux:.{sigfigs}} photons and constrast \"                 f\"{self.contrast:.{sigfigs}} offset from the optical axis by \"                 f\"{position} {angular_units} and spectrum\\n  \"                 f\"{spectrum_str}\")   class PointAndExtendedSource(RelativeFluxSource, ArrayDistribution):     \"\"\"     A class for modelling a point source and a resolved source that is defined     relative to the point source, but with its own spectra. An example would be     an unresolved quasar within a resolved galaxy. These two objects have     independent spectra but have their fluxes defined by flux (the mean flux)     and the flux ratio (contrast) between the point source and resolved     distribution. The resolved component is defined by an array (ie this class     inherits from ArrayDistribution).      Attributes     ----------     position : Array, radians         The (x, y) on-sky position of this object.     flux : Array, photons         The mean flux of the point and resolves source.     distribution : Array         The array of intensities respresenting the resolved source.     contrast : Array         The contrast ratio between the point source and the resolved         source.     spectrum : Spectrum         The spectrum of this object, represented by a Spectrum object.     name : str         The name for this object.     \"\"\"       def __init__(self         : Source,                  position     : Array    = np.array([0., 0.]),                  flux         : Array    = np.array(1.),                  distribution : Array    = np.ones((3, 3)),                  contrast     : Array    = np.array(1.),                  spectrum     : Spectrum = None,                  wavelengths  : Array    = None,                  name         : str      = 'PointAndExtendedSource') -&gt; Source:         \"\"\"         Parameters         ----------         position : Array, radians = np.array([0., 0.])             The (x, y) on-sky position of this object.         flux : Array, photons = np.array(1.)             The flux of the object.         distribution : Array = np.ones((3, 3))             The array of intensities respresenting the resolved source.         contrast : Array = np.array(1.)             The contrast ratio between the point source and the resolved             source.         spectrum : CombinedSpectrum = None             The spectrum of this object, represented by a CombinedSpectrum.         wavelengths : Array, meters = None             The array of wavelengths at which the spectrum is defined.         name : str = 'PointAndExtendedSource'             The name for this object.         \"\"\"         # Check spectrum &amp; wavelengths         assert spectrum is not None or wavelengths is not None, \\         (\"Either spectrum or wavelengths must be specified.\")         if spectrum is not None:             assert wavelengths is None, \\             (\"wavelengths can not be specified if spectrum is specified.\")             assert isinstance(spectrum, dLux.CombinedSpectrum), \\             (\"The input spectrum must be a CombinedSpectrum object.\")         else:             spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)          super().__init__(position=position, flux=flux, spectrum=spectrum, \\                          distribution=distribution, contrast=contrast, \\                          name=name)       def model(self      : Source,               optics    : Optics,               detector  : Detector = None,               filter_in : Filter   = None) -&gt; Array:         \"\"\"         Method to model the psf of the source through the optics. Implements a         basic convolution with the psf and source distribution, while also         modelling the single point source psf. Applied a different spectrum to         the point source and resolved source.          Parameters         ----------         optics : Optics             The optics through which to model the source objects.         detector : Detector = None             The detector object that is observing the psf.         filter_in : Filter = None             The filter through which the source is being observed. Default is             None which is uniform throughput.          Returns         -------         psf : Array             The psf of the source modelled through the optics.         \"\"\"         # Normalise and get parameters         self         = self.normalise()         wavelengths  = self.get_wavelengths()[0]         weights      = self.get_weights()         position     = self.get_position()         fluxes       = self.get_flux()         distribution = self.get_distribution()          # Get filter throughput         if filter_in is not None:             raise NotImplementedError(\"Filter modelling is under development.\")          # Vmap propagator         propagator = vmap(optics.propagate_mono, in_axes=(0, None))          # Model psfs         psfs = propagator(wavelengths, position)         point_psf    = fluxes[0] * (weights[0, :, None, None] * psfs).sum(0)         extended_psf = fluxes[1] * (weights[1, :, None, None] * psfs).sum(0)         convolved = convolve(extended_psf, distribution, mode='same')         psf = convolved + point_psf          # Apply detector if supplied         return psf if detector is None else detector.apply_detector(psf)           def summary(self            : Source,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         position = np.array_str(convert_angular(self.position, 'radians',                                              angular_units), precision=sigfigs)         spectrum_str = self.spectrum.summary(angular_units, cartesian_units,                                                 sigfigs)         return (f\"{self.name}: A Point and Resolved Source with mean flux \"                 f\"{self.flux} photons and constrast {self.contrast} offset \"                 f\"from the optical axis by {position} \"                 f\"{angular_units} and spectrum\\n  {spectrum_str}\")"},{"location":"dLux/sources/#abstract-classes","title":"Abstract Classes\u00b6","text":"<p>#######################</p>"},{"location":"dLux/sources/#concrete-classes","title":"Concrete Classes\u00b6","text":"<p>#######################</p>"},{"location":"dLux/spectrums/","title":"Spectrums","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nfrom abc import ABC, abstractmethod\nimport jax.numpy as np\nfrom equinox import tree_at\nfrom zodiax import Base\nfrom jax import vmap\nfrom dLux.utils.units import convert_cartesian\nfrom dLux.utils.helpers import spectrum_plot\n</pre> from __future__ import annotations from abc import ABC, abstractmethod import jax.numpy as np from equinox import tree_at from zodiax import Base from jax import vmap from dLux.utils.units import convert_cartesian from dLux.utils.helpers import spectrum_plot In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"ArraySpectrum\", \"PolynomialSpectrum\", \"CombinedSpectrum\"]\n</pre> __all__ = [\"ArraySpectrum\", \"PolynomialSpectrum\", \"CombinedSpectrum\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class Spectrum(Base, ABC):\n\"\"\"\n    Abstract base class for arbitrary spectral parametrisations.\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The array of wavelengths at which the spectrum is defined.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n    name        : str\n    wavelengths : Array\n\n\n    def __init__(self        : Spectrum,\n                 wavelengths : Array,\n                 name        : str = 'Spectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the Spectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'Spectrum'\n            The name of the spectrum.\n        \"\"\"\n        self.name = name\n        self.wavelengths = np.asarray(wavelengths, dtype=float)\n\n        # Input checking\n        assert self.wavelengths.ndim == 1, \\\n        (\"Wavelengths must be a 1d array.\")\n        assert len(self.wavelengths) &gt; 0, \\\n        (\"Length of wavelengths must be greater than 1.\")\n\n\n    def get_wavelengths(self : Spectrum) -&gt; Array:\n\"\"\"\n        Getter method for the wavelengths.\n\n        Returns\n        -------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        \"\"\"\n        return self.wavelengths\n\n\n    @abstractmethod\n    def normalise(self : Spectrum) -&gt; Spectrum: # pragma: no cover\n\"\"\"\n        Abstract method to normalise the spectrum. Must be overwitten by child\n        classes.\n        \"\"\"\n        return\n\n\n    @abstractmethod\n    def get_weights(self : Spectrum) -&gt; Array: # pragma: no cover\n\"\"\"\n        Abstract getter method for the weights. Must be overwritten by child\n        classes.\n        \"\"\"\n        return\n    \n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name} layer has no summary method yet.\"\n    \n\n    def display(self            : Spectrum, \n                figsize         : tuple = (6, 3),\n                dpi             : int = 120,\n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; None:\n\"\"\"\n        Displays a plot of the wavefront amplitude and opd or phase.\n\n        Parameters\n        ----------\n        figsize : tuple = (6, 3)\n            The size of the figure to display.\n        cmap : str = 'inferno'\n            The colour map to use.\n        dpi : int = 120\n            The resolution of the figure.\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n        \"\"\"\n        wavelengths = convert_cartesian(self.wavelengths, \"meters\", \n                                        cartesian_units)\n        spectrum_plot(wavelengths, self.get_weights(), figsize=figsize,\n                      cartesian_units=cartesian_units, dpi=dpi)\n</pre> class Spectrum(Base, ABC):     \"\"\"     Abstract base class for arbitrary spectral parametrisations.      Attributes     ----------     wavelengths : Array, meters         The array of wavelengths at which the spectrum is defined.     name : str         The name of the spectrum.     \"\"\"     name        : str     wavelengths : Array       def __init__(self        : Spectrum,                  wavelengths : Array,                  name        : str = 'Spectrum') -&gt; Spectrum:         \"\"\"         Constructor for the Spectrum class.          Parameters         ----------         wavelengths : Array, meters             The array of wavelengths at which the spectrum is defined.         name : str = 'Spectrum'             The name of the spectrum.         \"\"\"         self.name = name         self.wavelengths = np.asarray(wavelengths, dtype=float)          # Input checking         assert self.wavelengths.ndim == 1, \\         (\"Wavelengths must be a 1d array.\")         assert len(self.wavelengths) &gt; 0, \\         (\"Length of wavelengths must be greater than 1.\")       def get_wavelengths(self : Spectrum) -&gt; Array:         \"\"\"         Getter method for the wavelengths.          Returns         -------         wavelengths : Array, meters             The array of wavelengths at which the spectrum is defined.         \"\"\"         return self.wavelengths       @abstractmethod     def normalise(self : Spectrum) -&gt; Spectrum: # pragma: no cover         \"\"\"         Abstract method to normalise the spectrum. Must be overwitten by child         classes.         \"\"\"         return       @abstractmethod     def get_weights(self : Spectrum) -&gt; Array: # pragma: no cover         \"\"\"         Abstract getter method for the weights. Must be overwritten by child         classes.         \"\"\"         return           def summary(self            : Spectrum,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return f\"{self.name} layer has no summary method yet.\"           def display(self            : Spectrum,                  figsize         : tuple = (6, 3),                 dpi             : int = 120,                 angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; None:         \"\"\"         Displays a plot of the wavefront amplitude and opd or phase.          Parameters         ----------         figsize : tuple = (6, 3)             The size of the figure to display.         cmap : str = 'inferno'             The colour map to use.         dpi : int = 120             The resolution of the figure.         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.         \"\"\"         wavelengths = convert_cartesian(self.wavelengths, \"meters\",                                          cartesian_units)         spectrum_plot(wavelengths, self.get_weights(), figsize=figsize,                       cartesian_units=cartesian_units, dpi=dpi) In\u00a0[\u00a0]: Copied! <pre>class ArraySpectrum(Spectrum):\n\"\"\"\n    A Spectrum class that interally parametersises the spectrum via arrays (ie\n    wavelengths and weights)\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array\n        The relative weights of each wavelength.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n    weights : Array\n\n\n    def __init__(self        : Spectrum,\n                 wavelengths : Array,\n                 weights     : Array = None,\n                 name        : str = 'ArraySpectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the ArraySpectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        weights : Array = None\n            The relative weights of each wavelength. Defaults to uniform\n            spectrum. Weights are automatically normalised to a sum of 1.\n        name : str = 'ArraySpectrum'\n            The name of the spectrum.\n        \"\"\"\n        super().__init__(wavelengths, name)\n        weights = np.ones(len(self.wavelengths))/len(wavelengths) \\\n                                    if weights is None else weights\n        weights = np.asarray(weights, dtype=float)\n        self.weights = weights/np.sum(weights)\n\n        # Input checks\n        assert self.weights.ndim == 1, \\\n        (\"weights must be a 1d array.\")\n        assert len(self.weights) &gt; 0, \\\n        (\"Length of weights must be greater than 1.\")\n        assert len(self.wavelengths) == len(self.weights), \\\n        (\"wavelengths and weights must have the same length.\")\n\n\n    def get_weights(self : Spectrum) -&gt; Array:\n\"\"\"\n        Getter method for the weights.\n\n        Returns\n        -------\n        weights : Array\n            The relative weights of each wavelength.\n        \"\"\"\n        return self.weights\n\n\n    def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum.\n\n        Returns\n        -------\n        spectrum : Specturm\n            The spectrum object with the normalised spectrum.\n        \"\"\"\n        total_power = self.get_weights().sum()\n        norm_weights = self.get_weights()/total_power\n        return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n    \n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a spectrum with weights stored as an \"\n                \"array.\")\n</pre> class ArraySpectrum(Spectrum):     \"\"\"     A Spectrum class that interally parametersises the spectrum via arrays (ie     wavelengths and weights)      Attributes     ----------     wavelengths : Array, meters         The array of wavelengths at which the spectrum is defined.     weights : Array         The relative weights of each wavelength.     name : str         The name of the spectrum.     \"\"\"     weights : Array       def __init__(self        : Spectrum,                  wavelengths : Array,                  weights     : Array = None,                  name        : str = 'ArraySpectrum') -&gt; Spectrum:         \"\"\"         Constructor for the ArraySpectrum class.          Parameters         ----------         wavelengths : Array, meters             The array of wavelengths at which the spectrum is defined.         weights : Array = None             The relative weights of each wavelength. Defaults to uniform             spectrum. Weights are automatically normalised to a sum of 1.         name : str = 'ArraySpectrum'             The name of the spectrum.         \"\"\"         super().__init__(wavelengths, name)         weights = np.ones(len(self.wavelengths))/len(wavelengths) \\                                     if weights is None else weights         weights = np.asarray(weights, dtype=float)         self.weights = weights/np.sum(weights)          # Input checks         assert self.weights.ndim == 1, \\         (\"weights must be a 1d array.\")         assert len(self.weights) &gt; 0, \\         (\"Length of weights must be greater than 1.\")         assert len(self.wavelengths) == len(self.weights), \\         (\"wavelengths and weights must have the same length.\")       def get_weights(self : Spectrum) -&gt; Array:         \"\"\"         Getter method for the weights.          Returns         -------         weights : Array             The relative weights of each wavelength.         \"\"\"         return self.weights       def normalise(self : Spectrum) -&gt; Spectrum:         \"\"\"         Method for returning a new spectrum object with a normalised total         spectrum.          Returns         -------         spectrum : Specturm             The spectrum object with the normalised spectrum.         \"\"\"         total_power = self.get_weights().sum()         norm_weights = self.get_weights()/total_power         return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)           def summary(self            : Spectrum,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a spectrum with weights stored as an \"                 \"array.\") In\u00a0[\u00a0]: Copied! <pre>class PolynomialSpectrum(Spectrum):\n\"\"\"\n    Implements a generic polynomial spectrum. This is likely not needed and\n    will probably just be turned into LinearSpectrum in the future.\n\n    This implements a polynomial as follows:\n    f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The array of wavelengths at which the spectrum is defined.\n    degree : int\n        The degree of the polynomial.\n    coefficients : Array\n        The array of polynomial coefficient values.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n    degree       : int # Just a helper\n    coefficients : Array\n\n\n    def __init__(self         : Spectrum,\n                 wavelengths  : Array,\n                 coefficients : Array,\n                 name        : str = 'PolynomialSpectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the PolynomialSpectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        coefficients : Array\n            The array of polynomial coefficient values.\n        name : str = 'PolynomialSpectrum'\n            The name of the spectrum.\n        \"\"\"\n        super().__init__(wavelengths, name)\n\n        self.coefficients = np.asarray(coefficients, dtype=float)\n\n        assert self.coefficients.ndim == 1, \"Coefficients must be a 1d array.\"\n        assert not np.isnan(self.coefficients).any(), \\\n        (\"Coefficients must not be nan.\")\n        assert not np.isinf(self.coefficients).any(), \\\n        (\"Coefficients must be not be infinite.\")\n\n        # Input checks\n        assert self.coefficients.ndim == 1, \\\n        (\"coefficients must be a 1d array.\")\n        assert len(self.coefficients) &gt; 0, \\\n        (\"Length of coefficients must be greater than 1.\")\n\n        self.degree = int(len(coefficients) - 1)\n\n\n    def get_weights(self : Spectrum) -&gt; Array:\n\"\"\"\n        Gets the relative spectral weights by evalutating the polynomial\n        function at the internal wavelengths. This automaically normalises\n        the weights to have unitary amplitude.\n\n        Returns\n        -------\n        weights : Array\n            The normalised relative weights of each wavelength.\n        \"\"\"\n        generate_polynomial = vmap(lambda wavelength :\n                                np.array([self.coefficients[i] * wavelength**i \n                                for i in range(len(self.coefficients))]).sum())\n        weights = generate_polynomial(self.wavelengths)\n        return weights/weights.sum()\n\n\n    def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n        This method currently does nothing becuase solving for normalised\n        polynomial coefficients is difficut and the get_weights() method\n        already returns normalised weights.\n\n        Returns:\n        spectrum : Specturm\n            The unmodified spectrum object\n        \"\"\"\n        return self\n    \n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a spectrum with weights parametried by \"\n                f\"a polynomial of degree {self.degree}.\")\n</pre> class PolynomialSpectrum(Spectrum):     \"\"\"     Implements a generic polynomial spectrum. This is likely not needed and     will probably just be turned into LinearSpectrum in the future.      This implements a polynomial as follows:     f(x) = c0 + c1*x + c2*x^2 + ... + cn*x^n      Attributes     ----------     wavelengths : Array, meters         The array of wavelengths at which the spectrum is defined.     degree : int         The degree of the polynomial.     coefficients : Array         The array of polynomial coefficient values.     name : str         The name of the spectrum.     \"\"\"     degree       : int # Just a helper     coefficients : Array       def __init__(self         : Spectrum,                  wavelengths  : Array,                  coefficients : Array,                  name        : str = 'PolynomialSpectrum') -&gt; Spectrum:         \"\"\"         Constructor for the PolynomialSpectrum class.          Parameters         ----------         wavelengths : Array, meters             The array of wavelengths at which the spectrum is defined.         coefficients : Array             The array of polynomial coefficient values.         name : str = 'PolynomialSpectrum'             The name of the spectrum.         \"\"\"         super().__init__(wavelengths, name)          self.coefficients = np.asarray(coefficients, dtype=float)          assert self.coefficients.ndim == 1, \"Coefficients must be a 1d array.\"         assert not np.isnan(self.coefficients).any(), \\         (\"Coefficients must not be nan.\")         assert not np.isinf(self.coefficients).any(), \\         (\"Coefficients must be not be infinite.\")          # Input checks         assert self.coefficients.ndim == 1, \\         (\"coefficients must be a 1d array.\")         assert len(self.coefficients) &gt; 0, \\         (\"Length of coefficients must be greater than 1.\")          self.degree = int(len(coefficients) - 1)       def get_weights(self : Spectrum) -&gt; Array:         \"\"\"         Gets the relative spectral weights by evalutating the polynomial         function at the internal wavelengths. This automaically normalises         the weights to have unitary amplitude.          Returns         -------         weights : Array             The normalised relative weights of each wavelength.         \"\"\"         generate_polynomial = vmap(lambda wavelength :                                 np.array([self.coefficients[i] * wavelength**i                                  for i in range(len(self.coefficients))]).sum())         weights = generate_polynomial(self.wavelengths)         return weights/weights.sum()       def normalise(self : Spectrum) -&gt; Spectrum:         \"\"\"         This method currently does nothing becuase solving for normalised         polynomial coefficients is difficut and the get_weights() method         already returns normalised weights.          Returns:         spectrum : Specturm             The unmodified spectrum object         \"\"\"         return self           def summary(self            : Spectrum,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a spectrum with weights parametried by \"                 f\"a polynomial of degree {self.degree}.\") In\u00a0[\u00a0]: Copied! <pre>class CombinedSpectrum(ArraySpectrum):\n\"\"\"\n    Implements a combined spectrum, in order to have only a single spectrum\n    object for parameterised sources such as binary stars.\n\n    TODO: Expand to be arbitrary number of spectrums, store only a single\n    wavelengths array and tile it on the get_wavelengths method. (ie make work\n    for MultiPointSource)\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The (nspectra, nwavels) array of wavelengths at which the spectrum is \n        defined. Input can also be a 1d\n    weights : Array\n        The (nspectra, nwavels) relative weights of each wavelength. Defaults \n        to uniform throughput.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n\n\n    def __init__(self        : Spectrum,\n                 wavelengths : Array,\n                 weights     : Array = None,\n                 name        : str = 'CombinedSpectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the CombinedSpectrum class. Expects wavelengths and\n        weights to have the same dimensionality, ie (nsources, nwavelengths).\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The (nspectra, nwavels) array of wavelengths at which the spectrum \n            is defined. Input can also be a 1d\n        weights : Array (optional)\n            The (nspectra, nwavels) relative weights of each wavelength. \n            Defaults to uniform throughput.\n        name : str = 'CombinedSpectrum'\n            The name of the spectrum.\n        \"\"\"\n        super() # Access methods but don't instatiate attributes\n        self.name = str(name)\n        self.wavelengths = np.asarray(wavelengths, dtype=float)\n\n        # Wavelengths\n        # Tile single dimension wavelengths inputs\n        if self.wavelengths.ndim == 1:\n            self.wavelengths = np.tile(self.wavelengths, (2, 1))\n\n        # Input checking\n        assert self.wavelengths.ndim == 2, \\\n        (\"Wavelengths must be a 2d array.\")\n        assert len(self.wavelengths[0]) &gt; 0, \\\n        (\"Length of wavelengths must be greater than 1.\")\n\n        # Weights\n        weights = np.ones(self.wavelengths.shape)/self.wavelengths.shape[1] \\\n                                                if weights is None else weights\n        self.weights = np.asarray(weights, dtype=float)\n\n        # Tile single dimension weights inputs\n        if self.weights.ndim == 1:\n            self.weights = np.tile(self.weights, (len(self.wavelengths), 1))\n\n        # Input checking\n        assert self.weights.ndim == 2, \\\n        (\"weights must be a 2d array.\")\n        assert len(self.weights[0]) &gt; 0, \\\n        (\"Length of weights must be greater than 1.\")\n\n        # Check consistency between wavelenghts and weights\n        assert self.wavelengths.shape == self.weights.shape, \"Weights and \\\n        Wavelengths must have the same shape.\"\n\n\n    def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum for each individual source.\n\n        Returns\n        -------\n        spectrum : Specturm\n            The spectrum object with the normalised spectrums.\n        \"\"\"\n        weights = self.get_weights()\n        total_power = weights.sum(1).reshape((len(weights), 1))\n        norm_weights = weights/total_power\n        return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n    \n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a two spectrums with weights stored as \"\n                \"arrays.\")\n</pre> class CombinedSpectrum(ArraySpectrum):     \"\"\"     Implements a combined spectrum, in order to have only a single spectrum     object for parameterised sources such as binary stars.      TODO: Expand to be arbitrary number of spectrums, store only a single     wavelengths array and tile it on the get_wavelengths method. (ie make work     for MultiPointSource)      Attributes     ----------     wavelengths : Array, meters         The (nspectra, nwavels) array of wavelengths at which the spectrum is          defined. Input can also be a 1d     weights : Array         The (nspectra, nwavels) relative weights of each wavelength. Defaults          to uniform throughput.     name : str         The name of the spectrum.     \"\"\"       def __init__(self        : Spectrum,                  wavelengths : Array,                  weights     : Array = None,                  name        : str = 'CombinedSpectrum') -&gt; Spectrum:         \"\"\"         Constructor for the CombinedSpectrum class. Expects wavelengths and         weights to have the same dimensionality, ie (nsources, nwavelengths).          Parameters         ----------         wavelengths : Array, meters             The (nspectra, nwavels) array of wavelengths at which the spectrum              is defined. Input can also be a 1d         weights : Array (optional)             The (nspectra, nwavels) relative weights of each wavelength.              Defaults to uniform throughput.         name : str = 'CombinedSpectrum'             The name of the spectrum.         \"\"\"         super() # Access methods but don't instatiate attributes         self.name = str(name)         self.wavelengths = np.asarray(wavelengths, dtype=float)          # Wavelengths         # Tile single dimension wavelengths inputs         if self.wavelengths.ndim == 1:             self.wavelengths = np.tile(self.wavelengths, (2, 1))          # Input checking         assert self.wavelengths.ndim == 2, \\         (\"Wavelengths must be a 2d array.\")         assert len(self.wavelengths[0]) &gt; 0, \\         (\"Length of wavelengths must be greater than 1.\")          # Weights         weights = np.ones(self.wavelengths.shape)/self.wavelengths.shape[1] \\                                                 if weights is None else weights         self.weights = np.asarray(weights, dtype=float)          # Tile single dimension weights inputs         if self.weights.ndim == 1:             self.weights = np.tile(self.weights, (len(self.wavelengths), 1))          # Input checking         assert self.weights.ndim == 2, \\         (\"weights must be a 2d array.\")         assert len(self.weights[0]) &gt; 0, \\         (\"Length of weights must be greater than 1.\")          # Check consistency between wavelenghts and weights         assert self.wavelengths.shape == self.weights.shape, \"Weights and \\         Wavelengths must have the same shape.\"       def normalise(self : Spectrum) -&gt; Spectrum:         \"\"\"         Method for returning a new spectrum object with a normalised total         spectrum for each individual source.          Returns         -------         spectrum : Specturm             The spectrum object with the normalised spectrums.         \"\"\"         weights = self.get_weights()         total_power = weights.sum(1).reshape((len(weights), 1))         norm_weights = weights/total_power         return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)           def summary(self            : Spectrum,                  angular_units   : str = 'radians',                  cartesian_units : str = 'meters',                  sigfigs         : int = 4) -&gt; str:         \"\"\"         Returns a summary of the class.          Parameters         ----------         angular_units : str = 'radians'             The angular units to use in the summary. Options are 'radians',              'degrees', 'arcseconds' and 'arcminutes'.         cartesian_units : str = 'meters'             The cartesian units to use in the summary. Options are 'meters',             'millimeters' and 'microns'.         sigfigs : int = 4             The number of significant figures to use in the summary.          Returns         -------         summary : str             A summary of the class.         \"\"\"         return (f\"{self.name}: Applies a two spectrums with weights stored as \"                 \"arrays.\")"},{"location":"dLux/wavefronts/","title":"Wavefronts","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nfrom jax import vmap\nfrom equinox import tree_at\nfrom zodiax import Base\nfrom enum import IntEnum\nfrom abc import ABC\nfrom dLux.utils.coordinates import get_pixel_positions\nfrom dLux.utils.interpolation import interpolate_field, rotate_field\nimport dLux\n</pre> from __future__ import annotations import jax.numpy as np from jax import vmap from equinox import tree_at from zodiax import Base from enum import IntEnum from abc import ABC from dLux.utils.coordinates import get_pixel_positions from dLux.utils.interpolation import interpolate_field, rotate_field import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"PlaneType\", \"CartesianWavefront\", \"AngularWavefront\",\n           'FarFieldFresnelWavefront']\n</pre> __all__ = [\"PlaneType\", \"CartesianWavefront\", \"AngularWavefront\",            'FarFieldFresnelWavefront'] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class PlaneType(IntEnum):\n\"\"\"\n    Enumeration object to keep track of plane types. This may prove to be\n    redundant.\n\n    NOTE: Propagtors are not currently set up to ever set the PlaneType to\n    Intermediate. This will be done with the Near-Field Fresnel implementation.\n    \"\"\"\n    Pupil = 1\n    Focal = 2\n    Intermediate = 3\n</pre> class PlaneType(IntEnum):     \"\"\"     Enumeration object to keep track of plane types. This may prove to be     redundant.      NOTE: Propagtors are not currently set up to ever set the PlaneType to     Intermediate. This will be done with the Near-Field Fresnel implementation.     \"\"\"     Pupil = 1     Focal = 2     Intermediate = 3 In\u00a0[\u00a0]: Copied! <pre>class Wavefront(Base, ABC):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type.\n\n    All wavefronts currently only support square amplitude and phase arrays.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        can be in units of either meters per pixel or radians per pixel\n        depending on both the plane type and the wavfront type (Cartesian or\n        Angular).\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n    wavelength  : Array\n    pixel_scale : Array\n    plane_type  : PlaneType\n    amplitude   : Array\n    phase       : Array\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel\n            The physical dimensions of each square pixel.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        self.wavelength  = np.asarray(wavelength,  dtype=float)\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n        self.amplitude   = np.asarray(amplitude,   dtype=float)\n        self.phase       = np.asarray(phase,       dtype=float)\n        self.plane_type  = plane_type\n\n        # Input checks\n        assert self.wavelength.shape == (), \\\n        (\"wavelength must be a scalar Array.\")\n        assert self.pixel_scale.shape == (), \\\n        (\"pixel_scale must be a scalar Array.\")\n        assert self.amplitude.ndim == 3, \\\n        (\"amplitude must a 3d array (nfields, npix, npix).\")\n        assert self.phase.ndim == 3, \\\n        (\"phase must a 3d array (nfields, npix, npix).\")\n        assert self.amplitude.shape == self.phase.shape, \\\n        (\"The amplitude and phase arrays must have the same shape.\")\n        assert isinstance(plane_type, PlaneType), \\\n        (\"plane_type must a PlaneType object.\")\n\n\n    ########################\n    ### Getter Functions ###\n    ########################\n    @property\n    def diameter(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the current wavefront diameter calulated using the pixel scale\n        and number of pixels.\n\n        Returns\n        -------\n        diameter : Array, meters or radians\n            The current diameter of the wavefront.\n        \"\"\"\n        return self.npixels * self.pixel_scale\n\n\n    @property\n    def npixels(self : Wavefront) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        wavefront. Taken from the amplitude array.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[-1]\n\n\n    @property\n    def nfields(self : Wavefront) -&gt; int:\n\"\"\"\n        Returns the number of polarisation fields currently representing the\n        wavefront. Taken from the amplitude array first dimension.\n\n        Returns\n        -------\n        pixels : int\n            The number of polarisation fields that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[0]\n\n\n    @property\n    def real(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the real component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The real component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.cos(self.phase)\n\n\n    @property\n    def imaginary(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the imaginary component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The imaginary component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.sin(self.phase)\n\n\n    @property\n    def phasor(self : Wavefront) -&gt; Array:\n\"\"\"\n        The electric field phasor described by this Wavefront in complex form.\n\n        Returns\n        -------\n        field : Array\n            The electric field phasor of the wavefront.\n        \"\"\"\n        return self.amplitude * np.exp(1j * self.phase)\n\n\n    @property\n    def psf(self : Wavefront) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), ie the squared modulus\n        of the complex wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return np.sum(self.amplitude ** 2, axis=0)\n\n\n    @property\n    def pixel_coordinates(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the physical positions of the wavefront pixels in meters.\n\n        Returns\n        -------\n        pixel_positions : Array\n            The coordinates of the centers of each pixel representing the\n            wavefront.\n        \"\"\"\n        # return get_pixel_coordinates(self.npixels, self.pixel_scale)\n        return get_pixel_positions((self.npixels, self.npixels), \n                                   (self.pixel_scale, self.pixel_scale))\n\n\n    @property\n    def wavenumber(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the wavenumber of the wavefront (2 * pi / wavelength).\n\n        Returns\n        -------\n        wavenumber : Array, 1/meters\n            The wavenumber of the wavefront.\n        \"\"\"\n        return 2 * np.pi / self.wavelength\n\n\n    ########################\n    ### Setter Functions ###\n    ########################\n    def set_amplitude(self : Wavefront, amplitude : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the amplitude attribute.\n\n        Parameters\n        ---------\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated amplitude.\n        \"\"\"\n        assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n        (\"amplitude must be a 3d array.\")\n        return tree_at(\n            lambda wavefront : wavefront.amplitude, self, amplitude)\n\n\n    def set_phase(self : Wavefront, phase : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the phase attribute.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            The phases of each pixel on the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated phase.\n        \"\"\"\n        assert isinstance(phase, Array) and phase.ndim == 3, \\\n        (\"phase must be a 3d array.\")\n        return tree_at(\n            lambda wavefront : wavefront.phase, self, phase)\n\n\n    def set_pixel_scale(self : Wavefront, pixel_scale : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the pixel_scale attribute.\n\n        Parameters\n        ----------\n        pixel_scale : Array\n            The new pixel_scale associated with the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new Wavefront object with the updated pixel_scale.\n        \"\"\"\n        assert isinstance(pixel_scale, Array) and pixel_scale.ndim == 0, \\\n        (\"pixel_scale must be a scalar array.\")\n        return tree_at(\n            lambda wavefront : wavefront.pixel_scale, self, pixel_scale)\n\n\n    def set_plane_type(self : Wavefront, plane : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Mutator for the PlaneType attribute.\n\n        Parameters\n        ----------\n        plane : PlaneType\n            A PlaneType object describing the plane that the `Wavefront` is\n            currently in.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the update plate_type information.\n        \"\"\"\n        assert isinstance(plane, PlaneType), \\\n        (\"plane must be a PlaneType object.\")\n        return tree_at(\n            lambda wavefront : wavefront.plane_type, self, plane)\n\n\n    def set_phasor(self      : Wavefront,\n                      amplitude : Array,\n                      phase     : Array) -&gt; Wavefront:\n\"\"\"\n        Updates the phasor of the wavefront (ie both the amplitude and the\n        phase).\n\n        Parameters\n        ----------\n        amplitude : Array, power\n            The new electric field amplitude of the wavefront.\n        phase : Array, radians\n            The new electric field phase of the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with updated amplitude and phase.\n        \"\"\"\n        assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n        (\"amplitude must be a 3d array.\")\n        assert isinstance(phase, Array) and phase.ndim == 3, \\\n        (\"phase must be a 3d array.\")\n        assert amplitude.shape == phase.shape, \\\n        (\"amplitude and phase arrays must have the same shape.\")\n        return tree_at(\n            lambda wavefront : (wavefront.amplitude, wavefront.phase), self,\n                               (amplitude, phase))\n\n\n    #######################\n    ### Other Functions ###\n    #######################\n    def tilt_wavefront(self : Wavefront, tilt_angles : Array) -&gt; Wavefront:\n\"\"\"\n        Tilts the wavefront by the tilt_angles.\n\n        Parameters\n        ----------\n        tilt_angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the (x, y) tilts applied.\n        \"\"\"\n        assert isinstance(tilt_angles, Array) and tilt_angles.shape == (2,), \\\n        (\"tilt_angles must be an array with shape (2,) ie. (x, y).\")\n\n        opds = tilt_angles[:, None, None] * self.pixel_coordinates\n        return self.add_phase(- self.wavenumber * opds.sum(0))\n\n\n    def multiply_amplitude(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n        Multiply the amplitude of the `Wavefront` by either a float or array.\n\n        Parameters\n        ----------\n        array_like : Array\n            An array or float that has the same dimensions as amplitude that is\n            multipled by the current ampltide.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated amplitude.\n        \"\"\"\n        amplitude = self.amplitude\n        assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n        (\"array_like must be either a scalar array or array with 2 or 3 \"\n         \"dimensions.\")\n        if array_like.ndim in (2, 3):\n            assert array_like.shape[-2:] == amplitude.shape[-2:], \\\n            (\"array_like shape must be equal to the current ampltude array.\")\n        return self.set_amplitude(amplitude * array_like)\n\n\n    def add_phase(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n        Add to the phase of the `Wavefront` by either a float or array.\n\n        Parameters\n        ----------\n        array_like : Array\n            An array or float that has the same dimensions as phase that is\n            added to the current phase.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated phase.\n        \"\"\"\n        phase = self.phase\n        assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n        (\"array_like must be either a scalar array or array with 2 or 3 \"\n         \"dimensions.\")\n        if array_like.ndim in (2, 3):\n            assert array_like.shape[-2:] == phase.shape[-2:], \\\n            (\"array_like shape must be equal to the current phase array.\")\n        return self.set_phase(phase + array_like)\n\n\n    def add_opd(self: Wavefront, path_difference : Array) -&gt; Wavefront:\n\"\"\"\n        Applies the wavelength-dependent phase based on the supplied optical\n        path difference.\n\n        Parameters\n        ----------\n        path_difference : Array, meters\n            The physical optical path difference of either the entire wavefront\n            or each pixel individually.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phases updated according to the supplied\n            path_difference\n        \"\"\"\n        assert isinstance(path_difference, Array) and \\\n        path_difference.ndim in (0, 2, 3), (\"path_difference must be either a \"\n        \"scalar array or array with 2 or 3 dimensions.\")\n        phase_difference = self.wavenumber * path_difference\n        return self.add_phase(phase_difference)\n\n\n    def normalise(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the total power of the wavefront to 1.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the normalised electric field amplitudes.\n        \"\"\"\n        return self.multiply_amplitude(1 / np.linalg.norm(self.amplitude))\n\n\n    def wavefront_to_psf(self             : Wavefront,\n                         return_polarised : bool = False) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), ie the squared modulus\n        of the complex wavefront.\n\n        TODO: Take in the parameters dictionary and use the parameters in that\n        to determine the way to output the wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return np.sum(self.amplitude ** 2, axis=0)\n\n\n    def invert_x_and_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about both axes.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the phase and amplitude arrays reversed\n            along both axes.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=(-1, -2))\n        new_phase = np.flip(self.phase, axis=(-1, -2))\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def invert_x(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about the x axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the phase and amplitude arrays reversed\n            along the x axis.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=-1)\n        new_phase = np.flip(self.phase, axis=-1)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def invert_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about the y axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phase and amplitude arrays reversed\n            along the y axis.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=-2)\n        new_phase = np.flip(self.phase, axis=-2)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def interpolate(self            : Wavefront,\n                    npixels_out     : int,\n                    pixel_scale_out : Array,\n                    real_imaginary  : bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial interpolation on the wavefront, determined by the\n        the pixel_scale_out and npixels_out parameters. By default the\n        interpolation is done on the amplitude and phase arrays, however by\n        passing `real_imgainary=True` the interpolation is done on the real and\n        imaginary components. This option allows for consistent interpolation\n        behaviour when the phase array has a large amount of wrapping.\n        Automatically conserves energy though the interpolation.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels representing the wavefront after the\n            interpolation.\n        pixel_scale_out : Array\n            The pixel scale of the array after the interpolation.\n        real_imaginary : bool = False\n            Whether to interpolate the real and imaginary representation of the\n            wavefront as opposed to the the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront interpolated to the size and shape determined by\n            npixels_out and pixel_scale_out, with the updated pixel_scale.\n        \"\"\"\n        sampling_ratio = pixel_scale_out / self.pixel_scale\n        if real_imaginary:\n            field = np.array([self.real, self.imaginary])\n        else:\n            field = np.array([self.amplitude, self.phase])\n\n        if field.shape[1] == 1:\n            new_amplitude, new_phase = \\\n            interpolate_field(field[:, 0], npixels_out, sampling_ratio,\n                              real_imaginary=real_imaginary)[:, None, :, :]\n        else:\n            interpolator = vmap(interpolate_field, in_axes=(1, None, None))\n            new_amplitude, new_phase = interpolator(field, npixels_out,\n                                sampling_ratio, real_imaginary=real_imaginary)\n\n        # Update parameters\n        return tree_at(lambda wavefront:\n                 (wavefront.amplitude, wavefront.phase, wavefront.pixel_scale),\n                        self, (new_amplitude, new_phase, pixel_scale_out))\n\n\n    def rotate(self           : Wavefront,\n               angle          : Array,\n               real_imaginary : bool = False,\n               fourier        : bool = False,\n               order          : int  = 1,\n               padding        : int  = 2) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial rotation on the wavefront, determined by the\n        the angle parameter. By default the rotation is performed using a\n        simple linear interpolation, but an information perserving rotation\n        using fourier methods can be done by setting `fourier = True`. By\n        default rotation is done on the amplitude and phase arrays, however by\n        passing `real_imgainary=True` the rotation is done on the real and\n        imaginary components.\n\n        Parameters\n        ----------\n        angle : Array, radians\n            The angle by which to rotate the wavefront in a clockwise direction.\n        real_imaginary : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the the amplitude and phase representation.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        order : int = 2\n            The interpolation order to use. Must be 0, 1, or 3.\n        padding : int = 2\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront rotated by angle in the clockwise direction.\n        \"\"\"\n        # Get Field\n        if real_imaginary:\n            field = np.array([self.real, self.imaginary])\n        else:\n            field = np.array([self.amplitude, self.phase])\n\n        # Rotate\n        if field.shape[1] == 1:\n            new_amplitude, new_phase = \\\n            rotate_field(field[:, 0], angle, fourier=fourier,\n                    real_imaginary=real_imaginary, order=order)[:, None, :, :]\n        else:\n            rotator = vmap(rotate_field, in_axes=(1, None))\n            new_amplitude, new_phase = rotator(field, angle, fourier=fourier,\n                                    real_imaginary=real_imaginary, order=order)\n\n        # Update parameters\n        return tree_at(lambda wavefront: (wavefront.amplitude, wavefront.phase),\n                                   self, (new_amplitude, new_phase))\n\n\n    def pad_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n        Paraxially zero-pads the `Wavefront` to the size determined by\n        npixels_out. Note this only supports padding arrays of even dimension\n        to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or\n        3 -&gt; 5.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The size of the array to pad to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` zero-padded to the size npixels_out.\n        \"\"\"\n        npixels_in  = self.npixels\n        assert npixels_in  % 2 == npixels_out % 2, \\\n        (\"Only supports even -&gt; even or odd -&gt; odd padding\")\n        assert npixels_out &gt; npixels_in, (\"npixels_out must be larger than the\"\n        \" current array size: {}\".format(npixels_in))\n\n        new_centre = npixels_out // 2\n        centre = npixels_in  // 2\n        remainder = npixels_in  % 2\n        padded = np.zeros([self.nfields, npixels_out, npixels_out])\n\n        new_amplitude = padded.at[:,\n                new_centre - centre : centre + new_centre + remainder,\n                new_centre - centre : centre + new_centre + remainder\n            ].set(self.amplitude)\n        new_phase = padded.at[:,\n                new_centre - centre : centre + new_centre + remainder,\n                new_centre - centre : centre + new_centre + remainder\n            ].set(self.phase)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def crop_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n        Paraxially crops the `Wavefront` to the size determined by npixels_out.\n        Note this only supports padding arrays of even dimension to even\n        dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The size of the array to crop to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` cropped to the size npixels_out.\n        \"\"\"\n        npixels_in  = self.npixels\n\n        assert npixels_in%2 == npixels_out%2, \\\n        (\"Only supports even -&gt; even or odd -&gt; odd cropping\")\n        assert npixels_out &lt; npixels_in, (\"npixels_out must be smaller than the\"\n        \" current array size: {}\".format(npixels_in))\n\n        new_centre = npixels_in  // 2\n        centre = npixels_out // 2\n\n        new_amplitude = self.amplitude[:,\n            new_centre - centre : new_centre + centre,\n            new_centre - centre : new_centre + centre]\n        new_phase = self.phase[:,\n            new_centre - centre : new_centre + centre,\n            new_centre - centre : new_centre + centre]\n\n        return self.set_phasor(new_amplitude, new_phase)\n</pre> class Wavefront(Base, ABC):     \"\"\"     A class representing some wavefront, designed to track the various     parameters such as wavelength, pixel_scale, amplitude and phase, as well as     a helper parmeter, plane_type.      All wavefronts currently only support square amplitude and phase arrays.      Attributes     ----------     wavelength : float, meters         The wavelength of the `Wavefront`.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     pixel_scale : float, meters/pixel or radians/pixel         The physical dimensions of the pixels representing the wavefront. This         can be in units of either meters per pixel or radians per pixel         depending on both the plane type and the wavfront type (Cartesian or         Angular).     plane_type : enum.IntEnum.PlaneType         The current plane type of wavefront, can be Pupil, Focal or         Intermediate.     \"\"\"     wavelength  : Array     pixel_scale : Array     plane_type  : PlaneType     amplitude   : Array     phase       : Array       def __init__(self        : Wavefront,                  wavelength  : Array,                  pixel_scale : Array,                  amplitude   : Array,                  phase       : Array,                  plane_type  : PlaneType) -&gt; Wavefront:         \"\"\"         Constructor for the wavefront.          Parameters         ----------         wavelength : float, meters             The wavelength of the `Wavefront`.         pixel_scale : float, meters/pixel             The physical dimensions of each square pixel.         amplitude : Array, power             The electric field amplitude of the `Wavefront`.         phase : Array, radians             The electric field phase of the `Wavefront`.         plane_type : enum.IntEnum.PlaneType             The current plane of wavefront, can be Pupil, Focal.         \"\"\"         self.wavelength  = np.asarray(wavelength,  dtype=float)         self.pixel_scale = np.asarray(pixel_scale, dtype=float)         self.amplitude   = np.asarray(amplitude,   dtype=float)         self.phase       = np.asarray(phase,       dtype=float)         self.plane_type  = plane_type          # Input checks         assert self.wavelength.shape == (), \\         (\"wavelength must be a scalar Array.\")         assert self.pixel_scale.shape == (), \\         (\"pixel_scale must be a scalar Array.\")         assert self.amplitude.ndim == 3, \\         (\"amplitude must a 3d array (nfields, npix, npix).\")         assert self.phase.ndim == 3, \\         (\"phase must a 3d array (nfields, npix, npix).\")         assert self.amplitude.shape == self.phase.shape, \\         (\"The amplitude and phase arrays must have the same shape.\")         assert isinstance(plane_type, PlaneType), \\         (\"plane_type must a PlaneType object.\")       ########################     ### Getter Functions ###     ########################     @property     def diameter(self : Wavefront) -&gt; Array:         \"\"\"         Returns the current wavefront diameter calulated using the pixel scale         and number of pixels.          Returns         -------         diameter : Array, meters or radians             The current diameter of the wavefront.         \"\"\"         return self.npixels * self.pixel_scale       @property     def npixels(self : Wavefront) -&gt; int:         \"\"\"         Returns the side length of the arrays currently representing the         wavefront. Taken from the amplitude array.          Returns         -------         pixels : int             The number of pixels that represent the `Wavefront`.         \"\"\"         return self.amplitude.shape[-1]       @property     def nfields(self : Wavefront) -&gt; int:         \"\"\"         Returns the number of polarisation fields currently representing the         wavefront. Taken from the amplitude array first dimension.          Returns         -------         pixels : int             The number of polarisation fields that represent the `Wavefront`.         \"\"\"         return self.amplitude.shape[0]       @property     def real(self : Wavefront) -&gt; Array:         \"\"\"         Returns the real component of the `Wavefront`.          Returns         -------         wavefront : Array             The real component of the `Wavefront` phasor.         \"\"\"         return self.amplitude * np.cos(self.phase)       @property     def imaginary(self : Wavefront) -&gt; Array:         \"\"\"         Returns the imaginary component of the `Wavefront`.          Returns         -------         wavefront : Array             The imaginary component of the `Wavefront` phasor.         \"\"\"         return self.amplitude * np.sin(self.phase)       @property     def phasor(self : Wavefront) -&gt; Array:         \"\"\"         The electric field phasor described by this Wavefront in complex form.          Returns         -------         field : Array             The electric field phasor of the wavefront.         \"\"\"         return self.amplitude * np.exp(1j * self.phase)       @property     def psf(self : Wavefront) -&gt; Array:         \"\"\"         Calculates the Point Spread Function (PSF), ie the squared modulus         of the complex wavefront.          Returns         -------         psf : Array             The PSF of the wavefront.         \"\"\"         return np.sum(self.amplitude ** 2, axis=0)       @property     def pixel_coordinates(self : Wavefront) -&gt; Array:         \"\"\"         Returns the physical positions of the wavefront pixels in meters.          Returns         -------         pixel_positions : Array             The coordinates of the centers of each pixel representing the             wavefront.         \"\"\"         # return get_pixel_coordinates(self.npixels, self.pixel_scale)         return get_pixel_positions((self.npixels, self.npixels),                                     (self.pixel_scale, self.pixel_scale))       @property     def wavenumber(self : Wavefront) -&gt; Array:         \"\"\"         Returns the wavenumber of the wavefront (2 * pi / wavelength).          Returns         -------         wavenumber : Array, 1/meters             The wavenumber of the wavefront.         \"\"\"         return 2 * np.pi / self.wavelength       ########################     ### Setter Functions ###     ########################     def set_amplitude(self : Wavefront, amplitude : Array) -&gt; Wavefront:         \"\"\"         Mutator for the amplitude attribute.          Parameters         ---------         amplitude : Array, power             The electric field amplitude of the `Wavefront`.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the updated amplitude.         \"\"\"         assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\         (\"amplitude must be a 3d array.\")         return tree_at(             lambda wavefront : wavefront.amplitude, self, amplitude)       def set_phase(self : Wavefront, phase : Array) -&gt; Wavefront:         \"\"\"         Mutator for the phase attribute.          Parameters         ----------         phase : Array, radians             The phases of each pixel on the `Wavefront`.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the updated phase.         \"\"\"         assert isinstance(phase, Array) and phase.ndim == 3, \\         (\"phase must be a 3d array.\")         return tree_at(             lambda wavefront : wavefront.phase, self, phase)       def set_pixel_scale(self : Wavefront, pixel_scale : Array) -&gt; Wavefront:         \"\"\"         Mutator for the pixel_scale attribute.          Parameters         ----------         pixel_scale : Array             The new pixel_scale associated with the wavefront.          Returns         -------         wavefront : Wavefront             The new Wavefront object with the updated pixel_scale.         \"\"\"         assert isinstance(pixel_scale, Array) and pixel_scale.ndim == 0, \\         (\"pixel_scale must be a scalar array.\")         return tree_at(             lambda wavefront : wavefront.pixel_scale, self, pixel_scale)       def set_plane_type(self : Wavefront, plane : PlaneType) -&gt; Wavefront:         \"\"\"         Mutator for the PlaneType attribute.          Parameters         ----------         plane : PlaneType             A PlaneType object describing the plane that the `Wavefront` is             currently in.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the update plate_type information.         \"\"\"         assert isinstance(plane, PlaneType), \\         (\"plane must be a PlaneType object.\")         return tree_at(             lambda wavefront : wavefront.plane_type, self, plane)       def set_phasor(self      : Wavefront,                       amplitude : Array,                       phase     : Array) -&gt; Wavefront:         \"\"\"         Updates the phasor of the wavefront (ie both the amplitude and the         phase).          Parameters         ----------         amplitude : Array, power             The new electric field amplitude of the wavefront.         phase : Array, radians             The new electric field phase of the wavefront.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with updated amplitude and phase.         \"\"\"         assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\         (\"amplitude must be a 3d array.\")         assert isinstance(phase, Array) and phase.ndim == 3, \\         (\"phase must be a 3d array.\")         assert amplitude.shape == phase.shape, \\         (\"amplitude and phase arrays must have the same shape.\")         return tree_at(             lambda wavefront : (wavefront.amplitude, wavefront.phase), self,                                (amplitude, phase))       #######################     ### Other Functions ###     #######################     def tilt_wavefront(self : Wavefront, tilt_angles : Array) -&gt; Wavefront:         \"\"\"         Tilts the wavefront by the tilt_angles.          Parameters         ----------         tilt_angles : Array, radians             The (x, y) angles by which to tilt the wavefront.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the (x, y) tilts applied.         \"\"\"         assert isinstance(tilt_angles, Array) and tilt_angles.shape == (2,), \\         (\"tilt_angles must be an array with shape (2,) ie. (x, y).\")          opds = tilt_angles[:, None, None] * self.pixel_coordinates         return self.add_phase(- self.wavenumber * opds.sum(0))       def multiply_amplitude(self : Wavefront, array_like : Array) -&gt; Wavefront:         \"\"\"         Multiply the amplitude of the `Wavefront` by either a float or array.          Parameters         ----------         array_like : Array             An array or float that has the same dimensions as amplitude that is             multipled by the current ampltide.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the updated amplitude.         \"\"\"         amplitude = self.amplitude         assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\         (\"array_like must be either a scalar array or array with 2 or 3 \"          \"dimensions.\")         if array_like.ndim in (2, 3):             assert array_like.shape[-2:] == amplitude.shape[-2:], \\             (\"array_like shape must be equal to the current ampltude array.\")         return self.set_amplitude(amplitude * array_like)       def add_phase(self : Wavefront, array_like : Array) -&gt; Wavefront:         \"\"\"         Add to the phase of the `Wavefront` by either a float or array.          Parameters         ----------         array_like : Array             An array or float that has the same dimensions as phase that is             added to the current phase.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the updated phase.         \"\"\"         phase = self.phase         assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\         (\"array_like must be either a scalar array or array with 2 or 3 \"          \"dimensions.\")         if array_like.ndim in (2, 3):             assert array_like.shape[-2:] == phase.shape[-2:], \\             (\"array_like shape must be equal to the current phase array.\")         return self.set_phase(phase + array_like)       def add_opd(self: Wavefront, path_difference : Array) -&gt; Wavefront:         \"\"\"         Applies the wavelength-dependent phase based on the supplied optical         path difference.          Parameters         ----------         path_difference : Array, meters             The physical optical path difference of either the entire wavefront             or each pixel individually.          Returns         -------         wavefront : Wavefront             The new wavefront with the phases updated according to the supplied             path_difference         \"\"\"         assert isinstance(path_difference, Array) and \\         path_difference.ndim in (0, 2, 3), (\"path_difference must be either a \"         \"scalar array or array with 2 or 3 dimensions.\")         phase_difference = self.wavenumber * path_difference         return self.add_phase(phase_difference)       def normalise(self : Wavefront) -&gt; Wavefront:         \"\"\"         Normalises the total power of the wavefront to 1.          Returns         -------         wavefront : Wavefront             The new wavefront with the normalised electric field amplitudes.         \"\"\"         return self.multiply_amplitude(1 / np.linalg.norm(self.amplitude))       def wavefront_to_psf(self             : Wavefront,                          return_polarised : bool = False) -&gt; Array:         \"\"\"         Calculates the Point Spread Function (PSF), ie the squared modulus         of the complex wavefront.          TODO: Take in the parameters dictionary and use the parameters in that         to determine the way to output the wavefront.          Returns         -------         psf : Array             The PSF of the wavefront.         \"\"\"         return np.sum(self.amplitude ** 2, axis=0)       def invert_x_and_y(self : Wavefront) -&gt; Wavefront:         \"\"\"         Reflects the wavefront about both axes.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the phase and amplitude arrays reversed             along both axes.         \"\"\"         new_amplitude = np.flip(self.amplitude, axis=(-1, -2))         new_phase = np.flip(self.phase, axis=(-1, -2))         return self.set_phasor(new_amplitude, new_phase)       def invert_x(self : Wavefront) -&gt; Wavefront:         \"\"\"         Reflects the wavefront about the x axis.          Returns         -------         wavefront : Wavefront             The new `Wavefront` with the phase and amplitude arrays reversed             along the x axis.         \"\"\"         new_amplitude = np.flip(self.amplitude, axis=-1)         new_phase = np.flip(self.phase, axis=-1)         return self.set_phasor(new_amplitude, new_phase)       def invert_y(self : Wavefront) -&gt; Wavefront:         \"\"\"         Reflects the wavefront about the y axis.          Returns         -------         wavefront : Wavefront             The new wavefront with the phase and amplitude arrays reversed             along the y axis.         \"\"\"         new_amplitude = np.flip(self.amplitude, axis=-2)         new_phase = np.flip(self.phase, axis=-2)         return self.set_phasor(new_amplitude, new_phase)       def interpolate(self            : Wavefront,                     npixels_out     : int,                     pixel_scale_out : Array,                     real_imaginary  : bool = False) -&gt; Wavefront:         \"\"\"         Performs a paraxial interpolation on the wavefront, determined by the         the pixel_scale_out and npixels_out parameters. By default the         interpolation is done on the amplitude and phase arrays, however by         passing `real_imgainary=True` the interpolation is done on the real and         imaginary components. This option allows for consistent interpolation         behaviour when the phase array has a large amount of wrapping.         Automatically conserves energy though the interpolation.          Parameters         ----------         npixels_out : int             The number of pixels representing the wavefront after the             interpolation.         pixel_scale_out : Array             The pixel scale of the array after the interpolation.         real_imaginary : bool = False             Whether to interpolate the real and imaginary representation of the             wavefront as opposed to the the amplitude and phase representation.          Returns         -------         wavefront : Wavefront             The new wavefront interpolated to the size and shape determined by             npixels_out and pixel_scale_out, with the updated pixel_scale.         \"\"\"         sampling_ratio = pixel_scale_out / self.pixel_scale         if real_imaginary:             field = np.array([self.real, self.imaginary])         else:             field = np.array([self.amplitude, self.phase])          if field.shape[1] == 1:             new_amplitude, new_phase = \\             interpolate_field(field[:, 0], npixels_out, sampling_ratio,                               real_imaginary=real_imaginary)[:, None, :, :]         else:             interpolator = vmap(interpolate_field, in_axes=(1, None, None))             new_amplitude, new_phase = interpolator(field, npixels_out,                                 sampling_ratio, real_imaginary=real_imaginary)          # Update parameters         return tree_at(lambda wavefront:                  (wavefront.amplitude, wavefront.phase, wavefront.pixel_scale),                         self, (new_amplitude, new_phase, pixel_scale_out))       def rotate(self           : Wavefront,                angle          : Array,                real_imaginary : bool = False,                fourier        : bool = False,                order          : int  = 1,                padding        : int  = 2) -&gt; Wavefront:         \"\"\"         Performs a paraxial rotation on the wavefront, determined by the         the angle parameter. By default the rotation is performed using a         simple linear interpolation, but an information perserving rotation         using fourier methods can be done by setting `fourier = True`. By         default rotation is done on the amplitude and phase arrays, however by         passing `real_imgainary=True` the rotation is done on the real and         imaginary components.          Parameters         ----------         angle : Array, radians             The angle by which to rotate the wavefront in a clockwise direction.         real_imaginary : bool = False             Whether to rotate the real and imaginary representation of the             wavefront as opposed to the the amplitude and phase representation.         fourier : bool = False             Should the fourier rotation method be used (True), or regular             interpolation method be used (False).         order : int = 2             The interpolation order to use. Must be 0, 1, or 3.         padding : int = 2             The amount of fourier padding to use. Only applies if fourier is             True.           Returns         -------         wavefront : Wavefront             The new wavefront rotated by angle in the clockwise direction.         \"\"\"         # Get Field         if real_imaginary:             field = np.array([self.real, self.imaginary])         else:             field = np.array([self.amplitude, self.phase])          # Rotate         if field.shape[1] == 1:             new_amplitude, new_phase = \\             rotate_field(field[:, 0], angle, fourier=fourier,                     real_imaginary=real_imaginary, order=order)[:, None, :, :]         else:             rotator = vmap(rotate_field, in_axes=(1, None))             new_amplitude, new_phase = rotator(field, angle, fourier=fourier,                                     real_imaginary=real_imaginary, order=order)          # Update parameters         return tree_at(lambda wavefront: (wavefront.amplitude, wavefront.phase),                                    self, (new_amplitude, new_phase))       def pad_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:         \"\"\"         Paraxially zero-pads the `Wavefront` to the size determined by         npixels_out. Note this only supports padding arrays of even dimension         to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or         3 -&gt; 5.          Parameters         ----------         npixels_out : int             The size of the array to pad to the wavefront to.          Returns         -------         wavefront : Wavefront             The new `Wavefront` zero-padded to the size npixels_out.         \"\"\"         npixels_in  = self.npixels         assert npixels_in  % 2 == npixels_out % 2, \\         (\"Only supports even -&gt; even or odd -&gt; odd padding\")         assert npixels_out &gt; npixels_in, (\"npixels_out must be larger than the\"         \" current array size: {}\".format(npixels_in))          new_centre = npixels_out // 2         centre = npixels_in  // 2         remainder = npixels_in  % 2         padded = np.zeros([self.nfields, npixels_out, npixels_out])          new_amplitude = padded.at[:,                 new_centre - centre : centre + new_centre + remainder,                 new_centre - centre : centre + new_centre + remainder             ].set(self.amplitude)         new_phase = padded.at[:,                 new_centre - centre : centre + new_centre + remainder,                 new_centre - centre : centre + new_centre + remainder             ].set(self.phase)         return self.set_phasor(new_amplitude, new_phase)       def crop_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:         \"\"\"         Paraxially crops the `Wavefront` to the size determined by npixels_out.         Note this only supports padding arrays of even dimension to even         dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.          Parameters         ----------         npixels_out : int             The size of the array to crop to the wavefront to.          Returns         -------         wavefront : Wavefront             The new `Wavefront` cropped to the size npixels_out.         \"\"\"         npixels_in  = self.npixels          assert npixels_in%2 == npixels_out%2, \\         (\"Only supports even -&gt; even or odd -&gt; odd cropping\")         assert npixels_out &lt; npixels_in, (\"npixels_out must be smaller than the\"         \" current array size: {}\".format(npixels_in))          new_centre = npixels_in  // 2         centre = npixels_out // 2          new_amplitude = self.amplitude[:,             new_centre - centre : new_centre + centre,             new_centre - centre : new_centre + centre]         new_phase = self.phase[:,             new_centre - centre : new_centre + centre,             new_centre - centre : new_centre + centre]          return self.set_phasor(new_amplitude, new_phase) In\u00a0[\u00a0]: Copied! <pre>class CartesianWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. CartesianWavefronts have pixel scales in\n    units of meters per pixel in all planes.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of the pixels representing the wavefront.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for Cartesian wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel\n            The physical dimensions of each pixel.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</pre> class CartesianWavefront(Wavefront):     \"\"\"     A class representing some wavefront, designed to track the various     parameters such as wavelength, pixel_scale, amplitude and phase, as well as     a helper parmeter, plane_type. CartesianWavefronts have pixel scales in     units of meters per pixel in all planes.      Attributes     ----------     wavelength : float, meters         The wavelength of the `Wavefront`.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     pixel_scale : float, meters/pixel         The physical dimensions of the pixels representing the wavefront.     plane_type : enum.IntEnum.PlaneType         The current plane type of wavefront, can be Pupil, Focal or         Intermediate.     \"\"\"       def __init__(self        : Wavefront,                  wavelength  : Array,                  pixel_scale : Array,                  amplitude   : Array,                  phase       : Array,                  plane_type  : PlaneType) -&gt; Wavefront:         \"\"\"         Constructor for Cartesian wavefronts.          Parameters         ----------         wavelength : float, meters             The wavelength of the `Wavefront`.         pixel_scale : float, meters/pixel             The physical dimensions of each pixel.         amplitude : Array, power             The electric field amplitude of the `Wavefront`.         phase : Array, radians             The electric field phase of the `Wavefront`.         plane_type : enum.IntEnum.PlaneType             The current plane of wavefront, can be Pupil, Focal.         \"\"\"         super().__init__(wavelength, pixel_scale,                          amplitude, phase, plane_type) In\u00a0[\u00a0]: Copied! <pre>class AngularWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. AngularWavefronts have pixel scales in\n    units of meters per pixel in Pupil planes and radians per pixel in Focal\n    planes.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        is in units of meters per pixel in pupil planes and radians per pixel\n        in focal planes.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for Angular wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The physical dimensions of each pixel. Units are in meters\n            per pixel in Pupil planes and radians per pixel in Focal planes.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</pre> class AngularWavefront(Wavefront):     \"\"\"     A class representing some wavefront, designed to track the various     parameters such as wavelength, pixel_scale, amplitude and phase, as well as     a helper parmeter, plane_type. AngularWavefronts have pixel scales in     units of meters per pixel in Pupil planes and radians per pixel in Focal     planes.      Attributes     ----------     wavelength : float, meters         The wavelength of the `Wavefront`.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     pixel_scale : float, meters/pixel or radians/pixel         The physical dimensions of the pixels representing the wavefront. This         is in units of meters per pixel in pupil planes and radians per pixel         in focal planes.     plane_type : enum.IntEnum.PlaneType         The current plane type of wavefront, can be Pupil, Focal or         Intermediate.     \"\"\"       def __init__(self        : Wavefront,                  wavelength  : Array,                  pixel_scale : Array,                  amplitude   : Array,                  phase       : Array,                  plane_type  : PlaneType) -&gt; Wavefront:         \"\"\"         Constructor for Angular wavefronts.          Parameters         ----------         wavelength : float, meters             The wavelength of the `Wavefront`.         pixel_scale : float, meters/pixel or radians/pixel             The physical dimensions of each pixel. Units are in meters             per pixel in Pupil planes and radians per pixel in Focal planes.         amplitude : Array, power             The electric field amplitude of the `Wavefront`.         phase : Array, radians             The electric field phase of the `Wavefront`.         plane_type : enum.IntEnum.PlaneType             The current plane of wavefront, can be Pupil, Focal.         \"\"\"         super().__init__(wavelength, pixel_scale,                          amplitude, phase, plane_type) In\u00a0[\u00a0]: Copied! <pre>class FarFieldFresnelWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. FarFieldFresnelWavefronts are designed to\n    work with FarFieldFresnel Propagators, and are better able to represent the\n    behaviour of wavefronts outside of the focal planes, in the far-field\n    approximation.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of the pixels representing the wavefront.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for FarFieldFresnel wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel or radians.pixl\n            The physical dimensions of each pixel. Units are in meters\n            per pixel in Pupil planes and meters per pixel or radians per pixel\n            in Focal planes depending on if Cartesian or Angular Propagators\n            are used respectively.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</pre> class FarFieldFresnelWavefront(Wavefront):     \"\"\"     A class representing some wavefront, designed to track the various     parameters such as wavelength, pixel_scale, amplitude and phase, as well as     a helper parmeter, plane_type. FarFieldFresnelWavefronts are designed to     work with FarFieldFresnel Propagators, and are better able to represent the     behaviour of wavefronts outside of the focal planes, in the far-field     approximation.      Attributes     ----------     wavelength : float, meters         The wavelength of the `Wavefront`.     amplitude : Array, power         The electric field amplitude of the `Wavefront`.     phase : Array, radians         The electric field phase of the `Wavefront`.     pixel_scale : float, meters/pixel         The physical dimensions of the pixels representing the wavefront.     plane_type : enum.IntEnum.PlaneType         The current plane type of wavefront, can be Pupil, Focal or         Intermediate.     \"\"\"       def __init__(self        : Wavefront,                  wavelength  : Array,                  pixel_scale : Array,                  amplitude   : Array,                  phase       : Array,                  plane_type  : PlaneType) -&gt; Wavefront:         \"\"\"         Constructor for FarFieldFresnel wavefronts.          Parameters         ----------         wavelength : float, meters             The wavelength of the `Wavefront`.         pixel_scale : float, meters/pixel or radians.pixl             The physical dimensions of each pixel. Units are in meters             per pixel in Pupil planes and meters per pixel or radians per pixel             in Focal planes depending on if Cartesian or Angular Propagators             are used respectively.         amplitude : Array, power             The electric field amplitude of the `Wavefront`.         phase : Array, radians             The electric field phase of the `Wavefront`.         plane_type : enum.IntEnum.PlaneType             The current plane of wavefront, can be Pupil, Focal.         \"\"\"         super().__init__(wavelength, pixel_scale,                          amplitude, phase, plane_type)"},{"location":"dLux/dev/FFTfresnel/","title":"FFTfresnel","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre>import dLux\nimport typing\nimport jax \nimport jax.numpy as np\nimport equinox as eqx\n</pre> import dLux import typing import jax  import jax.numpy as np import equinox as eqx In\u00a0[\u00a0]: Copied! <pre>Scalar = typing.NewType(\"Scalar\", np.ndarray) # 0d\nVector = typing.NewType(\"Vector\", np.ndarray) # 1d\nArray =  typing.NewType(\"Array\",  np.ndarray) # 2d +\n</pre> Scalar = typing.NewType(\"Scalar\", np.ndarray) # 0d Vector = typing.NewType(\"Vector\", np.ndarray) # 1d Array =  typing.NewType(\"Array\",  np.ndarray) # 2d + In\u00a0[\u00a0]: Copied! <pre># Base \u2202Lux Objects\nWavefront   = typing.NewType(\"Wavefront\",   dLux.Wavefront)\nPropagator  = typing.NewType(\"Propagator\",  dLux.Propagator)\nPlaneType   = typing.NewType(\"PlaneType\",   dLux.PlaneType)\nLayer       = typing.NewType(\"Layers\",  object)\n</pre> # Base \u2202Lux Objects Wavefront   = typing.NewType(\"Wavefront\",   dLux.Wavefront) Propagator  = typing.NewType(\"Propagator\",  dLux.Propagator) PlaneType   = typing.NewType(\"PlaneType\",   dLux.PlaneType) Layer       = typing.NewType(\"Layers\",  object) In\u00a0[\u00a0]: Copied! <pre>class GaussianWavefront(dLux.Wavefront):\n\"\"\"\n    Expresses the behaviour and state of a wavefront propagating in \n    an optical system under the fresnel assumptions. This \n    implementation is based on the same class from the `poppy` \n    library [poppy](https://github.com/spacetelescope/poppy/fresnel.py)\n    and Chapter 3 from _Applied Optics and Optical Engineering_\n    by Lawrence G. N.\n\n    Approximates the wavefront as a Gaussian Beam parameterised by the \n    radius of the beam, the phase radius, the phase factor and the \n    Rayleigh distance. Propagation is based on two different regimes \n    for a total of four different opertations. \n    Attributes\n    ----------\n    position : float, meters\n        The position of the wavefront in the optical system.\n    beam_radius : float, meters \n        The *initial* radius of the beam. \n    waist_position : float, meters\n        The position of the beam waist along the optical axis. \n    spherical : bool\n        A convinience tracker for knowing if the wavefront is \n        currently spherical.\n    rayleigh_factor : float\n        Used to determine the range over which the wavefront remains\n        planar. \n    focal_length : float, meters\n        Used for the conversion between angular and physical units. \n    \"\"\"\n    angular : bool\n    spherical : bool\n    waist_radius : Scalar\n    position : Scalar\n    waist_position : Scalar\n    rayleigh_factor : Scalar\n    focal_length : Scalar\n    \n \n    def __init__(self            : Wavefront,\n                 wavelength      : Scalar,\n                 offset          : Vector,\n                 pixel_scale     : Scalar,\n                 plane_type      : PlaneType,\n                 amplitude       : Array, \n                 phase           : Array,\n                 waist_radius    : Scalar,\n                 rayleigh_factor : Scalar = 2.) -&gt; Wavefront:\n\"\"\"\n        Creates a wavefront with an empty amplitude and phase \n        arrays but of a given wavelength and phase offset. \n        Assumes that the beam starts at the waist following from \n        the `poppy` convention.\n\n        Parameters\n        ----------\n        beam_radius : float, meters\n            Radius of the beam at the initial optical plane.\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        offset : Array, radians\n            The (x, y) angular offset of the `Wavefront` from \n            the optical axis.\n        rayleigh_factor : float\n            A multiplicative factor determining the threshold for \n            considering the wavefront spherical.\n        \"\"\"\n        super().__init__(wavelength, offset, pixel_scale, plane_type,\n                        amplitude, phase)\n        self.waist_radius = np.asarray(waist_radius).astype(float)  \n        self.position = np.asarray(0., dtype=float)\n        self.waist_position = np.asarray(0., dtype=float)\n        self.rayleigh_factor = np.asarray(rayleigh_factor, dtype=float)\n        self.focal_length = np.inf \n        self.angular = np.asarray(False, dtype=bool)\n        self.spherical = np.asarray(False, dtype=bool)\n\n        \n    ### Getters ###\n    def get_position(self : Wavefront) -&gt; float:\n\"\"\"\n        Accessor for the position of the wavefront. \n\n        Returns \n        -------\n        position : float \n            The position of the `Wavefront` from its starting point \n            in meters.\n        \"\"\"\n        return self.position\n    \n\n    def get_phase_radius(self : Wavefront) -&gt; float:\n\"\"\"\n        Accessor for the phase radius of the wavefront.\n\n        Returns\n        -------\n        phase_radius : float \n            The phase radius of the wavefront. This is a unitless \n            quantity.\n        \"\"\"\n        return self.phase_radius\n    \n    \n    def get_pixel_positions(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns\n        -------\n        positions : Tensor, meters\n            The position of each pixel aligned according to the `fft` \n            algorithm that is implemented by `numpy`.\n        \"\"\"\n        pixels = self.number_of_pixels()\n        positions = np.array(np.indices((pixels, pixels)) - pixels / 2.)\n        return self.get_pixel_scale() * positions\n\n\n    def is_angular(self : Wavefront) -&gt; bool:\n\"\"\"\n        \"\"\"\n        return self.angular\n    \n    # NOTE: The pixel scale cannot be set when self.angular == True\n    # NOTE: This has the correct units always/\n    def get_pixel_scale(self : Wavefront):\n\"\"\"\n        NOTE - This seems dodgey, becuase if we enfore only using\n        getter and setter this would result in inifinite recursion.\n        Maybe this is okay though becuase it IS The getter\n        Returns\n        -------\n        pixel_scale : The width of a single pixel in the array\n            representing the `Wavefront`. Note that this differs\n            from `poppy` because it includes the oversample. \n        \"\"\"\n        return jax.lax.cond(self.is_angular(),\n            lambda : self.pixel_scale / self.focal_length,\n            lambda : self.pixel_scale)\n    \n    \n    def get_waist_radius(self : Wavefront):\n\"\"\"\n        Calculates the current waist radius as half of the diameter\n        Mainly just exists to keep consistency with textbook terms\n        \"\"\"\n        return self.waist_radius\n\n\n    def rayleigh_distance(self : Wavefront) -&gt; Scalar:\n\"\"\"\n        Calculates the rayleigh distance of the Gaussian beam.\n        Returns\n        -------\n        rayleigh_distance : float\n            The Rayleigh distance of the wavefront in metres.\n        \"\"\"\n        return np.pi * self.get_waist_radius() ** 2 / self.get_wavelength()\n    \n    \n    ### Setters ###\n    # NOT USED\n    def set_position(self : Wavefront, \n            position : float) -&gt; Wavefront:\n\"\"\"\n        Mutator for the position of the wavefront. Changes the \n        pixel_scale which is a function of the position.  \n\n        Parameters\n        ----------\n        position : float\n            The new position of the wavefront from its starting point \n            assumed to be in meters. \n        Returns\n        -------\n        wavefront : Wavefront\n            This wavefront at the new position. \n        \"\"\"\n        return eqx.tree_at(\n            lambda wavefront : wavefront.position, self, position,\n            is_leaf = lambda leaf : leaf is None)\n    \n    \n    # NOT UESD\n    def set_phase_radius(self : Wavefront, \n            phase_radius : float) -&gt; Wavefront:\n\"\"\"\n        Mutator for the phase_radius.\n\n        Parameters\n        ----------\n        phase_radius : float\n            The new phase_radius in meters.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            A modified Wavefront with the new phase_radius.\n        \"\"\"\n        return eqx.tree_at(lambda wavefront : wavefront.phase_radius, \n            self, phase_radius, is_leaf = lambda leaf : leaf is None)\n    \n    \n    # NOTE: ordering convention: dunder, _..., ..._at, ..._after, \n    # set_... get_...\n    # NOTE: naming conventself._outside_to_outsideion: position -&gt; absolute place on optical\n    # axis and distance -&gt; movement.\n    def set_waist_position(self : Wavefront, waist_position : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        waist_position : float, meters \n            The absolute position of the waist of the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The `Wavefront` with the updated parameters.  \n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.waist_position,\n            self, waist_position)    \n    \n\n    def set_waist_radius(self : Wavefront, waist_radius : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        beam_radius : float\n            The new beam_radius in meters.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            A modified `Wavefront` with the new `beam_radius`.\n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.waist_radius,\n            self, waist_radius)\n\n\n    def set_spherical(self : Wavefront, spherical : bool) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        spherical : bool\n            Toggle the state of the `Wavefront` to and from `spherical`.\n        Returns\n        -------\n        wavefront : Wavefront \n            The `Wavefront` with the parameters modified. \n        \"\"\"\n        \n        # Pretty sure the 'spherical' input need to wrapped into a jnp array\n        return eqx.tree_at(lambda wave : wave.spherical, self, spherical)\n    \n\n    # TODO: Do I even want to include this functionality as it is \n    # only for the translation between the angular and the physical\n    # coordinates. I'm not sure that we need this. \n    def set_focal_length(self : Wavefront, focal_length : Scalar) -&gt; Wavefront:\n\"\"\"\n        Parameters\n        ----------\n        focal_length : float, meters\n            The `focal_length` of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The `Wavefront` with the parameters modified. \n        \"\"\"\n        return eqx.tree_at(lambda wave : wave.focal_length,\n            self, focal_length)\n\n\n    # NOT USED\n    def calculate_pixel_scale(self: Wavefront, position: float) -&gt; None:\n\"\"\"\n        The pixel scale at the position along the axis of propagation.\n\n        Parameters\n        ----------\n        position : float\n            The position of the wavefront along the axis of propagation\n            in metres.\n        \"\"\"\n        new_pixel_scale = self.get_wavelength() * np.abs(position) / \\\n            self.number_of_pixels() / self.get_pixel_scale()  \n        return new_pixel_scale \n        \n    \n    # NOT USED\n    def is_inside(self: Wavefront, distance: float) -&gt; bool:\n\"\"\" \n        Determines whether a point at along the axis of propagation \n        at distance away from the current position is inside the \n        rayleigh distance. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to test in metres.\n\n        Returns\n        -------\n        inside : bool\n            true if the point is within the rayleigh distance false \n            otherwise.\n        \"\"\"\n        return np.abs(self.get_position() + distance - \\\n            self.waist_position) &lt;= self.rayleigh_distance()\n\n\n    # NOTE: This also needs an ..._after name. I could use something\n    # like quadratic_phase_after() or phase_after() \n    def quadratic_phase(self : Wavefront, distance : Scalar) -&gt; Array:\n\"\"\"\n        Convinience function that simplifies many of the diffraction\n        equations. Caclulates a quadratic phase factor associated with \n        Parameters\n        ----------\n        distance : float\n            The distance of the propagation measured in metres. \n\n        Returns\n        -------\n        phase : float\n            The near-field quadratic phase accumulated by the beam\n            from a propagation of distance.\n        \"\"\"      \n        positions = self.get_pixel_positions()\n        rho_squared = (positions ** 2).sum(axis = 0) \n        return np.exp(1.j * np.pi * rho_squared / distance /\\\n            self.wavelength)\n\n\n    def transfer(self : Wavefront, distance : Scalar) -&gt; Array:\n\"\"\"\n        The optical transfer function (OTF) for the gaussian beam.\n        Assumes propagation is along the axis. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to propagate the wavefront along the beam \n            via the optical transfer function in metres.\n\n        Returns\n        -------\n        phase : float \n            A phase representing the evolution of the wavefront over \n            the distance. \n        \"\"\"\n        positions = self.get_pixel_positions()\n        x, y = positions[0], positions[1]\n        rho_squared = \\\n            (x / (self.get_pixel_scale() ** 2 \\\n                * self.number_of_pixels())) ** 2 + \\\n            (y / (self.get_pixel_scale() ** 2 \\\n                * self.number_of_pixels())) ** 2\n        # Transfer Function of diffraction propagation eq. 22, eq. 87\n        return np.exp(-1.j * np.pi * self.wavelength * \\\n                distance * rho_squared)\n\n\n    def curvature_at(self : Wavefront, position : float) -&gt; float:\n\"\"\"\n        Calculate the radius of curvature of the `Wavefront` phase\n        at the absolute position: `position`.\n\n        Parameters\n        ----------\n        position : float, meters\n            The absolute position of the wave along the optical axis \n            from spawn.\n\n        Returns\n        -------\n        radius_of_curvature : float, radians\n            The radius of phase curvature for the wavefront. \n        \"\"\"\n        relative_position = position - self.waist_position\n        return relative_position + \\\n            self.rayleigh_distance() ** 2 / relative_position\n\n\n    def radius_at(self : Wavefront, position : Scalar) -&gt; Scalar:\n\"\"\"\n        Calculate the radius of the `Wavefront` at an absolute\n        position.\n\n        Parameters\n        ----------\n        position : float, meters\n            The absolute position of the `Wavefront` since spawn.\n        Returns\n        -------\n        radius : float, meters\n            The radius of the beam. \n        \"\"\"\n        relative_position = position - self.waist_position\n        return self.get_waist_radius() * \\\n            np.sqrt(1.0 + \\\n                (relative_position / self.rayleigh_distance()) ** 2)\n\n    \n    def is_planar_at(self : Wavefront, position : Scalar) -&gt; bool:\n\"\"\" \n        Determines whether a point at along the axis of propagation \n        at distance away from the current position is inside the \n        rayleigh distance. \n\n        Parameters\n        ----------\n        distance : float\n            The distance to test in metres.\n\n        Returns\n        -------\n        inside : bool\n            true if the point is within the rayleigh distance false \n            otherwise.\n        \"\"\"\n        return np.abs(self.waist_position - position) \\\n            &lt; self.rayleigh_distance()\n\n    \n    # NOTE: Also updates, so I want better names for these rather than \n    # after. \n    # NOTE: This is only for transitions from planar to spherical \n    # or vice versa so it needs a much better name than current. \n    def pixel_scale_after(self : Wavefront, distance : float) -&gt; Wavefront:\n\"\"\"\n        Calculate and assign the pixel scale of the `Wavefront` after\n        travelling distance. Note that this transformation is dependent\n        on the mode of propagation and is only correct for\n        `_spherical_to_waist` and `_waist_to_spherical` but not for \n        `_plane_to_plane`. \n\n        Parameters\n        ----------\n        distance : float, meters\n            The distance of propagation from the current position.\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront but the pixel_scale has been updated.\n        \"\"\"\n        pixel_scale = self.get_wavelength() * np.abs(distance) /\\\n            (self.number_of_pixels() * self.get_pixel_scale())\n        return self.set_pixel_scale(pixel_scale)\n\n    \n    def position_after(self : Wavefront, \n            distance : Scalar) -&gt; Wavefront:\n\"\"\"\n        Move the wavefront forward by `distance`.\n\n        Parameters\n        ----------\n        distance : float, meters\n            The distance of propagation.\n        Returns\n        -------\n        wavefront : Wavefront \n            The `Wavefront` with the `position` leaf updated.\n        \"\"\"\n        position = self.position + distance\n        return eqx.tree_at(lambda wave : wave.position, self, position)\n</pre> class GaussianWavefront(dLux.Wavefront):     \"\"\"     Expresses the behaviour and state of a wavefront propagating in      an optical system under the fresnel assumptions. This      implementation is based on the same class from the `poppy`      library [poppy](https://github.com/spacetelescope/poppy/fresnel.py)     and Chapter 3 from _Applied Optics and Optical Engineering_     by Lawrence G. N.      Approximates the wavefront as a Gaussian Beam parameterised by the      radius of the beam, the phase radius, the phase factor and the      Rayleigh distance. Propagation is based on two different regimes      for a total of four different opertations.           Attributes     ----------     position : float, meters         The position of the wavefront in the optical system.              beam_radius : float, meters          The *initial* radius of the beam.                        waist_position : float, meters         The position of the beam waist along the optical axis.      spherical : bool         A convinience tracker for knowing if the wavefront is          currently spherical.     rayleigh_factor : float         Used to determine the range over which the wavefront remains         planar.      focal_length : float, meters         Used for the conversion between angular and physical units.      \"\"\"     angular : bool     spherical : bool     waist_radius : Scalar     position : Scalar     waist_position : Scalar     rayleigh_factor : Scalar     focal_length : Scalar            def __init__(self            : Wavefront,                  wavelength      : Scalar,                  offset          : Vector,                  pixel_scale     : Scalar,                  plane_type      : PlaneType,                  amplitude       : Array,                   phase           : Array,                  waist_radius    : Scalar,                  rayleigh_factor : Scalar = 2.) -&gt; Wavefront:         \"\"\"         Creates a wavefront with an empty amplitude and phase          arrays but of a given wavelength and phase offset.          Assumes that the beam starts at the waist following from          the `poppy` convention.          Parameters         ----------         beam_radius : float, meters             Radius of the beam at the initial optical plane.         wavelength : float, meters             The wavelength of the `Wavefront`.         offset : Array, radians             The (x, y) angular offset of the `Wavefront` from              the optical axis.         rayleigh_factor : float             A multiplicative factor determining the threshold for              considering the wavefront spherical.         \"\"\"         super().__init__(wavelength, offset, pixel_scale, plane_type,                         amplitude, phase)         self.waist_radius = np.asarray(waist_radius).astype(float)           self.position = np.asarray(0., dtype=float)         self.waist_position = np.asarray(0., dtype=float)         self.rayleigh_factor = np.asarray(rayleigh_factor, dtype=float)         self.focal_length = np.inf          self.angular = np.asarray(False, dtype=bool)         self.spherical = np.asarray(False, dtype=bool)               ### Getters ###     def get_position(self : Wavefront) -&gt; float:         \"\"\"         Accessor for the position of the wavefront.           Returns          -------         position : float              The position of the `Wavefront` from its starting point              in meters.         \"\"\"         return self.position           def get_phase_radius(self : Wavefront) -&gt; float:         \"\"\"         Accessor for the phase radius of the wavefront.          Returns         -------         phase_radius : float              The phase radius of the wavefront. This is a unitless              quantity.         \"\"\"         return self.phase_radius               def get_pixel_positions(self : Wavefront) -&gt; Array:         \"\"\"         Returns         -------         positions : Tensor, meters             The position of each pixel aligned according to the `fft`              algorithm that is implemented by `numpy`.         \"\"\"         pixels = self.number_of_pixels()         positions = np.array(np.indices((pixels, pixels)) - pixels / 2.)         return self.get_pixel_scale() * positions       def is_angular(self : Wavefront) -&gt; bool:         \"\"\"                  \"\"\"         return self.angular          # NOTE: The pixel scale cannot be set when self.angular == True     # NOTE: This has the correct units always/     def get_pixel_scale(self : Wavefront):         \"\"\"                  NOTE - This seems dodgey, becuase if we enfore only using         getter and setter this would result in inifinite recursion.         Maybe this is okay though becuase it IS The getter                  Returns         -------         pixel_scale : The width of a single pixel in the array             representing the `Wavefront`. Note that this differs             from `poppy` because it includes the oversample.          \"\"\"         return jax.lax.cond(self.is_angular(),             lambda : self.pixel_scale / self.focal_length,             lambda : self.pixel_scale)               def get_waist_radius(self : Wavefront):         \"\"\"         Calculates the current waist radius as half of the diameter                  Mainly just exists to keep consistency with textbook terms         \"\"\"         return self.waist_radius       def rayleigh_distance(self : Wavefront) -&gt; Scalar:         \"\"\"         Calculates the rayleigh distance of the Gaussian beam.                  Returns         -------         rayleigh_distance : float             The Rayleigh distance of the wavefront in metres.         \"\"\"         return np.pi * self.get_waist_radius() ** 2 / self.get_wavelength()               ### Setters ###     # NOT USED     def set_position(self : Wavefront,              position : float) -&gt; Wavefront:         \"\"\"         Mutator for the position of the wavefront. Changes the          pixel_scale which is a function of the position.            Parameters         ----------         position : float             The new position of the wavefront from its starting point              assumed to be in meters.                   Returns         -------         wavefront : Wavefront             This wavefront at the new position.          \"\"\"         return eqx.tree_at(             lambda wavefront : wavefront.position, self, position,             is_leaf = lambda leaf : leaf is None)               # NOT UESD     def set_phase_radius(self : Wavefront,              phase_radius : float) -&gt; Wavefront:         \"\"\"         Mutator for the phase_radius.          Parameters         ----------         phase_radius : float             The new phase_radius in meters.          Returns         -------         wavefront : Wavefront             A modified Wavefront with the new phase_radius.         \"\"\"         return eqx.tree_at(lambda wavefront : wavefront.phase_radius,              self, phase_radius, is_leaf = lambda leaf : leaf is None)               # NOTE: ordering convention: dunder, _..., ..._at, ..._after,      # set_... get_...     # NOTE: naming conventself._outside_to_outsideion: position -&gt; absolute place on optical     # axis and distance -&gt; movement.     def set_waist_position(self : Wavefront, waist_position : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         waist_position : float, meters              The absolute position of the waist of the wavefront.          Returns         -------         wavefront : Wavefront             The `Wavefront` with the updated parameters.           \"\"\"         return eqx.tree_at(lambda wave : wave.waist_position,             self, waist_position)               def set_waist_radius(self : Wavefront, waist_radius : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         beam_radius : float             The new beam_radius in meters.          Returns         -------         wavefront : Wavefront             A modified `Wavefront` with the new `beam_radius`.         \"\"\"         return eqx.tree_at(lambda wave : wave.waist_radius,             self, waist_radius)       def set_spherical(self : Wavefront, spherical : bool) -&gt; Wavefront:         \"\"\"         Parameters         ----------         spherical : bool             Toggle the state of the `Wavefront` to and from `spherical`.                  Returns         -------         wavefront : Wavefront              The `Wavefront` with the parameters modified.          \"\"\"                  # Pretty sure the 'spherical' input need to wrapped into a jnp array         return eqx.tree_at(lambda wave : wave.spherical, self, spherical)           # TODO: Do I even want to include this functionality as it is      # only for the translation between the angular and the physical     # coordinates. I'm not sure that we need this.      def set_focal_length(self : Wavefront, focal_length : Scalar) -&gt; Wavefront:         \"\"\"         Parameters         ----------         focal_length : float, meters             The `focal_length` of the `Wavefront`.          Returns         -------         wavefront : Wavefront             The `Wavefront` with the parameters modified.          \"\"\"         return eqx.tree_at(lambda wave : wave.focal_length,             self, focal_length)       # NOT USED     def calculate_pixel_scale(self: Wavefront, position: float) -&gt; None:         \"\"\"         The pixel scale at the position along the axis of propagation.          Parameters         ----------         position : float             The position of the wavefront along the axis of propagation             in metres.         \"\"\"         new_pixel_scale = self.get_wavelength() * np.abs(position) / \\             self.number_of_pixels() / self.get_pixel_scale()           return new_pixel_scale                    # NOT USED     def is_inside(self: Wavefront, distance: float) -&gt; bool:         \"\"\"          Determines whether a point at along the axis of propagation          at distance away from the current position is inside the          rayleigh distance.           Parameters         ----------         distance : float             The distance to test in metres.          Returns         -------         inside : bool             true if the point is within the rayleigh distance false              otherwise.         \"\"\"         return np.abs(self.get_position() + distance - \\             self.waist_position) &lt;= self.rayleigh_distance()       # NOTE: This also needs an ..._after name. I could use something     # like quadratic_phase_after() or phase_after()      def quadratic_phase(self : Wavefront, distance : Scalar) -&gt; Array:         \"\"\"         Convinience function that simplifies many of the diffraction         equations. Caclulates a quadratic phase factor associated with          Parameters         ----------         distance : float             The distance of the propagation measured in metres.           Returns         -------         phase : float             The near-field quadratic phase accumulated by the beam             from a propagation of distance.         \"\"\"               positions = self.get_pixel_positions()         rho_squared = (positions ** 2).sum(axis = 0)          return np.exp(1.j * np.pi * rho_squared / distance /\\             self.wavelength)       def transfer(self : Wavefront, distance : Scalar) -&gt; Array:         \"\"\"         The optical transfer function (OTF) for the gaussian beam.         Assumes propagation is along the axis.           Parameters         ----------         distance : float             The distance to propagate the wavefront along the beam              via the optical transfer function in metres.          Returns         -------         phase : float              A phase representing the evolution of the wavefront over              the distance.          \"\"\"         positions = self.get_pixel_positions()         x, y = positions[0], positions[1]         rho_squared = \\             (x / (self.get_pixel_scale() ** 2 \\                 * self.number_of_pixels())) ** 2 + \\             (y / (self.get_pixel_scale() ** 2 \\                 * self.number_of_pixels())) ** 2         # Transfer Function of diffraction propagation eq. 22, eq. 87         return np.exp(-1.j * np.pi * self.wavelength * \\                 distance * rho_squared)       def curvature_at(self : Wavefront, position : float) -&gt; float:         \"\"\"         Calculate the radius of curvature of the `Wavefront` phase         at the absolute position: `position`.          Parameters         ----------         position : float, meters             The absolute position of the wave along the optical axis              from spawn.          Returns         -------         radius_of_curvature : float, radians             The radius of phase curvature for the wavefront.          \"\"\"         relative_position = position - self.waist_position         return relative_position + \\             self.rayleigh_distance() ** 2 / relative_position       def radius_at(self : Wavefront, position : Scalar) -&gt; Scalar:         \"\"\"         Calculate the radius of the `Wavefront` at an absolute         position.          Parameters         ----------         position : float, meters             The absolute position of the `Wavefront` since spawn.                  Returns         -------         radius : float, meters             The radius of the beam.          \"\"\"         relative_position = position - self.waist_position         return self.get_waist_radius() * \\             np.sqrt(1.0 + \\                 (relative_position / self.rayleigh_distance()) ** 2)           def is_planar_at(self : Wavefront, position : Scalar) -&gt; bool:         \"\"\"          Determines whether a point at along the axis of propagation          at distance away from the current position is inside the          rayleigh distance.           Parameters         ----------         distance : float             The distance to test in metres.          Returns         -------         inside : bool             true if the point is within the rayleigh distance false              otherwise.         \"\"\"         return np.abs(self.waist_position - position) \\             &lt; self.rayleigh_distance()           # NOTE: Also updates, so I want better names for these rather than      # after.      # NOTE: This is only for transitions from planar to spherical      # or vice versa so it needs a much better name than current.      def pixel_scale_after(self : Wavefront, distance : float) -&gt; Wavefront:         \"\"\"         Calculate and assign the pixel scale of the `Wavefront` after         travelling distance. Note that this transformation is dependent         on the mode of propagation and is only correct for         `_spherical_to_waist` and `_waist_to_spherical` but not for          `_plane_to_plane`.           Parameters         ----------         distance : float, meters             The distance of propagation from the current position.                  Returns         -------         wavefront : Wavefront             The wavefront but the pixel_scale has been updated.         \"\"\"         pixel_scale = self.get_wavelength() * np.abs(distance) /\\             (self.number_of_pixels() * self.get_pixel_scale())         return self.set_pixel_scale(pixel_scale)           def position_after(self : Wavefront,              distance : Scalar) -&gt; Wavefront:         \"\"\"         Move the wavefront forward by `distance`.          Parameters         ----------         distance : float, meters             The distance of propagation.                  Returns         -------         wavefront : Wavefront              The `Wavefront` with the `position` leaf updated.         \"\"\"         position = self.position + distance         return eqx.tree_at(lambda wave : wave.position, self, position) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class GaussianPropagator(eqx.Module):\n    distance : float\n\n    def __init__(self            : Propagator, \n                 distance        : float):\n        self.distance = np.asarray(distance).astype(float)\n\n    def _fourier_transform(self : Propagator, field : Array) -&gt; Array:\n        return 1 / field.shape[0] * np.fft.fft2(field)\n\n    def _inverse_fourier_transform(self : Propagator, field : Array) -&gt; Array:\n        return field.shape[0] * np.fft.ifft2(field)\n\n    # NOTE: need to add in the standard FFT normalising factor\n    # as in the propagator. \n    def _propagate(self : Propagator, field : Array, \n            distance : float) -&gt; Array:\n        return jax.lax.cond(distance &gt; 0,\n            lambda : self._inverse_fourier_transform(field),\n            lambda : self._fourier_transform(field))\n        \n    # NOTE: Wavefront must be planar \n    # NOTE: Uses eq. 82, 86, 87\n    def _plane_to_plane(self : Propagator, wavefront : Wavefront,\n            distance : float):\n        # NOTE: Seriously need to change the name to get_field()        \n        field = self._fourier_transform(wavefront.get_complex_form())\n        field *= np.fft.fftshift(wavefront.transfer(distance))  # eq. 6.68\n        field = self._inverse_fourier_transform(field)\n        \n        wavefront =  wavefront\\\n            .position_after(distance)\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\n        return wavefront\n \n    # NOTE: I'm thinking that the logic for repacking the wavefront\n    # should occur somewhere else although I guess that it can't really\n    # NOTE: Must start with a planar wavefront\n    def _waist_to_spherical(self : Propagator, wavefront : Wavefront, \n            distance : float) -&gt; Wavefront:\n        \n        # Lawrence eq. 83,88\n        field = wavefront.get_complex_form()\n        field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent\n        field = self._propagate(field, distance) # Wrapper for forwards/reverse FFTs\n        wavefront =  wavefront\\\n            .pixel_scale_after(distance)\\\n            .position_after(distance)\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\\\n            .set_spherical(True)   \n        return wavefront\n\n\n    # Wavefront.spherical must be True initially\n    def _spherical_to_waist(self : Propagator, wavefront : Wavefront,\n            distance : float) -&gt; Wavefront:\n        # Lawrence eq. 89\n        field = wavefront.get_complex_form()\n        field = self._propagate(field, distance)\n        wavefront = wavefront.pixel_scale_after(distance)\n        field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent\n        \n        wavefront = wavefront\\\n            .set_phase(np.angle(field))\\\n            .set_amplitude(np.abs(field))\\\n            .set_spherical(True)\\\n            .position_after(distance)\n        return wavefront\n\n    def _inside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:        \n        wave = self._plane_to_plane(wave, self.distance)\n        return wave\n\n\n    def _inside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront: \n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._plane_to_plane(wave, wave.waist_position - start)\n        wave = self._waist_to_spherical(wave, end - wave.waist_position)\n        return wave\n\n\n    def _outside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._spherical_to_waist(wave, wave.waist_position - start)\n        wave = self._plane_to_plane(wave, end - wave.waist_position)\n        return wave\n\n\n    def _outside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        start = wave.position\n        end = wave.position + self.distance\n        wave = self._spherical_to_waist(wave, wave.waist_position - start)\n        wave = self._waist_to_spherical(wave, end - wave.waist_position)\n        return wave\n\n\n    # NOTE: So I could attempt to move all of the functionality into \n    # the wavefront class and do very little here. Damn, I need to \n    # fit it into the overall architecture. \n    # TODO: Implement the oversample in the fixed sampling propagator\n    # Coordiantes must be in meters for the propagator\n    def __call__(self : Propagator, wave : Wavefront) -&gt; Wavefront:\n        # NOTE: need to understand this mystery. \n        field = np.fft.fftshift(wave.get_complex_form())\n        wave = wave.update_phasor(np.abs(field), np.angle(field))\n        position = wave.position + self.distance\n        decision = 2 * wave.spherical + wave.is_planar_at(position)\n        \n        wave = jax.lax.switch(\n            decision,\n            [self._inside_to_outside, self._inside_to_inside, \n            self._outside_to_outside, self._outside_to_inside], wave) \n\n        field = np.fft.fftshift(wave.get_complex_form())\n        wave = wave.update_phasor(np.abs(field), np.angle(field))        \n        return wave\n</pre> class GaussianPropagator(eqx.Module):     distance : float      def __init__(self            : Propagator,                   distance        : float):         self.distance = np.asarray(distance).astype(float)      def _fourier_transform(self : Propagator, field : Array) -&gt; Array:         return 1 / field.shape[0] * np.fft.fft2(field)      def _inverse_fourier_transform(self : Propagator, field : Array) -&gt; Array:         return field.shape[0] * np.fft.ifft2(field)      # NOTE: need to add in the standard FFT normalising factor     # as in the propagator.      def _propagate(self : Propagator, field : Array,              distance : float) -&gt; Array:         return jax.lax.cond(distance &gt; 0,             lambda : self._inverse_fourier_transform(field),             lambda : self._fourier_transform(field))              # NOTE: Wavefront must be planar      # NOTE: Uses eq. 82, 86, 87     def _plane_to_plane(self : Propagator, wavefront : Wavefront,             distance : float):         # NOTE: Seriously need to change the name to get_field()                 field = self._fourier_transform(wavefront.get_complex_form())         field *= np.fft.fftshift(wavefront.transfer(distance))  # eq. 6.68         field = self._inverse_fourier_transform(field)                  wavefront =  wavefront\\             .position_after(distance)\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))         return wavefront       # NOTE: I'm thinking that the logic for repacking the wavefront     # should occur somewhere else although I guess that it can't really     # NOTE: Must start with a planar wavefront     def _waist_to_spherical(self : Propagator, wavefront : Wavefront,              distance : float) -&gt; Wavefront:                  # Lawrence eq. 83,88         field = wavefront.get_complex_form()         field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent         field = self._propagate(field, distance) # Wrapper for forwards/reverse FFTs         wavefront =  wavefront\\             .pixel_scale_after(distance)\\             .position_after(distance)\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))\\             .set_spherical(True)            return wavefront       # Wavefront.spherical must be True initially     def _spherical_to_waist(self : Propagator, wavefront : Wavefront,             distance : float) -&gt; Wavefront:         # Lawrence eq. 89         field = wavefront.get_complex_form()         field = self._propagate(field, distance)         wavefront = wavefront.pixel_scale_after(distance)         field *= np.fft.fftshift(wavefront.quadratic_phase(distance)) # Wavelength dependent                  wavefront = wavefront\\             .set_phase(np.angle(field))\\             .set_amplitude(np.abs(field))\\             .set_spherical(True)\\             .position_after(distance)         return wavefront      def _inside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:                 wave = self._plane_to_plane(wave, self.distance)         return wave       def _inside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:          start = wave.position         end = wave.position + self.distance         wave = self._plane_to_plane(wave, wave.waist_position - start)         wave = self._waist_to_spherical(wave, end - wave.waist_position)         return wave       def _outside_to_inside(self : Propagator, wave : Wavefront) -&gt; Wavefront:         start = wave.position         end = wave.position + self.distance         wave = self._spherical_to_waist(wave, wave.waist_position - start)         wave = self._plane_to_plane(wave, end - wave.waist_position)         return wave       def _outside_to_outside(self : Propagator, wave : Wavefront) -&gt; Wavefront:         start = wave.position         end = wave.position + self.distance         wave = self._spherical_to_waist(wave, wave.waist_position - start)         wave = self._waist_to_spherical(wave, end - wave.waist_position)         return wave       # NOTE: So I could attempt to move all of the functionality into      # the wavefront class and do very little here. Damn, I need to      # fit it into the overall architecture.      # TODO: Implement the oversample in the fixed sampling propagator     # Coordiantes must be in meters for the propagator     def __call__(self : Propagator, wave : Wavefront) -&gt; Wavefront:         # NOTE: need to understand this mystery.          field = np.fft.fftshift(wave.get_complex_form())         wave = wave.update_phasor(np.abs(field), np.angle(field))         position = wave.position + self.distance         decision = 2 * wave.spherical + wave.is_planar_at(position)                  wave = jax.lax.switch(             decision,             [self._inside_to_outside, self._inside_to_inside,              self._outside_to_outside, self._outside_to_inside], wave)           field = np.fft.fftshift(wave.get_complex_form())         wave = wave.update_phasor(np.abs(field), np.angle(field))                 return wave In\u00a0[\u00a0]: Copied! <pre>class GaussianLens(eqx.Module):\n    focal_length : float\n    # TODO: Should this store its position in the optical system?\n    # No I don't think that it should. \n\n    def __init__(self : Layer, focal_length : float) -&gt; Layer:\n        self.focal_length = np.asarray(focal_length).astype(float)\n\n\n    def _phase(self : Layer, wave : Wavefront, \n            distance : float) -&gt; Array:\n        position = wave.get_pixel_positions()\n        rho_squared = (position ** 2).sum(axis = 0)\n        return np.exp(1.j / np.pi * rho_squared / distance *\\\n            wave.wavelength)\n\n\n    def __call__(self : Layer, wave : Wavefront) -&gt; Wavefront:\n        from_waist = wave.waist_position - wave.position\n        was_spherical = np.abs(from_waist) &gt; wave.rayleigh_factor * \\\n            wave.rayleigh_distance()\n\n        curve = wave.curvature_at(wave.position)\n\n        curve_at = jax.lax.cond(\n            was_spherical,\n            lambda : from_waist,\n            lambda : np.inf)\n\n        curve_after = jax.lax.cond(\n            was_spherical,\n            lambda : 1. / (1. / curve  - 1. / self.focal_length),\n            lambda : -self.focal_length)\n\n        radius = wave.radius_at(wave.position)\n        curve_ratio = (wave.wavelength * curve_after / np.pi / radius ** 2) ** 2\n        curve_matched = curve == self.focal_length\n\n        waist_position_after = jax.lax.cond(\n            curve_matched,\n            lambda : wave.position,\n            lambda : -curve_after / (1. + curve_ratio) + wave.position)\n\n        waist_radius_after = jax.lax.cond(\n            curve_matched,\n            lambda : radius,\n            lambda : radius / np.sqrt(1. + 1. / curve_ratio))\n\n        focal_length_after = jax.lax.cond(\n            np.isinf(wave.focal_length),\n            lambda : self.focal_length,\n            lambda : curve_after / curve_at * wave.focal_length)\n\n        wave = wave\\\n            .set_focal_length(focal_length_after)\\\n            .set_waist_radius(waist_radius_after)\\\n            .set_waist_position(waist_position_after)\n\n        from_new_waist = waist_position_after - wave.position\n        is_spherical = np.abs(from_new_waist) &gt; wave.rayleigh_distance()\n \n        distance = 1. / jax.lax.cond(\n            wave.spherical,\n            lambda : jax.lax.cond(\n                is_spherical,\n                lambda : 1. / self.focal_length + 1. / from_new_waist - 1. / curve_at,\n                lambda : 1. / self.focal_length - 1. / curve_at),\n            lambda : jax.lax.cond(\n                is_spherical, \n                lambda : 1. / self.focal_length + 1. / from_new_waist,\n                lambda : 1. / self.focal_length))\n\n        field = wave.get_complex_form() * self._phase(wave, distance)\n        phase = np.angle(field)\n        amplitude = np.abs(field)\n\n        return wave\\\n            .set_phase(phase)\\\n            .set_amplitude(amplitude)\\\n            .set_spherical(is_spherical)\\\n            .set_waist_position(waist_position_after)\\\n            .set_waist_radius(waist_radius_after)\\\n            .set_focal_length(focal_length_after)\n</pre> class GaussianLens(eqx.Module):     focal_length : float     # TODO: Should this store its position in the optical system?     # No I don't think that it should.       def __init__(self : Layer, focal_length : float) -&gt; Layer:         self.focal_length = np.asarray(focal_length).astype(float)       def _phase(self : Layer, wave : Wavefront,              distance : float) -&gt; Array:         position = wave.get_pixel_positions()         rho_squared = (position ** 2).sum(axis = 0)         return np.exp(1.j / np.pi * rho_squared / distance *\\             wave.wavelength)       def __call__(self : Layer, wave : Wavefront) -&gt; Wavefront:         from_waist = wave.waist_position - wave.position         was_spherical = np.abs(from_waist) &gt; wave.rayleigh_factor * \\             wave.rayleigh_distance()          curve = wave.curvature_at(wave.position)          curve_at = jax.lax.cond(             was_spherical,             lambda : from_waist,             lambda : np.inf)          curve_after = jax.lax.cond(             was_spherical,             lambda : 1. / (1. / curve  - 1. / self.focal_length),             lambda : -self.focal_length)          radius = wave.radius_at(wave.position)         curve_ratio = (wave.wavelength * curve_after / np.pi / radius ** 2) ** 2         curve_matched = curve == self.focal_length          waist_position_after = jax.lax.cond(             curve_matched,             lambda : wave.position,             lambda : -curve_after / (1. + curve_ratio) + wave.position)          waist_radius_after = jax.lax.cond(             curve_matched,             lambda : radius,             lambda : radius / np.sqrt(1. + 1. / curve_ratio))          focal_length_after = jax.lax.cond(             np.isinf(wave.focal_length),             lambda : self.focal_length,             lambda : curve_after / curve_at * wave.focal_length)          wave = wave\\             .set_focal_length(focal_length_after)\\             .set_waist_radius(waist_radius_after)\\             .set_waist_position(waist_position_after)          from_new_waist = waist_position_after - wave.position         is_spherical = np.abs(from_new_waist) &gt; wave.rayleigh_distance()           distance = 1. / jax.lax.cond(             wave.spherical,             lambda : jax.lax.cond(                 is_spherical,                 lambda : 1. / self.focal_length + 1. / from_new_waist - 1. / curve_at,                 lambda : 1. / self.focal_length - 1. / curve_at),             lambda : jax.lax.cond(                 is_spherical,                  lambda : 1. / self.focal_length + 1. / from_new_waist,                 lambda : 1. / self.focal_length))          field = wave.get_complex_form() * self._phase(wave, distance)         phase = np.angle(field)         amplitude = np.abs(field)          return wave\\             .set_phase(phase)\\             .set_amplitude(amplitude)\\             .set_spherical(is_spherical)\\             .set_waist_position(waist_position_after)\\             .set_waist_radius(waist_radius_after)\\             .set_focal_length(focal_length_after)"},{"location":"dLux/dev/constants/","title":"Constants","text":"In\u00a0[\u00a0]: Copied! <pre>-\"\"\"\n-dLux/sandbox/JWST/constants.py\n-------------------------------\n-This contains the vertices of the primary mirror segments taken form \n-the WebbPSF package.\n-\"\"\"\n-\n-from jax import numpy as np\n-from jax.config import config\n-\n-\n-config.update(\"jax_enable_x64\", True)\n-\n-\n-JWST_PRIMARY_SEGMENTS = (\n-    ('A1-1', np.array([\n-        [-0.38101, 0.667604],\n-        [-0.758826, 1.321999],\n-        [-0.38101, 1.976407],\n-        [0.38101, 1.976407],\n-        [0.758826, 1.321999],\n-        [0.38101, 0.667604]])),\n-    ('A2-2', np.array([\n-        [0.38765702, 0.66376634],\n-        [0.76547172, 1.31816209],\n-        [1.52111367, 1.31816784],\n-        [1.90212367, 0.65823916],\n-        [1.52429772, 0.00383691],\n-        [0.76866702, 0.00383766]])),\n-    ('A3-3', np.array([\n-        [0.76866702, -0.00383766],\n-        [1.52429772, -0.00383691],\n-        [1.90212367, -0.65823916],\n-        [1.52111367, -1.31816784],\n-        [0.76547172, -1.31816209],\n-        [0.38765702, -0.66376634]])),\n-    ('A4-4', np.array([\n-        [0.38101, -0.667604],\n-        [0.758826, -1.321999],\n-        [0.38101, -1.976407],\n-        [-0.38101, -1.976407],\n-        [-0.758826, -1.321999],\n-        [-0.38101, -0.667604]])),\n-    ('A5-5', np.array([\n-        [-0.38765702, -0.66376634],\n-        [-0.76547172, -1.31816209],\n-        [-1.52111367, -1.31816784],\n-        [-1.90212367, -0.65823916],\n-        [-1.52429772, -0.00383691],\n-        [-0.76866702, -0.00383766]])),\n-    ('A6-6', np.array([\n-        [-0.76866702, 0.00383766],\n-        [-1.52429772, 0.00383691],\n-        [-1.90212367, 0.65823916],\n-        [-1.52111367, 1.31816784],\n-        [-0.76547172, 1.31816209],\n-        [-0.38765702, 0.66376634]])),\n-    ('B1-7', np.array([\n-        [0.38101, 3.279674],\n-        [0.758826, 2.631791],\n-        [0.38101, 1.98402],\n-        [-0.38101, 1.98402],\n-        [-0.758826, 2.631791],\n-        [-0.38101, 3.279674]])),\n-    ('B2-9', np.array([\n-        [3.030786, 1.30987266],\n-        [2.65861086, 0.65873291],\n-        [1.90871672, 0.66204566],\n-        [1.52770672, 1.32197434],\n-        [1.89978486, 1.97305809],\n-        [2.649776, 1.96980134]])),\n-    ('B3-11', np.array([\n-        [2.649776, -1.96980134],\n-        [1.89978486, -1.97305809],\n-        [1.52770672, -1.32197434],\n-        [1.90871672, -0.66204566],\n-        [2.65861086, -0.65873291],\n-        [3.030786, -1.30987266]])),\n-    ('B4-13', np.array([\n-        [-0.38101, -3.279674],\n-        [-0.758826, -2.631791],\n-        [-0.38101, -1.98402],\n-        [0.38101, -1.98402],\n-        [0.758826, -2.631791],\n-        [0.38101, -3.279674]])),\n-    ('B5-15', np.array([\n-        [-3.030786, -1.30987266],\n-        [-2.65861086, -0.65873291],\n-        [-1.90871672, -0.66204566],\n-        [-1.52770672, -1.32197434],\n-        [-1.89978486, -1.97305809],\n-        [-2.649776, -1.96980134]])),\n-    ('B6-17', np.array([\n-        [-2.649776, 1.96980134],\n-        [-1.89978486, 1.97305809],\n-        [-1.52770672, 1.32197434],\n-        [-1.90871672, 0.66204566],\n-        [-2.65861086, 0.65873291],\n-        [-3.030786, 1.30987266]])),\n-    ('C1-8', np.array([\n-        [0.765201, 2.627516],\n-        [1.517956, 2.629178],\n-        [1.892896, 1.976441],\n-        [1.521076, 1.325812],\n-        [0.765454, 1.325807],\n-        [0.387649, 1.980196]])),\n-    ('C2-10', np.array([\n-        [2.6580961, 0.651074495],\n-        [3.03591294, 5.42172989e-07],\n-        [2.65809612, -0.651075523],\n-        [1.90872487, -0.654384457],\n-        [1.53090954, 8.90571587e-07],\n-        [1.90872454, .654384118]])),\n-    ('C3-12', np.array([\n-        [1.8928951, -1.97644151],\n-        [1.51795694, -2.62917746],\n-        [0.76520012, -2.62751652],\n-        [0.38764887, -1.98019646],\n-        [0.76545554, -1.32580611],\n-        [1.52107554, -1.32581188]])),\n-    ('C4-14', np.array([\n-        [-0.765201, -2.627516],\n-        [-1.517956, -2.629178],\n-        [-1.892896, -1.976441],\n-        [-1.521076, -1.325812],\n-        [-0.765454, -1.325807],\n-        [-0.387649, -1.980196]])),\n-    ('C5-16', np.array([\n-        [-2.6580961, -.651074495],\n-        [-3.03591294, -5.42172990e-07],\n-        [-2.65809612, .651075523],\n-        [-1.90872487, .654384457],\n-        [-1.53090954, -8.90571587e-07],\n-        [-1.90872454, -.654384118]])),\n-    ('C6-18', np.array([\n-        [-1.8928951, 1.97644151],\n-        [-1.51795694, 2.62917746],\n-        [-0.76520012, 2.62751652],\n-        [-0.38764887, 1.98019646],\n-        [-0.76545554, 1.32580611],\n-        [-1.52107554, 1.32581188]])),\n-)\n</pre> -\"\"\" -dLux/sandbox/JWST/constants.py ------------------------------- -This contains the vertices of the primary mirror segments taken form  -the WebbPSF package. -\"\"\" - -from jax import numpy as np -from jax.config import config - - -config.update(\"jax_enable_x64\", True) - - -JWST_PRIMARY_SEGMENTS = ( -    ('A1-1', np.array([ -        [-0.38101, 0.667604], -        [-0.758826, 1.321999], -        [-0.38101, 1.976407], -        [0.38101, 1.976407], -        [0.758826, 1.321999], -        [0.38101, 0.667604]])), -    ('A2-2', np.array([ -        [0.38765702, 0.66376634], -        [0.76547172, 1.31816209], -        [1.52111367, 1.31816784], -        [1.90212367, 0.65823916], -        [1.52429772, 0.00383691], -        [0.76866702, 0.00383766]])), -    ('A3-3', np.array([ -        [0.76866702, -0.00383766], -        [1.52429772, -0.00383691], -        [1.90212367, -0.65823916], -        [1.52111367, -1.31816784], -        [0.76547172, -1.31816209], -        [0.38765702, -0.66376634]])), -    ('A4-4', np.array([ -        [0.38101, -0.667604], -        [0.758826, -1.321999], -        [0.38101, -1.976407], -        [-0.38101, -1.976407], -        [-0.758826, -1.321999], -        [-0.38101, -0.667604]])), -    ('A5-5', np.array([ -        [-0.38765702, -0.66376634], -        [-0.76547172, -1.31816209], -        [-1.52111367, -1.31816784], -        [-1.90212367, -0.65823916], -        [-1.52429772, -0.00383691], -        [-0.76866702, -0.00383766]])), -    ('A6-6', np.array([ -        [-0.76866702, 0.00383766], -        [-1.52429772, 0.00383691], -        [-1.90212367, 0.65823916], -        [-1.52111367, 1.31816784], -        [-0.76547172, 1.31816209], -        [-0.38765702, 0.66376634]])), -    ('B1-7', np.array([ -        [0.38101, 3.279674], -        [0.758826, 2.631791], -        [0.38101, 1.98402], -        [-0.38101, 1.98402], -        [-0.758826, 2.631791], -        [-0.38101, 3.279674]])), -    ('B2-9', np.array([ -        [3.030786, 1.30987266], -        [2.65861086, 0.65873291], -        [1.90871672, 0.66204566], -        [1.52770672, 1.32197434], -        [1.89978486, 1.97305809], -        [2.649776, 1.96980134]])), -    ('B3-11', np.array([ -        [2.649776, -1.96980134], -        [1.89978486, -1.97305809], -        [1.52770672, -1.32197434], -        [1.90871672, -0.66204566], -        [2.65861086, -0.65873291], -        [3.030786, -1.30987266]])), -    ('B4-13', np.array([ -        [-0.38101, -3.279674], -        [-0.758826, -2.631791], -        [-0.38101, -1.98402], -        [0.38101, -1.98402], -        [0.758826, -2.631791], -        [0.38101, -3.279674]])), -    ('B5-15', np.array([ -        [-3.030786, -1.30987266], -        [-2.65861086, -0.65873291], -        [-1.90871672, -0.66204566], -        [-1.52770672, -1.32197434], -        [-1.89978486, -1.97305809], -        [-2.649776, -1.96980134]])), -    ('B6-17', np.array([ -        [-2.649776, 1.96980134], -        [-1.89978486, 1.97305809], -        [-1.52770672, 1.32197434], -        [-1.90871672, 0.66204566], -        [-2.65861086, 0.65873291], -        [-3.030786, 1.30987266]])), -    ('C1-8', np.array([ -        [0.765201, 2.627516], -        [1.517956, 2.629178], -        [1.892896, 1.976441], -        [1.521076, 1.325812], -        [0.765454, 1.325807], -        [0.387649, 1.980196]])), -    ('C2-10', np.array([ -        [2.6580961, 0.651074495], -        [3.03591294, 5.42172989e-07], -        [2.65809612, -0.651075523], -        [1.90872487, -0.654384457], -        [1.53090954, 8.90571587e-07], -        [1.90872454, .654384118]])), -    ('C3-12', np.array([ -        [1.8928951, -1.97644151], -        [1.51795694, -2.62917746], -        [0.76520012, -2.62751652], -        [0.38764887, -1.98019646], -        [0.76545554, -1.32580611], -        [1.52107554, -1.32581188]])), -    ('C4-14', np.array([ -        [-0.765201, -2.627516], -        [-1.517956, -2.629178], -        [-1.892896, -1.976441], -        [-1.521076, -1.325812], -        [-0.765454, -1.325807], -        [-0.387649, -1.980196]])), -    ('C5-16', np.array([ -        [-2.6580961, -.651074495], -        [-3.03591294, -5.42172990e-07], -        [-2.65809612, .651075523], -        [-1.90872487, .654384457], -        [-1.53090954, -8.90571587e-07], -        [-1.90872454, -.654384118]])), -    ('C6-18', np.array([ -        [-1.8928951, 1.97644151], -        [-1.51795694, 2.62917746], -        [-0.76520012, 2.62751652], -        [-0.38764887, 1.98019646], -        [-0.76545554, 1.32580611], -        [-1.52107554, 1.32581188]])), -)"},{"location":"dLux/utils/__init__/","title":"init","text":"In\u00a0[\u00a0]: Copied! <pre>name = \"utils\"\n</pre> name = \"utils\" In\u00a0[\u00a0]: Copied! <pre># Import as modules\nfrom . import coordinates\nfrom . import helpers\nfrom . import gradient_energy\nfrom . import interpolation\nfrom . import units\nfrom . import optics\nfrom . import bayes\nfrom . import math\nfrom . import models\n</pre> # Import as modules from . import coordinates from . import helpers from . import gradient_energy from . import interpolation from . import units from . import optics from . import bayes from . import math from . import models In\u00a0[\u00a0]: Copied! <pre># Dont import all functions from modules\nfrom .coordinates     import *\nfrom .helpers         import *\nfrom .gradient_energy import *\nfrom .interpolation   import *\nfrom .units           import *\nfrom .optics          import *\nfrom .bayes           import *\nfrom .models          import *\nfrom .math            import *\n</pre> # Dont import all functions from modules from .coordinates     import * from .helpers         import * from .gradient_energy import * from .interpolation   import * from .units           import * from .optics          import * from .bayes           import * from .models          import * from .math            import * In\u00a0[\u00a0]: Copied! <pre># Add to __all__\n__all__ = coordinates.__all__ + helpers.__all__ + gradient_energy.__all__ + \\\n            interpolation.__all__ + units.__all__ + optics.__all__ + \\\n                bayes.__all__ + models.__all__ + math.__all__\n</pre> # Add to __all__ __all__ = coordinates.__all__ + helpers.__all__ + gradient_energy.__all__ + \\             interpolation.__all__ + units.__all__ + optics.__all__ + \\                 bayes.__all__ + models.__all__ + math.__all__"},{"location":"dLux/utils/bayes/","title":"Bayes","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import hessian, grad\nfrom jax.scipy.stats import poisson\nfrom typing import Callable\n</pre> import jax.numpy as np from jax import hessian, grad from jax.scipy.stats import poisson from typing import Callable In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"poisson_likelihood\", \"poisson_log_likelihood\",\n           \"chi2_likelihood\", \"chi2_log_likelihood\",\n           \"calculate_covariance\", \"calculate_entropy\"]\n</pre> __all__ = [\"poisson_likelihood\", \"poisson_log_likelihood\",            \"chi2_likelihood\", \"chi2_log_likelihood\",            \"calculate_covariance\", \"calculate_entropy\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def poisson_likelihood(X         : Array,\n                       data      : Array,\n                       model     : object,\n                       update_fn : Callable,\n                       model_fn  : str,\n                       *args,\n                       **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the poissonion likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The poissonian likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(poisson.pmf(data, psf))\n</pre> def poisson_likelihood(X         : Array,                        data      : Array,                        model     : object,                        update_fn : Callable,                        model_fn  : str,                        *args,                        **kwargs) -&gt; Array:     \"\"\"     Calculates the poissonion likelihood after updating the model using the     update_fn. The extra *args and **kwargs are passed to the model function.      Parameters     ----------     X : Array         The array of values to update the model with.     data : Array         The data to calulcate the prior with respect to.     model : object         The model used to model the data.     update_fn : Callable         The function used to update the model before modelling. This should         take in the X array as the first argument and the model as the second.     model_fn : str         The name of the model function to use.      Returns     -------     likelhood : Array         The poissonian likelihood of the updated model with respect to the data.     \"\"\"     model = update_fn(X, model)     psf = getattr(model, model_fn)(*args, **kwargs)     return np.sum(poisson.pmf(data, psf)) In\u00a0[\u00a0]: Copied! <pre>def poisson_log_likelihood(X         : Array,\n                           data      : Array,\n                           model     : object,\n                           update_fn : Callable,\n                           model_fn  : str,\n                           *args,\n                           **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the poissonion log likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The poissonian log likelihood of the updated model with respect to the\n        data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(poisson.logpmf(data, psf))\n</pre> def poisson_log_likelihood(X         : Array,                            data      : Array,                            model     : object,                            update_fn : Callable,                            model_fn  : str,                            *args,                            **kwargs) -&gt; Array:     \"\"\"     Calculates the poissonion log likelihood after updating the model using the     update_fn. The extra *args and **kwargs are passed to the model function.      Parameters     ----------     X : Array         The array of values to update the model with.     data : Array         The data to calulcate the prior with respect to.     model : object         The model used to model the data.     update_fn : Callable         The function used to update the model before modelling. This should         take in the X array as the first argument and the model as the second.     model_fn : str         The name of the model function to use.      Returns     -------     likelhood : Array         The poissonian log likelihood of the updated model with respect to the         data.     \"\"\"     model = update_fn(X, model)     psf = getattr(model, model_fn)(*args, **kwargs)     return np.sum(poisson.logpmf(data, psf)) In\u00a0[\u00a0]: Copied! <pre>def chi2_likelihood(X         : Array,\n                    data      : Array,\n                    model     : object,\n                    update_fn : Callable,\n                    model_fn  : str,\n                    *args,\n                    **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the chi2 likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The chi2 likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(np.square((psf-data)/noise))\n</pre> def chi2_likelihood(X         : Array,                     data      : Array,                     model     : object,                     update_fn : Callable,                     model_fn  : str,                     *args,                     **kwargs) -&gt; Array:     \"\"\"     Calculates the chi2 likelihood after updating the model using the     update_fn. The extra *args and **kwargs are passed to the model function.      Parameters     ----------     X : Array         The array of values to update the model with.     data : Array         The data to calulcate the prior with respect to.     model : object         The model used to model the data.     update_fn : Callable         The function used to update the model before modelling. This should         take in the X array as the first argument and the model as the second.     model_fn : str         The name of the model function to use.      Returns     -------     likelhood : Array         The chi2 likelihood of the updated model with respect to the data.     \"\"\"     model = update_fn(X, model)     psf = getattr(model, model_fn)(*args, **kwargs)     return np.sum(np.square((psf-data)/noise)) In\u00a0[\u00a0]: Copied! <pre>def chi2_log_likelihood(X         : Array,\n                        data      : Array,\n                        model     : object,\n                        update_fn : Callable,\n                        model_fn  : str,\n                        *args,\n                        **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the chi2 log likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The chi2 log likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.log(np.sum(np.square((psf-data)/noise)))\n</pre> def chi2_log_likelihood(X         : Array,                         data      : Array,                         model     : object,                         update_fn : Callable,                         model_fn  : str,                         *args,                         **kwargs) -&gt; Array:     \"\"\"     Calculates the chi2 log likelihood after updating the model using the     update_fn. The extra *args and **kwargs are passed to the model function.      Parameters     ----------     X : Array         The array of values to update the model with.     data : Array         The data to calulcate the prior with respect to.     model : object         The model used to model the data.     update_fn : Callable         The function used to update the model before modelling. This should         take in the X array as the first argument and the model as the second.     model_fn : str         The name of the model function to use.      Returns     -------     likelhood : Array         The chi2 log likelihood of the updated model with respect to the data.     \"\"\"     model = update_fn(X, model)     psf = getattr(model, model_fn)(*args, **kwargs)     return np.log(np.sum(np.square((psf-data)/noise))) In\u00a0[\u00a0]: Copied! <pre>def calculate_covariance(likelihood_fn : Callable,\n                         *args,\n                         **kwargs) -&gt; Array:\n\"\"\"\n    Calcuates the covariance matrix under the Laplace approximation for the\n    given likelihood function. The *args and **kwargs are passed to the\n    likelihood function.\n\n    Parameters\n    ----------\n    likelihood_fn : Callable\n        The likelihood function to calculate the covaraince matrix with\n        respect to.\n\n    Returns\n    -------\n    covaraince : Array\n        The corresponding covariance matrix.\n    \"\"\"\n    matrix = hessian(likelihood_fn)(*args, **kwargs)\n    return -np.linalg.inv(matrix)\n</pre> def calculate_covariance(likelihood_fn : Callable,                          *args,                          **kwargs) -&gt; Array:     \"\"\"     Calcuates the covariance matrix under the Laplace approximation for the     given likelihood function. The *args and **kwargs are passed to the     likelihood function.      Parameters     ----------     likelihood_fn : Callable         The likelihood function to calculate the covaraince matrix with         respect to.      Returns     -------     covaraince : Array         The corresponding covariance matrix.     \"\"\"     matrix = hessian(likelihood_fn)(*args, **kwargs)     return -np.linalg.inv(matrix) In\u00a0[\u00a0]: Copied! <pre>def calculate_entropy(likelihood_fn : Callable,\n                      *args,\n                      **kwargs):\n\"\"\"\n    Calcuates the entropy of the covaraince matrix under the Laplace\n    approximation for the given likelihood function. The *args and **kwargs\n    are passed to through the calculate_covaraince function through to the\n    likelihood function.\n\n    Parameters\n    ----------\n    likelihood_fn : Callable\n        The likelihood function to calculate the entropy with respect to.\n\n    Returns\n    -------\n    entropy : Array\n        The entropy of the covariance matrix for the given likelihood function.\n    \"\"\"\n    cov = calculate_covariance(likelihood_fn, *args, **kwargs)\n    sign, logdet = np.linalg.slogdet(cov)\n    return 0.5 * (np.log(2 * np.pi * np.e) + (sign * logdet))\n</pre> def calculate_entropy(likelihood_fn : Callable,                       *args,                       **kwargs):     \"\"\"     Calcuates the entropy of the covaraince matrix under the Laplace     approximation for the given likelihood function. The *args and **kwargs     are passed to through the calculate_covaraince function through to the     likelihood function.      Parameters     ----------     likelihood_fn : Callable         The likelihood function to calculate the entropy with respect to.      Returns     -------     entropy : Array         The entropy of the covariance matrix for the given likelihood function.     \"\"\"     cov = calculate_covariance(likelihood_fn, *args, **kwargs)     sign, logdet = np.linalg.slogdet(cov)     return 0.5 * (np.log(2 * np.pi * np.e) + (sign * logdet))"},{"location":"dLux/utils/coordinates/","title":"Coordinates","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax.tree_util import tree_map\nfrom typing import Union\nimport dLux\n</pre> import jax.numpy as np from jax.tree_util import tree_map from typing import Union import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"cartesian_to_polar\", \"polar_to_cartesian\",\n           \"get_pixel_positions\", \"rotate\", \"translate\", \"shear\", \"compress\"]\n</pre> __all__ = [\"cartesian_to_polar\", \"polar_to_cartesian\",            \"get_pixel_positions\", \"rotate\", \"translate\", \"shear\", \"compress\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>### Coordinates convertions ###\ndef cartesian_to_polar(coordinates : Array) -&gt; Array:\n\"\"\"\n    Converts the input (x, y) cartesian cordinates into (r, phi) polar\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (x, y) cartesian coordinates to be converted into polar cordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input cartesian coordinates converted into (r, phi) polar\n        cordinates.\n    \"\"\"\n    x, y = coordinates\n    return np.array([np.hypot(x, y), np.arctan2(y, x)])\n</pre> ### Coordinates convertions ### def cartesian_to_polar(coordinates : Array) -&gt; Array:     \"\"\"     Converts the input (x, y) cartesian cordinates into (r, phi) polar     coordinates.      Parameters     ----------     coordinates : Array         The (x, y) cartesian coordinates to be converted into polar cordinates.      Returns     -------     coordinates : Array         The input cartesian coordinates converted into (r, phi) polar         cordinates.     \"\"\"     x, y = coordinates     return np.array([np.hypot(x, y), np.arctan2(y, x)]) In\u00a0[\u00a0]: Copied! <pre>def polar_to_cartesian(coordinates : Array) -&gt; Array:\n\"\"\"\n    Converts the input (r, phi) polar coordinates into (x, y) cartesian\n    cordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (r, phi) polar coordinates to be converted into cartesian\n        cordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input polar coordinates converted into (x, y) cartesian cordinates.\n    \"\"\"\n    r, phi = coordinates\n    return np.array([r*np.cos(phi), r*np.sin(phi)])\n</pre> def polar_to_cartesian(coordinates : Array) -&gt; Array:     \"\"\"     Converts the input (r, phi) polar coordinates into (x, y) cartesian     cordinates.      Parameters     ----------     coordinates : Array         The (r, phi) polar coordinates to be converted into cartesian         cordinates.      Returns     -------     coordinates : Array         The input polar coordinates converted into (x, y) cartesian cordinates.     \"\"\"     r, phi = coordinates     return np.array([r*np.cos(phi), r*np.sin(phi)]) In\u00a0[\u00a0]: Copied! <pre>### Positions Calculations ###\ndef get_pixel_positions(npixels      : Union[int, tuple], \n                        pixel_scales : Union[tuple, float, None] = None,\n                        offsets      : Union[tuple, float, None] = None,\n                        polar        : bool = False,\n                        indexing     : str = 'xy') -&gt; Array:\n\"\"\"\n    Calculates the positions of the pixel centers for the given input. All \n    coordinates are output in units of meters. \n    The indexing argument is the same\n    as in numpy.meshgrid., ie:  Giving the string \u2018ij\u2019 returns a meshgrid with \n    matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In \n    the 2-D case with inputs of length M and N, the outputs are of shape (N, M) \n    for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs \n    of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and \n    (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordainates, \n    indexing is set to 'xy' and the input must be 2d\n    Parameters\n    ----------\n    npixels : Union[int, tuple]\n        The number of pixels in each dimension.\n    pixel_scales : Union[tuple, float, None] = None\n        The pixel scales in each dimension. If a tuple, the length\n        of the tuple must match the number of dimensions. If a float, the same\n        scale is applied to all dimensions. If None, the scale is set to 1.\n    offsets : Union[tuple, float, None] = None\n        The offset of the pixel centers in each dimension. If a tuple, the \n        length of the tuple must match the number of dimensions. If a float, \n        the same offset is applied to all dimensions. If None, the offset is \n        set to 0.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        cartesian coordinates. Default is False.\n    indexing : str = 'xy'\n        The indexing of the output. Default is 'xy'. See numpy.meshgrid for more\n        details.\n    Returns\n    -------\n    positions : Array\n        The positions of the pixel centers in the given dimensions.\n    \"\"\"\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\"indexing must be either 'xy' or 'ij'.\")\n    \n    if polar and indexing == 'ij':\n        indexing = 'xy'\n\n    # Turn inputs into tuples\n    if isinstance(npixels, int):\n        npixels = (npixels,)\n\n        if offsets is None:\n            offsets = (0.,)\n        elif not isinstance(offsets, (float, Array)):\n            raise ValueError(\"offset must be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            offsets = (offsets,)\n\n        if pixel_scales is None:\n            pixel_scales = (1.,)\n        elif not isinstance(pixel_scales, (float, Array)):\n            raise ValueError(\"pixel_scales must be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            pixel_scales = (pixel_scales,)\n        \n    # Check input \n    else:\n        if offsets is None:\n            offsets = tuple([0.]*len(npixels))\n        elif not isinstance(offsets, tuple):\n            raise ValueError(\"offset must be an be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            if len(offsets) != len(npixels):\n                raise ValueError(\"offset must have the same length as npixels.\")\n            \n        if pixel_scales is None:\n            pixel_scales = tuple([1.]*len(npixels))\n        elif isinstance(pixel_scales, float):\n            pixel_scales = tuple([pixel_scales]*len(npixels))\n        elif not isinstance(pixel_scales, tuple):\n            raise ValueError(\"pixel_scales must be a tuple if npixels is a tuple.\")\n        else:\n            if len(pixel_scales) != len(npixels):\n                raise ValueError(\"pixel_scales must have the same length as npixels.\")\n    \n    def pixel_fn(n, offset, scale):\n        pix = np.arange(n) - (n - 1) / 2.\n        pix *= scale\n        pix -= offset\n        return pix\n    \n    pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)\n\n    # ouput (x, y) for 2d, else in order\n    positions = np.array(np.meshgrid(*pixels, indexing=indexing))\n\n    if polar:\n        if len(npixels) != 2:\n            raise ValueError(\"polar coordinates are only defined for 2D arrays.\")\n        return cartesian_to_polar(positions)\n\n    # Squeeze for empty axis removal with 1d\n    return np.squeeze(positions)\n</pre> ### Positions Calculations ### def get_pixel_positions(npixels      : Union[int, tuple],                          pixel_scales : Union[tuple, float, None] = None,                         offsets      : Union[tuple, float, None] = None,                         polar        : bool = False,                         indexing     : str = 'xy') -&gt; Array:     \"\"\"     Calculates the positions of the pixel centers for the given input. All      coordinates are output in units of meters.           The indexing argument is the same     as in numpy.meshgrid., ie:  Giving the string \u2018ij\u2019 returns a meshgrid with      matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In      the 2-D case with inputs of length M and N, the outputs are of shape (N, M)      for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs      of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and      (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordainates,      indexing is set to 'xy' and the input must be 2d          Parameters     ----------     npixels : Union[int, tuple]         The number of pixels in each dimension.     pixel_scales : Union[tuple, float, None] = None         The pixel scales in each dimension. If a tuple, the length         of the tuple must match the number of dimensions. If a float, the same         scale is applied to all dimensions. If None, the scale is set to 1.     offsets : Union[tuple, float, None] = None         The offset of the pixel centers in each dimension. If a tuple, the          length of the tuple must match the number of dimensions. If a float,          the same offset is applied to all dimensions. If None, the offset is          set to 0.     polar : bool = False         If True, the output is in polar coordinates. If False, the output is in         cartesian coordinates. Default is False.     indexing : str = 'xy'         The indexing of the output. Default is 'xy'. See numpy.meshgrid for more         details.          Returns     -------     positions : Array         The positions of the pixel centers in the given dimensions.     \"\"\"     if indexing not in ['xy', 'ij']:         raise ValueError(\"indexing must be either 'xy' or 'ij'.\")          if polar and indexing == 'ij':         indexing = 'xy'      # Turn inputs into tuples     if isinstance(npixels, int):         npixels = (npixels,)          if offsets is None:             offsets = (0.,)         elif not isinstance(offsets, (float, Array)):             raise ValueError(\"offset must be a float or Array if npixels \"                              \"is an int.\")         else:             offsets = (offsets,)          if pixel_scales is None:             pixel_scales = (1.,)         elif not isinstance(pixel_scales, (float, Array)):             raise ValueError(\"pixel_scales must be a float or Array if npixels \"                              \"is an int.\")         else:             pixel_scales = (pixel_scales,)              # Check input      else:         if offsets is None:             offsets = tuple([0.]*len(npixels))         elif not isinstance(offsets, tuple):             raise ValueError(\"offset must be an be a float or Array if npixels \"                              \"is an int.\")         else:             if len(offsets) != len(npixels):                 raise ValueError(\"offset must have the same length as npixels.\")                      if pixel_scales is None:             pixel_scales = tuple([1.]*len(npixels))         elif isinstance(pixel_scales, float):             pixel_scales = tuple([pixel_scales]*len(npixels))         elif not isinstance(pixel_scales, tuple):             raise ValueError(\"pixel_scales must be a tuple if npixels is a tuple.\")         else:             if len(pixel_scales) != len(npixels):                 raise ValueError(\"pixel_scales must have the same length as npixels.\")          def pixel_fn(n, offset, scale):         pix = np.arange(n) - (n - 1) / 2.         pix *= scale         pix -= offset         return pix          pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)      # ouput (x, y) for 2d, else in order     positions = np.array(np.meshgrid(*pixels, indexing=indexing))      if polar:         if len(npixels) != 2:             raise ValueError(\"polar coordinates are only defined for 2D arrays.\")         return cartesian_to_polar(positions)      # Squeeze for empty axis removal with 1d     return np.squeeze(positions) In\u00a0[\u00a0]: Copied! <pre>### Coordinates Transformations ###\ndef rotate(coordinates: Array, rotation: Array) -&gt; Array:\n\"\"\"\n    Rotate the coordinate system by a pre-specified amount.\n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        A `(2, npix, npix)` representation of the coordinate \n        system. The leading dimensions specifies the x and then \n        the y coordinates in that order. \n    rotation : Array, radians\n        The counter-clockwise rotation to apply.\n\n    Returns\n    -------\n    coordinates : Array, meters\n        The rotated coordinate system. \n    \"\"\"\n    x, y = coordinates[0], coordinates[1]\n    new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n    new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n    return np.array([new_x, new_y])\n</pre> ### Coordinates Transformations ### def rotate(coordinates: Array, rotation: Array) -&gt; Array:     \"\"\"     Rotate the coordinate system by a pre-specified amount.      Parameters     ----------     coordinates : Array, meters         A `(2, npix, npix)` representation of the coordinate          system. The leading dimensions specifies the x and then          the y coordinates in that order.      rotation : Array, radians         The counter-clockwise rotation to apply.      Returns     -------     coordinates : Array, meters         The rotated coordinate system.      \"\"\"     x, y = coordinates[0], coordinates[1]     new_x = np.cos(-rotation) * x + np.sin(-rotation) * y     new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y     return np.array([new_x, new_y]) In\u00a0[\u00a0]: Copied! <pre>def translate(coordinates: Array, centre: Array) -&gt; Array:\n\"\"\"\n    Move the center of the coordinate system by some \n    amount (centre). \n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    centre : Array, meters\n        The (x, y) coordinates of the new centre \n        with dimensions (2,)\n\n    Returns\n    -------\n    coordinates: Array, meters\n        The translated coordinate system. \n    \"\"\"\n    return coordinates - centre[:, None, None]\n</pre> def translate(coordinates: Array, centre: Array) -&gt; Array:     \"\"\"     Move the center of the coordinate system by some      amount (centre).       Parameters     ----------     coordinates : Array, meters         The (x, y) coordinates with the dimensions          (2, npix, npix).     centre : Array, meters         The (x, y) coordinates of the new centre          with dimensions (2,)      Returns     -------     coordinates: Array, meters         The translated coordinate system.      \"\"\"     return coordinates - centre[:, None, None] In\u00a0[\u00a0]: Copied! <pre>def shear(coordinates: Array, shear: Array) -&gt; Array:\n\"\"\"\n    Apply a shear to the coordinate system. \n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    shear : Array\n        The (x, y) shear with dimensions (2,)\n\n    Returns\n    -------\n    coordinates: Array, meters\n        The sheared coordinate system. \n    \"\"\"\n    trans_coordinates: Array = np.transpose(coordinates, (0, 2, 1))\n    return coordinates + trans_coordinates * shear[:, None, None]\n</pre> def shear(coordinates: Array, shear: Array) -&gt; Array:     \"\"\"     Apply a shear to the coordinate system.       Parameters     ----------     coordinates : Array, meters         The (x, y) coordinates with the dimensions          (2, npix, npix).     shear : Array         The (x, y) shear with dimensions (2,)      Returns     -------     coordinates: Array, meters         The sheared coordinate system.      \"\"\"     trans_coordinates: Array = np.transpose(coordinates, (0, 2, 1))     return coordinates + trans_coordinates * shear[:, None, None] In\u00a0[\u00a0]: Copied! <pre>def compress(coordinates: Array, compression: Array) -&gt; Array:\n\"\"\"\n    Apply a compression to the coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    compression : Array\n        The (x, y) compression with dimensions (2,)\n\n    Returns\n    -------\n    coordinates : Array, meters\n        The compressed coordinates. \n    \"\"\"\n    return coordinates * compression[:, None, None]\n</pre> def compress(coordinates: Array, compression: Array) -&gt; Array:     \"\"\"     Apply a compression to the coordinates.      Parameters     ----------     coordinates : Array, meters         The (x, y) coordinates with the dimensions          (2, npix, npix).     compression : Array         The (x, y) compression with dimensions (2,)      Returns     -------     coordinates : Array, meters         The compressed coordinates.      \"\"\"     return coordinates * compression[:, None, None] In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"dLux/utils/gradient_energy/","title":"Gradient energy","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport dLux\n</pre> import jax.numpy as np import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"get_GE\", \"get_RGE\", \"get_RWGE\", \"get_radial_mask\"]\n</pre> __all__ = [\"get_GE\", \"get_RGE\", \"get_RWGE\", \"get_radial_mask\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def get_GE(array : Array) -&gt; Array:\n\"\"\"\n    Calcuates the spatial gradient energy of the array.\n\n    Parameters\n    ----------\n    array : Array\n        The array to calcuate the gradient energy for.\n\n    Returns\n    -------\n    array : Array\n        The array of gradient energies.\n    \"\"\"\n    grads_vec = np.gradient(array)\n    return np.hypot(grads_vec[0], grads_vec[1])\n</pre> def get_GE(array : Array) -&gt; Array:     \"\"\"     Calcuates the spatial gradient energy of the array.      Parameters     ----------     array : Array         The array to calcuate the gradient energy for.      Returns     -------     array : Array         The array of gradient energies.     \"\"\"     grads_vec = np.gradient(array)     return np.hypot(grads_vec[0], grads_vec[1]) In\u00a0[\u00a0]: Copied! <pre>def get_RGE(array : Array, epsilon : float = 1e-8) -&gt; Array:\n\"\"\"\n    Calcuates the spatial radial gradient energy of the array.\n\n    Parameters\n    ----------\n    array : Array\n        The array to calcuate the radial gradient energy for.\n    epsilon : float\n        A small value added to the radial values to help with gradient\n        stability.\n\n    Returns\n    -------\n    array : Array\n        The array of radial gradient energies.\n    \"\"\"\n    npix = array.shape[0]\n    positions = dLux.utils.coordinates.get_pixel_positions((npix, npix))\n    grads_vec = np.gradient(array)\n\n    xnorm = positions[1]*grads_vec[0]\n    ynorm = positions[0]*grads_vec[1]\n    return np.square(xnorm + ynorm)\n</pre> def get_RGE(array : Array, epsilon : float = 1e-8) -&gt; Array:     \"\"\"     Calcuates the spatial radial gradient energy of the array.      Parameters     ----------     array : Array         The array to calcuate the radial gradient energy for.     epsilon : float         A small value added to the radial values to help with gradient         stability.      Returns     -------     array : Array         The array of radial gradient energies.     \"\"\"     npix = array.shape[0]     positions = dLux.utils.coordinates.get_pixel_positions((npix, npix))     grads_vec = np.gradient(array)      xnorm = positions[1]*grads_vec[0]     ynorm = positions[0]*grads_vec[1]     return np.square(xnorm + ynorm) In\u00a0[\u00a0]: Copied! <pre>def get_RWGE(array : Array, epsilon : float = 1e-8) -&gt; Array:\n\"\"\"\n    Calcuates the spatial radially weighted gradient energy of the array.\n\n    Parameters\n    ----------\n    array : Array\n        The array to calcuate the radially weighted gradient energy for.\n    epsilon : float\n        A small value added to the radially weighted values to help with\n        gradient stability.\n\n    Returns\n    -------\n    array : Array\n        The array of radial radially weighted energies.\n    \"\"\"\n    npix = array.shape[0]\n    positions = dLux.utils.coordinates.get_pixel_positions((npix, npix))\n    radii = dLux.utils.coordinates.get_pixel_positions((npix, npix), \n                                                        polar=True)[0]\n    radii_norm = positions/(radii + epsilon)\n    grads_vec = np.gradient(array)\n\n    xnorm = radii_norm[1]*grads_vec[0]\n    ynorm = radii_norm[0]*grads_vec[1]\n    return np.square(xnorm + ynorm)\n</pre> def get_RWGE(array : Array, epsilon : float = 1e-8) -&gt; Array:     \"\"\"     Calcuates the spatial radially weighted gradient energy of the array.      Parameters     ----------     array : Array         The array to calcuate the radially weighted gradient energy for.     epsilon : float         A small value added to the radially weighted values to help with         gradient stability.      Returns     -------     array : Array         The array of radial radially weighted energies.     \"\"\"     npix = array.shape[0]     positions = dLux.utils.coordinates.get_pixel_positions((npix, npix))     radii = dLux.utils.coordinates.get_pixel_positions((npix, npix),                                                          polar=True)[0]     radii_norm = positions/(radii + epsilon)     grads_vec = np.gradient(array)      xnorm = radii_norm[1]*grads_vec[0]     ynorm = radii_norm[0]*grads_vec[1]     return np.square(xnorm + ynorm) In\u00a0[\u00a0]: Copied! <pre>def get_radial_mask(npixels : int,\n                    rmin    : Array,\n                    rmax    : Array) -&gt; Array:\n\"\"\"\n    Calcautes a binary radial mask, masking out radii below rmin, and above\n    rmax.\n\n    Parameters\n    ----------\n    npixels : int\n        The linear size of the array.\n    rmin : Array\n        The inner radius to mask out.\n    rmax : Array\n        The outer radius to mask out.\n\n    Returns\n    -------\n    mask: Array\n        A mask with the the values below rmin and above rmax masked out.\n    \"\"\"\n    radii = dLux.utils.coordinates.get_pixel_positions((npixels, npixels), \n                                                        polar=True)[0]\n    return np.asarray((radii &lt; rmax) &amp; (radii &gt; rmin), dtype=float)\n</pre> def get_radial_mask(npixels : int,                     rmin    : Array,                     rmax    : Array) -&gt; Array:     \"\"\"     Calcautes a binary radial mask, masking out radii below rmin, and above     rmax.      Parameters     ----------     npixels : int         The linear size of the array.     rmin : Array         The inner radius to mask out.     rmax : Array         The outer radius to mask out.      Returns     -------     mask: Array         A mask with the the values below rmin and above rmax masked out.     \"\"\"     radii = dLux.utils.coordinates.get_pixel_positions((npixels, npixels),                                                          polar=True)[0]     return np.asarray((radii &lt; rmax) &amp; (radii &gt; rmin), dtype=float)"},{"location":"dLux/utils/helpers/","title":"Helpers","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom collections import OrderedDict\nimport matplotlib.pyplot as plt\n</pre> import jax.numpy as np from collections import OrderedDict import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"list_to_dictionary\", \"single_image_plot\", \"two_image_plot\",\n           \"spectrum_plot\"]\n</pre> __all__ = [\"list_to_dictionary\", \"single_image_plot\", \"two_image_plot\",            \"spectrum_plot\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def list_to_dictionary(list_in : list, ordered : bool = True) -&gt; dict:\n\"\"\"\n    Converts some input list of dLux layers and converts them into an\n    OrderedDict with the correct structure, ensuring that all keys are unique.\n\n    Parameters\n    ----------\n    list_in : list\n        The list of dLux OpticalLayers or DetectorLayers to be converted into\n        a dictionary.\n    ordered : bool = True\n        Whether to return an ordered or regular dictionary.\n\n    Returns\n    -------\n    dictionary : dict\n        The equivilent dictionary or ordered dictionary.\n    \"\"\"\n    # Construct names list and identify repeats\n    names, repeats = [], []\n    for i in range(len(list_in)):\n\n        # Check for name attribute\n        if hasattr(list_in[i], 'name') and list_in[i].name is not None:\n            name = list_in[i].name\n\n        # Else take name from object\n        else:\n            name = str(list_in[i]).split('(')[0]\n\n        # Check for Repeats\n        if name in names:\n            repeats.append(name)\n        names.append(name)\n\n    # Get list of unique repeats\n    repeats = list(set(repeats))\n\n    # Iterate over repeat names\n    for i in range(len(repeats)):\n\n        idx = 0\n        # Iterate over names list and append index value to name\n        for j in range(len(names)):\n            if repeats[i] == names[j]:\n                names[j] = names[j] + '_{}'.format(idx)\n                idx += 1\n\n    # Turn list into Dictionary\n    dict_out = OrderedDict() if ordered else {}\n    for i in range(len(names)):\n\n        # Assert no spaces in the name in order to ensure the __getattrr__\n        # method will work\n        assert ' ' not in names[i], \\\n        (\"names can not contain spaces, {} was supplied.\".format(names[i]))\n        dict_out[names[i]] = list_in[i].set('name', names[i])\n    return dict_out\n</pre> def list_to_dictionary(list_in : list, ordered : bool = True) -&gt; dict:     \"\"\"     Converts some input list of dLux layers and converts them into an     OrderedDict with the correct structure, ensuring that all keys are unique.      Parameters     ----------     list_in : list         The list of dLux OpticalLayers or DetectorLayers to be converted into         a dictionary.     ordered : bool = True         Whether to return an ordered or regular dictionary.      Returns     -------     dictionary : dict         The equivilent dictionary or ordered dictionary.     \"\"\"     # Construct names list and identify repeats     names, repeats = [], []     for i in range(len(list_in)):          # Check for name attribute         if hasattr(list_in[i], 'name') and list_in[i].name is not None:             name = list_in[i].name          # Else take name from object         else:             name = str(list_in[i]).split('(')[0]          # Check for Repeats         if name in names:             repeats.append(name)         names.append(name)      # Get list of unique repeats     repeats = list(set(repeats))      # Iterate over repeat names     for i in range(len(repeats)):          idx = 0         # Iterate over names list and append index value to name         for j in range(len(names)):             if repeats[i] == names[j]:                 names[j] = names[j] + '_{}'.format(idx)                 idx += 1      # Turn list into Dictionary     dict_out = OrderedDict() if ordered else {}     for i in range(len(names)):          # Assert no spaces in the name in order to ensure the __getattrr__         # method will work         assert ' ' not in names[i], \\         (\"names can not contain spaces, {} was supplied.\".format(names[i]))         dict_out[names[i]] = list_in[i].set('name', names[i])     return dict_out In\u00a0[\u00a0]: Copied! <pre>def single_image_plot(array       : Array, \n                      figsize     : tuple = (5, 4), \n                      title       : str   = \"Array\",\n                      cbar_label  : str   = None,\n                      cmap        : str   = \"inferno\",\n                      bound       : float = None,\n                      dpi         : int   = 120) -&gt; None:\n\"\"\"\n    Plots a  single image.\n\n    Parameters\n    ----------\n    array : Array\n        The first array to plot.\n    figsize : tuple = (5, 4)\n        The size of the figure to display.\n    title : str = \"Array\"\n        The title of the array.\n    cmap : str = \"inferno\"\n        The colour map to use.\n    bound : float = None\n        The bound of the colour map.\n    dpi : int = 120\n        The resolution of the figure.\n    \"\"\"\n    plt.figure(figsize=figsize)\n    plt.title(title)\n    if bound is not None:\n        array = array % bound\n    plt.imshow(array, cmap=cmap)\n    cbar = plt.colorbar()\n    if cbar_label is not None:\n        cbar.set_label(cbar_label)\n    plt.show()\n</pre> def single_image_plot(array       : Array,                        figsize     : tuple = (5, 4),                        title       : str   = \"Array\",                       cbar_label  : str   = None,                       cmap        : str   = \"inferno\",                       bound       : float = None,                       dpi         : int   = 120) -&gt; None:     \"\"\"     Plots a  single image.      Parameters     ----------     array : Array         The first array to plot.     figsize : tuple = (5, 4)         The size of the figure to display.     title : str = \"Array\"         The title of the array.     cmap : str = \"inferno\"         The colour map to use.     bound : float = None         The bound of the colour map.     dpi : int = 120         The resolution of the figure.     \"\"\"     plt.figure(figsize=figsize)     plt.title(title)     if bound is not None:         array = array % bound     plt.imshow(array, cmap=cmap)     cbar = plt.colorbar()     if cbar_label is not None:         cbar.set_label(cbar_label)     plt.show() In\u00a0[\u00a0]: Copied! <pre>def two_image_plot(array1      : Array, \n                   array2      : Array, \n                   figsize     : tuple = (10, 4), \n                   titles      : tuple = (\"Array 1\", \"Array 2\"),\n                   cbar_labels : tuple = (None, None),\n                   cmaps       : tuple = (\"inferno\", \"inferno\"),\n                   bounds      : tuple = (None, None),\n                   dpi         : int   = 120) -&gt; None:\n\"\"\"\n    Plots two images side by side.\n\n    Parameters\n    ----------\n    array1 : Array\n        The first array to plot.\n    array2 : Array\n        The second array to plot.\n    figsize : tuple = (10, 4)\n        The size of the figure to display.\n    titles : tuple = (\"Array 1\", \"Array 2\")\n        The titles of the arrays.\n    cmaps : tuple = (\"inferno\", \"inferno\")\n        The colour maps to use.\n    bounds : tuple = (None, None)\n        The bounds of the colour maps.\n    dpi : int = 120\n        The resolution of the figure.\n    \"\"\"\n    plt.figure(figsize=figsize)\n    plt.subplot(1, 2, 1)\n    plt.title(titles[0])\n    if bounds[0] is not None:\n        array1 = array1 % bounds[0]\n    plt.imshow(array1, cmap=cmaps[0])\n    cbar = plt.colorbar()\n    if cbar_labels[0] is not None:\n        cbar.set_label(cbar_labels[0])\n\n    plt.subplot(1, 2, 2)\n    plt.title(titles[1])\n    if bounds[1] is not None:\n        array2 = array2 % bounds[1]\n    plt.imshow(array2, cmap=cmaps[1])\n    cbar = plt.colorbar()\n    if cbar_labels[1] is not None:\n        cbar.set_label(cbar_labels[1])\n    plt.show()\n</pre> def two_image_plot(array1      : Array,                     array2      : Array,                     figsize     : tuple = (10, 4),                     titles      : tuple = (\"Array 1\", \"Array 2\"),                    cbar_labels : tuple = (None, None),                    cmaps       : tuple = (\"inferno\", \"inferno\"),                    bounds      : tuple = (None, None),                    dpi         : int   = 120) -&gt; None:     \"\"\"     Plots two images side by side.      Parameters     ----------     array1 : Array         The first array to plot.     array2 : Array         The second array to plot.     figsize : tuple = (10, 4)         The size of the figure to display.     titles : tuple = (\"Array 1\", \"Array 2\")         The titles of the arrays.     cmaps : tuple = (\"inferno\", \"inferno\")         The colour maps to use.     bounds : tuple = (None, None)         The bounds of the colour maps.     dpi : int = 120         The resolution of the figure.     \"\"\"     plt.figure(figsize=figsize)     plt.subplot(1, 2, 1)     plt.title(titles[0])     if bounds[0] is not None:         array1 = array1 % bounds[0]     plt.imshow(array1, cmap=cmaps[0])     cbar = plt.colorbar()     if cbar_labels[0] is not None:         cbar.set_label(cbar_labels[0])      plt.subplot(1, 2, 2)     plt.title(titles[1])     if bounds[1] is not None:         array2 = array2 % bounds[1]     plt.imshow(array2, cmap=cmaps[1])     cbar = plt.colorbar()     if cbar_labels[1] is not None:         cbar.set_label(cbar_labels[1])     plt.show() In\u00a0[\u00a0]: Copied! <pre>def spectrum_plot(wavelengths     : Array, \n                  weights         : Array, \n                  figsize         : tuple = (6, 3),\n                  labels          : tuple = None, \n                  cartesian_units : str = 'meters',\n                  dpi             : int = 120) -&gt; None:\n\"\"\"\n    Plots a spectrum based on wavelgths and weights.\n\n    Parameters\n    ----------\n    wavelengths : Array, meters\n        The wavelengths of the spectrum.\n    weights : Array\n        The weights of the spectrum.\n    figsize : tuple = (6, 3)\n        The size of the figure to display.\n    labels : tuple = None\n        The labels of the spectra.\n    cartesian_units : str = 'meters'\n        The units of the wavelengths.\n    dpi : int = 120\n        The resolution of the figure.\n    \"\"\"\n    nspectra = 1 if wavelengths.ndim == 1 else len(wavelengths)\n    if labels is None:\n        labels = ['Spectrum {}'.format(i) for i in range(nspectra)]\n    \n    plt.figure(figsize=figsize, dpi=dpi)\n    if nspectra == 1:\n        plt.scatter(wavelengths, weights, label=labels[0])\n    else:\n        for i in range(nspectra):\n            plt.scatter(wavelengths[i], weights[i], label=labels[i])\n    plt.legend()\n    plt.xlabel(f\"Wavelengths {cartesian_units}\")\n    plt.ylabel(\"Weights\")\n    plt.ylim(-0.01)\n    plt.show()\n</pre> def spectrum_plot(wavelengths     : Array,                    weights         : Array,                    figsize         : tuple = (6, 3),                   labels          : tuple = None,                    cartesian_units : str = 'meters',                   dpi             : int = 120) -&gt; None:     \"\"\"     Plots a spectrum based on wavelgths and weights.      Parameters     ----------     wavelengths : Array, meters         The wavelengths of the spectrum.     weights : Array         The weights of the spectrum.     figsize : tuple = (6, 3)         The size of the figure to display.     labels : tuple = None         The labels of the spectra.     cartesian_units : str = 'meters'         The units of the wavelengths.     dpi : int = 120         The resolution of the figure.     \"\"\"     nspectra = 1 if wavelengths.ndim == 1 else len(wavelengths)     if labels is None:         labels = ['Spectrum {}'.format(i) for i in range(nspectra)]          plt.figure(figsize=figsize, dpi=dpi)     if nspectra == 1:         plt.scatter(wavelengths, weights, label=labels[0])     else:         for i in range(nspectra):             plt.scatter(wavelengths[i], weights[i], label=labels[i])     plt.legend()     plt.xlabel(f\"Wavelengths {cartesian_units}\")     plt.ylabel(\"Weights\")     plt.ylim(-0.01)     plt.show()"},{"location":"dLux/utils/interpolation/","title":"Interpolation","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nfrom jax import vmap\nfrom jax.scipy.ndimage import map_coordinates\nfrom functools import partial\nimport dLux.utils.coordinates as c\n</pre> import jax.numpy as np from jax import vmap from jax.scipy.ndimage import map_coordinates from functools import partial import dLux.utils.coordinates as c In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"scale_array\", \"generate_coordinates\", \"interpolate_field\",\n           \"interpolate\", \"rotate_field\", \"rotate\", \"fourier_rotate\"]\n</pre> __all__ = [\"scale_array\", \"generate_coordinates\", \"interpolate_field\",            \"interpolate\", \"rotate_field\", \"rotate\", \"fourier_rotate\"] In\u00a0[\u00a0]: Copied! <pre>Array =  np.ndarray\n</pre> Array =  np.ndarray In\u00a0[\u00a0]: Copied! <pre>def scale_array(array    : Array,\n                size_out : int,\n                order    : int) -&gt; Array:\n\"\"\"\n    Scales some input array to size_out using interolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to scale.\n    size_out : int\n        The output size of the mask\n    order : int\n        The interpolation order. Supports 0 and 1.\n\n    Returns\n    -------\n    array : Array\n        The array scaled to size_out\n    \"\"\"\n    assert order in (0, 1), (\"order must be 0 or 1.\")\n    xs = np.linspace(0, array.shape[0], size_out)\n    xs, ys = np.meshgrid(xs, xs)\n    return map_coordinates(array, np.array([ys, xs]), order=order)\n</pre> def scale_array(array    : Array,                 size_out : int,                 order    : int) -&gt; Array:     \"\"\"     Scales some input array to size_out using interolation.      Parameters     ----------     array : Array         The array to scale.     size_out : int         The output size of the mask     order : int         The interpolation order. Supports 0 and 1.      Returns     -------     array : Array         The array scaled to size_out     \"\"\"     assert order in (0, 1), (\"order must be 0 or 1.\")     xs = np.linspace(0, array.shape[0], size_out)     xs, ys = np.meshgrid(xs, xs)     return map_coordinates(array, np.array([ys, xs]), order=order) In\u00a0[\u00a0]: Copied! <pre>def generate_coordinates(npixels_in     : int,\n                         npixels_out    : int,\n                         sampling_ratio : Array,\n                         x_shift        : Array = np.array(0.),\n                         y_shift        : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Generates a new set of paraxial coordinates which can be used for\n    interpolation.\n\n    Parameters\n    ----------\n    npixels_in : int\n        The number of pixels in the original array.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    coordinates : Array\n        The output coordinates at which to interpolate onto.\n    \"\"\"\n    old_centre = (npixels_in  - 1) / 2\n    new_centre = (npixels_out - 1) / 2\n    pixels = sampling_ratio * np.linspace(-new_centre, new_centre,\n                                          npixels_out) + old_centre\n    x_pixels, y_pixels = np.meshgrid(pixels + x_shift, pixels + y_shift)\n    return np.array([y_pixels, x_pixels])\n</pre> def generate_coordinates(npixels_in     : int,                          npixels_out    : int,                          sampling_ratio : Array,                          x_shift        : Array = np.array(0.),                          y_shift        : Array = np.array(0.)) -&gt; Array:     \"\"\"     Generates a new set of paraxial coordinates which can be used for     interpolation.      Parameters     ----------     npixels_in : int         The number of pixels in the original array.     npixels_out : int         The number of pixel in the output array.     sampling_ratio : Array         The ratio of pixel sizes in the input and output array,         ie pixel_scale_out/pixel_scale_in.     x_shift : Array, pixles = np.array(0.)         How much to shift the x_coordinates in the output array, in the pixel         units of the output array.     y_shift : Array, pixles = np.array(0.)         How much to shift the y_coordinates in the output array, in the pixel         units of the output array.      Returns     -------     coordinates : Array         The output coordinates at which to interpolate onto.     \"\"\"     old_centre = (npixels_in  - 1) / 2     new_centre = (npixels_out - 1) / 2     pixels = sampling_ratio * np.linspace(-new_centre, new_centre,                                           npixels_out) + old_centre     x_pixels, y_pixels = np.meshgrid(pixels + x_shift, pixels + y_shift)     return np.array([y_pixels, x_pixels]) In\u00a0[\u00a0]: Copied! <pre>def interpolate_field(field           : Array,\n                      npixels_out     : int,\n                      sampling_ratio  : Array,\n                      real_imaginary  : bool = False,\n                      x_shift         : Array = np.array(0.),\n                      y_shift         : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Paraxially interpolates a wavefront field (either in ampltude and phase, or\n    real and imaginiary) based on the sampling ratio, and npixels_out.\n\n    Parameters\n    ----------\n    field : Array\n        The input field to interpolate, either in amplitude and phase, or real\n        and imaginary.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    real_imaginary : bool = False\n        Is the input field given in amplitude and phase, or real and imagninary.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    field : Array\n        The interpolated output amplitude and phase arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = field.shape[-1]\n    coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,\n                                       x_shift, y_shift)\n\n    # Interpolate\n    interpolator = vmap(map_coordinates, in_axes=(0, None, None))\n    new_field = interpolator(field, coordinates, 1)\n\n    # Conserve energy\n    if real_imaginary:\n        amplitude = np.hypot(new_field[0], new_field[1])\n        phase = np.arctan2(new_field[1], new_field[0])\n    else:\n        amplitude, phase = new_field\n\n    return np.array([amplitude, phase])\n</pre> def interpolate_field(field           : Array,                       npixels_out     : int,                       sampling_ratio  : Array,                       real_imaginary  : bool = False,                       x_shift         : Array = np.array(0.),                       y_shift         : Array = np.array(0.)) -&gt; Array:     \"\"\"     Paraxially interpolates a wavefront field (either in ampltude and phase, or     real and imaginiary) based on the sampling ratio, and npixels_out.      Parameters     ----------     field : Array         The input field to interpolate, either in amplitude and phase, or real         and imaginary.     npixels_out : int         The number of pixel in the output array.     sampling_ratio : Array         The ratio of pixel sizes in the input and output array,         ie pixel_scale_out/pixel_scale_in.     real_imaginary : bool = False         Is the input field given in amplitude and phase, or real and imagninary.     x_shift : Array, pixles = np.array(0.)         How much to shift the x_coordinates in the output array, in the pixel         units of the output array.     y_shift : Array, pixles = np.array(0.)         How much to shift the y_coordinates in the output array, in the pixel         units of the output array.      Returns     -------     field : Array         The interpolated output amplitude and phase arrays.     \"\"\"     # Get coords arrays     npixels_in = field.shape[-1]     coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,                                        x_shift, y_shift)      # Interpolate     interpolator = vmap(map_coordinates, in_axes=(0, None, None))     new_field = interpolator(field, coordinates, 1)      # Conserve energy     if real_imaginary:         amplitude = np.hypot(new_field[0], new_field[1])         phase = np.arctan2(new_field[1], new_field[0])     else:         amplitude, phase = new_field      return np.array([amplitude, phase]) In\u00a0[\u00a0]: Copied! <pre>def interpolate(array          : Array,\n                npixels_out    : int,\n                sampling_ratio : Array,\n                x_shift        : Array = np.array(0.),\n                y_shift        : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Paraxially interpolates an array based on the sampling ratio, and\n    npixels_out.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to interpolate.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    field : Array\n        The interpolated arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = array.shape[-1]\n    coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,\n                                       x_shift, y_shift)\n\n    # Interpolate\n    new_array = map_coordinates(array, order=1)\n\n    # Conserve energy and return\n    return new_array * sampling_ratio\n</pre> def interpolate(array          : Array,                 npixels_out    : int,                 sampling_ratio : Array,                 x_shift        : Array = np.array(0.),                 y_shift        : Array = np.array(0.)) -&gt; Array:     \"\"\"     Paraxially interpolates an array based on the sampling ratio, and     npixels_out.      Parameters     ----------     array : Array         The input array to interpolate.     npixels_out : int         The number of pixel in the output array.     sampling_ratio : Array         The ratio of pixel sizes in the input and output array,         ie pixel_scale_out/pixel_scale_in.     x_shift : Array, pixles = np.array(0.)         How much to shift the x_coordinates in the output array, in the pixel         units of the output array.     y_shift : Array, pixles = np.array(0.)         How much to shift the y_coordinates in the output array, in the pixel         units of the output array.      Returns     -------     field : Array         The interpolated arrays.     \"\"\"     # Get coords arrays     npixels_in = array.shape[-1]     coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,                                        x_shift, y_shift)      # Interpolate     new_array = map_coordinates(array, order=1)      # Conserve energy and return     return new_array * sampling_ratio In\u00a0[\u00a0]: Copied! <pre>def rotate_field(field          : Array,\n                 angle          : Array,\n                 real_imaginary : bool = False,\n                 fourier        : bool = False,\n                 order          : int  = 1,\n                 padding        : int  = 2) -&gt; Array:\n\"\"\"\n    Paraxially rotates a wavefront field (either in ampltude and phase, or\n    real and imaginiary) in the {}wise direction by angle. Two methods are\n    available, interpolation and fourier rotation. Interpolation is much faster\n    with large arrays, and fourier rotation is information preserving.\n\n    Parameters\n    ----------\n    field : Array\n        The input field to rotate, either in amplitude and phase, or real\n        and imaginary.\n    angle : Array, radians\n        The angle by which to rotate the wavefront in a {}wise direction.\n    real_imaginary : bool = False\n        Whether to rotate the real and imaginary representation of the\n        wavefront as opposed to the the amplitude and phase representation.\n    fourier : bool = False\n        Should the fourier rotation method be used (True), or regular\n        interpolation method be used (False).\n    order : int = 2\n        The interpolation order to use. Must be 0, 1, or 3.\n    padding : int = 2\n        The amount of fourier padding to use. Only applies if fourier is True.\n\n    Returns\n    -------\n    field : Array\n        The rotated output amplitude and phase arrays.\n    \"\"\"\n    # Generate rotator function\n    if fourier:\n        padded_rotate = partial(fourier_rotate, padding=padding)\n        rotator = vmap(padded_rotate, in_axes=(0, None))\n    else:\n        order_rotate = partial(rotate, order=order)\n        rotator = vmap(order_rotate, in_axes=(0, None))\n\n    # Rotate\n    rotated_field = rotator(field, angle)\n\n    # Get amplitude phase\n    if real_imaginary:\n        amplitude = np.hypot(rotated_field[0], rotated_field[1])\n        phase = np.arctan2(rotated_field[1], rotated_field[0])\n    else:\n        amplitude, phase = rotated_field\n\n    return np.array([amplitude, phase])\n</pre> def rotate_field(field          : Array,                  angle          : Array,                  real_imaginary : bool = False,                  fourier        : bool = False,                  order          : int  = 1,                  padding        : int  = 2) -&gt; Array:     \"\"\"     Paraxially rotates a wavefront field (either in ampltude and phase, or     real and imaginiary) in the {}wise direction by angle. Two methods are     available, interpolation and fourier rotation. Interpolation is much faster     with large arrays, and fourier rotation is information preserving.      Parameters     ----------     field : Array         The input field to rotate, either in amplitude and phase, or real         and imaginary.     angle : Array, radians         The angle by which to rotate the wavefront in a {}wise direction.     real_imaginary : bool = False         Whether to rotate the real and imaginary representation of the         wavefront as opposed to the the amplitude and phase representation.     fourier : bool = False         Should the fourier rotation method be used (True), or regular         interpolation method be used (False).     order : int = 2         The interpolation order to use. Must be 0, 1, or 3.     padding : int = 2         The amount of fourier padding to use. Only applies if fourier is True.      Returns     -------     field : Array         The rotated output amplitude and phase arrays.     \"\"\"     # Generate rotator function     if fourier:         padded_rotate = partial(fourier_rotate, padding=padding)         rotator = vmap(padded_rotate, in_axes=(0, None))     else:         order_rotate = partial(rotate, order=order)         rotator = vmap(order_rotate, in_axes=(0, None))      # Rotate     rotated_field = rotator(field, angle)      # Get amplitude phase     if real_imaginary:         amplitude = np.hypot(rotated_field[0], rotated_field[1])         phase = np.arctan2(rotated_field[1], rotated_field[0])     else:         amplitude, phase = rotated_field      return np.array([amplitude, phase]) In\u00a0[\u00a0]: Copied! <pre>def rotate(array : Array, angle : Array, order : int = 1) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using linear interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n    if order not in (0, 1, 3):\n        raise ValueError(\"Order must be 0, 1, or 3.\")\n    # Get coordinates\n    npixels = array.shape[0]\n    centre = (npixels - 1) / 2\n    coordinates = c.get_pixel_positions((npixels, npixels), indexing='ij')\n    coordinates_rotated = c.rotate(coordinates, angle) + centre\n\n    # Interpolate\n    return map_coordinates(array, coordinates_rotated, order=order)\n</pre> def rotate(array : Array, angle : Array, order : int = 1) -&gt; Array:     \"\"\"     Rotates an array by the angle, using linear interpolation.      Parameters     ----------     array : Array         The array to rotate.     angle : Array, radians         The angle to rotate the array by.      Returns     -------     array : Array         The rotated array.     \"\"\"     if order not in (0, 1, 3):         raise ValueError(\"Order must be 0, 1, or 3.\")     # Get coordinates     npixels = array.shape[0]     centre = (npixels - 1) / 2     coordinates = c.get_pixel_positions((npixels, npixels), indexing='ij')     coordinates_rotated = c.rotate(coordinates, angle) + centre      # Interpolate     return map_coordinates(array, coordinates_rotated, order=order) In\u00a0[\u00a0]: Copied! <pre>def fourier_rotate(array   : Array,\n                   angle   : Array,\n                   padding : int = 2) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using a fourier rotation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    padding : int = 2\n        The amount of fourier padding to use.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n    raise NotImplementedError(\"Fourier rotation is under development.\")\n\n    in_shape = array.shape\n    array_shape = np.array(in_shape, dtype=int) + 3\n    array = np.full(array_shape, np.nan, dtype=float)\\\n        .at[1 : in_shape[0] + 1, 1 : in_shape[1] + 1]\\\n        .set(array)\n\n    # FFT rotation only work in the -45:+45 range\n    # So I need to work out how to determine the quadrant that\n    # angle is in and hence the\n    # number of required pi/2 rotations and angle in radians.\n    half_pi_to_1st_quadrant = angle // (np.pi / 2)\n    angle_in_1st_quadrant = - angle + (half_pi_to_1st_quadrant * np.pi / 2)\n\n    array = np.rot90(array, half_pi_to_1st_quadrant)\\\n        .at[:-1, :-1]\\\n        .get()\n\n    width, height = array.shape\n    left_corner   = int(((padding - 1) / 2.) * width)\n    right_corner  = int(((padding + 1) / 2.) * width)\n    top_corner    = int(((padding - 1) / 2.) * height)\n    bottom_corner = int(((padding + 1) / 2.) * height)\n\n    # Make the padded array\n    out_shape = (width * padding, height * padding)\n    padded_array = np.full(out_shape, np.nan, dtype=float)\\\n        .at[left_corner : right_corner, top_corner : bottom_corner]\\\n        .set(array)\n\n    padded_mask = np.ones(out_shape, dtype=bool)\\\n        .at[left_corner : right_corner, top_corner : bottom_corner]\\\n        .set(np.where(np.isnan(array), True, False))\n\n    # Rotate the mask, to know what part is actually the array\n    padded_mask = self.__rotate(padded_mask, -angle_in_1st_quadrant)\n\n    # Replace part outside the array which are NaN by 0, and go into \n    # Fourier space.\n    padded_array = np.where(np.isnan(padded_array), 0. , padded_array)\n\n    uncentered_angular_displacement = np.tan(angle_in_1st_quadrant / 2.)\n    centered_angular_displacement = -np.sin(angle_in_1st_quadrant)\n\n    uncentered_frequencies = np.fft.fftfreq(out_shape[0])\n    centered_frequencies = np.arange(-out_shape[0] / 2., out_shape[0] / 2.)\n\n    pi_factor = -2.j * np.pi * np.ones(out_shape, dtype=float)\n\n    uncentered_phase = np.exp(\n        uncentered_angular_displacement *\\\n        ((pi_factor * uncentered_frequencies).T *\\\n        centered_frequencies).T)\n\n    centered_phase = np.exp(\n        centered_angular_displacement *\\\n        (pi_factor * centered_frequencies).T *\\\n        uncentered_frequencies)\n\n    f1 = np.fft.ifft(\n        (np.fft.fft(padded_array, axis=0).T * uncentered_phase).T, axis=0)\n\n    f2 = np.fft.ifft(\n        np.fft.fft(f1, axis=1) * centered_phase, axis=1)\n\n    rotated_array = np.fft.ifft(\n        (np.fft.fft(f2, axis=0).T * uncentered_phase).T, axis=0)\\\n        .at[padded_mask]\\\n        .set(np.nan)\n\n    return np.real(rotated_array\\\n        .at[left_corner + 1 : right_corner - 1,\n            top_corner + 1 : bottom_corner - 1]\\\n        .get()).copy()\n</pre> def fourier_rotate(array   : Array,                    angle   : Array,                    padding : int = 2) -&gt; Array:     \"\"\"     Rotates an array by the angle, using a fourier rotation.      Parameters     ----------     array : Array         The array to rotate.     angle : Array, radians         The angle to rotate the array by.     padding : int = 2         The amount of fourier padding to use.      Returns     -------     array : Array         The rotated array.     \"\"\"     raise NotImplementedError(\"Fourier rotation is under development.\")      in_shape = array.shape     array_shape = np.array(in_shape, dtype=int) + 3     array = np.full(array_shape, np.nan, dtype=float)\\         .at[1 : in_shape[0] + 1, 1 : in_shape[1] + 1]\\         .set(array)      # FFT rotation only work in the -45:+45 range     # So I need to work out how to determine the quadrant that     # angle is in and hence the     # number of required pi/2 rotations and angle in radians.     half_pi_to_1st_quadrant = angle // (np.pi / 2)     angle_in_1st_quadrant = - angle + (half_pi_to_1st_quadrant * np.pi / 2)      array = np.rot90(array, half_pi_to_1st_quadrant)\\         .at[:-1, :-1]\\         .get()      width, height = array.shape     left_corner   = int(((padding - 1) / 2.) * width)     right_corner  = int(((padding + 1) / 2.) * width)     top_corner    = int(((padding - 1) / 2.) * height)     bottom_corner = int(((padding + 1) / 2.) * height)      # Make the padded array     out_shape = (width * padding, height * padding)     padded_array = np.full(out_shape, np.nan, dtype=float)\\         .at[left_corner : right_corner, top_corner : bottom_corner]\\         .set(array)      padded_mask = np.ones(out_shape, dtype=bool)\\         .at[left_corner : right_corner, top_corner : bottom_corner]\\         .set(np.where(np.isnan(array), True, False))      # Rotate the mask, to know what part is actually the array     padded_mask = self.__rotate(padded_mask, -angle_in_1st_quadrant)      # Replace part outside the array which are NaN by 0, and go into      # Fourier space.     padded_array = np.where(np.isnan(padded_array), 0. , padded_array)      uncentered_angular_displacement = np.tan(angle_in_1st_quadrant / 2.)     centered_angular_displacement = -np.sin(angle_in_1st_quadrant)      uncentered_frequencies = np.fft.fftfreq(out_shape[0])     centered_frequencies = np.arange(-out_shape[0] / 2., out_shape[0] / 2.)      pi_factor = -2.j * np.pi * np.ones(out_shape, dtype=float)      uncentered_phase = np.exp(         uncentered_angular_displacement *\\         ((pi_factor * uncentered_frequencies).T *\\         centered_frequencies).T)      centered_phase = np.exp(         centered_angular_displacement *\\         (pi_factor * centered_frequencies).T *\\         uncentered_frequencies)      f1 = np.fft.ifft(         (np.fft.fft(padded_array, axis=0).T * uncentered_phase).T, axis=0)      f2 = np.fft.ifft(         np.fft.fft(f1, axis=1) * centered_phase, axis=1)      rotated_array = np.fft.ifft(         (np.fft.fft(f2, axis=0).T * uncentered_phase).T, axis=0)\\         .at[padded_mask]\\         .set(np.nan)      return np.real(rotated_array\\         .at[left_corner + 1 : right_corner - 1,             top_corner + 1 : bottom_corner - 1]\\         .get()).copy()"},{"location":"dLux/utils/math/","title":"Math","text":"In\u00a0[\u00a0]: Copied! <pre>from jax import lax\n</pre> from jax import lax In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"factorial\"]\n\n \n # TODO: Use lax.cond to make n == 0 a safe case\ndef factorial(n : float) -&gt; float:\n\"\"\"\n    Calculate n! in a jax friendly way. Note that n == 0 is not a \n    safe case.  \n    Parameters\n    ----------\n    n : float\n        The value to calculate the factorial of.\n    Returns\n    -------\n    n! : float\n        The factorial of the value.\n    \"\"\"\n    return lax.exp(lax.lgamma(n + 1.))\n</pre> __all__ = [\"factorial\"]     # TODO: Use lax.cond to make n == 0 a safe case def factorial(n : float) -&gt; float:     \"\"\"     Calculate n! in a jax friendly way. Note that n == 0 is not a      safe case.         Parameters     ----------     n : float         The value to calculate the factorial of.       Returns     -------     n! : float         The factorial of the value.     \"\"\"     return lax.exp(lax.lgamma(n + 1.))"},{"location":"dLux/utils/models/","title":"Models","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport dLux\n</pre> import jax.numpy as np import dLux In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"simple_optical_system\", \"toliman\"]\n</pre> __all__ = [\"simple_optical_system\", \"toliman\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def simple_optical_system(aperture_diameter         : Array,\n                          wavefront_npixels         : int,\n                          detector_npixels          : int,\n                          detector_pixel_size       : Array,\n                          angular                   : bool  = True,\n                          focal_length              : Array = None,\n                          secondary_mirror_diameter : Array = None,\n                          nzernike                  : int   = None,\n                          zernike_coefficients      : Array = None,\n                          extra_layers              : list  = None,\n                          return_layers             : bool  = False):\n\"\"\"\n    Constucts a simple Fourier optical system.\n\n    Parameters\n    ----------\n    aperture_diameter : Array, meters\n        The diameter of the optical system aperture.\n    wavefront_npixels : int\n        The number of pixel used to represent the wavefront.\n    detector_npixels : int\n        The number of pixel of the detector\n    detector_pixel_size : Array, arcseconds/pixel or meters/pixel\n        The size of the detector pixels. Taken in units of arcseconds per pixel\n        if anuglar == True, else units are taken in meters per pixel.\n    angular : bool = True\n        Whether to use angular (radians) or cartesian (meters) units.\n    focal_length : Array = None\n        The focal length of the optical system. This paramter is only used if\n        angular == False.\n    secondary_mirror_diameter : Array = None\n        The diameter of the secondary mirror obscuration.\n    nzernike : int = None\n        The number of zernike terms to use. Ignore piston tip tilt.\n    zernike_coefficients : Array = None\n        The values of the zernike coefficients. Only used if nzerike == None.\n    extra_layers : list = None\n        The extra layers to add to the optical system.\n    return_layers : bool = False\n        Should the function return the layers, or an Optics class.\n\n    Returns\n    -------\n    optics : OpticalSystem\n        The optical system with the optical layers loaded.\n    \"\"\"\n    # Inputs checks\n    aperture_diameter = np.asarray(aperture_diameter, dtype=float)\n    assert aperture_diameter.ndim == 0, (\"aperture_diameter must be scalar.\")\n\n    assert isinstance(wavefront_npixels, int), \\\n    (\"wavefront_npixels must be an integer.\")\n\n    assert isinstance(detector_npixels, int), \\\n    (\"detector_npixels must be an integer.\")\n    detector_pixel_size = np.asarray(detector_pixel_size, dtype=float)\n\n    assert detector_pixel_size.ndim == 0, \\\n    (\"detector_pixel_size must be scalar.\")\n\n    assert isinstance(angular, bool), (\"angular must be a boolean.\")\n\n    if not angular:\n        focal_length = np.asarray(focal_length, dtype=float)\n        assert focal_length.ndim == 0, (\"focal_length must be scalar.\")\n\n    if secondary_mirror_diameter is not None:\n        secondary_mirror_diameter = np.asarray(secondary_mirror_diameter, \\\n                                               dtype=float)\n        assert secondary_mirror_diameter.ndim == 0, \\\n        (\"focal_length must be scalar.\")\n\n    if nzernike is not None:\n        assert isinstance(nzernike, int), (\"nzernike must an integer.\")\n\n    if zernike_coefficients is not None:\n        zernike_coefficients = np.asarray(zernike_coefficients, dtype=float)\n        assert zernike_coefficients.ndim == 1, \\\n        (\"zernike_coefficients must a one dimensional array.\")\n        assert len(zernike_coefficients) == nzernike, \\\n        (\"The lenght of zernike_coefficients must be equal to nzerike.\")\n\n    if extra_layers is not None:\n        assert isinstance(extra_layers, list), (\"extra_layers must be a list.\")\n        for layer in extra_layers:\n            assert isinstance(layer, dLux.optics.OpticalLayer), \\\n            (\"Each item in extra_layers must be a dLux OpticalLayer.\")\n\n    assert isinstance(return_layers, bool), \"return_layers must be a boolean.\"\n\n    # Create wavefront\n    if angular:\n        layers = [dLux.optics.CreateWavefront(wavefront_npixels,\n                                              aperture_diameter,\n                                              wavefront_type=\"Angular\")]\n    else:\n        layers = [dLux.optics.CreateWavefront(wavefront_npixels,\n                                              aperture_diameter)]\n\n    # Construct aperture\n    if secondary_mirror_diameter is not None:\n        secondary_ratio = secondary_mirror_diameter/aperture_diameter\n    else:\n        secondary_ratio = 0.\n    \n    if nzernike is not None:\n        zernikes = np.arange(3, nzernike + 3)\n        if zernike_coefficients is not None:\n            coeffs = zernike_coefficients\n        else:\n            coeffs = np.zeros(nzernike)\n    else:\n        zernikes = None\n        coeffs = None\n    \n    layers +=[dLux.ApertureFactory(wavefront_npixels, \n                secondary_ratio=secondary_ratio, zernikes=zernikes, \n                coefficients=coeffs)]\n\n    # Extra Layers\n    if extra_layers is not None:\n        for layer in extra_layers:\n            layers.append(layer)\n\n    # Normalised wavefront\n    layers += [dLux.NormaliseWavefront()]\n\n    # Propagator\n    if angular:\n        layers += [dLux.AngularMFT(detector_npixels,\n                        dLux.utils.arcseconds_to_radians(detector_pixel_size))]\n    else:\n        layers += [dLux.CartesianMFT(detector_npixels, detector_pixel_size,\n                                   focal_length)]\n\n    # Return optics or layers\n    return layers if return_layers else dLux.core.Optics(layers)\n</pre> def simple_optical_system(aperture_diameter         : Array,                           wavefront_npixels         : int,                           detector_npixels          : int,                           detector_pixel_size       : Array,                           angular                   : bool  = True,                           focal_length              : Array = None,                           secondary_mirror_diameter : Array = None,                           nzernike                  : int   = None,                           zernike_coefficients      : Array = None,                           extra_layers              : list  = None,                           return_layers             : bool  = False):     \"\"\"     Constucts a simple Fourier optical system.      Parameters     ----------     aperture_diameter : Array, meters         The diameter of the optical system aperture.     wavefront_npixels : int         The number of pixel used to represent the wavefront.     detector_npixels : int         The number of pixel of the detector     detector_pixel_size : Array, arcseconds/pixel or meters/pixel         The size of the detector pixels. Taken in units of arcseconds per pixel         if anuglar == True, else units are taken in meters per pixel.     angular : bool = True         Whether to use angular (radians) or cartesian (meters) units.     focal_length : Array = None         The focal length of the optical system. This paramter is only used if         angular == False.     secondary_mirror_diameter : Array = None         The diameter of the secondary mirror obscuration.     nzernike : int = None         The number of zernike terms to use. Ignore piston tip tilt.     zernike_coefficients : Array = None         The values of the zernike coefficients. Only used if nzerike == None.     extra_layers : list = None         The extra layers to add to the optical system.     return_layers : bool = False         Should the function return the layers, or an Optics class.      Returns     -------     optics : OpticalSystem         The optical system with the optical layers loaded.     \"\"\"     # Inputs checks     aperture_diameter = np.asarray(aperture_diameter, dtype=float)     assert aperture_diameter.ndim == 0, (\"aperture_diameter must be scalar.\")      assert isinstance(wavefront_npixels, int), \\     (\"wavefront_npixels must be an integer.\")      assert isinstance(detector_npixels, int), \\     (\"detector_npixels must be an integer.\")     detector_pixel_size = np.asarray(detector_pixel_size, dtype=float)      assert detector_pixel_size.ndim == 0, \\     (\"detector_pixel_size must be scalar.\")      assert isinstance(angular, bool), (\"angular must be a boolean.\")      if not angular:         focal_length = np.asarray(focal_length, dtype=float)         assert focal_length.ndim == 0, (\"focal_length must be scalar.\")      if secondary_mirror_diameter is not None:         secondary_mirror_diameter = np.asarray(secondary_mirror_diameter, \\                                                dtype=float)         assert secondary_mirror_diameter.ndim == 0, \\         (\"focal_length must be scalar.\")      if nzernike is not None:         assert isinstance(nzernike, int), (\"nzernike must an integer.\")      if zernike_coefficients is not None:         zernike_coefficients = np.asarray(zernike_coefficients, dtype=float)         assert zernike_coefficients.ndim == 1, \\         (\"zernike_coefficients must a one dimensional array.\")         assert len(zernike_coefficients) == nzernike, \\         (\"The lenght of zernike_coefficients must be equal to nzerike.\")      if extra_layers is not None:         assert isinstance(extra_layers, list), (\"extra_layers must be a list.\")         for layer in extra_layers:             assert isinstance(layer, dLux.optics.OpticalLayer), \\             (\"Each item in extra_layers must be a dLux OpticalLayer.\")      assert isinstance(return_layers, bool), \"return_layers must be a boolean.\"      # Create wavefront     if angular:         layers = [dLux.optics.CreateWavefront(wavefront_npixels,                                               aperture_diameter,                                               wavefront_type=\"Angular\")]     else:         layers = [dLux.optics.CreateWavefront(wavefront_npixels,                                               aperture_diameter)]      # Construct aperture     if secondary_mirror_diameter is not None:         secondary_ratio = secondary_mirror_diameter/aperture_diameter     else:         secondary_ratio = 0.          if nzernike is not None:         zernikes = np.arange(3, nzernike + 3)         if zernike_coefficients is not None:             coeffs = zernike_coefficients         else:             coeffs = np.zeros(nzernike)     else:         zernikes = None         coeffs = None          layers +=[dLux.ApertureFactory(wavefront_npixels,                  secondary_ratio=secondary_ratio, zernikes=zernikes,                  coefficients=coeffs)]      # Extra Layers     if extra_layers is not None:         for layer in extra_layers:             layers.append(layer)      # Normalised wavefront     layers += [dLux.NormaliseWavefront()]      # Propagator     if angular:         layers += [dLux.AngularMFT(detector_npixels,                         dLux.utils.arcseconds_to_radians(detector_pixel_size))]     else:         layers += [dLux.CartesianMFT(detector_npixels, detector_pixel_size,                                    focal_length)]      # Return optics or layers     return layers if return_layers else dLux.core.Optics(layers) In\u00a0[\u00a0]: Copied! <pre>def toliman(wavefront_npixels         : int,\n            detector_npixels          : int,\n            aperture_diameter         : Array = 0.13,\n            secondary_mirror_diameter : Array = 0.032,\n            detector_pixel_size       : Array = 0.375,\n            angular                   : bool  = True,\n            focal_length              : Array = None,\n            nzernike                  : int   = None,\n            zernike_coefficients      : Array = None,\n            extra_layers              : list  = None,\n            return_layers             : bool  = False):\n\"\"\"\n    Gets a simple Toliman optical system by calling the simple_optical_system\n    function with pre-loaded values.\n\n    Parameters\n    ----------\n    wavefront_npixels : int\n        The number of pixel used to represent the wavefront.\n    detector_npixels : int\n        The number of pixel of the detector\n    aperture_diameter : Array, meters = 0.13\n        The diameter of the optical system aperture.\n    secondary_mirror_diameter : Array = 0.032\n        The diameter of the secondary mirror obscuration.\n    detector_pixel_size : Array, arcseconds/pixel or meters/pixel = 0.375\n        The size of the detector pixels. Taken in units of arcseconds per pixel\n        if anuglar == True, else units are taken in meters per pixel. The\n        physical detector pixels are 2.4um\n    angular : bool = True\n        Whether to use angular (radians) or cartesian (meters) units.\n    focal_length : Array = None\n        The focal length of the optical system. This paramter is only used if\n        angular == False. The EFL is 1.32m.\n    nzernike : int = None\n        The number of zernike terms to use. Ignore piston tip tilt.\n    zernike_coefficients : Array = None\n        The values of the zernike coefficients. Only used if nzerike == None.\n    extra_layers : list = None\n        The extra layers to add to the optical system.\n    return_layers : bool = False\n        Should the function return the layers, or an Optics class.\n\n    Returns\n    -------\n    optics : OpticalSystem\n        The optical system with the optical layers loaded.\n    \"\"\"\n    return simple_optical_system(\n                        aperture_diameter,\n                        wavefront_npixels,\n                        detector_npixels,\n                        detector_pixel_size=detector_pixel_size,\n                        angular=angular,\n                        focal_length=focal_length,\n                        secondary_mirror_diameter=secondary_mirror_diameter,\n                        nzernike=nzernike,\n                        zernike_coefficients=zernike_coefficients,\n                        extra_layers=extra_layers,\n                        return_layers=return_layers)\n</pre> def toliman(wavefront_npixels         : int,             detector_npixels          : int,             aperture_diameter         : Array = 0.13,             secondary_mirror_diameter : Array = 0.032,             detector_pixel_size       : Array = 0.375,             angular                   : bool  = True,             focal_length              : Array = None,             nzernike                  : int   = None,             zernike_coefficients      : Array = None,             extra_layers              : list  = None,             return_layers             : bool  = False):     \"\"\"     Gets a simple Toliman optical system by calling the simple_optical_system     function with pre-loaded values.      Parameters     ----------     wavefront_npixels : int         The number of pixel used to represent the wavefront.     detector_npixels : int         The number of pixel of the detector     aperture_diameter : Array, meters = 0.13         The diameter of the optical system aperture.     secondary_mirror_diameter : Array = 0.032         The diameter of the secondary mirror obscuration.     detector_pixel_size : Array, arcseconds/pixel or meters/pixel = 0.375         The size of the detector pixels. Taken in units of arcseconds per pixel         if anuglar == True, else units are taken in meters per pixel. The         physical detector pixels are 2.4um     angular : bool = True         Whether to use angular (radians) or cartesian (meters) units.     focal_length : Array = None         The focal length of the optical system. This paramter is only used if         angular == False. The EFL is 1.32m.     nzernike : int = None         The number of zernike terms to use. Ignore piston tip tilt.     zernike_coefficients : Array = None         The values of the zernike coefficients. Only used if nzerike == None.     extra_layers : list = None         The extra layers to add to the optical system.     return_layers : bool = False         Should the function return the layers, or an Optics class.      Returns     -------     optics : OpticalSystem         The optical system with the optical layers loaded.     \"\"\"     return simple_optical_system(                         aperture_diameter,                         wavefront_npixels,                         detector_npixels,                         detector_pixel_size=detector_pixel_size,                         angular=angular,                         focal_length=focal_length,                         secondary_mirror_diameter=secondary_mirror_diameter,                         nzernike=nzernike,                         zernike_coefficients=zernike_coefficients,                         extra_layers=extra_layers,                         return_layers=return_layers)"},{"location":"dLux/utils/optics/","title":"Optics","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\n</pre> import jax.numpy as np In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"opd_to_phase\", \"phase_to_opd\", \"get_fringe_size\", \n           \"get_pixels_per_fringe\", \"get_pixel_scale\", \"get_airy_pixel_scale\"]\n</pre> __all__ = [\"opd_to_phase\", \"phase_to_opd\", \"get_fringe_size\",             \"get_pixels_per_fringe\", \"get_pixel_scale\", \"get_airy_pixel_scale\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def opd_to_phase(opd : Array, wavelength : Array) -&gt; Array:\n\"\"\"\n    Converts the input Optical Path Difference (opd) in units of meters to\n    phases in units of radians for the given wavelength.\n\n    Parameters\n    ----------\n    opd : Array, meters\n        The Optical Path Difference (opd) to be converted into phase.\n    wavelength : Array, meters\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    phase : Array, radians\n        The equivilent phase value for the given opd and wavelength.\n    \"\"\"\n    return 2*np.pi*opd/wavelength\n</pre> def opd_to_phase(opd : Array, wavelength : Array) -&gt; Array:     \"\"\"     Converts the input Optical Path Difference (opd) in units of meters to     phases in units of radians for the given wavelength.      Parameters     ----------     opd : Array, meters         The Optical Path Difference (opd) to be converted into phase.     wavelength : Array, meters         The wavelength at which to calculate the phase for.      Returns     -------     phase : Array, radians         The equivilent phase value for the given opd and wavelength.     \"\"\"     return 2*np.pi*opd/wavelength In\u00a0[\u00a0]: Copied! <pre>def phase_to_opd(phase : Array, wavelength : Array) -&gt; Array:\n\"\"\"\n    Converts the input phase in units of radians to the equivilent Optical Path\n    Difference (opd) in meters for the given wavelength.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be converted into Optical Path Difference (opd)\n    wavelength : Array, meters\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    opd : Array, meters\n        The equivilent opd value for the given phase and wavelength.\n    \"\"\"\n    return phase*wavelength/(2*np.pi)\n</pre> def phase_to_opd(phase : Array, wavelength : Array) -&gt; Array:     \"\"\"     Converts the input phase in units of radians to the equivilent Optical Path     Difference (opd) in meters for the given wavelength.      Parameters     ----------     phase : Array, radians         The phase to be converted into Optical Path Difference (opd)     wavelength : Array, meters         The wavelength at which to calculate the phase for.      Returns     -------     opd : Array, meters         The equivilent opd value for the given phase and wavelength.     \"\"\"     return phase*wavelength/(2*np.pi) In\u00a0[\u00a0]: Copied! <pre>def get_fringe_size(wavelength : Array, aperture : Array) -&gt; Array:\n\"\"\"\n    Calcualtes the angular size of the diffraction fringes.\n\n    Parameters\n    ----------\n    wavelength : Array, meters\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, meters\n        The size of the aperture.\n\n    Returns\n    -------\n    fringe_size : Array, radians\n        The angular fringe size in units of radians.\n    \"\"\"\n    return wavelength/aperture\n</pre> def get_fringe_size(wavelength : Array, aperture : Array) -&gt; Array:     \"\"\"     Calcualtes the angular size of the diffraction fringes.      Parameters     ----------     wavelength : Array, meters         The wavelength at which to calculate the diffraction fringe for.     aperture : Array, meters         The size of the aperture.      Returns     -------     fringe_size : Array, radians         The angular fringe size in units of radians.     \"\"\"     return wavelength/aperture In\u00a0[\u00a0]: Copied! <pre>def get_pixels_per_fringe(wavelength   : Array,\n                          aperture     : Array,\n                          pixel_scale  : Array,\n                          focal_length : Array = None) -&gt; Array:\n\"\"\"\n    Calculates the number of pixels per diffraction fringe, ie the fringe\n    sampling rate.\n\n    Parameters\n    ----------\n    wavelength : Array, meters\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, meters\n        The size of the aperture.\n    pixel_scale : Array, meters/pixel or radians/pixel\n        The size of each pixel. This is taken in units of radians per pixel if\n        no focal length is provided, else it is taken in size of meters per\n        pixel.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is taken in units of radians per pixel, else it is taken in\n        meters per pixel.\n\n    Returns\n    -------\n    sampling : Array\n        The sampling rate of the fringes in units of pixels.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to meters if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Return sampling\n    return fringe_size/pixel_scale\n    # return pixel_scale/fringe_size\n</pre> def get_pixels_per_fringe(wavelength   : Array,                           aperture     : Array,                           pixel_scale  : Array,                           focal_length : Array = None) -&gt; Array:     \"\"\"     Calculates the number of pixels per diffraction fringe, ie the fringe     sampling rate.      Parameters     ----------     wavelength : Array, meters         The wavelength at which to calculate the diffraction fringe for.     aperture : Array, meters         The size of the aperture.     pixel_scale : Array, meters/pixel or radians/pixel         The size of each pixel. This is taken in units of radians per pixel if         no focal length is provided, else it is taken in size of meters per         pixel.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is taken in units of radians per pixel, else it is taken in         meters per pixel.      Returns     -------     sampling : Array         The sampling rate of the fringes in units of pixels.     \"\"\"     # Get fringe size     fringe_size = get_fringe_size(wavelength, aperture)      # Convert to meters if focal_length is provided     if focal_length is not None:         fringe_size *= focal_length      # Return sampling     return fringe_size/pixel_scale     # return pixel_scale/fringe_size In\u00a0[\u00a0]: Copied! <pre>def get_pixel_scale(sampling_rate : Array,\n                    wavelength    : Array,\n                    aperture      : Array,\n                    focal_length  : Array = None) -&gt; Array:\n\"\"\"\n    Calcaultes the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, meters\n        The observation wavelength.\n    aperture : Array, meters\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        meters per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or meters per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radans per pixel if no focal length is\n        provided, else in units of meters per pixel.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to meters if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Get sampling rate\n    return fringe_size / sampling_rate\n</pre> def get_pixel_scale(sampling_rate : Array,                     wavelength    : Array,                     aperture      : Array,                     focal_length  : Array = None) -&gt; Array:     \"\"\"     Calcaultes the pixel_size needed in order to sample the diffraction fringes     at the given sampling rate.      Parameters     ----------     sampling_rate : Array         The rate at which to sample the diffraction fringes. A value of 2 will         give nyquist sampled pixels.     wavelength : Array, meters         The observation wavelength.     aperture : Array, meters         The size of the aperture.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is given in units of radians per pixel, else it is given in         meters per pixel.      Returns     -------     pixel_scale : Array, radians per pixel or meters per pixel         The pixel_size needed to sample the diffraction fringes at the input         sampling rate, in units of radans per pixel if no focal length is         provided, else in units of meters per pixel.     \"\"\"     # Get fringe size     fringe_size = get_fringe_size(wavelength, aperture)      # Convert to meters if focal_length is provided     if focal_length is not None:         fringe_size *= focal_length      # Get sampling rate     return fringe_size / sampling_rate In\u00a0[\u00a0]: Copied! <pre>def get_airy_pixel_scale(sampling_rate : Array,\n                         wavelength    : Array,\n                         aperture      : Array,\n                         focal_length  : Array = None) -&gt; Array:\n\"\"\"\n    Calcaultes the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate. Applies the 1.22 multiplier for Airy disk\n    diffraction fringes given by a circular aperture.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, meters\n        The observation wavelength.\n    aperture : Array, meters\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        meters per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or meters per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radans per pixel if no focal length is\n        provided, else in units of meters per pixel.\n    \"\"\"\n    return get_pixel_scale(sampling_rate, 1.22*wavelength, aperture,\n                           focal_length)\n</pre> def get_airy_pixel_scale(sampling_rate : Array,                          wavelength    : Array,                          aperture      : Array,                          focal_length  : Array = None) -&gt; Array:     \"\"\"     Calcaultes the pixel_size needed in order to sample the diffraction fringes     at the given sampling rate. Applies the 1.22 multiplier for Airy disk     diffraction fringes given by a circular aperture.      Parameters     ----------     sampling_rate : Array         The rate at which to sample the diffraction fringes. A value of 2 will         give nyquist sampled pixels.     wavelength : Array, meters         The observation wavelength.     aperture : Array, meters         The size of the aperture.     focal_length : Array = None         The focal length of the optical system. If none is provided, the pixel         scale is given in units of radians per pixel, else it is given in         meters per pixel.      Returns     -------     pixel_scale : Array, radians per pixel or meters per pixel         The pixel_size needed to sample the diffraction fringes at the input         sampling rate, in units of radans per pixel if no focal length is         provided, else in units of meters per pixel.     \"\"\"     return get_pixel_scale(sampling_rate, 1.22*wavelength, aperture,                            focal_length)"},{"location":"dLux/utils/units/","title":"Units","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\n</pre> import jax.numpy as np In\u00a0[\u00a0]: Copied! <pre>__all__ = [\"convert_cartesian\", \"convert_angular\",\n           \"radians_to_arcseconds\", \"radians_to_degrees\", \n           \"radians_to_arcminutes\", \"degrees_to_radians\", \n           \"degrees_to_arcminutes\", \"degrees_to_arcseconds\", \n           \"arcminutes_to_radians\", \"arcminutes_to_degrees\", \n           \"arcminutes_to_arcseconds\", \"arcseconds_to_radians\", \n           \"arcseconds_to_degrees\", \"arcseconds_to_arcminutes\",\n           \"r2s\", \"r2d\", \"r2m\", \"d2r\", \"d2m\", \"d2s\", \n           \"m2r\", \"m2d\", \"m2s\", \"s2r\", \"s2d\", \"s2m\"]\n</pre> __all__ = [\"convert_cartesian\", \"convert_angular\",            \"radians_to_arcseconds\", \"radians_to_degrees\",             \"radians_to_arcminutes\", \"degrees_to_radians\",             \"degrees_to_arcminutes\", \"degrees_to_arcseconds\",             \"arcminutes_to_radians\", \"arcminutes_to_degrees\",             \"arcminutes_to_arcseconds\", \"arcseconds_to_radians\",             \"arcseconds_to_degrees\", \"arcseconds_to_arcminutes\",            \"r2s\", \"r2d\", \"r2m\", \"d2r\", \"d2m\", \"d2s\",             \"m2r\", \"m2d\", \"m2s\", \"s2r\", \"s2d\", \"s2m\"] In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre># General conversion classes:\ndef convert_cartesian(values : Array, \n                      input  : str = 'meters', \n                      output : str = 'meters') -&gt; Array:\n\"\"\"\n    Converts the input values from one unit to another.\n\n    Parameters\n    ----------\n    values : Array\n        The input values to be converted.\n    input : str = 'meters'\n        The input units. Must be one of 'meters', 'millimeters', or 'microns'.\n    output : str = 'meters'\n        The output units. Must be one of 'meters', 'millimeters', or 'microns'.\n    Returns\n    -------\n    values : Array\n        The input values converted into the output units.\n    \"\"\"\n    if input not in ('meters', 'millimeters', 'microns'):\n        raise ValueError(\"input must be 'meters', 'millimeters', or 'microns'.\")\n    if output not in ('meters', 'millimeters', 'microns'):\n        raise ValueError(\"output must be 'meters', 'millimeters', or \"\n                         \"'microns'.\")\n    \n    if input == output:\n        factor = 1\n    elif input == 'meters':\n        if output == 'millimeters':\n            factor = 1e-3\n        elif output == 'microns':\n            factor = 1e-6\n    elif input == 'millimeter':\n        if output == 'meters':\n            factor = 1e3\n        elif output == 'microns':\n            factor = 1e-3\n    elif input == 'microns':\n        if output == 'meters':\n            factor = 1e6\n        elif output == 'millimeters':\n            factor = 1e3\n    return values * factor\n</pre> # General conversion classes: def convert_cartesian(values : Array,                        input  : str = 'meters',                        output : str = 'meters') -&gt; Array:     \"\"\"     Converts the input values from one unit to another.      Parameters     ----------     values : Array         The input values to be converted.     input : str = 'meters'         The input units. Must be one of 'meters', 'millimeters', or 'microns'.     output : str = 'meters'         The output units. Must be one of 'meters', 'millimeters', or 'microns'.          Returns     -------     values : Array         The input values converted into the output units.     \"\"\"     if input not in ('meters', 'millimeters', 'microns'):         raise ValueError(\"input must be 'meters', 'millimeters', or 'microns'.\")     if output not in ('meters', 'millimeters', 'microns'):         raise ValueError(\"output must be 'meters', 'millimeters', or \"                          \"'microns'.\")          if input == output:         factor = 1     elif input == 'meters':         if output == 'millimeters':             factor = 1e-3         elif output == 'microns':             factor = 1e-6     elif input == 'millimeter':         if output == 'meters':             factor = 1e3         elif output == 'microns':             factor = 1e-3     elif input == 'microns':         if output == 'meters':             factor = 1e6         elif output == 'millimeters':             factor = 1e3     return values * factor In\u00a0[\u00a0]: Copied! <pre>def convert_angular(values : Array,\n                    input  : str = 'radians',\n                    output : str = 'radians') -&gt; Array:\n\"\"\"\n    Converts the input values from one unit to another.\n\n    Parameters\n    ----------\n    values : Array\n        The input values to be converted.\n    input : str = 'radians'\n        The input units. Must be one of 'radians', 'degrees', 'arcseconds', or\n        'arcminutes'.\n    output : str = 'radians'\n        The output units. Must be one of 'radians', 'degrees', 'arcseconds', or\n        'arcminutes'.\n    Returns\n    -------\n    values : Array\n        The input values converted into the output units.\n    \"\"\"\n    if input not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):\n        raise ValueError(f\"input must be one of 'radians', 'degrees', \"\n                         f\"'arcseconds' or 'arcminutes'.\")\n    if output not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):\n        raise ValueError(f\"output must be one of 'radians', 'degrees', \"\n                         f\"'arcseconds' or 'arcminutes'.\")\n\n    if input == output:\n        factor = 1\n    elif input == 'radians':\n        if output == 'degrees':\n            factor = r2d(1)\n        elif output == 'arcminutes':\n            factor = r2m(1)\n        elif output == 'arcseconds':\n            factor = r2s(1)\n    elif input == 'degrees':\n        if output == 'radians':\n            factor = d2r(1)\n        elif output == 'arcminutes':\n            factor = d2m(1)\n        elif output == 'arcseconds':\n            factor = d2s(1)\n    elif input == 'arcminutes':\n        if output == 'radians':\n            factor = m2r(1)\n        elif output == 'degrees':\n            factor = m2d(1)\n        elif output == 'arcseconds':\n            factor = m2s(1)\n    elif input == 'arcseconds':\n        if output == 'radians':\n            factor = s2r(1)\n        elif output == 'degrees':\n            factor = s2d(1)\n        elif output == 'arcminutes':\n            factor = s2m(1)\n    return values * factor\n</pre> def convert_angular(values : Array,                     input  : str = 'radians',                     output : str = 'radians') -&gt; Array:     \"\"\"     Converts the input values from one unit to another.      Parameters     ----------     values : Array         The input values to be converted.     input : str = 'radians'         The input units. Must be one of 'radians', 'degrees', 'arcseconds', or         'arcminutes'.     output : str = 'radians'         The output units. Must be one of 'radians', 'degrees', 'arcseconds', or         'arcminutes'.          Returns     -------     values : Array         The input values converted into the output units.     \"\"\"     if input not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):         raise ValueError(f\"input must be one of 'radians', 'degrees', \"                          f\"'arcseconds' or 'arcminutes'.\")     if output not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):         raise ValueError(f\"output must be one of 'radians', 'degrees', \"                          f\"'arcseconds' or 'arcminutes'.\")      if input == output:         factor = 1     elif input == 'radians':         if output == 'degrees':             factor = r2d(1)         elif output == 'arcminutes':             factor = r2m(1)         elif output == 'arcseconds':             factor = r2s(1)     elif input == 'degrees':         if output == 'radians':             factor = d2r(1)         elif output == 'arcminutes':             factor = d2m(1)         elif output == 'arcseconds':             factor = d2s(1)     elif input == 'arcminutes':         if output == 'radians':             factor = m2r(1)         elif output == 'degrees':             factor = m2d(1)         elif output == 'arcseconds':             factor = m2s(1)     elif input == 'arcseconds':         if output == 'radians':             factor = s2r(1)         elif output == 'degrees':             factor = s2d(1)         elif output == 'arcminutes':             factor = s2m(1)     return values * factor In\u00a0[\u00a0]: Copied! <pre># Radians to:\ndef radians_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcseconds.\n\n    Can also be imported as r2s.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600 * 180 / np.pi\n</pre> # Radians to: def radians_to_arcseconds(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to arcseconds.      Can also be imported as r2s.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 3600 * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre>def radians_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to degrees.\n\n    Can also be imported as r2d.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values * 180 / np.pi\n</pre> def radians_to_degrees(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to degrees.      Can also be imported as r2d.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre>def radians_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcminutes.\n\n    Can also be imported as r2m.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60 * 180 / np.pi\n</pre> def radians_to_arcminutes(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from radians to arcminutes.      Can also be imported as r2m.      Parameters     ----------     values : Array, radians         The input values in units of radians to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values * 60 * 180 / np.pi In\u00a0[\u00a0]: Copied! <pre># Degrees to:\ndef degrees_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to radians.\n\n    Can also be imported as d2r.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / 180\n</pre> # Degrees to: def degrees_to_radians(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to radians.      Can also be imported as d2r.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / 180 In\u00a0[\u00a0]: Copied! <pre>def degrees_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcminutes.\n\n    Can also be imported as d2m.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60\n</pre> def degrees_to_arcminutes(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to arcminutes.      Can also be imported as d2m.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values * 60 In\u00a0[\u00a0]: Copied! <pre>def degrees_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcseconds.\n\n    Can also be imported as d2s.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600\n</pre> def degrees_to_arcseconds(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from degrees to arcseconds.      Can also be imported as d2s.      Parameters     ----------     values : Array, degrees         The input values in units of degrees to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 3600 In\u00a0[\u00a0]: Copied! <pre># Arcminutes to:\ndef arcminutes_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to radians.\n\n    Can also be imported as m2r.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (60 * 180)\n</pre> # Arcminutes to: def arcminutes_to_radians(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to radians.      Can also be imported as m2r.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / (60 * 180) In\u00a0[\u00a0]: Copied! <pre>def arcminutes_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to degrees.\n\n    Can also be imported as m2d.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 60\n</pre> def arcminutes_to_degrees(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to degrees.      Can also be imported as m2d.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values / 60 In\u00a0[\u00a0]: Copied! <pre>def arcminutes_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to arcseconds.\n\n    Can also be imported as m2s.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 60\n</pre> def arcminutes_to_arcseconds(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcminutes to arcseconds.      Can also be imported as m2s.      Parameters     ----------     values : Array, arcminutes         The input values in units of arcminutes to be converted into arcseconds.      Returns     -------     values : Array, arcseconds         The input values converted into arcseconds.     \"\"\"     return values * 60 In\u00a0[\u00a0]: Copied! <pre># Arcseconds to:\ndef arcseconds_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to radians.\n\n    Can also be imported as s2r.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (3600 * 180)\n</pre> # Arcseconds to: def arcseconds_to_radians(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to radians.      Can also be imported as s2r.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into radians.      Returns     -------     values : Array, radians         The input values converted into radians.     \"\"\"     return values * np.pi / (3600 * 180) In\u00a0[\u00a0]: Copied! <pre>def arcseconds_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to degrees.\n\n    Can also be imported as s2d.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 3600\n</pre> def arcseconds_to_degrees(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to degrees.      Can also be imported as s2d.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into degrees.      Returns     -------     values : Array, degrees         The input values converted into degrees.     \"\"\"     return values / 3600 In\u00a0[\u00a0]: Copied! <pre>def arcseconds_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to arcminutes.\n\n    Can also be imported as s2m.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values / 60\n</pre> def arcseconds_to_arcminutes(values : Array) -&gt; Array:     \"\"\"     Converts the inputs values from arcseconds to arcminutes.      Can also be imported as s2m.      Parameters     ----------     values : Array, arcseconds         The input values in units of arcseconds to be converted into arcminutes.      Returns     -------     values : Array, arcminutes         The input values converted into arcminutes.     \"\"\"     return values / 60 In\u00a0[\u00a0]: Copied! <pre># Alias to simpler names\nr2s = radians_to_arcseconds\nr2d = radians_to_degrees\nr2m = radians_to_arcminutes\nd2r = degrees_to_radians\nd2m = degrees_to_arcminutes\nd2s = degrees_to_arcseconds\nm2r = arcminutes_to_radians\nm2d = arcminutes_to_degrees\nm2s = arcminutes_to_arcseconds\ns2r = arcseconds_to_radians\ns2d = arcseconds_to_degrees\ns2m = arcseconds_to_arcminutes\n</pre> # Alias to simpler names r2s = radians_to_arcseconds r2d = radians_to_degrees r2m = radians_to_arcminutes d2r = degrees_to_radians d2m = degrees_to_arcminutes d2s = degrees_to_arcseconds m2r = arcminutes_to_radians m2d = arcminutes_to_degrees m2s = arcminutes_to_arcseconds s2r = arcseconds_to_radians s2d = arcseconds_to_degrees s2m = arcseconds_to_arcminutes"},{"location":"docs/creating_a_layer/","title":"Creating a Layer","text":"<p>Coming soon...</p>"},{"location":"docs/installation/","title":"Installation","text":"<p>\u2202Lux is hosted on PyPI, so simply pip install!</p> <pre><code>pip install dLux\n</code></pre> <p>You can also build from source. To do so, clone the git repo, enter the directory, and run</p> <pre><code>pip install .\n</code></pre> <p>We encourage the creation of a virtual enironment to run dLux to prevent software conflicts as we keep the software up to date with the lastest version of the core packages.</p>"},{"location":"docs/installation/#windowsgoogle-colab-quickstart","title":"Windows/Google Colab Quickstart","text":"<p><code>jaxlib</code> is currently not supported by the jax team on windows, however there are two work-arounds!</p> <p>Firstly here is some community built software to install jax on windows! We do not use this ourselves so have limited knowledge, but some users seems to have got everyting working fine!</p> <p>Secondly users can also run our software on Google Colab. If you want to instal from source in colab, run this at the start of your notebook!</p> <pre><code>!git clone https://github.com/LouisDesdoigts/dLux.git # Download latest version\n!cd dLux; pip install . -q # Navigate to \u2202Lux and install from source\n</code></pre> <p>From here everything should work! You can also run the code on GPU to take full advantage of Jax, simply by switch to a GPU runtime environment, no extra steps necessary!</p>"},{"location":"docs/usage/","title":"Using \u2202Lux","text":"<p>\u2202Lux is built in Zodiax, so users should start with the Using Zodiax Tutorial, which covers the the basics of the framework and how to use the optimisation tools used in \u2202Lux.</p>"},{"location":"docs/usage/#overview","title":"Overview","text":"<p>\u2202Lux is an open-source differentiable optical modelling framework harnessing the structural isomorphism between optical systems and neural networks, giving forwards models of optical system as a parametric neural network. In \u2202Lux we represent optical systems as a series of layers, each of which applies some transformation to either a wavefront or PSF. The layers are connected in a feed-forward manner, with the output of each layer as the input to the next. This construction allows for very complex optical systems to be parameterised by these layers and for each monochromatic wavefront calculation to be performed in parallel and optimised by Jax.</p> <p>dLux is designed to be verbose about what is happening under the hood. We think that in order for users to be confident in their results that it is important to be clear about what goes in to that model. Becuase of this dLux tries to avoid 'pre-built' classes and optical systes, allowing users to be flexible in the way they model their systems. This helps users become more familiar with the underlying physics and computational methods and allows them to build more complex configurations.</p> <p>Note</p> <p>All units within \u2202Lux are SI units. This means that all lengths are in meters, angles are in radians and wavelengths are in meters.</p>"},{"location":"docs/usage/#class-overview","title":"Class Overview","text":"<p>\u2202Lux has Five main classes that are used to model optical systems:</p> <ol> <li> <p><code>Optics</code>: A class that is used to store <code>OpticalLayer</code> classes. <code>OpticalLayer</code> classes perform transformations on the <code>Wavefront</code> class in order to model an optical system. There are three main types of <code>OpticalLayer</code> classes:</p> <ul> <li>Optical Layers: These perform the basic operations on wavefronts such as creation, normalisation, adding phase, optical path differences, titls, rotations etc.</li> <li>Aperture Layers: This is an expansive module that can be used to create both static and dynamic differentiable apertures. Most used cases are covered by the <code>ApertureFactory</code> class, which can be used to create a variety of single apertures including secondary mirror occulters and spiders.</li> <li>Propagators: These layers propagate wavefronts between Pupil and Image planes. The most commonly used propagator is the <code>AngularMFT</code> class, which allows for the ouput pixel scale to be specified.</li> </ul> </li> <li> <p><code>Detector</code>: A class that is used to store <code>DetectorLayer</code> class. These transformations are used to model the effects of the detector on the PSF.</p> </li> <li> <p><code>Sources</code>: These classes are a series of parameterised source objects.</p> </li> <li> <p><code>Instrument</code>: This class is used to store the <code>Optics</code>, <code>Detector</code> and <code>Source</code> classes. It is used to model the full instrument and is used to calculate the PSF.</p> </li> <li> <p><code>Observation</code>: These are clases that can be used to model complex observation schemes by allowing for the <code>Instrument</code> class to be manipulated in order to create data sets, time series PSFs and more.</p> </li> </ol> <p>In this tutorial we will cover the basics of these classes and how to use them together!</p>"},{"location":"docs/usage/#a-simple-optical-system","title":"A Simple Optical system","text":"<p>Layers that manipulate wavefronts are chained together in a list and passed into a <code>Optics</code> object. There are three types of layers that can be used inside the <code>Optics</code> object. Lets have a quick look at how we would create a basic optical system and model its PSF.</p> <pre><code>import jax.numpy as np\nimport dLux as dl\n\n# Define the parameters of the optical system\naperture_diameter = 1.0  # meters\npixel_scale       = 2e-7 # Radians per pixel of the detector\naperture_npixels  = 256  # Number of pixels representing the wavefront\ndetector_npixels  = 64   # Number of pixels in the detector\n\n# Define our Optical configuration as a list of layers\nlayers = [\n    # Create a wavefront object\n    dl.CreateWavefront(aperture_npixels, aperture_diameter),\n\n    # Create a Circular Aperture\n    dl.ApertureFactory(aperture_npixels, name='Aperture'),\n\n    # Normalise the wavefront to unity power\n    dl.NormaliseWavefront(),\n\n    # Propagate the wavefront to the detector\n    dl.AngularMFT(detector_npixels, pixel_scale, name='Propagator'),\n]\n\n# Create the Optics object\noptics = dl.Optics(layers)\n\n# Propagate the wavelengths through the optics\nwavelengths = np.linspace(1e-6, 1.2e-6, 5)\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Probability')\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\n\nplt.tight_layout()\nplt.savefig(\"assets/simple_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#working-with-lux-objects","title":"Working with \u2202Lux objects","text":"<p>\u2202Lux is built in Zodiax allowing for easy path based manipulation of the objects. Each \u2202Lux class has in-built <code>__getattr__</code> methods that allows for individual layers to be accessed by their <code>name</code> parameter (covered in the Using Zodiax Tutorial). This allows for easy manipulation of the layers in the <code>Optics</code> object. Lets start by examining the <code>optics</code> object which as inbuilt pretty-printing methods:</p> <pre><code>print(optics)\n</code></pre> <pre><code>&gt; Optics(\n&gt;   layers={\n&gt;     'CreateWavefront':\n&gt;     CreateWavefront(\n&gt;       name='CreateWavefront',\n&gt;       npixels=256,\n&gt;       diameter=f32[],\n&gt;       wavefront_type='Cartesian'\n&gt;     ),\n&gt;     'Aperture':\n&gt;     StaticAperture(name='Aperture', aperture=f32[256,256]),\n&gt;     'NormaliseWavefront':\n&gt;     NormaliseWavefront(name='NormaliseWavefront'),\n&gt;     'Propagator':\n&gt;     AngularMFT(\n&gt;       name='Propagator',\n&gt;       inverse=False,\n&gt;       npixels_out=64,\n&gt;       pixel_scale_out=f32[],\n&gt;       shift=f32[2],\n&gt;       pixel_shift=False\n&gt;     )\n&gt;   }\n&gt; )\n</code></pre> <p>We can see that the <code>Optics</code> object has a <code>layers</code> attribute which is an <code>OrderedDictionary</code> of the layers that are contained within the <code>Optics</code> object. Each layer has a name attribute which matches the name of the layer what can be used to access the layer. Lets see a practical example of how we can manipulate the optical system to oversample the detector.</p> <pre><code># Oversample\noversample = 2\noptics = optics.multiply(\"Propagator.npixels_out\", oversample)\noptics = optics.multiply(\"Propagator.pixel_scale_out\", 1/oversample)\n\n# Propagate\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Probability')\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\n\nplt.tight_layout()\nplt.savefig(\"assets/oversampled_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#building-more-complex-systems","title":"Building more complex systems","text":"<p>Now we will cover how to use all the different \u2202Lux classes with eachother in order to construct a more complex optical system including detector effects and observations.</p>"},{"location":"docs/usage/#optics","title":"Optics","text":"<p>Lets examine how to use the rest of the \u2202Lux classes to model a HST-like instrument object. We will use this class to recover and infer parameters of a binary star sytem through optics with a large amount of optical aberrations.</p> <pre><code>import jax.numpy as np\nimport jax.random as jr\nimport dLux as dl\nfrom dLux.utils import arcseconds_to_radians as a2r\n\n# Define the parameters of the optical system\naperture_npixels   = 256  # Number of pixels representing the wavefront\naperture_diameter  = 2.4  # meters\nsecondary_diameter = 0.35 # meters\nstrut_diameter     = 0.03 # meters\nnstruts            = 4    # Number of spiders\n\n# Calcuate values for the aperture\nsecondary_ratio = secondary_diameter / aperture_diameter\nstrut_ratio = strut_diameter / aperture_diameter\n\n# Aberrations\nzernikes = np.arange(4, 11) # 2nd and 3rd radial terms\ncoefficients = 2e-8 * jr.normal(jr.PRNGKey(0), zernikes.shape)\n\n# Detector parameters\npixel_scale        = a2r(0.02) # Arcseconds per pixel of the detector\ndetector_npixels   = 64        # Number of pixels in the detector\novsersample        = 3         # Oversample the detecto\n\n\n# Define our Optical configuration as a list of layers\nlayers = [\n    # Create a wavefront object\n    dl.CreateWavefront(aperture_npixels, aperture_diameter),\n\n    # Create a HST-like Aperture\n    dl.ApertureFactory(npixels         = aperture_npixels, \n                       secondary_ratio = secondary_ratio, \n                       nstruts         = nspiders, \n                       strut_ratio     = strut_ratio,\n                       name            = 'Aperture'),\n\n    # Add Zernike Aberrations\n    dl.AberrationFactory(npixels      = aperture_npixels, \n                         zernikes     = zernikes, \n                         coefficients = coefficients, \n                         name         = 'Aberrations'),\n\n    # Normalise the wavefront to unity power\n    dl.NormaliseWavefront(),\n\n    # Propagate the wavefront to the detector\n    dl.AngularMFT(npixels_out     = detector_npixels * oversample, \n                  pixel_scale_out = pixel_scale / oversample, \n                  name            = 'Propagator'),\n]\n\n# Create the Optics object\noptics = dl.Optics(layers)\n\n# Propagate the wavelengths through the optics\nwavelengths = np.linspace(1e-6, 1.2e-6, 5)\npsf = optics.propagate(wavelengths)\n</code></pre> Plotting code <pre><code>from matplotlib import colormaps\naberrations = optics.Aberrations.get_opd()\naperture = optics.Aperture.aperture\n\npupil = aberrations.at[np.where(aperture == 0.)].set(np.nan)\ncmap = colormaps['inferno']\ncmap.set_bad('k',1.)\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Pupil\")\nplt.imshow(pupil*1e6, cmap=cmap)\ncbar = plt.colorbar()\ncbar.set_label('OPD $\\mu m$')\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\n\nplt.subplot(1, 2, 2)\nplt.imshow(psf**0.5)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.colorbar()\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.tight_layout()\nplt.savefig(\"assets/hst_like_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#detector","title":"Detector","text":"<p>Now lets construct a detector object that we will use to model a jitter and downsample to the correct pixel-scale.</p> <pre><code># Jitter in pixels\npixel_jitter = 3. # Pixels\n\n# Define Detector Layers\ndetector_layers = [\n    dl.ApplyJitter(pixel_jitter, name=\"Jitter\"),\n    dl.IntegerDownsample(oversample)\n]\n\n# Construct Detector Object\ndetector = dl.Detector(detector_layers)\nimage = detector.apply_detector(psf)\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Original PSF\")\nplt.imshow(psf)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Probability')\n\nplt.subplot(1, 2, 2)\nplt.title(\"Jittered and downsampled PSF\")\nplt.imshow(image)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Probability')\n\nplt.tight_layout()\nplt.savefig(\"assets/detector_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#source","title":"Source","text":"<p>Now lets create a binary source object and propagate it through the optics.</p> <pre><code># Binary Source Parameters\nseparation = a2r(0.1)\ncontrast = 4\nmean_flux = 1e4\n\n# Construct Source Object\nsource = dl.BinarySource(separation  = separation, \n                         flux        = mean_flux,\n                         contrast    = contrast, \n                         wavelengths = wavelengths,\n                         name        = 'Source')\n\n# Model the PSF\npsf = optics.model(source)\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Photons')\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\n\nplt.tight_layout()\nplt.savefig(\"assets/binary_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#instrument","title":"Instrument","text":"<p>Now we can construct an <code>Instrument</code> object to model all these different components together coherently.</p> <pre><code># Construct the Telescope Object\ntel = dl.Instrument(optics   = optics,\n                    detector = detector,\n                    sources  = [source])\n\n# Model the PSF\npsf = tel.model()\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\ncbar.set_label('Photons')\n\nplt.subplot(1, 2, 2)\nplt.title(\"$\\sqrt{PSF}$\")\nplt.imshow(psf**0.5)\nplt.xlabel('Pixles')\nplt.ylabel('Pixles')\ncbar = plt.colorbar()\n\nplt.tight_layout()\nplt.savefig(\"assets/instrument_psf.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#observaton-data","title":"Observaton &amp; Data","text":"<p>Now lets create an observation object in order to model some pointing dithers. Then we will add some photon noise in order to turn this into some data we can recover parameters from.</p> <pre><code># Construct observation Dithers\ndithers = 2.5 * pixel_scale * np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\nobservation = dl.Dither(dithers)\n\n# Set the observation and model\ntel = tel.set('observation', observation)\npsfs = tel.observe()\ndata = jr.poisson(jr.PRNGKey(0), psfs)\n</code></pre> Plotting code <pre><code>plt.figure(figsize=(10, 8))\nfor i in range(4):\n    plt.subplot(2, 2, i+1)\n    plt.title(f\"Image: {i+1}\")\n    plt.imshow(data[i])\n    plt.xlabel(\"Pixels\")\n    plt.ylabel(\"Pixels\")\n    cbar = plt.colorbar()\n    cbar.set_label('Photons')\nplt.tight_layout()\nplt.savefig(\"assets/data.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#recovering-parameters","title":"Recovering parameters","text":""},{"location":"docs/usage/#initialising-a-model","title":"Initialising a Model","text":"<p>Now that we have some data, lets create a model that we will use to recover the parameters of both the optical system and the source!</p> <p>We need to start by perturbing the parameters of the optical system and the source.</p> <pre><code># Perturb values to construct initial model\nmodel = tel.multiply('Aberrations.coefficients', 0.)\nmodel = model.multiply('Jitter.sigma', 0.5)\nmodel = model.multiply('Source.separation', 1.2)\nmodel = model.multiply('Source.flux', 0.8)\n\n# Observe the model psfs\npsfs = model.observe()\n</code></pre> <p>Acessing Attributes</p> <p>The <code>Instrument</code> object also has inbuilt <code>__getattr__</code> methods that allow users to access all of the underlying layers and attributes of the <code>Optics</code>, <code>Detector</code>, <code>Observation</code> and <code>Source</code> objects by their <code>name</code> parameter. Lets see how this works.</p> <pre><code>detector_pixel_scale = tel.Propagator.pixel_scale_out\njitter = tel.Jitter.sigma\nseparation = tel.Source.separation\n</code></pre> <p>All of these can also be access and manipulated using the <code>get</code> and <code>set</code>, <code>multiply</code> methods implemented in Zodiax!</p> Plotting code <pre><code>plt.figure(figsize=(10, 8))\nfor i in range(4):\n    plt.subplot(2, 2, i+1)\n    plt.title(f\"Residual: {i+1}\")\n    plt.imshow(data[i] - psfs[i])\n    plt.xlabel(\"Pixels\")\n    plt.ylabel(\"Pixels\")\n    cbar = plt.colorbar()\n    cbar.set_label('Photons')\nplt.tight_layout()\nplt.savefig(\"assets/residuals.png\")\n</code></pre> <p></p>"},{"location":"docs/usage/#optimisation","title":"Optimisation","text":"<p>Now we define a loss fucntion and the parameters that we want to recover.</p> <pre><code>import zodiax as zdx\nfrom jax.scipy.stats import poisson\n\n# Define the parameters we want to recover\nparameters = [\n    'Aberrations.coefficients',\n    'Source.separation',\n    'Source.flux',\n]\n\n# Define the loss function\n@zdx.filter_jit\n@zdx.filter_value_and_grad(parameters)\ndef log_likelihood(model, data):\n    psfs = model.observe()\n    return poisson.logpmf(data, psfs).sum()\n\n# Compile\nloss, grads = log_likelihood(model, data)\n</code></pre> <p>Checking Gradients</p> <p>The <code>grads</code> object that is returned is also a \u2202Lux <code>Instrument</code> object! That means we can easily check that the returned gradients are neither nans nor zeros.</p> <pre><code># Examine\nprint(loss, grads.get(parameters))\n</code></pre> <pre><code>&gt; -55482.734 [Array([-6.6396436e+03,  9.0544004e+03,  2.0858955e+04,  1.1552759e+11,\n       -2.8185054e+11,  3.0387582e+11, -1.5286786e+11], dtype=float32), Array(-2.39274e+10, dtype=float32), Array(1.8175228, dtype=float32)]\n</code></pre> <p>Now lets define our learning rates and create a simple optimisation loop.</p> <pre><code>import optax\n\n# Define learning rates\nzernike_lr    = 1e-8\nseparation_lr = 1e-8\nflux_lr       = 1e2\n\n# Define the optimizer\noptimisers = [\n    optax.adam(zernike_lr),\n    optax.adam(separation_lr),\n    optax.adam(flux_lr),\n]\n\n# Optimise\noptimiser, state = zdx.get_optimiser(model, parameters, optimisers)\nlosses, models = [], []\nfor i in range(100):\n    loss, grads = log_likelihood(model, data)\n    updates, state = optimiser.update(grads, state)\n    model = zdx.apply_updates(model, updates)\n    losses.append(loss)\n    models.append(model)\n\n# Observe the final model\nfinal_psfs = model.observe()\n</code></pre> <p>Lets examine the residuals to see that we have a good model.</p> Plotting code <pre><code>plt.figure(figsize=(10, 8))\nfor i in range(4):\n    plt.subplot(2, 2, i+1)\n    plt.title(f\"Residual: {i+1}\")\n    plt.imshow(data[i] - final_psfs[i])\n    plt.xlabel(\"Pixels\")\n    plt.ylabel(\"Pixels\")\n    cbar = plt.colorbar()\n    cbar.set_label('Photons')\nplt.tight_layout()\nplt.savefig(\"assets/final_residuals.png\")\n</code></pre> <p></p>"},{"location":"docs/API/aberrations/","title":"Aberrations","text":"<p>The aberrations module provides a place for dynamically generated aberrations. Presently on the Zernike polynomials are implemented, but more aberrations can be added in the future. These can be used independently but are typically used in conjunction with the <code>AberratedAperture</code> class.</p> <p>Lets have a look at how to construct a Zernike Basis:</p> <pre><code>import dLux as dl\n\nzernike_basis = dl.ZernikeBasis(np.arange(1, 7))\nprint(zernike_basis)\n</code></pre> <pre><code>&gt; ZernikeBasis(\n&gt;   zernikes=[\n&gt;     Zernike(j=1, n=0, m=0, name='Piston', _k=f32[1], _c=f32[1]),\n&gt;     Zernike(j=2, n=1, m=1, name='Tilt X', _k=f32[1], _c=f32[1]),\n&gt;     Zernike(j=3, n=1, m=-1, name='Tilt Y', _k=f32[2], _c=f32[2]),\n&gt;     Zernike(j=4, n=2, m=0, name='Defocus', _k=f32[2], _c=f32[2]),\n&gt;     Zernike(j=5, n=2, m=-2, name='Astig X', _k=f32[3], _c=f32[3]),\n&gt;     Zernike(j=6, n=2, m=2, name='Astig Y', _k=f32[1], _c=f32[1])\n&gt;   ]\n&gt; )\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\n\n# Calcualte coordinates\n\nnpix = 256\ncoords = dl.utils.get_pixel_positions((npix, npix), (2/npix, 2/npix))\nbasis = zernike_basis.calculate_basis(coords)\n\nplt.figure(figsize=(15, 8))\nfor i in range(len(basis)):\n    plt.subplot(2, 3, i+1)\n    plt.title(f\"{zernike_basis.zernikes[i].name}\")\n    plt.imshow(basis[i])\n    plt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/zernike.png\")\n</code></pre> <p></p> Zernike Basis API <p>         Bases: <code>Base</code></p> <p>A class to calculate a set of Zernike polynomials on a dynamic set of coordiantes.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>zernikes</code> <code>list[Zernike]</code> <p>The list of Zernike polynomial classes to calculate.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>class ZernikeBasis(Base):\n\"\"\"\n    A class to calculate a set of Zernike polynomials on a dynamic set of\n    coordiantes.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n    Attributes\n    ----------\n    zernikes : list[Zernike]\n        The list of Zernike polynomial classes to calculate.\n    \"\"\"\n    zernikes : list[Zernike]\n\n\n    def __init__(self : ZernikeBasis, js : list[int]):\n\"\"\"\n        Constructor for the DynamicZernike class.\n\n        Parameters\n        ----------\n        js : list[int]\n            The list of Zernike (noll) indices to calculate.\n        \"\"\"\n        self.zernikes = [Zernike(j) for j in js]\n\n\n    def calculate_basis(self        : ZernikeBasis, \n                        coordinates : Array, \n                        nsides      : int = 0) -&gt; Array:\n\"\"\"\n        Calculates the full Zernike polynomial basis.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Arraya\n            The cartesian coordinates to calcualte the Zernike basis upon.\n\n        Returns\n        -------\n        zernike_basis : Array\n            The Zernike polynomial basis.\n        \"\"\"\n        leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n        calculate_fn = lambda z: z.calculate(coordinates, nsides)\n        return np.array(jtu.tree_map(calculate_fn, self.zernikes, \n                                     is_leaf=leaf_fn))\n</code></pre> Zernike API <p>         Bases: <code>Base</code></p> <p>A class to generate Zernike polynomials dynamically.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> <code>name</code> <code>str</code> <p>The name of the Zernike polynomial.</p> <code>_k</code> <code>Array</code> <p>The array of powers using the radial calculation. This is a  pre-calculated parameter and should not be changed.</p> <code>_c</code> <code>Array</code> <p>The array of normalisaton coefficients used in the radial calculation. This is a pre-calculated parameter and should not be changed.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>class Zernike(Base):\n\"\"\"\n    A class to generate Zernike polynomials dynamically.\n\n    The 'jth' zernike polynomial is defined [here](https://oeis.org/A176988).\n    The basic translation between the noll index and the pair of numbers is\n    shown below:\n\n    1 -&gt; (0, 0)\n\n    2, 3 -&gt; (1, -1), (1, 1)\n\n    4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)\n\n    7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)\n\n\n    Attributes\n    ----------\n    j : int\n        The Zernike (noll) index.\n    n : int\n        The radial order of the Zernike polynomial.\n    m : int\n        The azimuthal order of the Zernike polynomial.\n    name : str\n        The name of the Zernike polynomial.\n    _k : Array\n        The array of powers using the radial calculation. This is a \n        pre-calculated parameter and should not be changed.\n    _c : Array\n        The array of normalisaton coefficients used in the radial calculation.\n        This is a pre-calculated parameter and should not be changed.\n    \"\"\"\n    j    : int\n    n    : int\n    m    : int\n    name : str\n    _k    : Array\n    _c    : Array\n\n    def __init__(self : Zernike, j : int):\n\"\"\"\n        Construct for the Zernike class.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n        \"\"\"\n        if int(j) &lt; 1:\n            raise ValueError('The Zernike index must be greater than 0.')\n        self.j = int(j)\n        self.n, self.m = self._noll_index(self.j)\n        self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n                    else f'Zernike {int(self.j)}'\n\n        # Calcualte values\n        self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n        sign = lax.pow(-1., self._k)\n        _fact_1 = factorial(np.abs(self.n - self._k))\n        _fact_2 = factorial(self._k)\n        _fact_3 = factorial(((self.n + self.m) // 2) - self._k)\n        _fact_4 = factorial(((self.n - self.m) // 2) - self._k)\n        self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4 \n\n\n    def _noll_index(self : Zernike, j : int) -&gt; tuple[int]:\n\"\"\"\n        Calculate the radial and azimuthal orders of the Zernike polynomial.\n\n        Parameters\n        ----------\n        j : int\n            The Zernike (noll) index.\n\n        Returns\n        -------\n        n, m : tuple[int]\n            The radial and azimuthal orders of the Zernike polynomial.\n        \"\"\"\n        n = (np.ceil(-1 / 2 + np.sqrt(1 + 8 * j) / 2) - 1).astype(int)\n        smallest_j_in_row = n * (n + 1) / 2 + 1 \n        number_of_shifts = (j - smallest_j_in_row + ~(n &amp; 1) + 2) // 2\n        sign_of_shift = -(j &amp; 1) + ~(j &amp; 1) + 2\n        base_case = (n &amp; 1)\n        m = (sign_of_shift * (base_case + number_of_shifts * 2)).astype(int)\n        return int(n), int(m)\n\n\n    def _calculate_radial(self : Zernike, rho : Array) -&gt; Array:\n\"\"\"\n        Calculates the radial component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        rho : Array\n            The radial coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        radial : Array\n            The radial component of the Zernike polynomial.\n        \"\"\"\n        rads = lax.pow(rho[:, :, None], \n            (np.abs(self.n) - 2 * self._k)[None, None, :])\n        return (self._c * rads).sum(axis = 2)\n\n\n    def _calculate_azimuthal(self : Zernike, theta : Array) -&gt; Array:\n\"\"\"\n        Calculates the azimuthal component of the Zernike polynomial.\n\n        Parameters\n        ----------\n        theta : Array\n            The azimuthal coordinate of the Zernike polynomial.\n\n        Returns\n        -------\n        azimuthal : Array\n            The azimuthal component of the Zernike polynomial.\n        \"\"\"\n        norm_coeff = np.sqrt(self.n + 1)\n        if self.m != 0:\n            norm_coeff *= 1 + (np.sqrt(2) - 1)\n\n        if self.m &gt;= 0:\n            return norm_coeff * np.cos(np.abs(self.m) * theta)\n        else:\n            return norm_coeff * np.sin(np.abs(self.m) * theta)\n\n\n    def calculate_zernike(self : Zernike, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        polar_coordinates = cartesian_to_polar(coordinates)\n        rho = polar_coordinates[0]\n        theta = polar_coordinates[1]\n        aperture = rho &lt;= 1.\n        return aperture * self._calculate_radial(rho) * \\\n            self._calculate_azimuthal(theta)\n\n\n    def calculate_polike(self        : Zernike, \n                         coordinates : Array, \n                         nsides      : int) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial on an nsided aperture.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture.\n\n        Returns\n        -------\n        polike : Array\n            The Zernike polynomial on an nsided aperture.\n        \"\"\"\n        if nsides &lt; 3:\n            raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n        theta = cartesian_to_polar(coordinates)[1]\n        alpha = np.pi / nsides\n        phi = theta + alpha  \n        wedge = np.floor((phi + alpha) / (2. * alpha))\n        u_alpha = phi - wedge * (2 * alpha)\n        r_alpha = np.cos(alpha) / np.cos(u_alpha)\n        return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n\n\n    def calculate(self        : Zernike, \n                  coordinates : Array, \n                  nsides      : int = 0) -&gt; Array:\n\"\"\"\n        Calculates the Zernike polynomial.\n\n        Note: The zernike polynomial is defined on the coordinates up to a\n        radial value of 1.\n\n        Parameters\n        ----------\n        coordinates : Array\n            The cartesian coordinates to calcualte the Zernike polynomial upon.\n        nsides : int\n            The number of sides of the aperture. If 0, the Zernike polynomial\n            is calculated on a circular aperture.\n\n        Returns\n        -------\n        zernike : Array\n            The Zernike polynomial.\n        \"\"\"\n        if nsides == 0:\n            return self.calculate_zernike(coordinates)\n        else:\n            return self.calculate_polike(coordinates, nsides)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.__init__","title":"<code>__init__(js)</code>","text":"<p>Constructor for the DynamicZernike class.</p> <p>Parameters:</p> Name Type Description Default <code>js</code> <code>list[int]</code> <p>The list of Zernike (noll) indices to calculate.</p> required Source code in <code>dLux/aberrations.py</code> <pre><code>def __init__(self : ZernikeBasis, js : list[int]):\n\"\"\"\n    Constructor for the DynamicZernike class.\n\n    Parameters\n    ----------\n    js : list[int]\n        The list of Zernike (noll) indices to calculate.\n    \"\"\"\n    self.zernikes = [Zernike(j) for j in js]\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.calculate_basis","title":"<code>calculate_basis(coordinates, nsides=0)</code>","text":"<p>Calculates the full Zernike polynomial basis.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Arraya</code> <p>The cartesian coordinates to calcualte the Zernike basis upon.</p> required <p>Returns:</p> Name Type Description <code>zernike_basis</code> <code>Array</code> <p>The Zernike polynomial basis.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_basis(self        : ZernikeBasis, \n                    coordinates : Array, \n                    nsides      : int = 0) -&gt; Array:\n\"\"\"\n    Calculates the full Zernike polynomial basis.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Arraya\n        The cartesian coordinates to calcualte the Zernike basis upon.\n\n    Returns\n    -------\n    zernike_basis : Array\n        The Zernike polynomial basis.\n    \"\"\"\n    leaf_fn = lambda leaf: isinstance(leaf, Zernike)\n    calculate_fn = lambda z: z.calculate(coordinates, nsides)\n    return np.array(jtu.tree_map(calculate_fn, self.zernikes, \n                                 is_leaf=leaf_fn))\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.__init__","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.ZernikeBasis.calculate_basis","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.__init__","title":"<code>__init__(j)</code>","text":"<p>Construct for the Zernike class.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required Source code in <code>dLux/aberrations.py</code> <pre><code>def __init__(self : Zernike, j : int):\n\"\"\"\n    Construct for the Zernike class.\n\n    Parameters\n    ----------\n    j : int\n        The Zernike (noll) index.\n    \"\"\"\n    if int(j) &lt; 1:\n        raise ValueError('The Zernike index must be greater than 0.')\n    self.j = int(j)\n    self.n, self.m = self._noll_index(self.j)\n    self.name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 \\\n                else f'Zernike {int(self.j)}'\n\n    # Calcualte values\n    self._k = np.arange(((self.n - self.m) // 2) + 1, dtype=float)\n    sign = lax.pow(-1., self._k)\n    _fact_1 = factorial(np.abs(self.n - self._k))\n    _fact_2 = factorial(self._k)\n    _fact_3 = factorial(((self.n + self.m) // 2) - self._k)\n    _fact_4 = factorial(((self.n - self.m) // 2) - self._k)\n    self._c = sign * _fact_1 / _fact_2 / _fact_3 / _fact_4 \n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate","title":"<code>calculate(coordinates, nsides=0)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike polynomial is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate(self        : Zernike, \n              coordinates : Array, \n              nsides      : int = 0) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The cartesian coordinates to calcualte the Zernike polynomial upon.\n    nsides : int\n        The number of sides of the aperture. If 0, the Zernike polynomial\n        is calculated on a circular aperture.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    if nsides == 0:\n        return self.calculate_zernike(coordinates)\n    else:\n        return self.calculate_polike(coordinates, nsides)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_polike","title":"<code>calculate_polike(coordinates, nsides)</code>","text":"<p>Calculates the Zernike polynomial on an nsided aperture.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <p>Returns:</p> Name Type Description <code>polike</code> <code>Array</code> <p>The Zernike polynomial on an nsided aperture.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_polike(self        : Zernike, \n                     coordinates : Array, \n                     nsides      : int) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial on an nsided aperture.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The cartesian coordinates to calcualte the Zernike polynomial upon.\n    nsides : int\n        The number of sides of the aperture.\n\n    Returns\n    -------\n    polike : Array\n        The Zernike polynomial on an nsided aperture.\n    \"\"\"\n    if nsides &lt; 3:\n        raise ValueError(f'nsides must be &gt;= 3, not {nsides}.')\n    theta = cartesian_to_polar(coordinates)[1]\n    alpha = np.pi / nsides\n    phi = theta + alpha  \n    wedge = np.floor((phi + alpha) / (2. * alpha))\n    u_alpha = phi - wedge * (2 * alpha)\n    r_alpha = np.cos(alpha) / np.cos(u_alpha)\n    return 1 / r_alpha * self.calculate_zernike(coordinates / r_alpha)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_zernike","title":"<code>calculate_zernike(coordinates)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p> Source code in <code>dLux/aberrations.py</code> <pre><code>def calculate_zernike(self : Zernike, coordinates : Array) -&gt; Array:\n\"\"\"\n    Calculates the Zernike polynomial.\n\n    Note: The zernike polynomial is defined on the coordinates up to a\n    radial value of 1.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The cartesian coordinates to calcualte the Zernike polynomial upon.\n\n    Returns\n    -------\n    zernike : Array\n        The Zernike polynomial.\n    \"\"\"\n    polar_coordinates = cartesian_to_polar(coordinates)\n    rho = polar_coordinates[0]\n    theta = polar_coordinates[1]\n    aperture = rho &lt;= 1.\n    return aperture * self._calculate_radial(rho) * \\\n        self._calculate_azimuthal(theta)\n</code></pre>"},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.__init__","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_polike","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#dLux.aberrations.Zernike.calculate_zernike","title":"Aberrations","text":""},{"location":"docs/API/aberrations/#aberrations-factory","title":"Aberrations Factory","text":"<p>The <code>AberrationsFactory</code> class is a convenience class for generating aberrations. It operates very similarly to the <code>ApertureFactory</code> class. It takes in a list of aberration names and a list of coefficients and returns a <code>ZernikeBasis</code> object. This class is not actually ever instatiated, but is rather a class used to give a simple constructor interface that is used to construct the most commonly used aberrations. It is able to construct hard-edged circular or regular poygonal aberrations.</p> <p>Lets look at an example of how to construct a simple circular aberration class. Let calcualte this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>import dLux as dl\nfrom jax import numpy as np, random as jr\n\n# Construct Zernikes\n\nzernikes = np.arange(4, 11)\ncoefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n# Construct aberrations\n\naberrations = dl.AberrationFactory(512, zernikes=zernikes,\n                                   coefficients=coefficients)\nprint(aberrations)\n</code></pre> <pre><code>&gt; ApplyBasisOPD(\n&gt;   name='CircularAperture',\n&gt;   basis=f32[7,512,512],\n&gt;   coefficients=f32[7]\n&gt; )\n</code></pre> <p>As we can see this returns an <code>ApplyBasisOPD</code> class, as this is able to apply the aberations independently of any apertures. Aberrations can be generated from an aperture class using either the <code>ApertureFactory</code> or an <code>AberratedAperture</code> class.</p>"},{"location":"docs/API/apertures/","title":"An Overview of the Apertures","text":""},{"location":"docs/API/apertures/#introduction","title":"Introduction","text":"<p><code>dLux</code> implements a number of aperture components for telescopes. Because <code>dLux</code> is powered by autodiff, the shape of the aperture can be learned. Theoretically, you could learn the value of every pixel in the aperture. Learning by pixel would be computationally expensive and the model could chase noise making the results meaningless. Instead the apertures that we have implemented are parametrised. In general the apertures can be, translated, sheared, compressed androtated, all in a differentiable manner by softening the hard bounary using a sigmoid.</p> <p>There are four different aperture types: Dynamic, Static, Aberrated and Composite. The dynamic apertures are the most flexible and can be used to learn the shape of the aperture. The static apertures pre-compute the aperture and use the fixed array representation. The aberrated apertures are used to learn the shape of the aperture and the basis functions for phase retrieval. The compound apertures are used to combine multiple apertures into a single aperture. There are also spider apertures that are used to model secondary mirror supports.</p>"},{"location":"docs/API/apertures/#dynamic-apertures","title":"Dynamic Apertures","text":"<p>The dynamic apertures are form the basis for the rest of the apertures and contains 7 classes: <code>CircularAperture</code>, <code>AnnularAperture</code>, <code>HexagonalAperture</code>, <code>RectangularAperture</code>, <code>SquareAperture</code>, <code>RegularPolygonAperture</code>, <code>IrregularPolygonAperture</code>. Each of these classes has a seriers of common parameters: <code>translation</code>, <code>rotation</code>, <code>shear</code>, <code>compression</code>, <code>softening</code> and <code>occulting</code>. The <code>translation</code> and <code>rotation</code> parameters are used to move and rotate the aperture. The <code>shear</code> and <code>compression</code> parameters are used to change the shape of the aperture. The <code>softening</code> parameter is used to soften the hard boundary of the aperture, and <code>occulting</code> controls if the aperture is transmissive or occulting.</p> <p>Each of these classes then has a different parameterisation of the aperture itself, for example the <code>CircularAperture</code> has a <code>radius</code> parameter, the <code>AnnularAperture</code> has <code>inner_radius</code> and <code>outer_radius</code> parameters.</p> Circular Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>A circular aperture parameterised by its radius.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>Array, meters</code> <p>The radius of the aperture. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class CircularAperture(DynamicAperture):\n\"\"\"\n    A circular aperture parameterised by its radius.\n\n    Attributes\n    ----------\n    radius: Array, meters\n        The radius of the aperture. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    radius : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 radius      : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 occulting   : bool = False, \n                 softening   : Array = np.array(1.),\n                 name        : str = \"CircularAperture\",\n                 ) -&gt; Array:\n\"\"\"\n        Constructor for the CircularAperture class.\n\n        Parameters\n        ----------\n        radius: Array, meters \n            The radius of the aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'CircularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name) \n\n        self.radius = np.asarray(radius).astype(float)\n        dLux.exceptions.validate_eq_attr_dims((), self.radius.shape, \"radius\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(- coordinates + self.radius)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return (coordinates &lt; self.radius).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.radius\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        radius = convert_cartesian(self.radius, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Circular Aperture with radius \"\n                   f\"{radius} {cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Annular Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>An annular aperture defined by its inner and outer radii.</p> <p>Attributes:</p> Name Type Description <code>rmax</code> <code>Array, meters</code> <p>Outer radius of aperture.</p> <code>rmin</code> <code>Array, meters</code> <p>Inner radius of aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class AnnularAperture(DynamicAperture):\n\"\"\"\n    An annular aperture defined by its inner and outer radii.\n\n    Attributes\n    ----------\n    rmax: Array, meters\n        Outer radius of aperture.\n    rmin: Array, meters\n        Inner radius of aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    rmin : Array\n    rmax : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 rmax        : Array, \n                 rmin        : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"AnnularAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the AnnularAperture class.\n\n        Parameters\n        ----------\n        rmax : Array, meters\n            The outer radius of the aperture. \n        rmin : Array, meters\n            The inner radius of the aperture. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'AnnularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.rmax = np.asarray(rmax).astype(float)\n        self.rmin = np.asarray(rmin).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n        dLux.exceptions.validate_eq_attr_dims((), self.rmin.shape, \"rmin\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return self._soften(coordinates - self.rmin) * \\\n            self._soften(- coordinates + self.rmax)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        coordinates = np.hypot(coordinates[0], coordinates[1])\n        return ((coordinates &gt; self.rmin) * \\\n            (coordinates &lt; self.rmax)).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmin = convert_cartesian(self.rmin, 'meters', cartesian_units)\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Annular Aperture with inner \"\n                   f\"radius {rmin} {cartesian_units} and outer radius {rmax} \"\n                   f\"{cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Hexagonal Aperture API <p>         Bases: <code>RegularPolygonalAperture</code></p> <p>A hexagonal aperture parameterised by the maximum radius to the vertices  from its center.</p> <p>Attributes:</p> Name Type Description <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class HexagonalAperture(RegularPolygonalAperture):\n\"\"\"\n    A hexagonal aperture parameterised by the maximum radius to the vertices \n    from its center.\n\n    Attributes\n    ----------\n    rmax : Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    rmax : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 rmax        : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"HexagonalAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the HexagonalAperture class.\n\n        Parameters\n        ----------\n        rmax : Array, meters\n            The maximum radius to the vertices from its center.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'HexagonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(nsides = 6,\n                         rmax = rmax,\n                         centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Hexagonal Aperture of max radius \"\n                   f\"{rmax:.{sigfigs}} {cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Rectangular Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>A rectangular aperture parameterised by it height and width.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Array, meters</code> <p>The length of the aperture in the y-direction. </p> <code>width</code> <code>Array, meters</code> <p>The length of the aperture in the x-direction. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class RectangularAperture(DynamicAperture):\n\"\"\"\n    A rectangular aperture parameterised by it height and width.\n\n    Attributes\n    ----------\n    height: Array, meters\n        The length of the aperture in the y-direction. \n    width: Array, meters\n        The length of the aperture in the x-direction. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    height : Array\n    width  : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 height      : Array, \n                 width       : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"RectangularAperture\") -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the RectangularAperture class.\n\n        Parameters\n        ----------\n        height: Array, meters \n            The length of the aperture in the y-direction.\n        width: Array, meters\n            The length of the aperture in the x-direction.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'RectangularAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.height = np.asarray(height).astype(float)\n        self.width = np.asarray(width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.height.shape, \"height\")\n        dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        y_mask = self._soften(- np.abs(coordinates[1]) + self.height / 2.)\n        x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)\n        return x_mask * y_mask\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        y_mask = np.abs(coordinates[1]) &lt; self.height / 2.\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.\n        return (x_mask * y_mask).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.hypot(self.height / 2., self.width / 2.)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        height = convert_cartesian(self.height, 'meters', cartesian_units)\n        width = convert_cartesian(self.width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Rectangular Aperture with height \"\n                   f\"{height} {cartesian_units} and width {width} \"\n                   f\"{cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Square Aperture API <p>         Bases: <code>DynamicAperture</code></p> <p>A square aperture parameterised by its width.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Array, meters</code> <p>The side length of the aperture. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class SquareAperture(DynamicAperture):\n\"\"\"\n    A square aperture parameterised by its width.\n\n    Attributes\n    ----------\n    width: Array, meters\n        The side length of the aperture. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    width : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 width       : Array, \n                 centre      : Array = np.array([0., 0.]),\n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"SquareAperture\") -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the SquareAperture class.\n\n        Parameters\n        ----------\n        width: Array, meters\n            The side length of the aperture. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'SquareAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation, \n                         occulting = occulting, \n                         softening = softening,\n                         name = name)\n\n        self.width = np.asarray(width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        x_mask = self._soften(- np.abs(coordinates[0]) + self.width / 2.)\n        y_mask = self._soften(- np.abs(coordinates[1]) + self.width / 2.)\n        return x_mask * y_mask\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x_mask = np.abs(coordinates[0]) &lt; self.width / 2.\n        y_mask = np.abs(coordinates[1]) &lt; self.width / 2.\n        return (x_mask * y_mask).astype(float)\n\n\n    def _extent(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return np.sqrt(2) * self.width / 2.\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        width = convert_cartesian(self.width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} Rectangular Aperture with width \"\n                   f\"{width} {cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Regular Polygonal Aperture API <p>         Bases: <code>PolygonalAperture</code></p> <p>A regular polygonal aperture defined by its number of sides and the maximum  radius to the vertices from its center.</p> <p>Attributes:</p> Name Type Description <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. </p> <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class RegularPolygonalAperture(PolygonalAperture):\n\"\"\"\n    A regular polygonal aperture defined by its number of sides and the maximum \n    radius to the vertices from its center.\n\n    Attributes\n    ----------\n    nsides: int\n        The number of sides of the aperture. \n    rmax: Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    nsides : int\n    rmax   : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 nsides      : int,\n                 rmax        : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"RegularPolygonalAperture\"\n                 ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the RegularPolygonalAperture class.\n\n        Parameters\n        ----------\n        nsides: int\n            The number of sides of the aperture.  \n        rmax: Array, meters\n            The maximum radius to the vertices from its center.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'RegularPolygonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n\n        self.nsides = int(nsides)\n        self.rmax = np.array(rmax).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n\n\n    def _extent(self : ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        return self.rmax\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x) \n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None] # Dummy index\n        bounds = 2. * i * alpha\n\n        ms = -1 / np.tan(2. * i * alpha + alpha)\n        xs = self.rmax * np.cos(2. * i * alpha)\n        ys = self.rmax * np.sin(2. * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = self._soften(inside * dists)\n        return dist.prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        x = coordinates[0]\n        y = coordinates[1]\n\n        neg_pi_to_pi_phi = np.arctan2(y, x) \n        alpha = np.pi / self.nsides\n\n        i = np.arange(self.nsides)[:, None, None] # Dummy index\n        bounds = 2. * i * alpha\n\n        ms = -1 / np.tan(2. * i * alpha + alpha)\n        xs = self.rmax * np.cos(2. * i * alpha)\n        ys = self.rmax * np.sin(2. * i * alpha)\n        dists = self._perp_dists_from_lines(ms, xs, ys, x, y)\n        inside = self._is_orig_left_of_edge(ms, xs, ys)\n\n        dist = (inside * dists) &gt; 0.\n        return dist.prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = (f\"Applies a {transmissive} {self.nsides} sided Regular \"\n                   f\"Polygonal Aperture of max radius {rmax:.{sigfigs}} \"\n                   f\"{cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre> Irregular Polygonal Aperture API <p>         Bases: <code>PolygonalAperture</code></p> <p>An arbitrary aperture parameterised by a set of vertices.</p> <p>TODO: Check if the verticies need to be defined in a specific way, based on the methods this looks like the case (ie, ordered).</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>Array, meters</code> <p>The location of the vertices of the aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class IrregularPolygonalAperture(PolygonalAperture):\n\"\"\"\n    An arbitrary aperture parameterised by a set of vertices.\n\n    TODO: Check if the verticies need to be defined in a specific way, based on\n    the methods this looks like the case (ie, ordered).\n\n    Attributes\n    ----------\n    vertices: Array, meters\n        The location of the vertices of the aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    occulting: bool\n        Is the aperture occulting or tranmissive. False results in a tranmissive\n        aperture, and True results in an occulting aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    vertices : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 vertices    : Array,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 occulting   : bool  = False, \n                 softening   : Array = np.array(1.),\n                 name        : str   = \"IrregularPolygonalAperture\"\n                 ) -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the IrregularPolygonalAperture class.\n\n        Parameters\n        ----------\n        vertices: Array, meters\n            The location of the vertices of the aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        occulting: bool = False\n            Is the aperture occulting or tranmissive. False results in a \n            tranmissive aperture, and True results in an occulting aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'IrregularPolygonalAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         occulting = occulting,\n                         softening = softening,\n                         name = name)\n\n        self.vertices = np.array(vertices).astype(float)\n        dLux.exceptions.validate_bc_attr_dims(\n            (1, 2), self.vertices.shape, \"vertices\")\n\n\n    def _grads_from_many_points(self : ApertureLayer, \n                                xs   : float, \n                                ys   : float) -&gt; float:\n\"\"\"\n        Given a set of points, calculate the gradient of the line that connects \n        those points. This function assumes that the points are provided in the \n        order they are to be connected together. Notice that we also assume \n        there are more than two points, but more can be provided in which case \n        the shape is assumed to be closed. The output has the same shape as the \n        input and does not check for infinite (vertical) gradients.\n\n        Note: Due to the intensly vectorised nature of this code it is ofen \n        necessary to provide the parameters with expanded dimensions. This may \n        be achieved using `x1[:, None, None]` or `x1.reshape((-1, 1, 1))` or \n        `np.expand_dims(x1, (1, 2))`.\n\n        Parameters\n        ----------\n        xs: float, meters\n            The x coordinates of the points that are to be connected. \n        ys: float, meters\n            The y coordinates of the points that are to be connected. \n            Must have the same shape as x. \n\n        Returns\n        -------\n        ms: float\n            The gradients of the lines that connect the vertices. The vertices \n            wrap around to form a closed shape whatever it may look like. \n        \"\"\"\n        x_diffs = xs - np.roll(xs, -1)\n        y_diffs = ys - np.roll(ys, -1)\n        return y_diffs / x_diffs\n\n\n    def _extent(self : ApertureLayer) -&gt; float:\n\"\"\"\n        Returns the largest distance to the outer edge of the aperture from the\n        centre.\n\n        Returns\n        -------\n        extent : float\n            The maximum distance from the centre to edge of aperture.\n        \"\"\"\n        verts = self.vertices\n        dist_to_verts = np.hypot(verts[:, 1], verts[:, 0])\n        return np.max(dist_to_verts)\n\n\n    def _soft_edged(self : ApertureLayer, coordinates : float) -&gt; float:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\\n            sorted_y1, bc_x, bc_y)  \n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        soft_edges = self._soften(dist_sgn * dist_from_edges)\n\n        return (soft_edges).prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        # NOTE: see class docs.\n        bc_x1 = self.vertices[:, 0][:, None, None]\n        bc_y1 = self.vertices[:, 1][:, None, None]\n\n        bc_x = coordinates[0][None, :, :]\n        bc_y = coordinates[1][None, :, :]\n\n        theta = np.arctan2(bc_y1, bc_x1)\n        offset_theta = self._offset(theta, 0.)\n\n        sorted_inds = np.argsort(offset_theta.flatten())\n\n        sorted_x1 = bc_x1[sorted_inds]\n        sorted_y1 = bc_y1[sorted_inds]\n        sorted_m = self._grads_from_many_points(sorted_x1, sorted_y1)\n\n        dist_from_edges = self._perp_dists_from_lines(sorted_m, sorted_x1, \\\n            sorted_y1, bc_x, bc_y)  \n        dist_sgn = self._is_orig_left_of_edge(sorted_m, sorted_x1, sorted_y1)\n        edges = (dist_from_edges * dist_sgn) &gt; 0.\n\n        return (edges).prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n        transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n        summary = f\"Applies a {transmissive} Irregular Polygonal Aperture\"\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.__init__","title":"<code>__init__(radius, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), occulting=False, softening=np.array(1.0), name='CircularAperture')</code>","text":"<p>Constructor for the CircularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>Array</code> <p>The radius of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CircularAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             radius      : Array, \n             centre      : Array = np.array([0., 0.]),\n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             occulting   : bool = False, \n             softening   : Array = np.array(1.),\n             name        : str = \"CircularAperture\",\n             ) -&gt; Array:\n\"\"\"\n    Constructor for the CircularAperture class.\n\n    Parameters\n    ----------\n    radius: Array, meters \n        The radius of the aperture.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'CircularAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear, \n                     compression = compression, \n                     occulting = occulting, \n                     softening = softening,\n                     name = name) \n\n    self.radius = np.asarray(radius).astype(float)\n    dLux.exceptions.validate_eq_attr_dims((), self.radius.shape, \"radius\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    radius = convert_cartesian(self.radius, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} Circular Aperture with radius \"\n               f\"{radius} {cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CircularAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AnnularAperture.__init__","title":"<code>__init__(rmax, rmin, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), occulting=False, softening=np.array(1.0), name='AnnularAperture')</code>","text":"<p>Constructor for the AnnularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>rmax</code> <code>Array, meters</code> <p>The outer radius of the aperture.</p> required <code>rmin</code> <code>Array, meters</code> <p>The inner radius of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AnnularAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             rmax        : Array, \n             rmin        : Array, \n             centre      : Array = np.array([0., 0.]),\n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"AnnularAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the AnnularAperture class.\n\n    Parameters\n    ----------\n    rmax : Array, meters\n        The outer radius of the aperture. \n    rmin : Array, meters\n        The inner radius of the aperture. \n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'AnnularAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear, \n                     compression = compression, \n                     occulting = occulting, \n                     softening = softening,\n                     name = name)\n\n    self.rmax = np.asarray(rmax).astype(float)\n    self.rmin = np.asarray(rmin).astype(float)\n\n    dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n    dLux.exceptions.validate_eq_attr_dims((), self.rmin.shape, \"rmin\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AnnularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    rmin = convert_cartesian(self.rmin, 'meters', cartesian_units)\n    rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} Annular Aperture with inner \"\n               f\"radius {rmin} {cartesian_units} and outer radius {rmax} \"\n               f\"{cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AnnularAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AnnularAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AnnularAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.HexagonalAperture.__init__","title":"<code>__init__(rmax, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='HexagonalAperture')</code>","text":"<p>Constructor for the HexagonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'HexagonalAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             rmax        : Array,\n             centre      : Array = np.array([0., 0.]), \n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"HexagonalAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the HexagonalAperture class.\n\n    Parameters\n    ----------\n    rmax : Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'HexagonalAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(nsides = 6,\n                     rmax = rmax,\n                     centre = centre, \n                     shear = shear, \n                     compression = compression,\n                     rotation = rotation,\n                     occulting = occulting,\n                     softening = softening,\n                     name = name)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.HexagonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} Hexagonal Aperture of max radius \"\n               f\"{rmax:.{sigfigs}} {cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.HexagonalAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.HexagonalAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.HexagonalAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.__init__","title":"<code>__init__(height, width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='RectangularAperture')</code>","text":"<p>Constructor for the RectangularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>Array</code> <p>The length of the aperture in the y-direction.</p> required <code>width</code> <code>Array</code> <p>The length of the aperture in the x-direction.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'RectangularAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             height      : Array, \n             width       : Array, \n             centre      : Array = np.array([0., 0.]),\n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"RectangularAperture\") -&gt; ApertureLayer: \n\"\"\"\n    Constructor for the RectangularAperture class.\n\n    Parameters\n    ----------\n    height: Array, meters \n        The length of the aperture in the y-direction.\n    width: Array, meters\n        The length of the aperture in the x-direction.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'RectangularAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear,\n                     compression = compression,\n                     rotation = rotation, \n                     occulting = occulting, \n                     softening = softening,\n                     name = name)\n\n    self.height = np.asarray(height).astype(float)\n    self.width = np.asarray(width).astype(float)\n\n    dLux.exceptions.validate_eq_attr_dims((), self.height.shape, \"height\")\n    dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    height = convert_cartesian(self.height, 'meters', cartesian_units)\n    width = convert_cartesian(self.width, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} Rectangular Aperture with height \"\n               f\"{height} {cartesian_units} and width {width} \"\n               f\"{cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RectangularAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.SquareAperture.__init__","title":"<code>__init__(width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='SquareAperture')</code>","text":"<p>Constructor for the SquareAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>Array</code> <p>The side length of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'SquareAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             width       : Array, \n             centre      : Array = np.array([0., 0.]),\n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"SquareAperture\") -&gt; ApertureLayer: \n\"\"\"\n    Constructor for the SquareAperture class.\n\n    Parameters\n    ----------\n    width: Array, meters\n        The side length of the aperture. \n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'SquareAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear,\n                     compression = compression,\n                     rotation = rotation, \n                     occulting = occulting, \n                     softening = softening,\n                     name = name)\n\n    self.width = np.asarray(width).astype(float)\n\n    dLux.exceptions.validate_eq_attr_dims((), self.width.shape, \"width\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.SquareAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    width = convert_cartesian(self.width, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} Rectangular Aperture with width \"\n               f\"{width} {cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.SquareAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.SquareAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.SquareAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RegularPolygonalAperture.__init__","title":"<code>__init__(nsides, rmax, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='RegularPolygonalAperture')</code>","text":"<p>Constructor for the RegularPolygonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>rmax</code> <code>Array</code> <p>The maximum radius to the vertices from its center.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'RegularPolygonalAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             nsides      : int,\n             rmax        : Array,\n             centre      : Array = np.array([0., 0.]), \n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"RegularPolygonalAperture\"\n             ) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the RegularPolygonalAperture class.\n\n    Parameters\n    ----------\n    nsides: int\n        The number of sides of the aperture.  \n    rmax: Array, meters\n        The maximum radius to the vertices from its center.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'RegularPolygonalAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear, \n                     compression = compression,\n                     rotation = rotation,\n                     occulting = occulting,\n                     softening = softening,\n                     name = name)\n\n    self.nsides = int(nsides)\n    self.rmax = np.array(rmax).astype(float)\n\n    dLux.exceptions.validate_eq_attr_dims((), self.rmax.shape, \"rmax\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RegularPolygonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    rmax = convert_cartesian(self.rmax, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = (f\"Applies a {transmissive} {self.nsides} sided Regular \"\n               f\"Polygonal Aperture of max radius {rmax:.{sigfigs}} \"\n               f\"{cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.RegularPolygonalAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RegularPolygonalAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.RegularPolygonalAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.IrregularPolygonalAperture.__init__","title":"<code>__init__(vertices, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='IrregularPolygonalAperture')</code>","text":"<p>Constructor for the IrregularPolygonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Array</code> <p>The location of the vertices of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'IrregularPolygonalAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             vertices    : Array,\n             centre      : Array = np.array([0., 0.]), \n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             occulting   : bool  = False, \n             softening   : Array = np.array(1.),\n             name        : str   = \"IrregularPolygonalAperture\"\n             ) -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the IrregularPolygonalAperture class.\n\n    Parameters\n    ----------\n    vertices: Array, meters\n        The location of the vertices of the aperture.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    occulting: bool = False\n        Is the aperture occulting or tranmissive. False results in a \n        tranmissive aperture, and True results in an occulting aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'IrregularPolygonalAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(centre = centre, \n                     shear = shear, \n                     compression = compression,\n                     rotation = rotation,\n                     occulting = occulting,\n                     softening = softening,\n                     name = name)\n\n    self.vertices = np.array(vertices).astype(float)\n    dLux.exceptions.validate_bc_attr_dims(\n        (1, 2), self.vertices.shape, \"vertices\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.IrregularPolygonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n    transmissive = \"transmissive\" if not self.occulting else \"occulting\"\n\n    summary = f\"Applies a {transmissive} Irregular Polygonal Aperture\"\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.IrregularPolygonalAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.IrregularPolygonalAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.IrregularPolygonalAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#static-apertures","title":"Static Apertures","text":"<p>The inbuild flexibility of the <code>dLux.apertures</code> module is very powerful but unlikely to be needed in most cases. For this reason Dynamic apertures can be turned into static apertures where the array of tranmission values are calculated once, and then kept fixed to avoid re-calculation of the aperture every evaluation.</p> Static Aperture API <p>         Bases: <code>AbstractStaticAperture</code></p> <p>A class for static pre-calculated apertures, without aberrations. Static apertures with aberrations can be instantiated using the  StaticAberratedAberrated class.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The aperture represented as an array.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class StaticAperture(AbstractStaticAperture):\n\"\"\"\n    A class for static pre-calculated apertures, without aberrations. Static\n    apertures with aberrations can be instantiated using the \n    StaticAberratedAberrated class.\n\n    Attributes\n    ----------\n    aperture: Array\n        The aperture represented as an array.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self        : ApertureLayer, \n                 aperture    : ApertureLayer, \n                 npixels     : int   = None, \n                 diameter    : float = None,\n                 coordinates : Array = None,\n                 name        : str   = \"StaticAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the StaticAperture class.\n\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            An instance of DynamicAperture. \n        npixels : int = None\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters = None\n            The diameter of the aperture in meters. \n        coordinates : Array, meters = None\n            The coordinate system to calculate the aperture on.\n        name: str = 'StaticAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        if isinstance(aperture, AbstractStaticAperture):\n            raise ValueError(\"This Aperture is already static, please \" + \\\n                \"provide a dynamic aperture.\")\n\n        if isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n            len(aperture._aberrated_apertures()) &gt; 0 or \\\n                isinstance(aperture, AberratedAperture):\n            raise ValueError(\"This Aperture contains aberrated apertures, \" + \\\n                \"please use the StaticAberratedAperture class.\")\n\n        super().__init__(aperture = aperture, \n                         npixels = npixels, \n                         diameter = diameter, \n                         coordinates = coordinates, \n                         name = name)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return \"Applies a pre-calculated Static Aperture.\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAperture.__init__","title":"<code>__init__(aperture, npixels=None, diameter=None, coordinates=None, name='StaticAperture')</code>","text":"<p>Constructor for the StaticAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>An instance of DynamicAperture.</p> required <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> <code>None</code> <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> <code>None</code> <code>coordinates</code> <code>Array, meters</code> <p>The coordinate system to calculate the aperture on.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'StaticAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             aperture    : ApertureLayer, \n             npixels     : int   = None, \n             diameter    : float = None,\n             coordinates : Array = None,\n             name        : str   = \"StaticAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the StaticAperture class.\n\n    Parameters\n    ----------\n    aperture: ApertureLayer\n        An instance of DynamicAperture. \n    npixels : int = None\n        The number of pixels accross one edge of the aperture.  \n    diameter : float, meters = None\n        The diameter of the aperture in meters. \n    coordinates : Array, meters = None\n        The coordinate system to calculate the aperture on.\n    name: str = 'StaticAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    if isinstance(aperture, AbstractStaticAperture):\n        raise ValueError(\"This Aperture is already static, please \" + \\\n            \"provide a dynamic aperture.\")\n\n    if isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n        len(aperture._aberrated_apertures()) &gt; 0 or \\\n            isinstance(aperture, AberratedAperture):\n        raise ValueError(\"This Aperture contains aberrated apertures, \" + \\\n            \"please use the StaticAberratedAperture class.\")\n\n    super().__init__(aperture = aperture, \n                     npixels = npixels, \n                     diameter = diameter, \n                     coordinates = coordinates, \n                     name = name)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return \"Applies a pre-calculated Static Aperture.\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#aberrated-apertures","title":"Aberrated Apertures","text":"<p>Both dynamic and static apertures can have aberations applied to them using the <code>AberratedAperture</code> class. This class takes an aperture as an argument and then applies a set of basis vectors to the aperture. The basis vectors are derived from the Zernike polynomials and calculated to be orthonormal on all regular-polygon apertures. The underlying aberrations are generated in the aberations module.</p> Aberrated Aperture API <p>         Bases: <code>AbstractAberratedAperture</code></p> <p>A class for generating apertures with aberrations. This class generates the basis vectors of the aberrations at run time, allowing for the aperture and aberrations to be recovered simultaneously.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> <code>basis</code> <code>list[Zernike]</code> <p>A list of basis functions that represent the basis. The exact  polynomials that are represented will depend on the aperture shape. </p> <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class AberratedAperture(AbstractAberratedAperture):\n\"\"\"\n    A class for generating apertures with aberrations. This class generates the\n    basis vectors of the aberrations at run time, allowing for the aperture and\n    aberrations to be recovered simultaneously.\n\n    Attributes\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    basis: list[Zernike]\n        A list of basis functions that represent the basis. The exact \n        polynomials that are represented will depend on the aperture shape. \n    coefficients: Array\n        The amplitude of each basis vector of the aberrations.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    aperture : ApertureLayer\n    basis    : dLux.aberrations.ZernikeBasis\n\n\n    def __init__(self         : ApertureLayer, \n                 aperture     : ApertureLayer, \n                 noll_inds    : Array,\n                 coefficients : Array = None,\n                 name         : str   = \"AberratedAperture\",\n                 **kwargs) -&gt; ApertureLayer: \n\"\"\"\n        Constructor for the AberratedAperture class.\n\n        Parameters\n        ----------\n        aperture: ApertureLayer\n            The aperture on which the aberration basis is defined.\n        noll_inds: List[int]\n            The noll indices are a scheme for indexing the Zernike\n            polynomials. Normally these polynomials have two \n            indices but the noll indices prevent an order to \n            these pairs. All basis can be indexed using the noll\n            indices based on `n` and `m`. \n        coefficients: Array = None\n            The amplitude of each basis vector of the aberrations. If nothing \n            is provided, then the coefficients are set to zero.\n        name: str = 'AberratedAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        if aperture.occulting:\n            raise ValueError(\"AberratedApertures can not be occulting.\")\n\n        if not isinstance(aperture, DynamicAperture):\n            raise ValueError(\"AberratedApertures can not contain Static, \" + \\\n                \"Compound or Multi Apertures. AberratedApertures can be \" + \\\n                \"placed in Compound or Multi Apertures, which can then be \" + \\\n                \"promoted to Static.\")\n\n        # Set Aperture\n        self.aperture = aperture\n\n        # Set Basis\n        self.basis = dLux.aberrations.ZernikeBasis(noll_inds)\n\n        # Initialise the coefficinets\n        coefficients = np.zeros(len(noll_inds)) if coefficients is None \\\n            else np.asarray(coefficients).astype(float)\n\n        super().__init__(coefficients=coefficients, name=name, **kwargs)\n\n        # Dimensionality check\n        dLux.exceptions.validate_bc_attr_dims(\n            noll_inds.shape, self.coefficients.shape, \"coefficients\")\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture and the abberations to the wavefront.  \n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront that is passing through the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after passing through the aperture.\n        \"\"\"\n        # Calculate aperture and opd\n        coordinates = wavefront.pixel_coordinates\n        opd = self._opd(coordinates)\n        aperture = self.aperture._aperture(coordinates)\n\n        # Calculate and update amplitude and phase\n        phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)\n        amplitude = wavefront.amplitude * aperture\n        return wavefront.set_phasor(amplitude, phase)\n\n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        return self.aperture._aperture(coordinates)\n\n\n    def get_aperture(self     : ApertureLayer, \n                     npixels  : int, \n                     diameter : float) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on a set of coordinates \n        with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the aperture.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self.aperture._aperture(coordinates)\n\n\n    def _basis(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        coordinates = self.aperture._normalised_coordinates(coordinates)\n\n        if isinstance(self.aperture, RegularPolygonalAperture):\n            ikes = self.basis.calculate_basis(coordinates, self.aperture.nsides)\n        else:\n            ikes = self.basis.calculate_basis(coordinates)\n\n        is_reg_pol = isinstance(self.aperture, RegularPolygonalAperture)\n        is_circ = isinstance(self.aperture, CircularAperture)\n\n        if is_circ or is_reg_pol:\n            return ikes\n\n        aperture = self.aperture._aperture(coordinates)\n        ikes = self._orthonormalise(aperture, ikes)\n\n        return ikes \n\n\n    def get_basis(self     : ApertureLayer, \n                  npixels  : int, \n                  diameter : float) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations on the provided \n        coordinates with the specified number of pixels and diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._basis(coordinates)\n\n\n    def _opd(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the opd on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        basis = self._basis(coordinates)\n        return (basis * self.coefficients[:, None, None]).sum(axis=0)\n\n\n    def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations \n        on the provided coordinates with the specified number of pixels and \n        diameter.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters\n            The diameter of the aperture in meters. \n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n        return self._opd(coordinates)\n\n\n    def _orthonormalise(self     : ApertureLayer, \n                        aperture : Array, \n                        zernikes : Array) -&gt; Array:\n\"\"\"\n        Orthonomalises the zernike polynomials on the aperture.\n\n        Parameters\n        ----------\n        aperture : Array\n            An array representing the aperture.\n        zernikes : Array\n            The zernike polynomials to orthonormalise on the aperture.\n\n        Returns\n        -------\n        basis : Array\n            The orthonormalised zernike polynomials evaluated on the aperture.\n        \"\"\"\n        pixel_area = aperture.sum()\n        shape = zernikes.shapediameter\n        basis = np.zeros(shape).at[0].set(aperture)\n\n        for j in np.arange(1, self.nterms):\n            intermediate = zernikes[j] * aperture\n            coefficient = np.zeros((self.nterms, 1, 1), dtype=float)\n            mask = (np.arange(1, self.nterms) &gt; j + 1).reshape((-1, 1, 1))\n\n            coefficient = -1 / pixel_area * \\\n                (zernikes[j] * basis[1:] * aperture * mask)\\\n                .sum(axis = (1, 2))\\\n                .reshape(-1, 1, 1) \n\n            intermediate += (coefficient * basis[1:] * mask).sum(axis = 0)\n\n            basis = basis\\\n                .at[j]\\\n                .set(intermediate / \\\n                    np.sqrt((intermediate ** 2).sum() / pixel_area))\n\n        return basis\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = super().summary(angular_units, cartesian_units, sigfigs)\n        return summary[:-1] + f\" with {len(self.coefficients)} aberrations.\"\n</code></pre> Static Aberrated Aperture API <p>         Bases: <code>AbstractAberratedAperture</code>, <code>AbstractStaticAperture</code></p> <p>A class for static pre-calculated apertures with aberrations. This  pre-calcaultes both the aperture and the basis at init time and can not  have the aperture properties optimised.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The aperture represented as an array.</p> <code>basis</code> <code>Array</code> <p>The basis represented as an array.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class StaticAberratedAperture(AbstractAberratedAperture, AbstractStaticAperture):\n\"\"\"\n    A class for static pre-calculated apertures with aberrations. This \n    pre-calcaultes both the aperture and the basis at init time and can not \n    have the aperture properties optimised.\n\n    Attributes\n    ----------\n    aperture: Array\n        The aperture represented as an array.\n    basis: Array \n        The basis represented as an array.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis : Array\n\n\n    def __init__(self        : ApertureLayer, \n                 aperture    : ApertureLayer, \n                 npixels     : int   = None, \n                 diameter    : float = None,\n                 coordinates : Array = None,\n                 name        : str   = \"StaticAberratedAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the StaticAberratedAperture class.\n\n        Parameters\n        ----------\n        aperture: AberratedAperture\n            An instance of AberratedAperture. \n        npixels : int = None\n            The number of pixels accross one edge of the aperture.  \n        diameter : float, meters = None\n            The diameter of the aperture in meters. \n        coordinates : Array, meters = None\n            The coordinate system to calculate the aperture on.\n        name: str = 'StaticAberratedAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        # Ensure correct aperture types\n        if not isinstance(aperture, \n            (AberratedAperture, CompoundAperture, MultiAperture)) and \\\n                (isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n                    len(aperture._aberrated_apertures()) == 0):\n            raise ValueError(\"The provided aperture must have aberrations.\")\n\n        # Input check: Coordinates provided\n        if coordinates is not None and \\\n            (npixels is not None or diameter is not None):\n            raise ValueError(\"If coordinates is specified npixels and \" + \\\n                \"diameter can not be provided.\")\n        # Input check: Coordinates not provided\n        elif coordinates is None and \\\n            (npixels is None or diameter is None):\n            raise ValueError(\"both npixels and diameter must be provided.\")\n\n        # Generate coordinates if not provided\n        if coordinates is None:\n            npixels_in = (npixels, npixels)\n        pixel_scales = (diameter / npixels, diameter / npixels)\n        coordinates = get_pixel_positions(npixels_in, pixel_scales)\n\n        super().__init__(aperture=aperture, coordinates=coordinates, \n            coefficients=aperture.coefficients, name=name)\n\n        self.basis = aperture._basis(coordinates)\n\n\n    def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the aperture to the wavefront.\n\n        Parameters\n        ----------\n        wavefront: Wavefront\n            The wavefront that is passing through the aperture.\n\n        Returns\n        -------\n        wavefront: Wavefront\n            The wavefront after passing through the aperture\n        \"\"\"\n        # Calculate and update amplitude and phase\n        phase = wavefront.phase + opd_to_phase(self._opd(), \n                                               wavefront.wavelength)\n        amplitude = wavefront.amplitude * self.aperture\n        return wavefront.set_phasor(amplitude, phase)\n\n\n    def _basis(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the basis vectors on.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        return self.basis\n\n\n    def get_basis(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the basis vectors of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the basis vectors of the aperture aberrations.\n        \"\"\"\n        return self._basis()\n\n\n    def _opd(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        if self.coefficients.ndim == 1:\n            return (self.basis * self.coefficients[:, None, None]).sum(0)\n        else:\n            return (self.basis * self.coefficients[:, :, None, None]).sum((0, 1))\n\n\n    def get_opd(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n        Compute the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        return self._opd()\n\n\n    @property\n    def opd(self : ApertureLayer) -&gt; Array:\n\"\"\"\n        Return the total optical path difference of the aperture aberrations.\n\n        Returns\n        -------\n        basis : Array \n            The array of the total opd of the aperture aberrations.\n        \"\"\"\n        return self._opd()\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"Applies a pre-calculated Static Aperture with \"\n                f\"{len(self.coefficients)} aberrations.\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the aperture and the abberations to the wavefront.  </p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is passing through the aperture.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront after passing through the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Apply the aperture and the abberations to the wavefront.  \n\n    Parameters\n    ----------\n    wavefront: Wavefront\n        The wavefront that is passing through the aperture.\n\n    Returns\n    -------\n    wavefront: Wavefront\n        The wavefront after passing through the aperture.\n    \"\"\"\n    # Calculate aperture and opd\n    coordinates = wavefront.pixel_coordinates\n    opd = self._opd(coordinates)\n    aperture = self.aperture._aperture(coordinates)\n\n    # Calculate and update amplitude and phase\n    phase = wavefront.phase + opd_to_phase(opd, wavefront.wavelength)\n    amplitude = wavefront.amplitude * aperture\n    return wavefront.set_phasor(amplitude, phase)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__init__","title":"<code>__init__(aperture, noll_inds, coefficients=None, name='AberratedAperture', **kwargs)</code>","text":"<p>Constructor for the AberratedAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> required <code>noll_inds</code> <code>Array</code> <p>The noll indices are a scheme for indexing the Zernike polynomials. Normally these polynomials have two  indices but the noll indices prevent an order to  these pairs. All basis can be indexed using the noll indices based on <code>n</code> and <code>m</code>.</p> required <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations. If nothing  is provided, then the coefficients are set to zero.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AberratedAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self         : ApertureLayer, \n             aperture     : ApertureLayer, \n             noll_inds    : Array,\n             coefficients : Array = None,\n             name         : str   = \"AberratedAperture\",\n             **kwargs) -&gt; ApertureLayer: \n\"\"\"\n    Constructor for the AberratedAperture class.\n\n    Parameters\n    ----------\n    aperture: ApertureLayer\n        The aperture on which the aberration basis is defined.\n    noll_inds: List[int]\n        The noll indices are a scheme for indexing the Zernike\n        polynomials. Normally these polynomials have two \n        indices but the noll indices prevent an order to \n        these pairs. All basis can be indexed using the noll\n        indices based on `n` and `m`. \n    coefficients: Array = None\n        The amplitude of each basis vector of the aberrations. If nothing \n        is provided, then the coefficients are set to zero.\n    name: str = 'AberratedAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    if aperture.occulting:\n        raise ValueError(\"AberratedApertures can not be occulting.\")\n\n    if not isinstance(aperture, DynamicAperture):\n        raise ValueError(\"AberratedApertures can not contain Static, \" + \\\n            \"Compound or Multi Apertures. AberratedApertures can be \" + \\\n            \"placed in Compound or Multi Apertures, which can then be \" + \\\n            \"promoted to Static.\")\n\n    # Set Aperture\n    self.aperture = aperture\n\n    # Set Basis\n    self.basis = dLux.aberrations.ZernikeBasis(noll_inds)\n\n    # Initialise the coefficinets\n    coefficients = np.zeros(len(noll_inds)) if coefficients is None \\\n        else np.asarray(coefficients).astype(float)\n\n    super().__init__(coefficients=coefficients, name=name, **kwargs)\n\n    # Dimensionality check\n    dLux.exceptions.validate_bc_attr_dims(\n        noll_inds.shape, self.coefficients.shape, \"coefficients\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_aperture","title":"<code>get_aperture(npixels, diameter)</code>","text":"<p>Compute the array representing the aperture on a set of coordinates  with the specified number of pixels and diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The array representing the transmission of the aperture.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def get_aperture(self     : ApertureLayer, \n                 npixels  : int, \n                 diameter : float) -&gt; Array:\n\"\"\"\n    Compute the array representing the aperture on a set of coordinates \n    with the specified number of pixels and diameter.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels accross one edge of the aperture.  \n    diameter : float, meters\n        The diameter of the aperture in meters. \n\n    Returns\n    -------\n    aperture : Array \n        The array representing the transmission of the aperture.\n    \"\"\"\n    npixels_in = (npixels, npixels)\n    pixel_scales = (diameter / npixels, diameter / npixels)\n    coordinates = get_pixel_positions(npixels_in, pixel_scales)\n    return self.aperture._aperture(coordinates)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_basis","title":"<code>get_basis(npixels, diameter)</code>","text":"<p>Compute the basis vectors of the aperture aberrations on the provided  coordinates with the specified number of pixels and diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the basis vectors of the aperture aberrations.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def get_basis(self     : ApertureLayer, \n              npixels  : int, \n              diameter : float) -&gt; Array:\n\"\"\"\n    Compute the basis vectors of the aperture aberrations on the provided \n    coordinates with the specified number of pixels and diameter.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels accross one edge of the aperture.  \n    diameter : float, meters\n        The diameter of the aperture in meters. \n\n    Returns\n    -------\n    basis : Array \n        The array of the basis vectors of the aperture aberrations.\n    \"\"\"\n    npixels_in = (npixels, npixels)\n    pixel_scales = (diameter / npixels, diameter / npixels)\n    coordinates = get_pixel_positions(npixels_in, pixel_scales)\n    return self._basis(coordinates)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_opd","title":"<code>get_opd(npixels, diameter)</code>","text":"<p>Compute the total optical path difference of the aperture aberrations  on the provided coordinates with the specified number of pixels and  diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def get_opd(self : ApertureLayer, npixels : int, diameter : float) -&gt; Array:\n\"\"\"\n    Compute the total optical path difference of the aperture aberrations \n    on the provided coordinates with the specified number of pixels and \n    diameter.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels accross one edge of the aperture.  \n    diameter : float, meters\n        The diameter of the aperture in meters. \n\n    Returns\n    -------\n    basis : Array \n        The array of the total opd of the aperture aberrations.\n    \"\"\"\n    npixels_in = (npixels, npixels)\n    pixel_scales = (diameter / npixels, diameter / npixels)\n    coordinates = get_pixel_positions(npixels_in, pixel_scales)\n    return self._opd(coordinates)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    summary = super().summary(angular_units, cartesian_units, sigfigs)\n    return summary[:-1] + f\" with {len(self.coefficients)} aberrations.\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__call__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_aperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_basis","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.get_opd","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.AberratedAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.opd","title":"<code>opd: Array</code>  <code>property</code>","text":"<p>Return the total optical path difference of the aperture aberrations.</p> <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the aperture to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is passing through the aperture.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront after passing through the aperture</p> Source code in <code>dLux/apertures.py</code> <pre><code>def __call__(self : ApertureLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Apply the aperture to the wavefront.\n\n    Parameters\n    ----------\n    wavefront: Wavefront\n        The wavefront that is passing through the aperture.\n\n    Returns\n    -------\n    wavefront: Wavefront\n        The wavefront after passing through the aperture\n    \"\"\"\n    # Calculate and update amplitude and phase\n    phase = wavefront.phase + opd_to_phase(self._opd(), \n                                           wavefront.wavelength)\n    amplitude = wavefront.amplitude * self.aperture\n    return wavefront.set_phasor(amplitude, phase)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.__init__","title":"<code>__init__(aperture, npixels=None, diameter=None, coordinates=None, name='StaticAberratedAperture')</code>","text":"<p>Constructor for the StaticAberratedAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>An instance of AberratedAperture.</p> required <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> <code>None</code> <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> <code>None</code> <code>coordinates</code> <code>Array, meters</code> <p>The coordinate system to calculate the aperture on.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'StaticAberratedAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer, \n             aperture    : ApertureLayer, \n             npixels     : int   = None, \n             diameter    : float = None,\n             coordinates : Array = None,\n             name        : str   = \"StaticAberratedAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the StaticAberratedAperture class.\n\n    Parameters\n    ----------\n    aperture: AberratedAperture\n        An instance of AberratedAperture. \n    npixels : int = None\n        The number of pixels accross one edge of the aperture.  \n    diameter : float, meters = None\n        The diameter of the aperture in meters. \n    coordinates : Array, meters = None\n        The coordinate system to calculate the aperture on.\n    name: str = 'StaticAberratedAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    # Ensure correct aperture types\n    if not isinstance(aperture, \n        (AberratedAperture, CompoundAperture, MultiAperture)) and \\\n            (isinstance(aperture, (CompoundAperture, MultiAperture)) and \\\n                len(aperture._aberrated_apertures()) == 0):\n        raise ValueError(\"The provided aperture must have aberrations.\")\n\n    # Input check: Coordinates provided\n    if coordinates is not None and \\\n        (npixels is not None or diameter is not None):\n        raise ValueError(\"If coordinates is specified npixels and \" + \\\n            \"diameter can not be provided.\")\n    # Input check: Coordinates not provided\n    elif coordinates is None and \\\n        (npixels is None or diameter is None):\n        raise ValueError(\"both npixels and diameter must be provided.\")\n\n    # Generate coordinates if not provided\n    if coordinates is None:\n        npixels_in = (npixels, npixels)\n    pixel_scales = (diameter / npixels, diameter / npixels)\n    coordinates = get_pixel_positions(npixels_in, pixel_scales)\n\n    super().__init__(aperture=aperture, coordinates=coordinates, \n        coefficients=aperture.coefficients, name=name)\n\n    self.basis = aperture._basis(coordinates)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.get_basis","title":"<code>get_basis(**kwargs)</code>","text":"<p>Compute the basis vectors of the aperture aberrations.</p> <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the basis vectors of the aperture aberrations.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def get_basis(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n    Compute the basis vectors of the aperture aberrations.\n\n    Returns\n    -------\n    basis : Array \n        The array of the basis vectors of the aperture aberrations.\n    \"\"\"\n    return self._basis()\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.get_opd","title":"<code>get_opd(**kwargs)</code>","text":"<p>Compute the total optical path difference of the aperture aberrations.</p> <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def get_opd(self : ApertureLayer, **kwargs) -&gt; Array:\n\"\"\"\n    Compute the total optical path difference of the aperture aberrations.\n\n    Returns\n    -------\n    basis : Array \n        The array of the total opd of the aperture aberrations.\n    \"\"\"\n    return self._opd()\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"Applies a pre-calculated Static Aperture with \"\n            f\"{len(self.coefficients)} aberrations.\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.opd","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.__call__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.get_basis","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.get_opd","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.StaticAberratedAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#composite-apertures","title":"Composite Apertures","text":"<p>The Composite apertures are designed to take in a series of dynamic aperture and combine them to create arbirary aperture shapes. There are two types of composite aperture, Compound and Multi apertures. The CompoundAperture is used to combine apertures that are overlapping, and the MultiAperture is used to combine apertures that are not overlapping. For example if we wanted to create a HST-like aperture we would combine an annular aperture with a spiders class. If we wanted to create an aperture mask, we would combine a series of circular apertures in a MultiAperture class.</p> Compound Aperture API <p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture with spiders holding a secondary mirror.</p> <p>This class is distinct from the MultiAperture class in that the  sub-apertures are combined by mulitplying their respective tranmissions  together, ie the sub-apertures are overlapping.</p> <p>This class should not contain a MulitAperture, but MultiApertures can  contain CompoundApertures.</p> <p>A single aberrated aperture can be placed into the set of apertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class CompoundAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture with spiders holding a secondary mirror.\n\n    This class is distinct from the MultiAperture class in that the \n    sub-apertures are combined by mulitplying their respective tranmissions \n    together, ie the sub-apertures are overlapping.\n\n    This class should not contain a MulitAperture, but MultiApertures can \n    contain CompoundApertures.\n\n    A single aberrated aperture can be placed into the set of apertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self        : ApertureLayer,\n                 apertures   : list,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = \"CompoundAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the CompoundAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'CompoundAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        # Check for more than one aberration\n        naberrated = 0\n        for aperture in apertures:\n            if isinstance(aperture, CompositeAperture):\n                raise ValueError(\"CompositeApertures cannot be nested. To \" +\\\n                    \"combine multiple CompositeApertures, use MultiAperture.\")\n            if isinstance(aperture, AberratedAperture):\n                naberrated += 1\n        if naberrated &gt; 1:\n            raise ValueError(\"CompoundAperture can only have one \" + \\\n                             \"AberratedAperture.\")\n\n        super().__init__(apertures,\n                         centre = centre,\n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n\n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n        aps = self._stacked_apertures(coordinates)\n        return aps.prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = (\"Applies a Compound Aperture with the following \"\n                   \"sub-apertures: \\n\")\n        for ap in self.apertures.values():\n            ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n            summary += ap_summary + \"\\n\"\n        return summary\n</code></pre> Multi Aperture API <p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture mask.</p> <p>This class is distinct from the CompoundAperture class in that the  sub-apertures are combined by adding their respective tranmissions  together, ie the sub-apertures are not overlapping.</p> <p>This class can contain multiple CompoundApertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class MultiAperture(CompositeAperture):\n\"\"\"\n    A  class used to combine multiple apertures into a single coherent aperture.\n    An example would be an aperture mask.\n\n    This class is distinct from the CompoundAperture class in that the \n    sub-apertures are combined by adding their respective tranmissions \n    together, ie the sub-apertures are not overlapping.\n\n    This class can contain multiple CompoundApertures.\n\n    Attributes\n    ----------\n    apertures: dict(str, Aperture)\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self        : ApertureLayer,\n                 apertures   : list,\n                 centre      : Array = np.array([0., 0.]), \n                 shear       : Array = np.array([0., 0.]),\n                 compression : Array = np.array([1., 1.]),\n                 rotation    : Array = np.array(0.),\n                 name        : str   = \"MultiAperture\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the MultiAperture class.\n\n        Parameters\n        ----------\n        apertures: list[Aperture]\n            The sub-apertures that make up the full aperture.\n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        name: str = 'MultiAperture'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(apertures,\n                         centre = centre,\n                         shear = shear,\n                         compression = compression,\n                         rotation = rotation,\n                         name = name)\n\n\n    def _aperture(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Compute the array representing the aperture on the provided coordinates.\n\n        Parameters\n        ----------\n        coordinates : Array, meters\n            The coordinate system to calculate the aperture on.\n\n        Returns\n        -------\n        aperture : Array \n            The array representing the transmission of the combined \n            sub-apertures. \n        \"\"\"\n        aps = self._stacked_apertures(coordinates)\n        return aps.sum(axis=0)\n\n\n    def _aberrated_apertures(self : ApertureLayer) -&gt; list:\n\"\"\"\n        Returns the individual apertures with aberrations.\n        Note: This method returns CompoundApertures if it contains apertures\n        with aberrations in them.\n\n        Returns\n        -------\n        apertures: list[Union[AberratedAperture, CompoundAperture]]\n            The list of apertures with aberrations.\n        \"\"\"\n        # Define leaf fn\n        def is_aberrated(leaf):\n            if isinstance(leaf, AberratedAperture):\n                return True\n            elif isinstance(leaf, CompoundAperture):\n                if len(leaf._aberrated_apertures()) &gt; 0:\n                    return True\n            return False\n\n        # Get aberrated apertures\n        filter_map = tree_map(is_aberrated, self.apertures, is_leaf=is_aberrated)\n        aberrated = filter(self.apertures, filter_map)\n        return tree_flatten(aberrated, is_leaf=is_aberrated)[0]\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        summary = (\"Applies a Multi Aperture with the following \"\n                   \"sub-apertures: \\n\")\n        for ap in self.apertures.values():\n            ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n            summary += ap_summary + \"\\n\"\n        return summary\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.__init__","title":"<code>__init__(apertures, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), name='CompoundAperture')</code>","text":"<p>Constructor for the CompoundAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CompoundAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer,\n             apertures   : list,\n             centre      : Array = np.array([0., 0.]), \n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             name        : str   = \"CompoundAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the CompoundAperture class.\n\n    Parameters\n    ----------\n    apertures: list[Aperture]\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    name: str = 'CompoundAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    # Check for more than one aberration\n    naberrated = 0\n    for aperture in apertures:\n        if isinstance(aperture, CompositeAperture):\n            raise ValueError(\"CompositeApertures cannot be nested. To \" +\\\n                \"combine multiple CompositeApertures, use MultiAperture.\")\n        if isinstance(aperture, AberratedAperture):\n            naberrated += 1\n    if naberrated &gt; 1:\n        raise ValueError(\"CompoundAperture can only have one \" + \\\n                         \"AberratedAperture.\")\n\n    super().__init__(apertures,\n                     centre = centre,\n                     shear = shear,\n                     compression = compression,\n                     rotation = rotation,\n                     name = name)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    summary = (\"Applies a Compound Aperture with the following \"\n               \"sub-apertures: \\n\")\n    for ap in self.apertures.values():\n        ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n        summary += ap_summary + \"\\n\"\n    return summary\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.CompoundAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture.__init__","title":"<code>__init__(apertures, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), name='MultiAperture')</code>","text":"<p>Constructor for the MultiAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'MultiAperture'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self        : ApertureLayer,\n             apertures   : list,\n             centre      : Array = np.array([0., 0.]), \n             shear       : Array = np.array([0., 0.]),\n             compression : Array = np.array([1., 1.]),\n             rotation    : Array = np.array(0.),\n             name        : str   = \"MultiAperture\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the MultiAperture class.\n\n    Parameters\n    ----------\n    apertures: list[Aperture]\n        The sub-apertures that make up the full aperture.\n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    name: str = 'MultiAperture'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(apertures,\n                     centre = centre,\n                     shear = shear,\n                     compression = compression,\n                     rotation = rotation,\n                     name = name)\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    summary = (\"Applies a Multi Aperture with the following \"\n               \"sub-apertures: \\n\")\n    for ap in self.apertures.values():\n        ap_summary = ap.summary(angular_units, cartesian_units, sigfigs)\n        summary += ap_summary + \"\\n\"\n    return summary\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.MultiAperture.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#spiders","title":"Spiders","text":"<p>The spiders class are just a specific parametrisation of rectangular apertures for simplicity.</p> Uniform Spider API <p>         Bases: <code>Spider</code></p> <p>A set of spider struts with equally-spaced, equal-width struts.</p> <p>Attributes:</p> Name Type Description <code>nstruts</code> <code>int</code> <p>The number of spider struts.</p> <code>strut_width</code> <code>Array, meters</code> <p>The width of each strut. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/apertures.py</code> <pre><code>class UniformSpider(Spider):\n\"\"\"\n    A set of spider struts with equally-spaced, equal-width struts.\n\n    Attributes\n    ----------\n    nstruts: int \n        The number of spider struts.\n    strut_width: Array, meters\n        The width of each strut. \n    centre: Array, meters\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array\n        The (x, y) linear shear of the aperutre.\n    compression: Array \n        The (x, y) compression of the aperture. \n    rotation: Array, radians\n        The clockwise rotation of the aperture.\n    softening: Array, pixels\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    nstruts     : int\n    strut_width : Array\n\n\n    def __init__(self         : ApertureLayer, \n                 nstruts      : int,\n                 strut_width  : Array,\n                 centre       : Array = np.array([0., 0.]), \n                 shear        : Array = np.array([0., 0.]),\n                 compression  : Array = np.array([1., 1.]),\n                 rotation     : Array = np.array(0.),\n                 softening    : Array = np.array(1.),\n                 name         : str   = \"UniformSpider\") -&gt; ApertureLayer:\n\"\"\"\n        Constructor for the UniformSpider class.\n\n        Parameters\n        ----------\n        nstruts: int \n            The number of struts to equally space around the circle. This is not \n            a differentiable parameter. \n        strut_width: Array, meters\n            The width of each strut. \n        centre: Array, meters = np.array([0., 0.])\n            The (x, y) coordinates of the centre of the aperture.\n        shear: Array = np.array([0., 0.])\n            The (x, y) linear shear of the aperutre.\n        compression: Array  = np.array([1., 1.]) \n            The (x, y) compression of the aperture. \n        rotation: Array, radians = np.array(0.)\n            The clockwise rotation of the aperture.\n        softening: Array, pixels = np.array(1.)\n            The approximate pixel width of the soft boundary applied to the \n            aperture. Hard edges can be achieved by setting the softening to 0.\n        name: str = 'UniformSpider'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\" \n        super().__init__(centre = centre, \n                         shear = shear, \n                         compression = compression,\n                         rotation = rotation,\n                         softening = softening,\n                         name = name)\n\n        self.nstruts = int(nstruts)\n        self.strut_width = np.asarray(strut_width).astype(float)\n\n        dLux.exceptions.validate_eq_attr_dims(\n            (), self.strut_width.shape, \"Width_of_struts\")\n\n\n    def _stacked_struts(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calculates an array of individual struts comprising the full spider \n        aperture on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinate system to calculate the struts on.\n\n        Returns\n        -------\n        struts: Array\n            The array of all the individual struts.\n        \"\"\"\n        coordinates = self._coordinates(coordinates)\n        angles = np.linspace(0, two_pi, self.nstruts, endpoint=False)\n        angles += self.rotation\n        return vmap(self._strut, in_axes=(0, None))(angles, coordinates) \n\n\n    def _soft_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the soft edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The softed edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) - self.strut_width / 2.\n        softened = self._soften(struts)\n        return softened.prod(axis=0)\n\n\n    def _hard_edged(self : ApertureLayer, coordinates : Array) -&gt; Array:\n\"\"\"\n        Calcualtes the hard edged aperture shape on the input coordinates.\n\n        Parameters\n        ----------\n        coordinates: Array, meters\n            The coordinates to calculate the aperture shape on.\n\n        Returns\n        -------\n        aperture: Array\n            The hard edged aperture shape.\n        \"\"\"\n        struts = self._stacked_struts(coordinates) &gt; self.strut_width / 2. \n        return struts.prod(axis=0)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        width = convert_cartesian(self.strut_width, 'meters', cartesian_units)\n        center = convert_cartesian(self.center, 'meters', cartesian_units)\n        rotation = convert_angular(self.rotation, 'radians', angular_units)\n\n        summary = (f\"Applies a {self.nstrut} strut spider with widths {width} \"\n                   f\"{cartesian_units}\")\n\n        if self.softening != np.array(0):\n            summary += f\" softened by ~{self.softening} pixels\"\n        if self.center != np.array([0., 0.]):\n            summary += f\" centred at {center}\"\n        if self.rotation != np.array(0.):\n            summary += f\" rotated by {rotation} {angular_units}\"\n        if self.shear != np.array([0., 0.]):\n            summary += f\" sheared by {self.shear}\"\n        if self.compression != np.array([1., 1.]):\n            summary += f\" compressed by {self.compression}\"\n        return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.UniformSpider.__init__","title":"<code>__init__(nstruts, strut_width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), softening=np.array(1.0), name='UniformSpider')</code>","text":"<p>Constructor for the UniformSpider class.</p> <p>Parameters:</p> Name Type Description Default <code>nstruts</code> <code>int</code> <p>The number of struts to equally space around the circle. This is not  a differentiable parameter.</p> required <code>strut_width</code> <code>Array</code> <p>The width of each strut.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'UniformSpider'</code> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self         : ApertureLayer, \n             nstruts      : int,\n             strut_width  : Array,\n             centre       : Array = np.array([0., 0.]), \n             shear        : Array = np.array([0., 0.]),\n             compression  : Array = np.array([1., 1.]),\n             rotation     : Array = np.array(0.),\n             softening    : Array = np.array(1.),\n             name         : str   = \"UniformSpider\") -&gt; ApertureLayer:\n\"\"\"\n    Constructor for the UniformSpider class.\n\n    Parameters\n    ----------\n    nstruts: int \n        The number of struts to equally space around the circle. This is not \n        a differentiable parameter. \n    strut_width: Array, meters\n        The width of each strut. \n    centre: Array, meters = np.array([0., 0.])\n        The (x, y) coordinates of the centre of the aperture.\n    shear: Array = np.array([0., 0.])\n        The (x, y) linear shear of the aperutre.\n    compression: Array  = np.array([1., 1.]) \n        The (x, y) compression of the aperture. \n    rotation: Array, radians = np.array(0.)\n        The clockwise rotation of the aperture.\n    softening: Array, pixels = np.array(1.)\n        The approximate pixel width of the soft boundary applied to the \n        aperture. Hard edges can be achieved by setting the softening to 0.\n    name: str = 'UniformSpider'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\" \n    super().__init__(centre = centre, \n                     shear = shear, \n                     compression = compression,\n                     rotation = rotation,\n                     softening = softening,\n                     name = name)\n\n    self.nstruts = int(nstruts)\n    self.strut_width = np.asarray(strut_width).astype(float)\n\n    dLux.exceptions.validate_eq_attr_dims(\n        (), self.strut_width.shape, \"Width_of_struts\")\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.UniformSpider.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    width = convert_cartesian(self.strut_width, 'meters', cartesian_units)\n    center = convert_cartesian(self.center, 'meters', cartesian_units)\n    rotation = convert_angular(self.rotation, 'radians', angular_units)\n\n    summary = (f\"Applies a {self.nstrut} strut spider with widths {width} \"\n               f\"{cartesian_units}\")\n\n    if self.softening != np.array(0):\n        summary += f\" softened by ~{self.softening} pixels\"\n    if self.center != np.array([0., 0.]):\n        summary += f\" centred at {center}\"\n    if self.rotation != np.array(0.):\n        summary += f\" rotated by {rotation} {angular_units}\"\n    if self.shear != np.array([0., 0.]):\n        summary += f\" sheared by {self.shear}\"\n    if self.compression != np.array([1., 1.]):\n        summary += f\" compressed by {self.compression}\"\n    return summary + \".\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.UniformSpider","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.UniformSpider.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.UniformSpider.summary","title":"Apertures","text":""},{"location":"docs/API/apertures/#usage-and-examples","title":"Usage and Examples","text":"<p>Now let's write some code. We can create a basic circular aperture at the centre of the coordinate system with a 1m radius like so:</p> <pre><code>import dLux as dl\n\napertures = [\n    dl.CircularAperture(1.),\n    dl.CircularAperture(1., centre=[.5, .5]),\n    dl.CircularAperture(1., shear=[.05, .05]),\n    dl.CircularAperture(1., compression=[1.05, .95]),\n    dl.CircularAperture(1., softening=20),\n    dl.CircularAperture(1., occulting=True)\n]\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(30, 4))\nfor i in range(len(apertures)):\n    plt.subplot(1, 6, i+1)\n    plt.imshow(apertures[i].get_aperture(256, 2))\nplt.tight_layout()\nplt.savefig(\"assets/apertures.png\")\n</code></pre> <p></p>"},{"location":"docs/API/apertures/#aperture-factory","title":"Aperture Factory","text":"<p>Most users will not need to use the dynamic apertures, so the <code>ApertureFactory</code> class is designed to provide a simple interface to generate the most common apertures. It is able to construct hard-edged circular or regular poygonal apertures. Secondary mirrors obscurations with the same aperture shape can be constructed, along with uniformly spaced struts. Aberrations can also be applied to the aperture. The ratio of the primary aperture opening to the array size is determined by the aperture_ratio parameter, with secondary mirror obscurations and struts being scaled relative to the aperture diameter.</p> Aperture Factory API <p>This class is not actually ever instatiated, but is rather a class used to  give a simple constructor interface that is used to construct the most commonly used apertures. It is able to construct hard-edged circular or  regular poygonalal apertures. Secondary mirrors obscurations with the same aperture shape can be constructed, along with uniformly spaced struts.  Aberrations can also be applied to the aperture. The ratio of the primary aperture opening to the array size is determined by the <code>aperture_ratio</code> parameter, with secondary mirror obscurations and struts being scaled relative to the aperture diameter. </p> <p>Lets look at an example of how to construct a simple circular aperture with a secondary mirror obscurtion held by 4 struts and some low-order  aberrations. For this example lets take a 2m diameter aperutre, with a 20cm  secondary mirror held by 3 struts with a width of 2cm. In this example the secondary mirror is 10% of the primary aperture diameter and the struts are 1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for the <code>secondary_ratio</code> and <code>strut_ratio</code> parameters. Let calcualte this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>from dLux import SimpleAperture\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nzernikes = np.arange(4, 11)\ncoefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n# Construct aperture\naperture = SimpleAperture(512, secondary_ratio=0.1, nstruts=4, \n                          strut_ratio=0.01, zernikes=zernikes, \n                          coefficients=coefficients)\n</code></pre> <p>The resulting aperture class has three parameters, <code>.aperture</code>, <code>.basis</code> and <code>.coefficients</code>. We can examine the aperture and opd like so:</p> <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.aperture)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(aperture.opd)\nplt.colorbar()\nplt.show()\n</code></pre> <p>We can also easily change this to a hexagonal aperture with 3 struts:</p> <pre><code># Make aperture\naperture = SimpleAperture(512, nsides=6, secondary_ratio=0.1, nstruts=3, \n                          strut_ratio=0.01, zernikes=zernikes, \n                          coefficients=coefficients)\n\n# Examine\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.aperture)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(aperture.opd)\nplt.colorbar()\nplt.show()\n</code></pre> Source code in <code>dLux/apertures.py</code> <pre><code>class ApertureFactory():\n\"\"\"\n    This class is not actually ever instatiated, but is rather a class used to \n    give a simple constructor interface that is used to construct the most\n    commonly used apertures. It is able to construct hard-edged circular or \n    regular poygonalal apertures. Secondary mirrors obscurations with the same\n    aperture shape can be constructed, along with uniformly spaced struts. \n    Aberrations can also be applied to the aperture. The ratio of the primary\n    aperture opening to the array size is determined by the `aperture_ratio`\n    parameter, with secondary mirror obscurations and struts being scaled\n    relative to the aperture diameter. \n\n    Lets look at an example of how to construct a simple circular aperture with\n    a secondary mirror obscurtion held by 4 struts and some low-order \n    aberrations. For this example lets take a 2m diameter aperutre, with a 20cm \n    secondary mirror held by 3 struts with a width of 2cm. In this example the\n    secondary mirror is 10% of the primary aperture diameter and the struts are\n    1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for\n    the `secondary_ratio` and `strut_ratio` parameters. Let calcualte this for\n    a 512x512 array with the aperture spanning the full array.\n\n    ```python\n    from dLux import SimpleAperture\n    import jax.numpy as np\n    import jax.random as jr\n\n    # Construct Zernikes\n    zernikes = np.arange(4, 11)\n    coefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n    # Construct aperture\n    aperture = SimpleAperture(512, secondary_ratio=0.1, nstruts=4, \n                              strut_ratio=0.01, zernikes=zernikes, \n                              coefficients=coefficients)\n    ```\n\n    The resulting aperture class has three parameters, `.aperture`, `.basis`\n    and `.coefficients`. We can examine the aperture and opd like so:\n\n    ```python\n    import matplotlib.pyplot as plt\n\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.aperture)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(aperture.opd)\n    plt.colorbar()\n    plt.show()\n    ```\n\n    We can also easily change this to a hexagonal aperture with 3 struts:\n\n    ```python\n    # Make aperture\n    aperture = SimpleAperture(512, nsides=6, secondary_ratio=0.1, nstruts=3, \n                              strut_ratio=0.01, zernikes=zernikes, \n                              coefficients=coefficients)\n\n    # Examine\n    plt.figure(figsize=(10, 5))\n    plt.subplot(1, 2, 1)\n    plt.imshow(aperture.aperture)\n    plt.colorbar()\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(aperture.opd)\n    plt.colorbar()\n    plt.show()\n    ```\n    \"\"\"\n    def __new__(cls              : ApertureFactory, \n                npixels          : int, \n                nsides           : int   = 0,\n                rotation         : float = 0., \n\n                # Sizing\n                aperture_ratio   : float = 1.0,\n                secondary_ratio  : float = 0.,\n                secondary_nsides : int = 0,\n\n                # Spiders\n                nstruts          : int   = 0,\n                strut_ratio      : float = 0.,\n                strut_rotation   : float = 0.,\n\n                # Aberrations\n                zernikes         : Array = None, \n                coefficients     : Array = None, \n\n                # name\n                name             : str = None):\n\"\"\"\n        Constructs a basic single static aperture, either with or without \n        aberrations.\n\n        TODO: Add link to the zenike noll indicies\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperture_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        secondary_ratio : float = 0.\n            The ratio of the secondary mirror obsuration diameter to the \n            aperture diameter. A value of 0. results in no secondary mirror \n            obsuration.\n        secondary_nsides : int = 0\n            The number of sides of the secondary mirror obsuration. A zero input\n            results in a circular aperture. All other other values of three and \n            above are supported.\n        nstruts : int = 0\n            The number of uniformly spaced struts holding the secondary mirror. \n        strut_ratio : float = 0.\n            The ratio of the width of the strut to the aperture diameter.\n        strut_rotation : float = 0\n            The rotation of the struts in radians.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n\n        Returns\n        -------\n        aperture : Union[StaticAperture, StaticAberratedAperture]\n            Returns an appropriately constructed StaticAperture or \n            StaticAberratedAperture, depending on if zernikes are provided.\n        \"\"\"\n        # Check vaid inputs\n        if nsides &lt; 3 and nsides != 0:\n            raise ValueError(\"nsides must be either 0 or &gt;=3\")\n\n        if secondary_nsides &lt; 3 and secondary_nsides != 0:\n            raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")\n\n        if aperture_ratio &lt;= 0:\n            raise ValueError(\"aperture_ratio must be &gt; 0\")\n\n        if secondary_ratio &lt; 0:\n            raise ValueError(\"secondary_ratio must be &gt;= 0\")\n\n        if strut_ratio &lt; 0:\n            raise ValueError(\"strut_ratio must be &gt;= 0\")\n\n\n        # Auto-name\n        if name is None:\n            if nsides &gt; 8:\n                raise ValueError(\"Warning: Auto-naming not supported for \" + \\\n                \"nsides &gt; 8. Please provide a name.\")\n            sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\", \n                \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]\n            name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"\n\n\n        # Construct components\n        apertures = []\n\n        # Circular Primary\n        if nsides == 0:\n            apertures.append(CircularAperture(aperture_ratio/2, softening=0))\n        # Polygonal Primary\n        else: \n            apertures.append(RegularPolygonalAperture(\n                nsides, aperture_ratio/2, softening=0, rotation=rotation))\n\n        # Secondary\n        if secondary_ratio != 0:\n            secondary_rel = aperture_ratio * secondary_ratio\n\n            # Circular\n            if secondary_nsides == 0: \n                apertures.append(CircularAperture(\n                    secondary_rel/2, softening=0, occulting=True))\n            # Polygonal\n            else: \n                apertures.append(RegularPolygonalAperture(secondary_nsides, \n                    secondary_rel/2, softening=0, rotation=rotation, \n                        occulting=True))\n\n        # Spiders\n        if nstruts &gt; 0:\n            if strut_ratio == 0:\n                raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")\n            strut_rel = aperture_ratio * strut_ratio\n            full_rotation = strut_rotation + rotation\n            apertures.append(UniformSpider(\n                nstruts, strut_rel, rotation=full_rotation, softening=0))\n\n\n        # Add aberrations and make static\n        if zernikes is not None:\n            # Construct Aberrations\n            apertures[0] = AberratedAperture(apertures[0], zernikes, \n                                                coefficients)\n\n            # Construct CompoundAperture\n            full_aperture = CompoundAperture(apertures)\n            static = StaticAberratedAperture(full_aperture, npixels, 1, \n                                                name=name)\n        else:\n            # Construct CompoundAperture\n            full_aperture = CompoundAperture(apertures)\n            static = StaticAperture(full_aperture, npixels, 1, name=name)\n\n        return static\n\n\n    def __init__(self             : ApertureFactory, \n                 npixels          : int, \n                 nsides           : int   = 0,\n                 rotation         : float = 0., \n\n                 # Sizing\n                 aperture_ratio   : float = 1.0,\n                 secondary_ratio  : float = 0.,\n                 secondary_nsides : int = 0,\n\n                 # Spiders\n                 nstruts          : int   = 0,\n                 strut_ratio      : float = 0.,\n                 strut_rotation   : float = 0.,\n\n                 # Aberrations\n                 zernikes         : Array = None, \n                 coefficients     : Array = None, \n\n                 # name\n                 name             : str = None):\n\"\"\"\n        Constructs a basic single static aperture, either with or without \n        aberrations.\n\n        Parameters\n        ----------\n        npixels : int\n            Number of pixels used to represent the aperture.\n        nsides : int = 0\n            Number of sides of the aperture. A zero input results in a circular\n            aperture. All other other values of three and above are supported.\n        rotation : float, radians = 0\n            The global rotation of the aperture in radians.\n        aperture_ratio : float = 1.\n            The ratio of the aperture size to the array size. A value of 1. \n            results in an aperture that fully spans the array, a value of 0.5 \n            retuls in an aperure that is half the size of the array, which is \n            equivilent to a padding factor of 2.\n        secondary_ratio : float = 0.\n            The ratio of the secondary mirror obsuration diameter to the \n            aperture diameter. A value of 0. results in no secondary mirror \n            obsuration.\n        nstruts : int = 0\n            The number of uniformly spaced struts holding the secondary mirror. \n        strut_ratio : float = 0.\n            The ratio of the width of the strut to the aperture diameter.\n        strut_rotation : float = 0\n            The rotation of the struts in radians.\n        zernikes : Array = None\n            The zernike noll indices to be used for the aberrations. Please \n            refer to (this)[Add this link] docstring to see which indicides \n            correspond to which aberrations. Typical values are range(4, 11).\n        coefficients : Array = None\n            The zernike cofficients to be applied to the aberrations. Defaults \n            to an array of zeros.\n        name : str = None\n            The name of the aperture used to index the layers dictionary. If \n            not supplied, the aperture will be named based on the number of\n            sides. However this is only supported up to 8 sides, and a name\n            must be supplied for apertures with more than 8 sides.\n\n        Returns\n        -------\n        aperture : Union[StaticAperture, StaticAberratedAperture]\n            Returns an appropriately constructed StaticAperture or \n            StaticAberratedAperture, depending on if zernikes are provided.\n        \"\"\"\n</code></pre> <p>Lets look at an example of how to construct a simple circular aperture with a secondary mirror obscurtion held by 4 struts and some low-order aberrations. For this example lets take a 2m diameter aperutre, with a 20cm secondary mirror held by 3 struts with a width of 2cm. In this example the secondary mirror is 10% of the primary aperture diameter and the struts are 1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for the secondary_ratio and strut_ratio parameters. Let calcualte this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>import dLux as dl\nfrom jax import numpy as np, random as jr\n\n# Construct Zernikes\nzernikes = np.arange(4, 11)\ncoefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n# Construct aperture\naperture = dl.ApertureFactory(\n    npixels         = 512,\n    secondary_ratio = 0.1, \n    nstruts         = 4, \n    strut_ratio     = 0.01, \n    zernikes        = zernikes, \n    coefficients    = coefficients,\n    name            = 'Aperture')\n\nprint(aperture)\n</code></pre> <pre><code>&gt; StaticAberratedAperture(\n&gt;   name='Aperture',\n&gt;   aperture=f32[512,512],\n&gt;   coefficients=f32[7],\n&gt;   basis=f32[7,512,512]\n&gt; )\n</code></pre> <p>As we can see the resulting aperture class has three parameters, <code>aperture</code>, <code>basis</code> and <code>coefficients</code>. Lets have a look at the resulting aperture and aberrations.</p> Plotting code <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.aperture)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(aperture.opd)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/aperture_factory.png\")\n</code></pre> <p></p>"},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory.__init__","title":"<code>__init__(npixels, nsides=0, rotation=0.0, aperture_ratio=1.0, secondary_ratio=0.0, secondary_nsides=0, nstruts=0, strut_ratio=0.0, strut_rotation=0.0, zernikes=None, coefficients=None, name=None)</code>","text":"<p>Constructs a basic single static aperture, either with or without  aberrations.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> <code>0</code> <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> <code>0.0</code> <code>aperture_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> <code>1.0</code> <code>secondary_ratio</code> <code>float</code> <p>The ratio of the secondary mirror obsuration diameter to the  aperture diameter. A value of 0. results in no secondary mirror  obsuration.</p> <code>0.0</code> <code>nstruts</code> <code>int</code> <p>The number of uniformly spaced struts holding the secondary mirror.</p> <code>0</code> <code>strut_ratio</code> <code>float</code> <p>The ratio of the width of the strut to the aperture diameter.</p> <code>0.0</code> <code>strut_rotation</code> <code>float</code> <p>The rotation of the struts in radians.</p> <code>0.0</code> <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> <code>None</code> <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>aperture</code> <code>Union[StaticAperture, StaticAberratedAperture]</code> <p>Returns an appropriately constructed StaticAperture or  StaticAberratedAperture, depending on if zernikes are provided.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def __init__(self             : ApertureFactory, \n             npixels          : int, \n             nsides           : int   = 0,\n             rotation         : float = 0., \n\n             # Sizing\n             aperture_ratio   : float = 1.0,\n             secondary_ratio  : float = 0.,\n             secondary_nsides : int = 0,\n\n             # Spiders\n             nstruts          : int   = 0,\n             strut_ratio      : float = 0.,\n             strut_rotation   : float = 0.,\n\n             # Aberrations\n             zernikes         : Array = None, \n             coefficients     : Array = None, \n\n             # name\n             name             : str = None):\n\"\"\"\n    Constructs a basic single static aperture, either with or without \n    aberrations.\n\n    Parameters\n    ----------\n    npixels : int\n        Number of pixels used to represent the aperture.\n    nsides : int = 0\n        Number of sides of the aperture. A zero input results in a circular\n        aperture. All other other values of three and above are supported.\n    rotation : float, radians = 0\n        The global rotation of the aperture in radians.\n    aperture_ratio : float = 1.\n        The ratio of the aperture size to the array size. A value of 1. \n        results in an aperture that fully spans the array, a value of 0.5 \n        retuls in an aperure that is half the size of the array, which is \n        equivilent to a padding factor of 2.\n    secondary_ratio : float = 0.\n        The ratio of the secondary mirror obsuration diameter to the \n        aperture diameter. A value of 0. results in no secondary mirror \n        obsuration.\n    nstruts : int = 0\n        The number of uniformly spaced struts holding the secondary mirror. \n    strut_ratio : float = 0.\n        The ratio of the width of the strut to the aperture diameter.\n    strut_rotation : float = 0\n        The rotation of the struts in radians.\n    zernikes : Array = None\n        The zernike noll indices to be used for the aberrations. Please \n        refer to (this)[Add this link] docstring to see which indicides \n        correspond to which aberrations. Typical values are range(4, 11).\n    coefficients : Array = None\n        The zernike cofficients to be applied to the aberrations. Defaults \n        to an array of zeros.\n    name : str = None\n        The name of the aperture used to index the layers dictionary. If \n        not supplied, the aperture will be named based on the number of\n        sides. However this is only supported up to 8 sides, and a name\n        must be supplied for apertures with more than 8 sides.\n\n    Returns\n    -------\n    aperture : Union[StaticAperture, StaticAberratedAperture]\n        Returns an appropriately constructed StaticAperture or \n        StaticAberratedAperture, depending on if zernikes are provided.\n    \"\"\"\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory.__new__","title":"<code>__new__(npixels, nsides=0, rotation=0.0, aperture_ratio=1.0, secondary_ratio=0.0, secondary_nsides=0, nstruts=0, strut_ratio=0.0, strut_rotation=0.0, zernikes=None, coefficients=None, name=None)</code>","text":"<p>Constructs a basic single static aperture, either with or without  aberrations.</p> <p>TODO: Add link to the zenike noll indicies</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> <code>0</code> <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> <code>0.0</code> <code>aperture_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> <code>1.0</code> <code>secondary_ratio</code> <code>float</code> <p>The ratio of the secondary mirror obsuration diameter to the  aperture diameter. A value of 0. results in no secondary mirror  obsuration.</p> <code>0.0</code> <code>secondary_nsides</code> <code>int</code> <p>The number of sides of the secondary mirror obsuration. A zero input results in a circular aperture. All other other values of three and  above are supported.</p> <code>0</code> <code>nstruts</code> <code>int</code> <p>The number of uniformly spaced struts holding the secondary mirror.</p> <code>0</code> <code>strut_ratio</code> <code>float</code> <p>The ratio of the width of the strut to the aperture diameter.</p> <code>0.0</code> <code>strut_rotation</code> <code>float</code> <p>The rotation of the struts in radians.</p> <code>0.0</code> <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> <code>None</code> <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>aperture</code> <code>Union[StaticAperture, StaticAberratedAperture]</code> <p>Returns an appropriately constructed StaticAperture or  StaticAberratedAperture, depending on if zernikes are provided.</p> Source code in <code>dLux/apertures.py</code> <pre><code>def __new__(cls              : ApertureFactory, \n            npixels          : int, \n            nsides           : int   = 0,\n            rotation         : float = 0., \n\n            # Sizing\n            aperture_ratio   : float = 1.0,\n            secondary_ratio  : float = 0.,\n            secondary_nsides : int = 0,\n\n            # Spiders\n            nstruts          : int   = 0,\n            strut_ratio      : float = 0.,\n            strut_rotation   : float = 0.,\n\n            # Aberrations\n            zernikes         : Array = None, \n            coefficients     : Array = None, \n\n            # name\n            name             : str = None):\n\"\"\"\n    Constructs a basic single static aperture, either with or without \n    aberrations.\n\n    TODO: Add link to the zenike noll indicies\n\n    Parameters\n    ----------\n    npixels : int\n        Number of pixels used to represent the aperture.\n    nsides : int = 0\n        Number of sides of the aperture. A zero input results in a circular\n        aperture. All other other values of three and above are supported.\n    rotation : float, radians = 0\n        The global rotation of the aperture in radians.\n    aperture_ratio : float = 1.\n        The ratio of the aperture size to the array size. A value of 1. \n        results in an aperture that fully spans the array, a value of 0.5 \n        retuls in an aperure that is half the size of the array, which is \n        equivilent to a padding factor of 2.\n    secondary_ratio : float = 0.\n        The ratio of the secondary mirror obsuration diameter to the \n        aperture diameter. A value of 0. results in no secondary mirror \n        obsuration.\n    secondary_nsides : int = 0\n        The number of sides of the secondary mirror obsuration. A zero input\n        results in a circular aperture. All other other values of three and \n        above are supported.\n    nstruts : int = 0\n        The number of uniformly spaced struts holding the secondary mirror. \n    strut_ratio : float = 0.\n        The ratio of the width of the strut to the aperture diameter.\n    strut_rotation : float = 0\n        The rotation of the struts in radians.\n    zernikes : Array = None\n        The zernike noll indices to be used for the aberrations. Please \n        refer to (this)[Add this link] docstring to see which indicides \n        correspond to which aberrations. Typical values are range(4, 11).\n    coefficients : Array = None\n        The zernike cofficients to be applied to the aberrations. Defaults \n        to an array of zeros.\n    name : str = None\n        The name of the aperture used to index the layers dictionary. If \n        not supplied, the aperture will be named based on the number of\n        sides. However this is only supported up to 8 sides, and a name\n        must be supplied for apertures with more than 8 sides.\n\n    Returns\n    -------\n    aperture : Union[StaticAperture, StaticAberratedAperture]\n        Returns an appropriately constructed StaticAperture or \n        StaticAberratedAperture, depending on if zernikes are provided.\n    \"\"\"\n    # Check vaid inputs\n    if nsides &lt; 3 and nsides != 0:\n        raise ValueError(\"nsides must be either 0 or &gt;=3\")\n\n    if secondary_nsides &lt; 3 and secondary_nsides != 0:\n        raise ValueError(\"secondary_nsides must be either 0 or &gt;=3\")\n\n    if aperture_ratio &lt;= 0:\n        raise ValueError(\"aperture_ratio must be &gt; 0\")\n\n    if secondary_ratio &lt; 0:\n        raise ValueError(\"secondary_ratio must be &gt;= 0\")\n\n    if strut_ratio &lt; 0:\n        raise ValueError(\"strut_ratio must be &gt;= 0\")\n\n\n    # Auto-name\n    if name is None:\n        if nsides &gt; 8:\n            raise ValueError(\"Warning: Auto-naming not supported for \" + \\\n            \"nsides &gt; 8. Please provide a name.\")\n        sides = [\"Circular\", \"Triangular\", \"Square\", \"Pentagonal\", \n            \"Hexagonal\", \"Heptagonal\", \"Octagonal\"]\n        name = sides[np.maximum(nsides-2, 0)] + \"Aperture\"\n\n\n    # Construct components\n    apertures = []\n\n    # Circular Primary\n    if nsides == 0:\n        apertures.append(CircularAperture(aperture_ratio/2, softening=0))\n    # Polygonal Primary\n    else: \n        apertures.append(RegularPolygonalAperture(\n            nsides, aperture_ratio/2, softening=0, rotation=rotation))\n\n    # Secondary\n    if secondary_ratio != 0:\n        secondary_rel = aperture_ratio * secondary_ratio\n\n        # Circular\n        if secondary_nsides == 0: \n            apertures.append(CircularAperture(\n                secondary_rel/2, softening=0, occulting=True))\n        # Polygonal\n        else: \n            apertures.append(RegularPolygonalAperture(secondary_nsides, \n                secondary_rel/2, softening=0, rotation=rotation, \n                    occulting=True))\n\n    # Spiders\n    if nstruts &gt; 0:\n        if strut_ratio == 0:\n            raise ValueError(\"strut_ratio must be &gt; 0 if nstruts &gt; 0\")\n        strut_rel = aperture_ratio * strut_ratio\n        full_rotation = strut_rotation + rotation\n        apertures.append(UniformSpider(\n            nstruts, strut_rel, rotation=full_rotation, softening=0))\n\n\n    # Add aberrations and make static\n    if zernikes is not None:\n        # Construct Aberrations\n        apertures[0] = AberratedAperture(apertures[0], zernikes, \n                                            coefficients)\n\n        # Construct CompoundAperture\n        full_aperture = CompoundAperture(apertures)\n        static = StaticAberratedAperture(full_aperture, npixels, 1, \n                                            name=name)\n    else:\n        # Construct CompoundAperture\n        full_aperture = CompoundAperture(apertures)\n        static = StaticAperture(full_aperture, npixels, 1, name=name)\n\n    return static\n</code></pre>"},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory.__init__","title":"Apertures","text":""},{"location":"docs/API/apertures/#dLux.apertures.ApertureFactory.__new__","title":"Apertures","text":""},{"location":"docs/API/api/","title":"Overview","text":"<p>\u2202Lux has two modules, <code>dLux</code> and <code>dLux.utils</code>. The <code>dLux</code> repo contains the core functionality of \u2202Lux, while <code>dLux.utils</code> contains various functions that are used throughout the package.</p> <p>The <code>dLux</code> module is composed of 10 distint scripts:</p> <ul> <li><code>core.py</code></li> <li><code>optics.py</code></li> <li><code>apertures.py</code></li> <li><code>aberrations.py</code></li> <li><code>propagators.py</code></li> <li><code>wavefronts.py</code></li> <li><code>detectors.py</code></li> <li><code>sources.py</code></li> <li><code>spectrums.py</code></li> <li><code>observtions.py</code></li> </ul> <p>The <code>core.py</code> script contains the primarily classes that users will interact with and are generally populated with the rest of the classes in dLux. Most of these scripts contains one type of class, although a series of classes are related to each other. The core of dLux works by providing layers that modify the <code>Wavefront</code> class. Layers that modify the <code>Wavefront</code> class all inherit from the <code>OpticalLayer</code> class defined in the <code>optics.py</code> script, however all classes in <code>apertures.py</code>, <code>aberrations.py</code> and <code>propagators.py</code> inherit from the <code>OpticalLayer</code> class. All of the remaining classes are distinct from one another.</p> <p>Lets get an overview of the different classes in dLux:</p>"},{"location":"docs/API/api/#instrument","title":"Instrument:","text":"<p>Script: <code>core.py</code></p> <p>The <code>Instrument</code> class is the primary class that users will interact with. It is designed to hold all the other classes in dLux and automate their interactions. The <code>Instrument</code> class can hold the following classes:</p> <ul> <li><code>Optics</code></li> <li><code>Detector</code></li> <li><code>Source</code> (Not a core class)</li> <li><code>Observation</code> (Not a core class)</li> </ul> <p>Lets have a look at these different classes and what they do.</p>"},{"location":"docs/API/api/#optics","title":"Optics:","text":"<p>Script: <code>core.py</code></p> <p>The main diffraction engine is the <code>Optics</code> class, which only has a single attribute <code>layers</code>. This attribute is stored as an <code>OrderedDict</code> and holds all the layers that modify the <code>Wavefront</code> class that all inherit from the <code>OpticalLayer</code> class which will be detailed later. While the <code>Optics</code> class is fully functional on its own, in general it is interacted with through the <code>Instrument</code> class.</p>"},{"location":"docs/API/api/#detector","title":"Detector:","text":"<p>Script: <code>core.py</code></p> <p>The <code>Detector</code> class mirrors the <code>Optics</code> class in that it only has a single attribute <code>layers</code> which is an <code>OrderedDict</code>. The layers arributes stores all classes that inherit from the <code>DetectorLayer</code> class which perform transformation on PSF's. </p>"},{"location":"docs/API/api/#observations","title":"Observations:","text":"<p>Script: <code>oberservations.py</code></p> <p>The <code>Observation</code> class is designed to allow for fine-grained control over the modelling of the <code>Instrument</code> class. An example of this is to allow for dithering patterns modelled, or for observing a series of different sources independently.</p>"},{"location":"docs/API/api/#wavefront-classes","title":"Wavefront classes:","text":"<p>Script: <code>wavefronts.py</code></p> <p>The <code>Wavefront</code> class represents a physical wavefront which is transformed and propagated through the <code>Optics</code> class. This class is generally not needed to be interacted with directly, unless you are creating a new <code>OpticalLayer</code> class. This class provides a wide range of methods that can perform calculations and transformations of the parameters of the wavefront.</p>"},{"location":"docs/API/api/#optical-layers","title":"Optical Layers:","text":"<p>Scripts:</p> <ul> <li><code>optics.py</code></li> <li><code>apertures.py</code></li> <li><code>aberrations.py</code></li> <li><code>propagators.py</code></li> </ul> <p>All layers that operate on the <code>Wavefront</code> class are known as <code>OpticalLayers</code>. Becuase there are many different operations that can be performed on the <code>Wavefront</code> class they are split up into four different scripts.</p> <p>The <code>optics.py</code> class contains the main layers used to operate on the wavefront. They provide general classes used to create wavefronts, add phases and OPDs, titls, rotations etc. The <code>apertures.py</code> script is a module designed to generate most apertures that will be needed in a dynamic and differentiable way. The <code>aberrations.py</code> script contains classes that can be used to add aberrations (presently only Zernike aberrations) to the wavefront. The <code>propagators.py</code> script contains the classes that transform <code>Wavefronts</code> to and from pupil and focal planes.</p>"},{"location":"docs/API/api/#sources","title":"Sources:","text":"<p>Scripts:</p> <ul> <li><code>sources.py</code></li> <li><code>spectrums.py</code></li> </ul> <p>The source classes are designed to provide parameterisations of light sources. Currently they are geared towards astronomical sources, however they can be used for other sources as well. The <code>Source</code> classes primarily control positions, fluxes and any resolved components. They require a <code>Spectrum</code> class which provides different way to parametrise the source spectrum.</p> <p>All of these classes can be explored in more detail in the API documentation.</p>"},{"location":"docs/API/bayes/","title":"Bayesian Utility Functions","text":"<p>This module contains a few likelihood functions. plus functions to calcualte things like covariance matrices and its entropy. This module is likely to be moved in the base package of dLux, Zodiax.</p> <p>These functions have an unusual syntax becuase they are designed for calculating Fisher Matrices. To get an idea of how to use them please refer to the Fisher Matrix Tutorial. Later these docs will be expanded with specific examples.</p>"},{"location":"docs/API/bayes/#poisson-likelihood","title":"Poisson Likelihood","text":"<p>Calculates the Poisson likelihood after updating some model with the <code>update_fn</code> and calling the <code>model_fn</code>.</p> Poisson Likelihood API <p>Calculates the poissonion likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The poissonian likelihood of the updated model with respect to the data.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def poisson_likelihood(X         : Array,\n                       data      : Array,\n                       model     : object,\n                       update_fn : Callable,\n                       model_fn  : str,\n                       *args,\n                       **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the poissonion likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The poissonian likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(poisson.pmf(data, psf))\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.poisson_likelihood","title":"Bayes","text":""},{"location":"docs/API/bayes/#poisson-log-likelihood","title":"Poisson Log Likelihood","text":"<p>Calculates the Poisson log likelihood after updating some model with the <code>update_fn</code> and calling the <code>model_fn</code>.</p> Poisson Log Likelihood API <p>Calculates the poissonion log likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The poissonian log likelihood of the updated model with respect to the data.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def poisson_log_likelihood(X         : Array,\n                           data      : Array,\n                           model     : object,\n                           update_fn : Callable,\n                           model_fn  : str,\n                           *args,\n                           **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the poissonion log likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The poissonian log likelihood of the updated model with respect to the\n        data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(poisson.logpmf(data, psf))\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.poisson_log_likelihood","title":"Bayes","text":""},{"location":"docs/API/bayes/#chi2-likelihood","title":"Chi2 Likelihood","text":"<p>Calculates the Chi2 likelihood after updating some model with the <code>update_fn</code> and calling the <code>model_fn</code>.</p> Chi2 Likelihood API <p>Calculates the chi2 likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The chi2 likelihood of the updated model with respect to the data.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def chi2_likelihood(X         : Array,\n                    data      : Array,\n                    model     : object,\n                    update_fn : Callable,\n                    model_fn  : str,\n                    *args,\n                    **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the chi2 likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The chi2 likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.sum(np.square((psf-data)/noise))\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.chi2_likelihood","title":"Bayes","text":""},{"location":"docs/API/bayes/#chi2-log-likelihood","title":"Chi2 Log Likelihood","text":"<p>Calculates the Chi2 log likelihood after updating some model with the <code>update_fn</code> and calling the <code>model_fn</code>.</p> Chi2 Log Likelihood API <p>Calculates the chi2 log likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The chi2 log likelihood of the updated model with respect to the data.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def chi2_log_likelihood(X         : Array,\n                        data      : Array,\n                        model     : object,\n                        update_fn : Callable,\n                        model_fn  : str,\n                        *args,\n                        **kwargs) -&gt; Array:\n\"\"\"\n    Calculates the chi2 log likelihood after updating the model using the\n    update_fn. The extra *args and **kwargs are passed to the model function.\n\n    Parameters\n    ----------\n    X : Array\n        The array of values to update the model with.\n    data : Array\n        The data to calulcate the prior with respect to.\n    model : object\n        The model used to model the data.\n    update_fn : Callable\n        The function used to update the model before modelling. This should\n        take in the X array as the first argument and the model as the second.\n    model_fn : str\n        The name of the model function to use.\n\n    Returns\n    -------\n    likelhood : Array\n        The chi2 log likelihood of the updated model with respect to the data.\n    \"\"\"\n    model = update_fn(X, model)\n    psf = getattr(model, model_fn)(*args, **kwargs)\n    return np.log(np.sum(np.square((psf-data)/noise)))\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.chi2_log_likelihood","title":"Bayes","text":""},{"location":"docs/API/bayes/#calculate-covariance","title":"Calculate Covariance","text":"<p>Calcluates the covaraince matrix of some likelihood function.</p> Calculate Covariance API <p>Calcuates the covariance matrix under the Laplace approximation for the given likelihood function. The args and *kwargs are passed to the likelihood function.</p> <p>Parameters:</p> Name Type Description Default <code>likelihood_fn</code> <code>Callable</code> <p>The likelihood function to calculate the covaraince matrix with respect to.</p> required <p>Returns:</p> Name Type Description <code>covaraince</code> <code>Array</code> <p>The corresponding covariance matrix.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def calculate_covariance(likelihood_fn : Callable,\n                         *args,\n                         **kwargs) -&gt; Array:\n\"\"\"\n    Calcuates the covariance matrix under the Laplace approximation for the\n    given likelihood function. The *args and **kwargs are passed to the\n    likelihood function.\n\n    Parameters\n    ----------\n    likelihood_fn : Callable\n        The likelihood function to calculate the covaraince matrix with\n        respect to.\n\n    Returns\n    -------\n    covaraince : Array\n        The corresponding covariance matrix.\n    \"\"\"\n    matrix = hessian(likelihood_fn)(*args, **kwargs)\n    return -np.linalg.inv(matrix)\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.calculate_covariance","title":"Bayes","text":""},{"location":"docs/API/bayes/#calculate-entropy","title":"Calculate Entropy","text":"<p>Calculates the entropy of a covariance matrix.</p> Calculate Entropy API <p>Calcuates the entropy of the covaraince matrix under the Laplace approximation for the given likelihood function. The args and *kwargs are passed to through the calculate_covaraince function through to the likelihood function.</p> <p>Parameters:</p> Name Type Description Default <code>likelihood_fn</code> <code>Callable</code> <p>The likelihood function to calculate the entropy with respect to.</p> required <p>Returns:</p> Name Type Description <code>entropy</code> <code>Array</code> <p>The entropy of the covariance matrix for the given likelihood function.</p> Source code in <code>dLux/utils/bayes.py</code> <pre><code>def calculate_entropy(likelihood_fn : Callable,\n                      *args,\n                      **kwargs):\n\"\"\"\n    Calcuates the entropy of the covaraince matrix under the Laplace\n    approximation for the given likelihood function. The *args and **kwargs\n    are passed to through the calculate_covaraince function through to the\n    likelihood function.\n\n    Parameters\n    ----------\n    likelihood_fn : Callable\n        The likelihood function to calculate the entropy with respect to.\n\n    Returns\n    -------\n    entropy : Array\n        The entropy of the covariance matrix for the given likelihood function.\n    \"\"\"\n    cov = calculate_covariance(likelihood_fn, *args, **kwargs)\n    sign, logdet = np.linalg.slogdet(cov)\n    return 0.5 * (np.log(2 * np.pi * np.e) + (sign * logdet))\n</code></pre>"},{"location":"docs/API/bayes/#dLux.utils.bayes.calculate_entropy","title":"Bayes","text":""},{"location":"docs/API/coordinates/","title":"Coordinates Utility Functions","text":"<p>This module contains a series of functions that are used to calculate coordinates arrays, apply transformations to coordinate those arrays, and convert between cartesian and polar coordiantes.</p>"},{"location":"docs/API/coordinates/#get-pixel-positions","title":"Get Pixel Positions","text":"<p>This calculates the coordinates of pixel centers for an arbitrary number of dimensions, lengths and pixel scales. Each dimension can be shifted by an arbitrary amount using the <code>offset</code> parameter. 2D arrays can be output in polar coordinates by setting the <code>polar</code> flag.</p> Get Pixel Positions API <p>Calculates the positions of the pixel centers for the given input. All  coordinates are output in units of meters. </p> <p>The indexing argument is the same as in numpy.meshgrid., ie:  Giving the string \u2018ij\u2019 returns a meshgrid with  matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In  the 2-D case with inputs of length M and N, the outputs are of shape (N, M)  for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs  of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and  (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordainates,  indexing is set to 'xy' and the input must be 2d</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>Union[int, tuple]</code> <p>The number of pixels in each dimension.</p> required <code>pixel_scales</code> <code>Union[tuple, float, None]</code> <p>The pixel scales in each dimension. If a tuple, the length of the tuple must match the number of dimensions. If a float, the same scale is applied to all dimensions. If None, the scale is set to 1.</p> <code>None</code> <code>offsets</code> <code>Union[tuple, float, None]</code> <p>The offset of the pixel centers in each dimension. If a tuple, the  length of the tuple must match the number of dimensions. If a float,  the same offset is applied to all dimensions. If None, the offset is  set to 0.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If True, the output is in polar coordinates. If False, the output is in cartesian coordinates. Default is False.</p> <code>False</code> <code>indexing</code> <code>str</code> <p>The indexing of the output. Default is 'xy'. See numpy.meshgrid for more details.</p> <code>'xy'</code> <p>Returns:</p> Name Type Description <code>positions</code> <code>Array</code> <p>The positions of the pixel centers in the given dimensions.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def get_pixel_positions(npixels      : Union[int, tuple], \n                        pixel_scales : Union[tuple, float, None] = None,\n                        offsets      : Union[tuple, float, None] = None,\n                        polar        : bool = False,\n                        indexing     : str = 'xy') -&gt; Array:\n\"\"\"\n    Calculates the positions of the pixel centers for the given input. All \n    coordinates are output in units of meters. \n\n    The indexing argument is the same\n    as in numpy.meshgrid., ie:  Giving the string \u2018ij\u2019 returns a meshgrid with \n    matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In \n    the 2-D case with inputs of length M and N, the outputs are of shape (N, M) \n    for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs \n    of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and \n    (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordainates, \n    indexing is set to 'xy' and the input must be 2d\n\n    Parameters\n    ----------\n    npixels : Union[int, tuple]\n        The number of pixels in each dimension.\n    pixel_scales : Union[tuple, float, None] = None\n        The pixel scales in each dimension. If a tuple, the length\n        of the tuple must match the number of dimensions. If a float, the same\n        scale is applied to all dimensions. If None, the scale is set to 1.\n    offsets : Union[tuple, float, None] = None\n        The offset of the pixel centers in each dimension. If a tuple, the \n        length of the tuple must match the number of dimensions. If a float, \n        the same offset is applied to all dimensions. If None, the offset is \n        set to 0.\n    polar : bool = False\n        If True, the output is in polar coordinates. If False, the output is in\n        cartesian coordinates. Default is False.\n    indexing : str = 'xy'\n        The indexing of the output. Default is 'xy'. See numpy.meshgrid for more\n        details.\n\n    Returns\n    -------\n    positions : Array\n        The positions of the pixel centers in the given dimensions.\n    \"\"\"\n    if indexing not in ['xy', 'ij']:\n        raise ValueError(\"indexing must be either 'xy' or 'ij'.\")\n\n    if polar and indexing == 'ij':\n        indexing = 'xy'\n\n    # Turn inputs into tuples\n    if isinstance(npixels, int):\n        npixels = (npixels,)\n\n        if offsets is None:\n            offsets = (0.,)\n        elif not isinstance(offsets, (float, Array)):\n            raise ValueError(\"offset must be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            offsets = (offsets,)\n\n        if pixel_scales is None:\n            pixel_scales = (1.,)\n        elif not isinstance(pixel_scales, (float, Array)):\n            raise ValueError(\"pixel_scales must be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            pixel_scales = (pixel_scales,)\n\n    # Check input \n    else:\n        if offsets is None:\n            offsets = tuple([0.]*len(npixels))\n        elif not isinstance(offsets, tuple):\n            raise ValueError(\"offset must be an be a float or Array if npixels \"\n                             \"is an int.\")\n        else:\n            if len(offsets) != len(npixels):\n                raise ValueError(\"offset must have the same length as npixels.\")\n\n        if pixel_scales is None:\n            pixel_scales = tuple([1.]*len(npixels))\n        elif isinstance(pixel_scales, float):\n            pixel_scales = tuple([pixel_scales]*len(npixels))\n        elif not isinstance(pixel_scales, tuple):\n            raise ValueError(\"pixel_scales must be a tuple if npixels is a tuple.\")\n        else:\n            if len(pixel_scales) != len(npixels):\n                raise ValueError(\"pixel_scales must have the same length as npixels.\")\n\n    def pixel_fn(n, offset, scale):\n        pix = np.arange(n) - (n - 1) / 2.\n        pix *= scale\n        pix -= offset\n        return pix\n\n    pixels = tree_map(pixel_fn, npixels, offsets, pixel_scales)\n\n    # ouput (x, y) for 2d, else in order\n    positions = np.array(np.meshgrid(*pixels, indexing=indexing))\n\n    if polar:\n        if len(npixels) != 2:\n            raise ValueError(\"polar coordinates are only defined for 2D arrays.\")\n        return cartesian_to_polar(positions)\n\n    # Squeeze for empty axis removal with 1d\n    return np.squeeze(positions)\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.get_pixel_positions","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#polar-to-cartesian","title":"Polar to Cartesian","text":"<p>Converts a polar coordinate array to cartesian coordinates.</p> Polar to Cartesian API <p>Converts the input (r, phi) polar coordinates into (x, y) cartesian cordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (r, phi) polar coordinates to be converted into cartesian cordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input polar coordinates converted into (x, y) cartesian cordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def polar_to_cartesian(coordinates : Array) -&gt; Array:\n\"\"\"\n    Converts the input (r, phi) polar coordinates into (x, y) cartesian\n    cordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (r, phi) polar coordinates to be converted into cartesian\n        cordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input polar coordinates converted into (x, y) cartesian cordinates.\n    \"\"\"\n    r, phi = coordinates\n    return np.array([r*np.cos(phi), r*np.sin(phi)])\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.polar_to_cartesian","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#cartesian-to-polar","title":"Cartesian to Polar","text":"<p>Converts a cartesian coordinate array to polar coordinates.</p> Cartesian to Polar API <p>Converts the input (x, y) cartesian cordinates into (r, phi) polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (x, y) cartesian coordinates to be converted into polar cordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input cartesian coordinates converted into (r, phi) polar cordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def cartesian_to_polar(coordinates : Array) -&gt; Array:\n\"\"\"\n    Converts the input (x, y) cartesian cordinates into (r, phi) polar\n    coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array\n        The (x, y) cartesian coordinates to be converted into polar cordinates.\n\n    Returns\n    -------\n    coordinates : Array\n        The input cartesian coordinates converted into (r, phi) polar\n        cordinates.\n    \"\"\"\n    x, y = coordinates\n    return np.array([np.hypot(x, y), np.arctan2(y, x)])\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.cartesian_to_polar","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#translate","title":"Translate","text":"<p>Translates a coordinate array by a given amount.</p> Translate API <p>Move the center of the coordinate system by some  amount (centre). </p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the new centre  with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The translated coordinate system.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def translate(coordinates: Array, centre: Array) -&gt; Array:\n\"\"\"\n    Move the center of the coordinate system by some \n    amount (centre). \n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    centre : Array, meters\n        The (x, y) coordinates of the new centre \n        with dimensions (2,)\n\n    Returns\n    -------\n    coordinates: Array, meters\n        The translated coordinate system. \n    \"\"\"\n    return coordinates - centre[:, None, None]\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.translate","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#rotate","title":"Rotate","text":"<p>Rotates a coordinate array by a given amount.</p> Rotate API <p>Rotate the coordinate system by a pre-specified amount.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>A <code>(2, npix, npix)</code> representation of the coordinate  system. The leading dimensions specifies the x and then  the y coordinates in that order.</p> required <code>rotation</code> <code>Array, radians</code> <p>The counter-clockwise rotation to apply.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The rotated coordinate system.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def rotate(coordinates: Array, rotation: Array) -&gt; Array:\n\"\"\"\n    Rotate the coordinate system by a pre-specified amount.\n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        A `(2, npix, npix)` representation of the coordinate \n        system. The leading dimensions specifies the x and then \n        the y coordinates in that order. \n    rotation : Array, radians\n        The counter-clockwise rotation to apply.\n\n    Returns\n    -------\n    coordinates : Array, meters\n        The rotated coordinate system. \n    \"\"\"\n    x, y = coordinates[0], coordinates[1]\n    new_x = np.cos(-rotation) * x + np.sin(-rotation) * y\n    new_y = -np.sin(-rotation) * x + np.cos(-rotation) * y\n    return np.array([new_x, new_y])\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.rotate","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#compress","title":"Compress","text":"<p>Compresses a coordinate array by a given amount.</p> Compress API <p>Apply a compression to the coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>compression</code> <code>Array</code> <p>The (x, y) compression with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The compressed coordinates.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def compress(coordinates: Array, compression: Array) -&gt; Array:\n\"\"\"\n    Apply a compression to the coordinates.\n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    compression : Array\n        The (x, y) compression with dimensions (2,)\n\n    Returns\n    -------\n    coordinates : Array, meters\n        The compressed coordinates. \n    \"\"\"\n    return coordinates * compression[:, None, None]\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.compress","title":"Coordinates","text":""},{"location":"docs/API/coordinates/#shear","title":"Shear","text":"<p>Shears a coordinate array by a given amount.</p> Shear API <p>Apply a shear to the coordinate system. </p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>shear</code> <code>Array</code> <p>The (x, y) shear with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The sheared coordinate system.</p> Source code in <code>dLux/utils/coordinates.py</code> <pre><code>def shear(coordinates: Array, shear: Array) -&gt; Array:\n\"\"\"\n    Apply a shear to the coordinate system. \n\n    Parameters\n    ----------\n    coordinates : Array, meters\n        The (x, y) coordinates with the dimensions \n        (2, npix, npix).\n    shear : Array\n        The (x, y) shear with dimensions (2,)\n\n    Returns\n    -------\n    coordinates: Array, meters\n        The sheared coordinate system. \n    \"\"\"\n    trans_coordinates: Array = np.transpose(coordinates, (0, 2, 1))\n    return coordinates + trans_coordinates * shear[:, None, None]\n</code></pre>"},{"location":"docs/API/coordinates/#dLux.utils.coordinates.shear","title":"Coordinates","text":""},{"location":"docs/API/core/","title":"Core classes","text":"<p>The <code>core.py</code> class contains the core classes that users will interact with. These classes are designed to be modular and allow for the creation of complex instruments. The <code>core.py</code> script contains the following classes:</p> <ul> <li><code>Instrument</code></li> <li><code>Optics</code></li> <li><code>Detector</code></li> </ul> <p>Lets examine the <code>Optics</code> class first as it is the core diffraction engine of dLux.</p>"},{"location":"docs/API/core/#optics","title":"Optics","text":"<p>The <code>Optics</code> class is the core class that controls the diffraction of wavefronts. It has only a single attribute, <code>layers</code> which is stored as an ordered dictionary, but input as a list.</p> <p>Construction</p> <p>The <code>Optics</code> class only has a single input, <code>layers</code>. This is a list of <code>Layer</code> classes that will be applied to the wavefront in the order they are given. The layers input is taken as a list and automatically converted to an ordered dictionary, populating the dictionary with the <code>name</code> parameter of each layer as the key. If there are mulitple layers with the same name parameter, the names will be modified to \"original_name_0\", \"original_name_1\" etc.</p> <p>Here is how we would create a basic optics class:</p> <pre><code>import dLux as dl\n\nwf_npix = 256\ndet_npix = 128\naperture_diameter = 1.0\ndet_pixel_size = 1e-6\n\nlayers = [\n    dl.CreateWavefront(wf_npix, aperture_diameter),\n    dl.ApertureFactory(wf_npix, name=\"Aperture\"),\n    dl.NormaliseWavefront(),\n    dl.AngularMFT(det_npix, det_pixel_size, name=\"Propagator\")\n]\n\noptics = dl.Optics(layers)\n</code></pre> Constructor API <p>Constructor for the Optics class.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>A list of \u2202Lux 'layers' that define the transformations and operations upon some input wavefront through an optical system.</p> required Source code in <code>dLux/core.py</code> <pre><code>def __init__(self : Optics, layers : list) -&gt; Optics:\n\"\"\"\n    Constructor for the Optics class.\n\n    Parameters\n    ----------\n    layers : list\n        A list of \u2202Lux 'layers' that define the transformations and\n        operations upon some input wavefront through an optical system.\n    \"\"\"\n    # Ensure input is a list\n    assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\\n    \" automatically converted to a dictionary\")\n\n    # Ensure all entries are dLux layers\n    for layer in layers:\n        assert isinstance(layer, dLux.optics.OpticalLayer), (\"All entries\" \\\n        \" within layers must be an dLux.optics.OpticalLayer object\")\n\n    self.layers = dLux.utils.list_to_dictionary(layers)\n</code></pre> <p>A Basic Optical Setup</p> <p>In dLux the four layers shown above form a very basic optical train and these layers are used in almost every example.</p> <p><code>CreateWavefont</code> should be the first layer in all optical layers as this is used to actually initialse a wavefront object that is operated on by the other layers. </p> <p><code>ApertureFactory</code> is used to create an aperture that is applied to the wavefront. While this layer is not strictly nessecary, almost all models will have some form of non-square aperture and so will likely require some form of aperture layer.</p> <p><code>NormaliseWavefront</code> is used to normalise the wavefront to a unit intensity. This simply controls at what point the wavefront is normalised to unity power. Since most calculations in optics use the collecting area of the aperture, most use cases will require this layer directly after the aperture.</p> <p><code>AngularMFT</code> is used to propagate the wavefront from the pupil to the focal plane as is common in most optical systems. Typically at least one propagator type layer will be needed in an optical train.</p> <p>To a degree these processes could be automated and made parameters of the <code>Optics</code> class itself, but in the goal of flexibilty and generalisability dLux instead chooses to be verbose to give users full control in order to be able to create any optical system they want.</p> <p>Accessing Parameters</p> <p>The Optics class is set up with a <code>__getattr__</code> method that is able to raise parameters from the <code>layers</code> attribute such that they can be accessed as class parameters via their name. Taking the example from above, we can access <code>Aperture</code> layer via:</p> <pre><code>aperture = optics.Aperture\n</code></pre> <p>Without the <code>__getattr__</code> method we would have to use the following path to access the 'Aperture' layer:</p> <pre><code>aperture = optics.layers['Aperture']\n</code></pre> <p>Which is a lot less nice!</p> <p>The <code>Optics</code> has a simple API with <code>model</code> being its primary method. The <code>model</code> method takes in a source or list of sources and propagates them through the layers of the optics class.</p> model API <p>A base level modelling function for modelling the optical system. Models the source or sources through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>Union[Source, dict, list]</code> <p>The source or sources to observe.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling.</p> <code>True</code> <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened.</p> <code>False</code> <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input sources (ie dict).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>image</code> <code>Array, dict</code> <p>The image of the scene modelled through the optics. Returns either as a single array (if return_tree is false), or a dict of the output for each source.</p> Source code in <code>dLux/core.py</code> <pre><code>def model(self              : Optics,\n          sources           : Union[Source, dict, list],\n          normalise_sources : bool = True,\n          flatten           : bool = False,\n          return_tree       : bool = False) -&gt; Union(Array, dict):\n\"\"\"\n    A base level modelling function for modelling the optical system.\n    Models the source or sources through the optics.\n\n    Parameters\n    ----------\n    sources : Union[Source, dict, list]\n        The source or sources to observe.\n    normalise_sources : bool = True\n        Whether to normalise the sources before modelling.\n    flatten : bool = False\n        Whether the output image should be flattened.\n    return_tree : bool = False\n        Whether to return a Pytree like object with matching tree structure\n        as the input sources (ie dict).\n\n    Returns\n    -------\n    image : Array, dict\n        The image of the scene modelled through the optics. Returns either\n        as a single array (if return_tree is false), or a dict of the output\n        for each source.\n    \"\"\"\n    # None input is for the detector\n    return model(self, sources, None, normalise_sources, flatten,\n        return_tree)\n</code></pre> <p>It also has both <code>propagate</code> and <code>propagate_mono</code> methods, which propagate a broadband and monochromatic wavelengths through the optics class respectively. They take in either an array of wavelengths or a single wavelength and return the calcualted PSF.</p> propagate API <p>Propagates a broadband point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The wavelengths of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>weights</code> <code>Array</code> <p>The relative weighting of the wavelengths. Simply scales the output psf.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The broadband point spread function after being propagated though the optical layers.</p> Source code in <code>dLux/core.py</code> <pre><code>def propagate(self        : Optics,\n              wavelengths : Array,\n              offset      : Array = np.zeros(2),\n              weights     : Array = None) -&gt; Array:\n\"\"\"\n    Propagates a broadband point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelengths : Array, meters\n        The wavelengths of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    weights : Array = None\n        The relative weighting of the wavelengths. Simply scales the output\n        psf.\n\n    Returns\n    -------\n    psf : Array\n        The broadband point spread function after being propagated\n        though the optical layers.\n    \"\"\"\n    # Format weights input\n    wavelengths = np.asarray(wavelengths, dtype=float) \\\n              if not isinstance(wavelengths, np.ndarray) else wavelengths\n    assert wavelengths.ndim == 1, \"wavelengths must be 1 dimensional..\"\n\n    # Format weights input\n    if weights is None:\n        weights = np.ones(len(wavelengths))/len(wavelengths)\n    elif not isinstance(weights, np.ndarray):\n        weights = np.asarray(weights, dtype=float)\n    assert weights.ndim == 1, \"weights must be 1 dimensional.\"\n\n    # Ensure matching dimensionality\n    assert wavelengths.shape == weights.shape, \\\n    (\"wavelengths and weights must have the same shape.\")\n\n    # Offset checking\n    offset = np.asarray(offset, dtype=float) \\\n             if not isinstance(offset, np.ndarray) else offset\n    assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"\n\n    # Propagate\n    propagator = vmap(self.propagate_mono, in_axes=(0, None, 0))\n    psfs = propagator(wavelengths, offset, weights)\n    return psfs.sum(0)\n</code></pre> propagate_mono API <p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>weight</code> <code>Array</code> <p>The relative weighting of the wavelength. Simply scales the output psf.</p> <code>np.array(1.0)</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> Source code in <code>dLux/core.py</code> <pre><code>def propagate_mono(self       : Optics,\n                   wavelength : Array,\n                   offset     : Array = np.zeros(2),\n                   weight     : Array = np.array(1.)) -&gt; Array:\n\"\"\"\n    Propagates a monochromatic point source through the optical layers.\n\n    Parameters\n    ----------\n    wavelength : Array, meters\n        The wavelength of the wavefront to propagate through the optical\n        layers.\n    offset : Array, radians, = np.zeros(2)\n        The (x, y) offset from the optical axis of the source. Default\n        value is (0, 0), on axis.\n    weight : Array, = np.array(1.)\n        The relative weighting of the wavelength. Simply scales the output\n        psf.\n\n    Returns\n    -------\n    psf : Array\n        The monochromatic point spread function after being propagated\n        though the optical layers.\n    \"\"\"\n    # Ensure jax arrays\n    wavelength = np.asarray(wavelength, dtype=float) \\\n                if not isinstance(wavelength, np.ndarray) else wavelength\n    offset = np.asarray(offset, dtype=float) \\\n                if not isinstance(offset, np.ndarray) else offset\n    weight = np.asarray(weight, dtype=float) \\\n                if not isinstance(weight, np.ndarray) else weight\n\n    # Ensure dimensionality\n    assert wavelength.shape == (), \"wavelength must be a scalar.\"\n    assert offset.shape == (2,), \"offset must be shape (2,), ie (x, y).\"\n    assert weight.shape == (), \"weight must be a scalar.\"\n\n    # Construct parameters dictionary\n    params_dict = {\"Wavefront\"  : None,\n                   \"optics\"     : self,\n                   \"wavelength\" : wavelength,\n                   \"offset\"     : offset}\n\n    # Propagate though layers\n    for key, layer in self.layers.items():\n        params_dict = layer.apply(params_dict)\n    psf = params_dict[\"Wavefront\"].wavefront_to_psf()\n    return weight * psf\n</code></pre>"},{"location":"docs/API/core/#dLux.core.Optics.__init__","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Optics.model","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Optics.propagate","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Optics.propagate_mono","title":"Core","text":""},{"location":"docs/API/core/#instrument","title":"Instrument","text":"<p>The <code>Instrument</code> class is a high level class that is designed to control the interaction and modelling of various other classes. It has the following attributes:</p> <ul> <li><code>optics</code>: The <code>Optics</code> class that controls the diffraction of wavefronts.</li> <li><code>detector</code>: The <code>Detector</code> class that controls the transformation applied by a detector.</li> <li><code>sources</code>: The <code>Source</code> class that controls the source.</li> <li><code>observation</code>: The <code>Observation</code> class that controls custom observation stratergies.</li> </ul> <p>It has a two primary methods: <code>Instrument.model()</code> &amp; <code>Instrument.observe()</code>. The <code>model</code> method will automatically propagate all the of the sources through the optics and detector if it is present. The <code>observe</code> method will instead call the <code>observe</code> method of the <code>Observation</code> class, which is designed to give fine-grained control over how the modelling is done in order to create a set of data over multiple filters, for example.</p> <p>It also has the methods <code>normalise</code>, <code>plot</code> and <code>summarise</code>. <code>normalise</code> will normalise all sources stored within the class, <code>summarise</code> prints a brief summary of the objects it contains and <code>plot</code> will propagate a single wavelength through the instrument and show it at intemediate states, although <code>plot</code> and <code>summarise</code> and both considered to experimental and are subject to change in the future.</p> <p>Construction</p> <p>The <code>Instrument</code> class requires both an <code>Optics</code> and <code>Source</code> object, with <code>Detector</code> and <code>Observation</code> classes being optional.</p> <p>Here is how we would create a basic instrument:</p> <pre><code>import dLux as dl\n\ninstrument = dl.Instrument(optics, source)\n</code></pre> <p>We can also pass in a list of sources if we want to model multiple sources:</p> <pre><code>import dLux as dl\n\ninstrument = dl.Instrument(optics, [source1, source2])\n</code></pre> Constructor API <p>Constructor for the Instrument class.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>A pre-configured Optics object.</p> required <code>sources</code> <code>Union[list, Source]</code> <p>Either a list of sources or an individual Source object.</p> required <code>detector</code> <code>Detector</code> <p>A pre-configured Detector object.</p> <code>None</code> <code>observation</code> <code>Observation</code> <p>An class that inherits from Observation. This is to allow flexibility in the different kind of observations, ie applying dithers, switching filters, etc.</p> <code>None</code> Source code in <code>dLux/core.py</code> <pre><code>def __init__(self        : Instrument,\n             optics      : Optics,\n             sources     : Union[list, Source],\n             detector    : Detector    = None,\n             observation : Observation = None,\n             ) -&gt; Instrument:\n\"\"\"\n    Constructor for the Instrument class.\n\n    Parameters\n    ----------\n    optics : Optics\n        A pre-configured Optics object.\n    sources : Union[list, Source]\n        Either a list of sources or an individual Source object.\n    detector : Detector = None\n        A pre-configured Detector object.\n    observation : Observation = None\n        An class that inherits from Observation. This is to allow\n        flexibility in the different kind of observations, ie applying\n        dithers, switching filters, etc.\n    \"\"\"\n    # Optics\n    if not isinstance(optics, Optics):\n        raise ValueError(\"optics must be an Optics object.\")\n    self.optics = optics\n\n    # Sources\n    if isinstance(sources, Source()):\n        sources = [sources]\n    elif isinstance(sources, list):\n        for source in sources:\n            if not isinstance(source, Source()):\n                raise ValueError(\n                    \"sources must be a list of Source objects.\")\n    self.sources = dLux.utils.list_to_dictionary(sources, ordered=False)\n\n    # Detector\n    if not isinstance(detector, (Detector, type(None))):\n        raise ValueError(\"detector must be an Detector object. \"\n            f\"Got type {type(detector)}\")\n    self.detector = detector\n\n    # Observation\n    if not isinstance(observation, (Observation(), type(None))):\n        raise ValueError(\"observation must be an Observation object.\")\n    self.observation = observation\n</code></pre> <p>Accessing Parameters</p> <p>The Instrument class is set up with a <code>__getattr__</code> method that is able to raise parameters from the <code>optics</code>, <code>detector</code>, <code>sources</code> and <code>observation</code> classes if they are present. Say we have a Instrument with an <code>Optics</code> class that applies optical aberrations via a layer called <code>Aberrations</code> set via its name parameter. We would normally need to use the following path to access the <code>name</code> parameter:</p> <pre><code>aberration_layer = instrument.optics.layers['Aberrations']\n</code></pre> <p>Which is quite long. Since all instrument classes have an optics class and all optics classes have a layers attribute, we can instead use the following:</p> <pre><code>aberration_layer = instrument.Aberrations\n</code></pre> <p>Which is much simpler! Dont forget to set the name parameter of layers you will need to access often!</p> model API <p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector.</p> <p>Parameters:</p> Name Type Description Default <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling.</p> <code>True</code> <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened.</p> <code>False</code> <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input sources (ie dict).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>image</code> <code>Array, dict</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a dict of the output for each source.</p> Source code in <code>dLux/core.py</code> <pre><code>def model(self              : Instrument,\n          normalise_sources : bool = True,\n          flatten           : bool = False,\n          return_tree       : bool = False) -&gt; Union(Array, dict):\n\"\"\"\n    A base level modelling function designed to robustly handle the\n    different combinations of inputs. Models the sources through the\n    instrument optics and detector.\n\n    Parameters\n    ----------\n    normalise_sources : bool = True\n        Whether to normalise the sources before modelling.\n    flatten : bool = False\n        Whether the output image should be flattened.\n    return_tree : bool = False\n        Whether to return a Pytree like object with matching tree structure\n        as the input sources (ie dict).\n\n    Returns\n    -------\n    image : Array, dict\n        The image of the scene modelled through the optics with detector and\n        filter effects applied if they are supplied. Returns either as a\n        single array (if return_tree is false), or a dict of the output for\n        each source.\n    \"\"\"\n    return model(self.optics, self.sources, self.detector, \n        normalise_sources, flatten, return_tree)\n</code></pre> observe API <p>Calls the <code>observe</code> method of the stored observation class, passing in any extra keyword arguments.</p> <p>Returns:</p> Type Description <code> </code> <p>The output of the stored observation class.</p> Source code in <code>dLux/core.py</code> <pre><code>def observe(self : Instrument, **kwargs) -&gt; Any:\n\"\"\"\n    Calls the `observe` method of the stored observation class, passing in\n    any extra keyword arguments.\n\n    Returns\n    -------\n     : Any\n        The output of the stored observation class.\n    \"\"\"\n    return self.observation.observe(self, **kwargs)\n</code></pre>"},{"location":"docs/API/core/#dLux.core.Instrument.__init__","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Instrument.model","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Instrument.observe","title":"Core","text":""},{"location":"docs/API/core/#detector","title":"Detector","text":"<p>The <code>Detector</code> class is a high level class that is designed to control the transformation applied by a detector. It has only a single attribute, <code>layers</code> which is stored as an ordered dictionary, but input as a list.</p> <p>Construction</p> <p>The <code>Detector</code> class only has a single input, <code>layers</code>. This is a list of <code>Layer</code> classes that will be applied to the psf in the order they are given. The layers input is taken as a list and automatically converted to an ordered dictionary, populating the dictionary with the <code>name</code> parameter of each layer as the key. If there are mulitple layers with the same name parameter, the names will be modified to \"original_name_0\", \"original_name_1\" etc.</p> <p>Here is how we would create a basic detector class:</p> <pre><code>import dLux as dl\n\njitter = 0.5 # Pixels\nsaturation = 1e5 # ADU\n\nlayers = [\n    dl.ApplyJitter(jitter, name='Jitter'),\n    dl.ApplySaturation(saturation, name='Saturation'),\n    ]\n\ndetector = dl.Detector(layers)\n</code></pre> Constructor API <p>Constructor for the Detector class.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>An list of dLux detector layer classes that define the instrumental effects for some detector.</p> required Source code in <code>dLux/core.py</code> <pre><code>def __init__(self : Detector, layers : list) -&gt; Instrument:\n\"\"\"\n    Constructor for the Detector class.\n\n    Parameters\n    ----------\n    layers : list\n        An list of dLux detector layer classes that define the instrumental\n        effects for some detector.\n    \"\"\"\n    # Ensure input is a list\n    assert isinstance(layers, list), (\"Input layers must be a list, it is\" \\\n    \" automatically converted to a dictionary.\")\n\n    # Ensure all entries are dLux layers\n    for layer in layers:\n        assert isinstance(layer, dLux.detectors.DetectorLayer), \\\n        (\"All entries within layers must be a \"\n         \"dLux.detectors.DetectorLayer object.\")\n\n    # Construct layers\n    self.layers = dLux.utils.list_to_dictionary(layers)\n</code></pre> <p>Accessing Parameters</p> <p>The Detector class is set up with a <code>__getattr__</code> method that is able to raise parameters from the <code>layers</code> attribute such that they can be accessed as class parameters via their name. Taking the example from above, we can access <code>Jitter</code> layer via:</p> <pre><code>jitter_layer = detector.Jitter\n</code></pre> <p>Without the <code>__getattr__</code> method we would have to use the following path to access the 'Jitter' layer:</p> <pre><code>jitter_layer = detector.layers['Jitter']\n</code></pre> <p>Which is a lot less nice!</p> <p>The <code>Detector</code> has a simple API with two primary methods: <code>model</code> and <code>apply_detector</code>. The <code>model</code> method takes in an Optics object and source or list of sources, propagates them through the layers of the optics class and then applies the detector layers. The <code>apply_detector</code> method simply applies the detector layers to a given input array.</p> model API <p>A function to apply the detector layers to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to be transformed by the detector layers.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image after being transformed by the detector layers.</p> Source code in <code>dLux/core.py</code> <pre><code>def model(self : Detector, image: Array) -&gt; Array:\n\"\"\"\n    A function to apply the detector layers to the input image.\n\n    Parameters\n    ----------\n    image: Array\n        The image to be transformed by the detector layers.\n\n    Returns\n    -------\n    image : Array\n        The image after being transformed by the detector layers.\n    \"\"\"\n    return self.apply_detector(image)\n</code></pre> apply_detector API <p>Applied the stored detector layers to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The input 'image' to the detector to be transformed.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The ouput 'image' after being transformed by the detector layers.</p> Source code in <code>dLux/core.py</code> <pre><code>def apply_detector(self : Instrument, image : Array) -&gt; Array:\n\"\"\"\n    Applied the stored detector layers to the input image.\n\n    Parameters\n    ----------\n    image : Array\n        The input 'image' to the detector to be transformed.\n\n    Returns\n    -------\n    image : Array\n        The ouput 'image' after being transformed by the detector layers.\n    \"\"\"\n    # Input type checking\n    assert isinstance(image, np.ndarray), \"Input must be a jax array.\"\n    assert image.ndim == 2, \"Input image must a 2d array.\"\n\n    # Apply detector layers\n    for key, layer in self.layers.items():\n        image = layer(image)\n    return image\n</code></pre>"},{"location":"docs/API/core/#dLux.core.Detector.__init__","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Detector.model","title":"Core","text":""},{"location":"docs/API/core/#dLux.core.Detector.apply_detector","title":"Core","text":""},{"location":"docs/API/detectors/","title":"Detectors","text":"<p>The <code>detectors.py</code> script contains the general <code>DetectorLayer</code> classes. The main class is <code>DetectorLayer</code> which is the base class for all other detector layers. Unless you are creating a new optical layer, you will not need to use this class directly. If you do, please refer to the \"Creating a Layer\" tutorial.</p>"},{"location":"docs/API/detectors/#apply-pixel-response","title":"Apply Pixel Response","text":"<p>This layer takes in an array of per-pixel response values and multiplies the psf by these values. Input arrays must be the same size as the psf.</p> Apply Pixel Response API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a pixel response array to the the input image, via a multiplication.</p> <p>Attributes:</p> Name Type Description <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class ApplyPixelResponse(DetectorLayer):\n\"\"\"\n    Applies a pixel response array to the the input image, via a multiplication.\n\n    Attributes\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    pixel_response : Array\n\n\n    def __init__(self           : DetectorLayer,\n                 pixel_response : Array,\n                 name           : str = 'ApplyPixelResponse') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplyPixelResponse class.\n\n        Parameters\n        ----------\n        pixel_response : Array\n            The pixel_response to apply to the input image. Must be a 2\n            dimensional array equal to size of the image at time of application.\n        name : str = 'ApplyPixelResponse'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.pixel_response = np.asarray(pixel_response, dtype=float)\n        assert self.pixel_response.ndim == 2, \\\n        (\"pixel_response must be a 2 dimensional array.\")\n\n\n    def __call__(self : DetectorLayer, image) -&gt; Array:\n\"\"\"\n        Applies the pixel response to the input image, via a multiplication.\n\n        Parameters\n        ----------\n        image : Array\n            The image to apply the pixel_response to.\n\n        Returns\n        -------\n        image : Array\n            The image with the pixel_response applied.\n        \"\"\"\n        return image * self.pixel_response\n\n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Applies the pixel response to the image.\"\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the pixel response to the input image, via a multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to apply the pixel_response to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the pixel_response applied.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self : DetectorLayer, image) -&gt; Array:\n\"\"\"\n    Applies the pixel response to the input image, via a multiplication.\n\n    Parameters\n    ----------\n    image : Array\n        The image to apply the pixel_response to.\n\n    Returns\n    -------\n    image : Array\n        The image with the pixel_response applied.\n    \"\"\"\n    return image * self.pixel_response\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.__init__","title":"<code>__init__(pixel_response, name='ApplyPixelResponse')</code>","text":"<p>Constructor for the ApplyPixelResponse class.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image. Must be a 2 dimensional array equal to size of the image at time of application.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyPixelResponse'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self           : DetectorLayer,\n             pixel_response : Array,\n             name           : str = 'ApplyPixelResponse') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the ApplyPixelResponse class.\n\n    Parameters\n    ----------\n    pixel_response : Array\n        The pixel_response to apply to the input image. Must be a 2\n        dimensional array equal to size of the image at time of application.\n    name : str = 'ApplyPixelResponse'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.pixel_response = np.asarray(pixel_response, dtype=float)\n    assert self.pixel_response.ndim == 2, \\\n    (\"pixel_response must be a 2 dimensional array.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : DetectorLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return f\"{self.name}: Applies the pixel response to the image.\"\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyPixelResponse.summary","title":"Detectors","text":""},{"location":"docs/API/detectors/#apply-jitter","title":"Apply Jitter","text":"<p>This layer takes in an jitter value in pixel units and applies a convolves the psf with a 2d gaussian of that size.</p> Apply Jitter API <p>         Bases: <code>DetectorLayer</code></p> <p>Convolves the image with a gaussian kernel parameterised by the standard deviation (sigma).</p> <p>Attributes:</p> Name Type Description <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the guassian kernel, in units of pixels.</p> <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class ApplyJitter(DetectorLayer):\n\"\"\"\n    Convolves the image with a gaussian kernel parameterised by the standard\n    deviation (sigma).\n\n    Attributes\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the guassian kernel, in units of pixels.\n    kernel_size : int\n        The size of the convolution kernel to use.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    kernel_size : int\n    sigma       : Array\n\n\n    def __init__(self        : DetectorLayer,\n                 sigma       : Array,\n                 kernel_size : int = 10,\n                 name        : str = 'ApplyJitter') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplyJitter class.\n\n        Parameters\n        ----------\n        sigma : Array, pixels\n            The standard deviation of the guassian kernel, in units of pixels.\n        kernel_size : int = 10\n            The size of the convolution kernel to use.\n        name : str = 'ApplyJitter'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.kernel_size = int(kernel_size)\n        self.sigma       = np.asarray(sigma, dtype=float)\n        assert self.sigma.ndim == 0, (\"sigma must be scalar array.\")\n\n\n    def generate_kernel(self : DetectorLayer) -&gt; Array:\n\"\"\"\n        Generates the normalised guassian kernel.\n\n        Returns\n        -------\n        kernel : Array\n            The gaussian kernel.\n        \"\"\"\n        # Generate distribution\n        x = np.linspace(-10, 10, self.kernel_size)\n        kernel = norm.pdf(x,          scale=self.sigma) * \\\n                 norm.pdf(x[:, None], scale=self.sigma)\n        return kernel/np.sum(kernel)\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Convolves the input image with the generate gaussian kernel.\n\n        Parameters\n        ----------\n        image : Array\n            The image to convolve with the gussian kernel.\n\n        Returns\n        -------\n        image : Array\n            The image with the gaussian kernel convolution applied.\n        \"\"\"\n        kernel = self.generate_kernel()\n        return convolve(image, kernel, mode='same')\n\n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a jitter of {self.jitter:.{sigfigs}} \"\n                \"pixels.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.__call__","title":"<code>__call__(image)</code>","text":"<p>Convolves the input image with the generate gaussian kernel.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to convolve with the gussian kernel.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the gaussian kernel convolution applied.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n    Convolves the input image with the generate gaussian kernel.\n\n    Parameters\n    ----------\n    image : Array\n        The image to convolve with the gussian kernel.\n\n    Returns\n    -------\n    image : Array\n        The image with the gaussian kernel convolution applied.\n    \"\"\"\n    kernel = self.generate_kernel()\n    return convolve(image, kernel, mode='same')\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.__init__","title":"<code>__init__(sigma, kernel_size=10, name='ApplyJitter')</code>","text":"<p>Constructor for the ApplyJitter class.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the guassian kernel, in units of pixels.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> <code>10</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyJitter'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self        : DetectorLayer,\n             sigma       : Array,\n             kernel_size : int = 10,\n             name        : str = 'ApplyJitter') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the ApplyJitter class.\n\n    Parameters\n    ----------\n    sigma : Array, pixels\n        The standard deviation of the guassian kernel, in units of pixels.\n    kernel_size : int = 10\n        The size of the convolution kernel to use.\n    name : str = 'ApplyJitter'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.kernel_size = int(kernel_size)\n    self.sigma       = np.asarray(sigma, dtype=float)\n    assert self.sigma.ndim == 0, (\"sigma must be scalar array.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.generate_kernel","title":"<code>generate_kernel()</code>","text":"<p>Generates the normalised guassian kernel.</p> <p>Returns:</p> Name Type Description <code>kernel</code> <code>Array</code> <p>The gaussian kernel.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def generate_kernel(self : DetectorLayer) -&gt; Array:\n\"\"\"\n    Generates the normalised guassian kernel.\n\n    Returns\n    -------\n    kernel : Array\n        The gaussian kernel.\n    \"\"\"\n    # Generate distribution\n    x = np.linspace(-10, 10, self.kernel_size)\n    kernel = norm.pdf(x,          scale=self.sigma) * \\\n             norm.pdf(x[:, None], scale=self.sigma)\n    return kernel/np.sum(kernel)\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : DetectorLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies a jitter of {self.jitter:.{sigfigs}} \"\n            \"pixels.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.generate_kernel","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplyJitter.summary","title":"Detectors","text":""},{"location":"docs/API/detectors/#apply-saturation","title":"Apply Saturation","text":"<p>This layer takes in an saturation value and applies a simply threshold to the psf, it does not model any charge bleeding effects.</p> Apply Saturation API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a simple saturation model to the input image, by clipping any values above saturation, to saturation.</p> <p>Attributes:</p> Name Type Description <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class ApplySaturation(DetectorLayer):\n\"\"\"\n    Applies a simple saturation model to the input image, by clipping any\n    values above saturation, to saturation.\n\n    Attributes\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    saturation : Array\n\n\n    def __init__(self       : DetectorLayer,\n                 saturation : Array,\n                 name       : str = 'ApplySaturation') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the ApplySaturation class.\n\n        Parameters\n        ----------\n        saturation : Array\n            The value at which the saturation is applied.\n        name : str = 'ApplySaturation'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.saturation = np.asarray(saturation, dtype=float)\n        assert self.saturation.ndim == 0, (\"saturation must be a scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Applies the satuation effect by reducing all values in the image above\n        saturation, to the saturation value.\n\n        Parameters\n        ----------\n        image : Array\n            The image to apply the saturation to.\n\n        Returns\n        -------\n        image : Array\n            The image with the saturation applied.\n        \"\"\"\n        return np.minimum(image, self.saturation)\n\n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a saturation of \"\n                f\"{self.saturation:.{sigfigs}} counts.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the satuation effect by reducing all values in the image above saturation, to the saturation value.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to apply the saturation to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the saturation applied.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n    Applies the satuation effect by reducing all values in the image above\n    saturation, to the saturation value.\n\n    Parameters\n    ----------\n    image : Array\n        The image to apply the saturation to.\n\n    Returns\n    -------\n    image : Array\n        The image with the saturation applied.\n    \"\"\"\n    return np.minimum(image, self.saturation)\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.__init__","title":"<code>__init__(saturation, name='ApplySaturation')</code>","text":"<p>Constructor for the ApplySaturation class.</p> <p>Parameters:</p> Name Type Description Default <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplySaturation'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self       : DetectorLayer,\n             saturation : Array,\n             name       : str = 'ApplySaturation') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the ApplySaturation class.\n\n    Parameters\n    ----------\n    saturation : Array\n        The value at which the saturation is applied.\n    name : str = 'ApplySaturation'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.saturation = np.asarray(saturation, dtype=float)\n    assert self.saturation.ndim == 0, (\"saturation must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : DetectorLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies a saturation of \"\n            f\"{self.saturation:.{sigfigs}} counts.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.ApplySaturation.summary","title":"Detectors","text":""},{"location":"docs/API/detectors/#add-constant","title":"Add Constant","text":"<p>This layer takes in an constant value and adds it to the psf, representing the mean of the background noise.</p> Add Constant API <p>         Bases: <code>DetectorLayer</code></p> <p>Add a constant to the output image. This is typically used to model the mean value of the detector noise.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Array</code> <p>The value to add to the image.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class AddConstant(DetectorLayer):\n\"\"\"\n    Add a constant to the output image. This is typically used to model the\n    mean value of the detector noise.\n\n    Attributes\n    ----------\n    value : Array\n        The value to add to the image.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    value : Array\n\n\n    def __init__(self  : DetectorLayer,\n                 value : Array,\n                 name  : str = 'AddConstant') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the AddConstant class.\n\n        Parameters\n        ----------\n        value : Array\n            The value to add to the image.\n        name : str = 'AddConstant'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.value = np.asarray(value, dtype=float)\n        assert self.value.ndim == 0, (\"value must be a scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Adds the value to the input image.\n\n        Parameters\n        ----------\n        image : Array\n            The image to add the value to.\n\n        Returns\n        -------\n        image : Array\n            The image with the value added.\n        \"\"\"\n        return image + self.value\n\n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Adds a constant value of \"\n                f\"{self.value:.{sigfigs}} counts.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.__call__","title":"<code>__call__(image)</code>","text":"<p>Adds the value to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to add the value to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the value added.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n    Adds the value to the input image.\n\n    Parameters\n    ----------\n    image : Array\n        The image to add the value to.\n\n    Returns\n    -------\n    image : Array\n        The image with the value added.\n    \"\"\"\n    return image + self.value\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.__init__","title":"<code>__init__(value, name='AddConstant')</code>","text":"<p>Constructor for the AddConstant class.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Array</code> <p>The value to add to the image.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddConstant'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self  : DetectorLayer,\n             value : Array,\n             name  : str = 'AddConstant') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the AddConstant class.\n\n    Parameters\n    ----------\n    value : Array\n        The value to add to the image.\n    name : str = 'AddConstant'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.value = np.asarray(value, dtype=float)\n    assert self.value.ndim == 0, (\"value must be a scalar array.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : DetectorLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Adds a constant value of \"\n            f\"{self.value:.{sigfigs}} counts.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.AddConstant","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.AddConstant.summary","title":"Detectors","text":""},{"location":"docs/API/detectors/#integer-downsample","title":"Integer Downsample","text":"<p>This layer takes in an integer downsampling factor and downsamples the psf by that factor.</p> Integer Downsample API <p>         Bases: <code>DetectorLayer</code></p> <p>Downsamples an input image by an integer number of pixels via a sum. The number of pixels in the input image must by integer divisible by the kernel_size.</p> <p>Attributes:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/detectors.py</code> <pre><code>class IntegerDownsample(DetectorLayer):\n\"\"\"\n    Downsamples an input image by an integer number of pixels via a sum.\n    The number of pixels in the input image must by integer divisible by the\n    kernel_size.\n\n    Attributes\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    kernel_size : int\n\n\n    def __init__(self        : DetectorLayer,\n                 kernel_size : int,\n                 name        : str = 'IntegerDownsample') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the IntegerDownsample class.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the downsampling kernel.\n        name : str = 'IntegerDownsample'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.kernel_size = int(kernel_size)\n\n\n    def downsample(self        : DetectorLayer,\n                   array       : Array,\n                   kernel_size : int) -&gt; Array:\n\"\"\"\n        Downsamples the input array by kernel_size.\n\n        Parameters\n        ----------\n        array : Array\n            The input array to downsample.\n\n        Returns\n        -------\n        kernel_size : int\n            The size of the downsample kernel.\n        \"\"\"\n        size_in = array.shape[0]\n        size_out = size_in//kernel_size\n\n        # Downsample first dimension\n        array = array.reshape((size_in*size_out, kernel_size)).sum(1)\n        array = array.reshape(size_in, size_out).T\n\n        # Downsample second dimension\n        array = array.reshape((size_out*size_out, kernel_size)).sum(1)\n        array = array.reshape(size_out, size_out).T\n        return array\n\n\n    def __call__(self, image):\n\"\"\"\n        Downsamples the input image by the internally stored kernel_size.\n\n        Parameters\n        ----------\n        image : Array\n            The image to downsample.\n\n        Returns\n        -------\n        image : Array\n            The downsampled image.\n        \"\"\"\n        return self.downsample(image, self.kernel_size)\n\n\n    def summary(self            : DetectorLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Downsamples the image by {self.kernel_size} \"\n                f\"pixels.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.__call__","title":"<code>__call__(image)</code>","text":"<p>Downsamples the input image by the internally stored kernel_size.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to downsample.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The downsampled image.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self, image):\n\"\"\"\n    Downsamples the input image by the internally stored kernel_size.\n\n    Parameters\n    ----------\n    image : Array\n        The image to downsample.\n\n    Returns\n    -------\n    image : Array\n        The downsampled image.\n    \"\"\"\n    return self.downsample(image, self.kernel_size)\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.__init__","title":"<code>__init__(kernel_size, name='IntegerDownsample')</code>","text":"<p>Constructor for the IntegerDownsample class.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'IntegerDownsample'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self        : DetectorLayer,\n             kernel_size : int,\n             name        : str = 'IntegerDownsample') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the IntegerDownsample class.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the downsampling kernel.\n    name : str = 'IntegerDownsample'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.kernel_size = int(kernel_size)\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.downsample","title":"<code>downsample(array, kernel_size)</code>","text":"<p>Downsamples the input array by kernel_size.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to downsample.</p> required <p>Returns:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsample kernel.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def downsample(self        : DetectorLayer,\n               array       : Array,\n               kernel_size : int) -&gt; Array:\n\"\"\"\n    Downsamples the input array by kernel_size.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to downsample.\n\n    Returns\n    -------\n    kernel_size : int\n        The size of the downsample kernel.\n    \"\"\"\n    size_in = array.shape[0]\n    size_out = size_in//kernel_size\n\n    # Downsample first dimension\n    array = array.reshape((size_in*size_out, kernel_size)).sum(1)\n    array = array.reshape(size_in, size_out).T\n\n    # Downsample second dimension\n    array = array.reshape((size_out*size_out, kernel_size)).sum(1)\n    array = array.reshape(size_out, size_out).T\n    return array\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : DetectorLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Downsamples the image by {self.kernel_size} \"\n            f\"pixels.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.downsample","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.IntegerDownsample.summary","title":"Detectors","text":""},{"location":"docs/API/detectors/#rotate","title":"Rotate","text":"<p>This layer takes in an angle in radians and rotates the psf by that angle using interpolation.</p> Rotate API <p>         Bases: <code>DetectorLayer</code></p> <p>Applies a rotation to the image using interpolation methods.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required <code>fourier</code> <code>bool</code> <p>Should the rotation be done using fourier methods or interpolation.</p> <code>False</code> <code>padding</code> <code>int</code> <p>The amount of padding to use if the fourier method is used.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code> Source code in <code>dLux/detectors.py</code> <pre><code>class Rotate(DetectorLayer):\n\"\"\"\n    Applies a rotation to the image using interpolation methods.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the image in the clockwise direction.\n    fourier : bool\n        Should the rotation be done using fourier methods or interpolation.\n    padding : int\n        The amount of padding to use if the fourier method is used.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    angle   : Array\n    fourier : bool\n    padding : int\n\n\n    def __init__(self    : DetectorLayer,\n                 angle   : Array,\n                 fourier : bool = False,\n                 padding : int  = None,\n                 name    : str  = 'Rotate') -&gt; DetectorLayer:\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the image in the clockwise direction.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        padding : int = None\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n        name : str = 'Rotate'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.angle   = np.asarray(angle, dtype=float)\n        self.fourier = bool(fourier)\n        self.padding = padding if padding is None else int(padding)\n        assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n\n\n    def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n        Applies the rotation to an image.\n\n        Parameters\n        ----------\n        image : Array\n            The image to rotate.\n\n        Returns\n        -------\n        image : Array\n            The rotated image.\n        \"\"\"\n        if self.fourier:\n            return fourier_rotate(image, self.angle, self.padding)\n        else:\n            return rotate(image, self.angle)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angle = convert_angular(self.angle, 'radians', angular_units)\n\n        if self.fourier:\n            method = f\"a Fourier method with padding of {self.padding}\"\n        else:\n            method = \"an Interpolation method of order 1\"\n\n        return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n                f\"rotation to the image using {method}.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.Rotate.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the rotation to an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to rotate.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The rotated image.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def __call__(self : DetectorLayer, image : Array) -&gt; Array:\n\"\"\"\n    Applies the rotation to an image.\n\n    Parameters\n    ----------\n    image : Array\n        The image to rotate.\n\n    Returns\n    -------\n    image : Array\n        The rotated image.\n    \"\"\"\n    if self.fourier:\n        return fourier_rotate(image, self.angle, self.padding)\n    else:\n        return rotate(image, self.angle)\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.Rotate.__init__","title":"<code>__init__(angle, fourier=False, padding=None, name='Rotate')</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code> Source code in <code>dLux/detectors.py</code> <pre><code>def __init__(self    : DetectorLayer,\n             angle   : Array,\n             fourier : bool = False,\n             padding : int  = None,\n             name    : str  = 'Rotate') -&gt; DetectorLayer:\n\"\"\"\n    Constructor for the Rotate class.\n\n    Parameters\n    ----------\n    angle: float, radians\n        The angle by which to rotate the image in the clockwise direction.\n    fourier : bool = False\n        Should the fourier rotation method be used (True), or regular\n        interpolation method be used (False).\n    padding : int = None\n        The amount of fourier padding to use. Only applies if fourier is\n        True.\n    name : str = 'Rotate'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.angle   = np.asarray(angle, dtype=float)\n    self.fourier = bool(fourier)\n    self.padding = padding if padding is None else int(padding)\n    assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.Rotate.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/detectors.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    angle = convert_angular(self.angle, 'radians', angular_units)\n\n    if self.fourier:\n        method = f\"a Fourier method with padding of {self.padding}\"\n    else:\n        method = \"an Interpolation method of order 1\"\n\n    return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n            f\"rotation to the image using {method}.\")\n</code></pre>"},{"location":"docs/API/detectors/#dLux.detectors.Rotate","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.Rotate.__call__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.Rotate.__init__","title":"Detectors","text":""},{"location":"docs/API/detectors/#dLux.detectors.Rotate.summary","title":"Detectors","text":""},{"location":"docs/API/helpers/","title":"Helper Utility Functions","text":"<p>This module contains any other functions that don't fit into the rest of the utils module!</p>"},{"location":"docs/API/helpers/#list-to-dictionary","title":"List to Dictionary","text":"<p>Converts a list of dLux objects into either a regular ordered dictionary. This shouldn't need to be used by the user, but is used internally in many of the constructors.</p> List to Dictionary API <p>Converts some input list of dLux layers and converts them into an OrderedDict with the correct structure, ensuring that all keys are unique.</p> <p>Parameters:</p> Name Type Description Default <code>list_in</code> <code>list</code> <p>The list of dLux OpticalLayers or DetectorLayers to be converted into a dictionary.</p> required <code>ordered</code> <code>bool</code> <p>Whether to return an ordered or regular dictionary.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dictionary</code> <code>dict</code> <p>The equivilent dictionary or ordered dictionary.</p> Source code in <code>dLux/utils/helpers.py</code> <pre><code>def list_to_dictionary(list_in : list, ordered : bool = True) -&gt; dict:\n\"\"\"\n    Converts some input list of dLux layers and converts them into an\n    OrderedDict with the correct structure, ensuring that all keys are unique.\n\n    Parameters\n    ----------\n    list_in : list\n        The list of dLux OpticalLayers or DetectorLayers to be converted into\n        a dictionary.\n    ordered : bool = True\n        Whether to return an ordered or regular dictionary.\n\n    Returns\n    -------\n    dictionary : dict\n        The equivilent dictionary or ordered dictionary.\n    \"\"\"\n    # Construct names list and identify repeats\n    names, repeats = [], []\n    for i in range(len(list_in)):\n\n        # Check for name attribute\n        if hasattr(list_in[i], 'name') and list_in[i].name is not None:\n            name = list_in[i].name\n\n        # Else take name from object\n        else:\n            name = str(list_in[i]).split('(')[0]\n\n        # Check for Repeats\n        if name in names:\n            repeats.append(name)\n        names.append(name)\n\n    # Get list of unique repeats\n    repeats = list(set(repeats))\n\n    # Iterate over repeat names\n    for i in range(len(repeats)):\n\n        idx = 0\n        # Iterate over names list and append index value to name\n        for j in range(len(names)):\n            if repeats[i] == names[j]:\n                names[j] = names[j] + '_{}'.format(idx)\n                idx += 1\n\n    # Turn list into Dictionary\n    dict_out = OrderedDict() if ordered else {}\n    for i in range(len(names)):\n\n        # Assert no spaces in the name in order to ensure the __getattrr__\n        # method will work\n        assert ' ' not in names[i], \\\n        (\"names can not contain spaces, {} was supplied.\".format(names[i]))\n        dict_out[names[i]] = list_in[i].set('name', names[i])\n    return dict_out\n</code></pre>"},{"location":"docs/API/helpers/#dLux.utils.helpers.list_to_dictionary","title":"Helpers","text":""},{"location":"docs/API/interpolation/","title":"Interpolation Utility Functions","text":"<p>This module contains some basic interpolation functions that can be used on arrays and wavefronts.</p>"},{"location":"docs/API/interpolation/#interpolate","title":"Interpolate","text":"<p>Paraxially interpolates an array by some sampling ratio with optional shifts.</p> Interpolate API <p>Paraxially interpolates an array based on the sampling ratio, and npixels_out.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to interpolate.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The interpolated arrays.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def interpolate(array          : Array,\n                npixels_out    : int,\n                sampling_ratio : Array,\n                x_shift        : Array = np.array(0.),\n                y_shift        : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Paraxially interpolates an array based on the sampling ratio, and\n    npixels_out.\n\n    Parameters\n    ----------\n    array : Array\n        The input array to interpolate.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    field : Array\n        The interpolated arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = array.shape[-1]\n    coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,\n                                       x_shift, y_shift)\n\n    # Interpolate\n    new_array = map_coordinates(array, order=1)\n\n    # Conserve energy and return\n    return new_array * sampling_ratio\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.interpolate","title":"Interpolation","text":""},{"location":"docs/API/interpolation/#scale-array","title":"Scale Array","text":"<p>Scales an array to some number of output pixels.</p> Scale Array API <p>Scales some input array to size_out using interolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to scale.</p> required <code>size_out</code> <code>int</code> <p>The output size of the mask</p> required <code>order</code> <code>int</code> <p>The interpolation order. Supports 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array scaled to size_out</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def scale_array(array    : Array,\n                size_out : int,\n                order    : int) -&gt; Array:\n\"\"\"\n    Scales some input array to size_out using interolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to scale.\n    size_out : int\n        The output size of the mask\n    order : int\n        The interpolation order. Supports 0 and 1.\n\n    Returns\n    -------\n    array : Array\n        The array scaled to size_out\n    \"\"\"\n    assert order in (0, 1), (\"order must be 0 or 1.\")\n    xs = np.linspace(0, array.shape[0], size_out)\n    xs, ys = np.meshgrid(xs, xs)\n    return map_coordinates(array, np.array([ys, xs]), order=order)\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.scale_array","title":"Interpolation","text":""},{"location":"docs/API/interpolation/#interpolate-field","title":"Interpolate Field","text":"<p>Paraxially interpolates a wavefront by some sampling ratio with optional shifts. Inputs of the wavefront arrays can be either amplitude and phase or real and imaginary.</p> Interpolate Field API <p>Paraxially interpolates a wavefront field (either in ampltude and phase, or real and imaginiary) based on the sampling ratio, and npixels_out.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Array</code> <p>The input field to interpolate, either in amplitude and phase, or real and imaginary.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>real_imaginary</code> <code>bool</code> <p>Is the input field given in amplitude and phase, or real and imagninary.</p> <code>False</code> <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The interpolated output amplitude and phase arrays.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def interpolate_field(field           : Array,\n                      npixels_out     : int,\n                      sampling_ratio  : Array,\n                      real_imaginary  : bool = False,\n                      x_shift         : Array = np.array(0.),\n                      y_shift         : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Paraxially interpolates a wavefront field (either in ampltude and phase, or\n    real and imaginiary) based on the sampling ratio, and npixels_out.\n\n    Parameters\n    ----------\n    field : Array\n        The input field to interpolate, either in amplitude and phase, or real\n        and imaginary.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    real_imaginary : bool = False\n        Is the input field given in amplitude and phase, or real and imagninary.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    field : Array\n        The interpolated output amplitude and phase arrays.\n    \"\"\"\n    # Get coords arrays\n    npixels_in = field.shape[-1]\n    coordinates = generate_coordinates(npixels_in, npixels_out, sampling_ratio,\n                                       x_shift, y_shift)\n\n    # Interpolate\n    interpolator = vmap(map_coordinates, in_axes=(0, None, None))\n    new_field = interpolator(field, coordinates, 1)\n\n    # Conserve energy\n    if real_imaginary:\n        amplitude = np.hypot(new_field[0], new_field[1])\n        phase = np.arctan2(new_field[1], new_field[0])\n    else:\n        amplitude, phase = new_field\n\n    return np.array([amplitude, phase])\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.interpolate_field","title":"Interpolation","text":""},{"location":"docs/API/interpolation/#rotate","title":"Rotate","text":"<p>Rotates an array via interpolation by some angle in radians.</p> Rotate API <p>Rotates an array by the angle, using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle to rotate the array by.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def rotate(array : Array, angle : Array, order : int = 1) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using linear interpolation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n    if order not in (0, 1, 3):\n        raise ValueError(\"Order must be 0, 1, or 3.\")\n    # Get coordinates\n    npixels = array.shape[0]\n    centre = (npixels - 1) / 2\n    coordinates = c.get_pixel_positions((npixels, npixels), indexing='ij')\n    coordinates_rotated = c.rotate(coordinates, angle) + centre\n\n    # Interpolate\n    return map_coordinates(array, coordinates_rotated, order=order)\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.rotate","title":"Interpolation","text":""},{"location":"docs/API/interpolation/#fourier-rotate","title":"Fourier Rotate","text":"<p>Rotates an array via Fourier methods by some angle in radians.</p> Fourier Rotate API <p>Rotates an array by the angle, using a fourier rotation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle to rotate the array by.</p> required <code>padding</code> <code>int</code> <p>The amount of fourier padding to use.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def fourier_rotate(array   : Array,\n                   angle   : Array,\n                   padding : int = 2) -&gt; Array:\n\"\"\"\n    Rotates an array by the angle, using a fourier rotation.\n\n    Parameters\n    ----------\n    array : Array\n        The array to rotate.\n    angle : Array, radians\n        The angle to rotate the array by.\n    padding : int = 2\n        The amount of fourier padding to use.\n\n    Returns\n    -------\n    array : Array\n        The rotated array.\n    \"\"\"\n    raise NotImplementedError(\"Fourier rotation is under development.\")\n\n    in_shape = array.shape\n    array_shape = np.array(in_shape, dtype=int) + 3\n    array = np.full(array_shape, np.nan, dtype=float)\\\n        .at[1 : in_shape[0] + 1, 1 : in_shape[1] + 1]\\\n        .set(array)\n\n    # FFT rotation only work in the -45:+45 range\n    # So I need to work out how to determine the quadrant that\n    # angle is in and hence the\n    # number of required pi/2 rotations and angle in radians.\n    half_pi_to_1st_quadrant = angle // (np.pi / 2)\n    angle_in_1st_quadrant = - angle + (half_pi_to_1st_quadrant * np.pi / 2)\n\n    array = np.rot90(array, half_pi_to_1st_quadrant)\\\n        .at[:-1, :-1]\\\n        .get()\n\n    width, height = array.shape\n    left_corner   = int(((padding - 1) / 2.) * width)\n    right_corner  = int(((padding + 1) / 2.) * width)\n    top_corner    = int(((padding - 1) / 2.) * height)\n    bottom_corner = int(((padding + 1) / 2.) * height)\n\n    # Make the padded array\n    out_shape = (width * padding, height * padding)\n    padded_array = np.full(out_shape, np.nan, dtype=float)\\\n        .at[left_corner : right_corner, top_corner : bottom_corner]\\\n        .set(array)\n\n    padded_mask = np.ones(out_shape, dtype=bool)\\\n        .at[left_corner : right_corner, top_corner : bottom_corner]\\\n        .set(np.where(np.isnan(array), True, False))\n\n    # Rotate the mask, to know what part is actually the array\n    padded_mask = self.__rotate(padded_mask, -angle_in_1st_quadrant)\n\n    # Replace part outside the array which are NaN by 0, and go into \n    # Fourier space.\n    padded_array = np.where(np.isnan(padded_array), 0. , padded_array)\n\n    uncentered_angular_displacement = np.tan(angle_in_1st_quadrant / 2.)\n    centered_angular_displacement = -np.sin(angle_in_1st_quadrant)\n\n    uncentered_frequencies = np.fft.fftfreq(out_shape[0])\n    centered_frequencies = np.arange(-out_shape[0] / 2., out_shape[0] / 2.)\n\n    pi_factor = -2.j * np.pi * np.ones(out_shape, dtype=float)\n\n    uncentered_phase = np.exp(\n        uncentered_angular_displacement *\\\n        ((pi_factor * uncentered_frequencies).T *\\\n        centered_frequencies).T)\n\n    centered_phase = np.exp(\n        centered_angular_displacement *\\\n        (pi_factor * centered_frequencies).T *\\\n        uncentered_frequencies)\n\n    f1 = np.fft.ifft(\n        (np.fft.fft(padded_array, axis=0).T * uncentered_phase).T, axis=0)\n\n    f2 = np.fft.ifft(\n        np.fft.fft(f1, axis=1) * centered_phase, axis=1)\n\n    rotated_array = np.fft.ifft(\n        (np.fft.fft(f2, axis=0).T * uncentered_phase).T, axis=0)\\\n        .at[padded_mask]\\\n        .set(np.nan)\n\n    return np.real(rotated_array\\\n        .at[left_corner + 1 : right_corner - 1,\n            top_corner + 1 : bottom_corner - 1]\\\n        .get()).copy()\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.fourier_rotate","title":"Interpolation","text":""},{"location":"docs/API/interpolation/#generate-coordiantes","title":"Generate Coordiantes","text":"<p>Just a helper function used to generate the coordaintes required by the low-level interpolation functions.</p> Generate Coordiantes API <p>Generates a new set of paraxial coordinates which can be used for interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_in</code> <code>int</code> <p>The number of pixels in the original array.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The output coordinates at which to interpolate onto.</p> Source code in <code>dLux/utils/interpolation.py</code> <pre><code>def generate_coordinates(npixels_in     : int,\n                         npixels_out    : int,\n                         sampling_ratio : Array,\n                         x_shift        : Array = np.array(0.),\n                         y_shift        : Array = np.array(0.)) -&gt; Array:\n\"\"\"\n    Generates a new set of paraxial coordinates which can be used for\n    interpolation.\n\n    Parameters\n    ----------\n    npixels_in : int\n        The number of pixels in the original array.\n    npixels_out : int\n        The number of pixel in the output array.\n    sampling_ratio : Array\n        The ratio of pixel sizes in the input and output array,\n        ie pixel_scale_out/pixel_scale_in.\n    x_shift : Array, pixles = np.array(0.)\n        How much to shift the x_coordinates in the output array, in the pixel\n        units of the output array.\n    y_shift : Array, pixles = np.array(0.)\n        How much to shift the y_coordinates in the output array, in the pixel\n        units of the output array.\n\n    Returns\n    -------\n    coordinates : Array\n        The output coordinates at which to interpolate onto.\n    \"\"\"\n    old_centre = (npixels_in  - 1) / 2\n    new_centre = (npixels_out - 1) / 2\n    pixels = sampling_ratio * np.linspace(-new_centre, new_centre,\n                                          npixels_out) + old_centre\n    x_pixels, y_pixels = np.meshgrid(pixels + x_shift, pixels + y_shift)\n    return np.array([y_pixels, x_pixels])\n</code></pre>"},{"location":"docs/API/interpolation/#dLux.utils.interpolation.generate_coordinates","title":"Interpolation","text":""},{"location":"docs/API/maths/","title":"Math Utility Functions","text":"<p>This module only contains a single function used to calcluate factorials differentiably.</p>"},{"location":"docs/API/maths/#factorial","title":"Factorial","text":"<p>Calculates the factorial of a number.</p> Factorial API <p>Calculate n! in a jax friendly way. Note that n == 0 is not a  safe case.  </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The value to calculate the factorial of.</p> required <p>Returns:</p> Type Description <code>n</code> <p>The factorial of the value.</p> Source code in <code>dLux/utils/math.py</code> <pre><code>def factorial(n : float) -&gt; float:\n\"\"\"\n    Calculate n! in a jax friendly way. Note that n == 0 is not a \n    safe case.  \n\n    Parameters\n    ----------\n    n : float\n        The value to calculate the factorial of.\n\n    Returns\n    -------\n    n! : float\n        The factorial of the value.\n    \"\"\"\n    return lax.exp(lax.lgamma(n + 1.))\n</code></pre>"},{"location":"docs/API/maths/#dLux.utils.math.factorial","title":"Math Utility Functions","text":""},{"location":"docs/API/models/","title":"Models Utility Functions","text":"<p>This module contains a single function used to generate a simple model of an optial system.</p>"},{"location":"docs/API/models/#simple-optical-system","title":"Simple Optical System","text":"<p>This function generates a simple optical system with a single pupil and single focal plane. It requires the diameter of the aperture, the number of pixels representing the wavefront, the number of detector pixels, and the size of the detector pixels. Units can be either angular or cartesian by setting the <code>angular</code> flag. Aberrations can also be added, along with any other extra layers to be appended to the last layer of the pupil plane.</p> Simple Optical System API <p>Constucts a simple Fourier optical system.</p> <p>Parameters:</p> Name Type Description Default <code>aperture_diameter</code> <code>Array, meters</code> <p>The diameter of the optical system aperture.</p> required <code>wavefront_npixels</code> <code>int</code> <p>The number of pixel used to represent the wavefront.</p> required <code>detector_npixels</code> <code>int</code> <p>The number of pixel of the detector</p> required <code>detector_pixel_size</code> <code>Array, arcseconds</code> <p>The size of the detector pixels. Taken in units of arcseconds per pixel if anuglar == True, else units are taken in meters per pixel.</p> required <code>angular</code> <code>bool</code> <p>Whether to use angular (radians) or cartesian (meters) units.</p> <code>True</code> <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. This paramter is only used if angular == False.</p> <code>None</code> <code>secondary_mirror_diameter</code> <code>Array</code> <p>The diameter of the secondary mirror obscuration.</p> <code>None</code> <code>nzernike</code> <code>int</code> <p>The number of zernike terms to use. Ignore piston tip tilt.</p> <code>None</code> <code>zernike_coefficients</code> <code>Array</code> <p>The values of the zernike coefficients. Only used if nzerike == None.</p> <code>None</code> <code>extra_layers</code> <code>list</code> <p>The extra layers to add to the optical system.</p> <code>None</code> <code>return_layers</code> <code>bool</code> <p>Should the function return the layers, or an Optics class.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>optics</code> <code>OpticalSystem</code> <p>The optical system with the optical layers loaded.</p> Source code in <code>dLux/utils/models.py</code> <pre><code>def simple_optical_system(aperture_diameter         : Array,\n                          wavefront_npixels         : int,\n                          detector_npixels          : int,\n                          detector_pixel_size       : Array,\n                          angular                   : bool  = True,\n                          focal_length              : Array = None,\n                          secondary_mirror_diameter : Array = None,\n                          nzernike                  : int   = None,\n                          zernike_coefficients      : Array = None,\n                          extra_layers              : list  = None,\n                          return_layers             : bool  = False):\n\"\"\"\n    Constucts a simple Fourier optical system.\n\n    Parameters\n    ----------\n    aperture_diameter : Array, meters\n        The diameter of the optical system aperture.\n    wavefront_npixels : int\n        The number of pixel used to represent the wavefront.\n    detector_npixels : int\n        The number of pixel of the detector\n    detector_pixel_size : Array, arcseconds/pixel or meters/pixel\n        The size of the detector pixels. Taken in units of arcseconds per pixel\n        if anuglar == True, else units are taken in meters per pixel.\n    angular : bool = True\n        Whether to use angular (radians) or cartesian (meters) units.\n    focal_length : Array = None\n        The focal length of the optical system. This paramter is only used if\n        angular == False.\n    secondary_mirror_diameter : Array = None\n        The diameter of the secondary mirror obscuration.\n    nzernike : int = None\n        The number of zernike terms to use. Ignore piston tip tilt.\n    zernike_coefficients : Array = None\n        The values of the zernike coefficients. Only used if nzerike == None.\n    extra_layers : list = None\n        The extra layers to add to the optical system.\n    return_layers : bool = False\n        Should the function return the layers, or an Optics class.\n\n    Returns\n    -------\n    optics : OpticalSystem\n        The optical system with the optical layers loaded.\n    \"\"\"\n    # Inputs checks\n    aperture_diameter = np.asarray(aperture_diameter, dtype=float)\n    assert aperture_diameter.ndim == 0, (\"aperture_diameter must be scalar.\")\n\n    assert isinstance(wavefront_npixels, int), \\\n    (\"wavefront_npixels must be an integer.\")\n\n    assert isinstance(detector_npixels, int), \\\n    (\"detector_npixels must be an integer.\")\n    detector_pixel_size = np.asarray(detector_pixel_size, dtype=float)\n\n    assert detector_pixel_size.ndim == 0, \\\n    (\"detector_pixel_size must be scalar.\")\n\n    assert isinstance(angular, bool), (\"angular must be a boolean.\")\n\n    if not angular:\n        focal_length = np.asarray(focal_length, dtype=float)\n        assert focal_length.ndim == 0, (\"focal_length must be scalar.\")\n\n    if secondary_mirror_diameter is not None:\n        secondary_mirror_diameter = np.asarray(secondary_mirror_diameter, \\\n                                               dtype=float)\n        assert secondary_mirror_diameter.ndim == 0, \\\n        (\"focal_length must be scalar.\")\n\n    if nzernike is not None:\n        assert isinstance(nzernike, int), (\"nzernike must an integer.\")\n\n    if zernike_coefficients is not None:\n        zernike_coefficients = np.asarray(zernike_coefficients, dtype=float)\n        assert zernike_coefficients.ndim == 1, \\\n        (\"zernike_coefficients must a one dimensional array.\")\n        assert len(zernike_coefficients) == nzernike, \\\n        (\"The lenght of zernike_coefficients must be equal to nzerike.\")\n\n    if extra_layers is not None:\n        assert isinstance(extra_layers, list), (\"extra_layers must be a list.\")\n        for layer in extra_layers:\n            assert isinstance(layer, dLux.optics.OpticalLayer), \\\n            (\"Each item in extra_layers must be a dLux OpticalLayer.\")\n\n    assert isinstance(return_layers, bool), \"return_layers must be a boolean.\"\n\n    # Create wavefront\n    if angular:\n        layers = [dLux.optics.CreateWavefront(wavefront_npixels,\n                                              aperture_diameter,\n                                              wavefront_type=\"Angular\")]\n    else:\n        layers = [dLux.optics.CreateWavefront(wavefront_npixels,\n                                              aperture_diameter)]\n\n    # Construct aperture\n    if secondary_mirror_diameter is not None:\n        secondary_ratio = secondary_mirror_diameter/aperture_diameter\n    else:\n        secondary_ratio = 0.\n\n    if nzernike is not None:\n        zernikes = np.arange(3, nzernike + 3)\n        if zernike_coefficients is not None:\n            coeffs = zernike_coefficients\n        else:\n            coeffs = np.zeros(nzernike)\n    else:\n        zernikes = None\n        coeffs = None\n\n    layers +=[dLux.ApertureFactory(wavefront_npixels, \n                secondary_ratio=secondary_ratio, zernikes=zernikes, \n                coefficients=coeffs)]\n\n    # Extra Layers\n    if extra_layers is not None:\n        for layer in extra_layers:\n            layers.append(layer)\n\n    # Normalised wavefront\n    layers += [dLux.NormaliseWavefront()]\n\n    # Propagator\n    if angular:\n        layers += [dLux.AngularMFT(detector_npixels,\n                        dLux.utils.arcseconds_to_radians(detector_pixel_size))]\n    else:\n        layers += [dLux.CartesianMFT(detector_npixels, detector_pixel_size,\n                                   focal_length)]\n\n    # Return optics or layers\n    return layers if return_layers else dLux.core.Optics(layers)\n</code></pre>"},{"location":"docs/API/models/#dLux.utils.models.simple_optical_system","title":"Models","text":""},{"location":"docs/API/observations/","title":"Observations","text":"<p>The observations class is designed to give users complete control over how the instrument is modelled. It is designed to be used in conjunction with the <code>Instrument</code> class and stored as one of its class attributes. There is one main class <code>AbstractObservation</code> that is designed to be subclassed. Users can create custom observations by inheriting from <code>AbstractObservation</code> and implementing the <code>observe</code> method. Lets take a look at an example observation class. Lets say we wanted to model the response of some instrument over two different band-passes. We could do this by creating a custom observation class:</p> <pre><code>import dLux as dl\nfrom jax import Array, numpy as np\n\nclass TwoFilterObservation(dl.AbstractObservation):\n    filter1 : Array\n    filter2 : Array\n\n    def __init__(self, filter1, filter2):\n\"\"\"Constructs the observation class\"\"\"\n        super().__init__(name='TwoFilterObservation')\n        self.filter1 = np.asarray(filter1, dtype=float)\n        self.filter2 = np.asarray(filter2, dtype=float)\n\n    def observe(self, instrument):\n\"\"\"Models the instrument over two different band-passes\"\"\"\n\n        # Model first PSF\n        instrument = instrument.set('PointSource.wavelengths', self.filter1)\n        psf1 = instrument.model()\n\n        # Model second PSF\n        instrument = instrument.set('PointSource.wavelengths', self.filter2)\n        psf2 = instrument.model()\n\n        return psf1, psf2\n\nfilter1 = 1e-6 * np.linspace(1., 1.5, 10)\nfilter2 = 1e-6 * np.linspace(1.5, 2., 10)\nobservation = TwoFilterObservation(filter1, filter2)\n</code></pre> <p>We then load this into the instrument class:</p> <pre><code># Define the parameters of the optical system\naperture_diameter = 1.0  # meters\npixel_scale       = 2e-7 # Radians per pixel of the detector\naperture_npixels  = 256  # Number of pixels representing the wavefront\ndetector_npixels  = 64   # Number of pixels in the detector\n\n# Define a simple optical system\nlayers = [\n    dl.CreateWavefront(aperture_npixels, aperture_diameter),\n    dl.ApertureFactory(aperture_npixels, name='Aperture'),\n    dl.NormaliseWavefront(),\n    dl.AngularMFT(detector_npixels, pixel_scale, name='Propagator'),\n]\n\n# Create the Optics object\noptics = dl.Optics(layers)\n\n# Create a Point Source\nsource = dl.PointSource(wavelengths=filter1)\n\n# Create the Telescope object\ntelescope = dl.Instrument(optics, source, observation=observation)\n\n# Models the two PSFs\npsf1, psf2 = telescope.observe()\n</code></pre> Plotting code <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Filter 1\")\nplt.imshow(psf1)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.title(\"Filter 2\")\nplt.imshow(psf2)\nplt.colorbar()\nplt.tight_layout()\nplt.savefig(\"assets/observation.png\")\n</code></pre> <p></p> <p>This is a relatively simple example, but shows the flexibilty that can be gained with this class! It can also be used to remove redunancies in calcualtions. Say you wanted to model multiple sources through the same instrument that are separated by a large on-sky angle that still fall on detector, rather than model the full array we can model only the regions that we care about in order to save a lot of redundant compute!</p> <p>Acessing Parameters</p> <p>The <code>AbstractObservation</code> class has a built in <code>__getattr__</code> class that allows for its parameters to be accessed from high level classes like <code>Instrument</code>. That means if we wanted to access the <code>filter1</code> parameter we could do so like this:</p> <pre><code>filt = telescope.filter1\n</code></pre> <p>As opposed to the longer:</p> <pre><code>filt = telescope.observation.filter1\n</code></pre>"},{"location":"docs/API/observations/#abstract-observation","title":"Abstract Observation","text":"<p>The base class that all user-created observations should inherit from.</p> Abstract Observation API <p>         Bases: <code>Base</code></p> <p>Abstract base class for observations. All observations should inherit from this class and must implement an <code>.observe()</code> method that only takes in a single instance of <code>dLux.Instrument</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> Source code in <code>dLux/observations.py</code> <pre><code>class AbstractObservation(Base):\n\"\"\"\n    Abstract base class for observations. All observations should inherit from\n    this class and must implement an `.observe()` method that only takes in a\n    single instance of `dLux.Instrument`.\n\n    Attributes\n    ----------\n    name : str\n        The name of the observation that can be used to access the observation\n        from the `Instrument` class.\n    \"\"\"\n    name : str\n\n\n    def __init__(self : AbstractObservation, \n                 name : str = 'AbstractObservation'):\n\"\"\"\n        Constructor for the AbstractObservation class.\n\n        Parameters\n        ----------\n        name : str = 'AbstractObservation'\n            The name of the observation that can be used to access the\n            observation from the `Instrument` class.\n        \"\"\"\n        self.name = str(name)\n\n\n    @abstractmethod\n    def observe(self       : AbstractObservation, \n                instrument : dLux.core.Instrument) -&gt; Any:\n\"\"\"\n        Abstract method for the observation function.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.AbstractObservation.__init__","title":"<code>__init__(name='AbstractObservation')</code>","text":"<p>Constructor for the AbstractObservation class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> <code>'AbstractObservation'</code> Source code in <code>dLux/observations.py</code> <pre><code>def __init__(self : AbstractObservation, \n             name : str = 'AbstractObservation'):\n\"\"\"\n    Constructor for the AbstractObservation class.\n\n    Parameters\n    ----------\n    name : str = 'AbstractObservation'\n        The name of the observation that can be used to access the\n        observation from the `Instrument` class.\n    \"\"\"\n    self.name = str(name)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.AbstractObservation.observe","title":"<code>observe(instrument)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the observation function.</p> Source code in <code>dLux/observations.py</code> <pre><code>@abstractmethod\ndef observe(self       : AbstractObservation, \n            instrument : dLux.core.Instrument) -&gt; Any:\n\"\"\"\n    Abstract method for the observation function.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.AbstractObservation","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.AbstractObservation.__init__","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.AbstractObservation.observe","title":"Observations","text":""},{"location":"docs/API/observations/#dither","title":"Dither","text":"<p>A simple dither observation class that models the instrument over a grid of relative pointings.</p> Dither API <p>         Bases: <code>AbstractObservation</code></p> <p>Observation class designed to apply a series of dithers to the insturment and return the corresponding psfs.</p> <p>Attributes:</p> Name Type Description <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> Source code in <code>dLux/observations.py</code> <pre><code>class Dither(AbstractObservation):\n\"\"\"\n    Observation class designed to apply a series of dithers to the insturment\n    and return the corresponding psfs.\n\n    Attributes\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of the\n        array should be (ndithers, 2) where ndithers is the number of dithers\n        and the second dimension is the (x, y) dither in radians.\n    name : str\n        The name of the observation that can be used to access the observation\n        from the `Instrument` class.\n    \"\"\"\n    dithers : Array\n\n\n    def __init__(self : Dither, dithers : Array, name : str = 'Dither'):\n\"\"\"\n        Constructor for the Dither class.\n\n        Parameters\n        ----------\n        dithers : Array, (radians)\n            The array of dithers to apply to the source positions. The shape of\n            the array should be (ndithers, 2) where ndithers is the number of\n            dithers and the second dimension is the (x, y) dither in radians.\n        name : str = 'Dither'\n            The name of the observation that can be used to access the\n            observation from the `Instrument` class.\n        \"\"\"\n        super().__init__(name)\n        self.dithers = np.asarray(dithers, float)\n        dLux.exceptions.validate_bc_attr_dims(self.dithers.shape, (1, 2), \n            'dithers')\n\n\n    def dither_position(self       : Dither, \n                        instrument : Instrument, \n                        dither     : Array) -&gt; Instrument:\n\"\"\"\n        Dithers the position of the source objects by dither.\n\n        Parameters\n        ----------\n        dither : Array, radians\n            The (x, y) dither to apply to the source positions.\n\n        Returns\n        -------\n        instrument : Instrument\n            The instrument with the sources dithered.\n        \"\"\"\n        assert dither.shape == (2,), (\"dither must have shape (2,) ie (x, y)\")\n\n        # Define the dither function\n        dither_fn = lambda source: source.add('position', dither)\n\n        # Map the dithers across the sources\n        dithered_sources = tree_map(dither_fn, instrument.sources, \\\n            is_leaf = lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n        # Apply updates\n        return tree_at(lambda instrument: instrument.sources, instrument, \n            dithered_sources)\n\n\n    def observe(self       : Dither,\n                instrument : Instrument,\n                *args, \n                **kwargs) -&gt; Array:\n\"\"\"\n        Applies a series of dithers to the instrument sources and calls the\n        .model() method after applying each dither.\n\n        Parameters\n        ----------\n        instrument : Instrument\n            The array of dithers to apply to the source positions.\n\n        Returns\n        -------\n        psfs : Array\n            The psfs generated after applying the dithers to the source\n            positions.\n        \"\"\"\n        dith_fn = lambda dither: self.dither_position(instrument, \n            dither).model(*args, **kwargs)\n        return vmap(dith_fn, 0)(self.dithers)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.__init__","title":"<code>__init__(dithers, name='Dither')</code>","text":"<p>Constructor for the Dither class.</p> <p>Parameters:</p> Name Type Description Default <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> required <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> <code>'Dither'</code> Source code in <code>dLux/observations.py</code> <pre><code>def __init__(self : Dither, dithers : Array, name : str = 'Dither'):\n\"\"\"\n    Constructor for the Dither class.\n\n    Parameters\n    ----------\n    dithers : Array, (radians)\n        The array of dithers to apply to the source positions. The shape of\n        the array should be (ndithers, 2) where ndithers is the number of\n        dithers and the second dimension is the (x, y) dither in radians.\n    name : str = 'Dither'\n        The name of the observation that can be used to access the\n        observation from the `Instrument` class.\n    \"\"\"\n    super().__init__(name)\n    self.dithers = np.asarray(dithers, float)\n    dLux.exceptions.validate_bc_attr_dims(self.dithers.shape, (1, 2), \n        'dithers')\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.dither_position","title":"<code>dither_position(instrument, dither)</code>","text":"<p>Dithers the position of the source objects by dither.</p> <p>Parameters:</p> Name Type Description Default <code>dither</code> <code>Array, radians</code> <p>The (x, y) dither to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>instrument</code> <code>Instrument</code> <p>The instrument with the sources dithered.</p> Source code in <code>dLux/observations.py</code> <pre><code>def dither_position(self       : Dither, \n                    instrument : Instrument, \n                    dither     : Array) -&gt; Instrument:\n\"\"\"\n    Dithers the position of the source objects by dither.\n\n    Parameters\n    ----------\n    dither : Array, radians\n        The (x, y) dither to apply to the source positions.\n\n    Returns\n    -------\n    instrument : Instrument\n        The instrument with the sources dithered.\n    \"\"\"\n    assert dither.shape == (2,), (\"dither must have shape (2,) ie (x, y)\")\n\n    # Define the dither function\n    dither_fn = lambda source: source.add('position', dither)\n\n    # Map the dithers across the sources\n    dithered_sources = tree_map(dither_fn, instrument.sources, \\\n        is_leaf = lambda leaf: isinstance(leaf, dLux.sources.Source))\n\n    # Apply updates\n    return tree_at(lambda instrument: instrument.sources, instrument, \n        dithered_sources)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither.observe","title":"<code>observe(instrument, *args, **kwargs)</code>","text":"<p>Applies a series of dithers to the instrument sources and calls the .model() method after applying each dither.</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>Instrument</code> <p>The array of dithers to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>psfs</code> <code>Array</code> <p>The psfs generated after applying the dithers to the source positions.</p> Source code in <code>dLux/observations.py</code> <pre><code>def observe(self       : Dither,\n            instrument : Instrument,\n            *args, \n            **kwargs) -&gt; Array:\n\"\"\"\n    Applies a series of dithers to the instrument sources and calls the\n    .model() method after applying each dither.\n\n    Parameters\n    ----------\n    instrument : Instrument\n        The array of dithers to apply to the source positions.\n\n    Returns\n    -------\n    psfs : Array\n        The psfs generated after applying the dithers to the source\n        positions.\n    \"\"\"\n    dith_fn = lambda dither: self.dither_position(instrument, \n        dither).model(*args, **kwargs)\n    return vmap(dith_fn, 0)(self.dithers)\n</code></pre>"},{"location":"docs/API/observations/#dLux.observations.Dither","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.__init__","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.dither_position","title":"Observations","text":""},{"location":"docs/API/observations/#dLux.observations.Dither.observe","title":"Observations","text":""},{"location":"docs/API/optics/","title":"Optics","text":"<p>The <code>optics.py</code> script contains the general <code>OpticalLayer</code> classes. The main class is <code>OpticalLayer</code> which is the base class for all other optical layers, including those in <code>apertures.py</code>, <code>aberrations.py</code> and <code>propagators.py</code>. Unless you are creating a new optical layer, you will not need to use this class directly.</p>"},{"location":"docs/API/optics/#create-wavefront","title":"Create Wavefront","text":"<p>This layer should be the first layer of almost all set of optical layers. It is used to initialise the wavefront object by specifying the number of pixels and the diameter of the wavefront.</p> CreateWavefront API <p>         Bases: <code>OpticalLayer</code></p> <p>Initialises the relevant Wavefront class with the specified attributes. Also applies the tilt specified by the source object, defined in the parameters dictionary. All wavefronts are cosntructed in the Pupil plane.</p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels used to represent the wavefront.</p> <code>diameter</code> <code>Array, meters</code> <p>The diameter of the wavefront in the Pupil plane.</p> <code>wavefront_type</code> <code>str</code> <p>Determines the type of wavefront class to create. Currently supports 'Cartesian', 'Angular', 'FarFieldFresnel'.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class CreateWavefront(OpticalLayer):\n\"\"\"\n    Initialises the relevant Wavefront class with the specified attributes.\n    Also applies the tilt specified by the source object, defined in the\n    parameters dictionary. All wavefronts are cosntructed in the Pupil plane.\n\n    Attributes\n    ----------\n    npixels : int\n        The number of pixels used to represent the wavefront.\n    diameter: Array, meters\n        The diameter of the wavefront in the Pupil plane.\n    wavefront_type: str\n        Determines the type of wavefront class to create. Currently supports\n        'Cartesian', 'Angular', 'FarFieldFresnel'.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    npixels        : int\n    diameter       : Array\n    wavefront_type : str\n\n\n    def __init__(self           : OpticalLayer,\n                 npixels        : int,\n                 diameter       : Array,\n                 wavefront_type : str = 'Angular',\n                 name           : str = 'CreateWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the CreateWavefront class.\n\n        Parameters\n        ----------\n        npixels : int\n            The number of pixels used to represent the wavefront.\n        diameter: Array, meters\n            The diameter of the wavefront in the Pupil plane.\n        wavefront_type: str = 'Angular'\n            Determines the type of wavefront class to create. Currently supports\n            'Cartesian', 'Angular', 'FarFieldFresnel'.\n        name : str = 'CreateWavefront'\n            The name of the layer, which is used to index the layers dictionary.\n            Default is 'CreateWavefront'.\n        \"\"\"\n        super().__init__(name)\n        self.npixels        = int(npixels)\n        self.diameter       = np.asarray(diameter, dtype=float)\n        self.wavefront_type = str(wavefront_type)\n\n        # Input checks\n        assert self.diameter.ndim == 0, (\"diameter must be \"\n        \"a scalar array.\")\n        assert wavefront_type in ('Cartesian', 'Angular', 'FarFieldFresnel'), \\\n        (\"wavefront_type must be either 'Cartesian', 'Angular' or \"\n         \"'FarFieldFresnel'\")\n\n\n    def __call__(self               : OpticalLayer,\n                 wavefront          : Wavefront,\n                 parameters         : dict,\n                 returns_parameters : bool = True) -&gt; Wavefront:\n\"\"\"\n        Constructs a wavefront obect based on the parameters of the class and\n        the parameters within the parameters dictionary.\n\n        Parameters\n        ----------\n        wavefront : None\n            Any empty None type input to the class in order to maintain the\n            input conventions determied by the apply method of OpticalLayers.\n        parameters : dict\n            A dictionary of parameters needed to construct the wavefront.\n        returns_parameters : bool = True\n            Determines if the class returns the parameters dictionary.\n\n        Returns\n        -------\n        wavefront, parameters : (Wavefront, dict)\n            Returns the constructed wavefront and the updated parameters\n            dictionary. If returns_parameters is False, only the wavefront is\n            returned.\n        \"\"\"\n        # Get the wavelength\n        wavelength = parameters[\"wavelength\"]\n\n        # Determine the pixel scale\n        pixel_scale = self.diameter/self.npixels\n\n        # Construct normalised Amplitude\n        amplitude = np.ones((1, self.npixels, self.npixels))\n        amplitude /= np.linalg.norm(amplitude)\n\n        # Construct empty phases\n        phase = np.zeros(((1, self.npixels, self.npixels)))\n\n        # Get correct Wavefront type\n        wavefront_constructor = getattr(dLux.wavefronts,\n                                        self.wavefront_type + \"Wavefront\")\n\n        # Construct Wavefront\n        wavefront = wavefront_constructor(wavelength, pixel_scale, amplitude,\n                                      phase, dLux.wavefronts.PlaneType.Pupil)\n\n        # Tilt wavefront from source offset\n        wavefront = wavefront.tilt_wavefront(parameters[\"offset\"])\n\n        # Kill PlaneType Gradients\n        is_leaf = lambda x: isinstance(x, dLux.wavefronts.PlaneType)\n        kill_gradient = lambda x: stop_gradient(x.value) if is_leaf(x) else x\n        wavefront = tree_map(kill_gradient, wavefront, is_leaf=is_leaf)\n\n        # Update the parameters dictionary with the constructed wavefront\n        parameters[\"Wavefront\"] = wavefront\n\n        # Return either the wavefront or wavefront and parameters dictionary\n        if returns_parameters:\n            return wavefront, parameters\n        else:\n            return wavefront\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Creates a {self.wavefront_type} wavefront of \" \n                f\"size {self.npixels} pixels and diameter {self.diameter} m.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.__call__","title":"<code>__call__(wavefront, parameters, returns_parameters=True)</code>","text":"<p>Constructs a wavefront obect based on the parameters of the class and the parameters within the parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>None</code> <p>Any empty None type input to the class in order to maintain the input conventions determied by the apply method of OpticalLayers.</p> required <code>parameters</code> <code>dict</code> <p>A dictionary of parameters needed to construct the wavefront.</p> required <code>returns_parameters</code> <code>bool</code> <p>Determines if the class returns the parameters dictionary.</p> <code>True</code> <p>Returns:</p> Type Description <code>wavefront, parameters</code> <p>Returns the constructed wavefront and the updated parameters dictionary. If returns_parameters is False, only the wavefront is returned.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self               : OpticalLayer,\n             wavefront          : Wavefront,\n             parameters         : dict,\n             returns_parameters : bool = True) -&gt; Wavefront:\n\"\"\"\n    Constructs a wavefront obect based on the parameters of the class and\n    the parameters within the parameters dictionary.\n\n    Parameters\n    ----------\n    wavefront : None\n        Any empty None type input to the class in order to maintain the\n        input conventions determied by the apply method of OpticalLayers.\n    parameters : dict\n        A dictionary of parameters needed to construct the wavefront.\n    returns_parameters : bool = True\n        Determines if the class returns the parameters dictionary.\n\n    Returns\n    -------\n    wavefront, parameters : (Wavefront, dict)\n        Returns the constructed wavefront and the updated parameters\n        dictionary. If returns_parameters is False, only the wavefront is\n        returned.\n    \"\"\"\n    # Get the wavelength\n    wavelength = parameters[\"wavelength\"]\n\n    # Determine the pixel scale\n    pixel_scale = self.diameter/self.npixels\n\n    # Construct normalised Amplitude\n    amplitude = np.ones((1, self.npixels, self.npixels))\n    amplitude /= np.linalg.norm(amplitude)\n\n    # Construct empty phases\n    phase = np.zeros(((1, self.npixels, self.npixels)))\n\n    # Get correct Wavefront type\n    wavefront_constructor = getattr(dLux.wavefronts,\n                                    self.wavefront_type + \"Wavefront\")\n\n    # Construct Wavefront\n    wavefront = wavefront_constructor(wavelength, pixel_scale, amplitude,\n                                  phase, dLux.wavefronts.PlaneType.Pupil)\n\n    # Tilt wavefront from source offset\n    wavefront = wavefront.tilt_wavefront(parameters[\"offset\"])\n\n    # Kill PlaneType Gradients\n    is_leaf = lambda x: isinstance(x, dLux.wavefronts.PlaneType)\n    kill_gradient = lambda x: stop_gradient(x.value) if is_leaf(x) else x\n    wavefront = tree_map(kill_gradient, wavefront, is_leaf=is_leaf)\n\n    # Update the parameters dictionary with the constructed wavefront\n    parameters[\"Wavefront\"] = wavefront\n\n    # Return either the wavefront or wavefront and parameters dictionary\n    if returns_parameters:\n        return wavefront, parameters\n    else:\n        return wavefront\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.__init__","title":"<code>__init__(npixels, diameter, wavefront_type='Angular', name='CreateWavefront')</code>","text":"<p>Constructor for the CreateWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels used to represent the wavefront.</p> required <code>diameter</code> <code>Array</code> <p>The diameter of the wavefront in the Pupil plane.</p> required <code>wavefront_type</code> <code>str</code> <p>Determines the type of wavefront class to create. Currently supports 'Cartesian', 'Angular', 'FarFieldFresnel'.</p> <code>'Angular'</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary. Default is 'CreateWavefront'.</p> <code>'CreateWavefront'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self           : OpticalLayer,\n             npixels        : int,\n             diameter       : Array,\n             wavefront_type : str = 'Angular',\n             name           : str = 'CreateWavefront') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the CreateWavefront class.\n\n    Parameters\n    ----------\n    npixels : int\n        The number of pixels used to represent the wavefront.\n    diameter: Array, meters\n        The diameter of the wavefront in the Pupil plane.\n    wavefront_type: str = 'Angular'\n        Determines the type of wavefront class to create. Currently supports\n        'Cartesian', 'Angular', 'FarFieldFresnel'.\n    name : str = 'CreateWavefront'\n        The name of the layer, which is used to index the layers dictionary.\n        Default is 'CreateWavefront'.\n    \"\"\"\n    super().__init__(name)\n    self.npixels        = int(npixels)\n    self.diameter       = np.asarray(diameter, dtype=float)\n    self.wavefront_type = str(wavefront_type)\n\n    # Input checks\n    assert self.diameter.ndim == 0, (\"diameter must be \"\n    \"a scalar array.\")\n    assert wavefront_type in ('Cartesian', 'Angular', 'FarFieldFresnel'), \\\n    (\"wavefront_type must be either 'Cartesian', 'Angular' or \"\n     \"'FarFieldFresnel'\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Creates a {self.wavefront_type} wavefront of \" \n            f\"size {self.npixels} pixels and diameter {self.diameter} m.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.CreateWavefront","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.CreateWavefront.summary","title":"Optics","text":""},{"location":"docs/API/optics/#normalise-wavefront","title":"Normalise Wavefront","text":"<p>This layer is used to normalise the wavefront to a unit intensity. This simply controls at what point the wavefront is normalised to unity power. Since most calculations in optics use the collecting area of the aperture, most use cases will require this layer at some point after an aperture layer.</p> NormaliseWavefront API <p>         Bases: <code>OpticalLayer</code></p> <p>Normalises the input wavefront using the in-built wavefront normalisation method.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class NormaliseWavefront(OpticalLayer):\n\"\"\"\n    Normalises the input wavefront using the in-built wavefront normalisation\n    method.\n\n    Attributes\n    ----------\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n\n\n    def __init__(self : OpticalLayer,\n                 name : str = 'NormaliseWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the NormaliseWavefront class.\n\n        Parameters\n        ----------\n        name : string = 'NormaliseWavefront'\n            The name of the layer, which is used to index the layers\n            dictionary.\n        \"\"\"\n        super().__init__(name)\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the wavefront normalisation method applied.\n        \"\"\"\n        return wavefront.normalise()\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Normalises the wavefront to unity power.\"\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Normalises the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the wavefront normalisation method applied.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Normalises the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the wavefront normalisation method applied.\n    \"\"\"\n    return wavefront.normalise()\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.__init__","title":"<code>__init__(name='NormaliseWavefront')</code>","text":"<p>Constructor for the NormaliseWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'NormaliseWavefront'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self : OpticalLayer,\n             name : str = 'NormaliseWavefront') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the NormaliseWavefront class.\n\n    Parameters\n    ----------\n    name : string = 'NormaliseWavefront'\n        The name of the layer, which is used to index the layers\n        dictionary.\n    \"\"\"\n    super().__init__(name)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return f\"{self.name}: Normalises the wavefront to unity power.\"\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.NormaliseWavefront.summary","title":"Optics","text":""},{"location":"docs/API/optics/#tilt-wavefront","title":"Tilt Wavefront","text":"<p>This class is used to tilt the wavefront by a specified angle in radians.</p> TiltWavefront API <p>         Bases: <code>OpticalLayer</code></p> <p>Tilts the wavefront by the input tilt_angles.</p> <p>Attributes:</p> Name Type Description <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class TiltWavefront(OpticalLayer):\n\"\"\"\n    Tilts the wavefront by the input tilt_angles.\n\n    Attributes\n    ----------\n    tilt_angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    tilt_angles : Array\n\n\n    def __init__(self        : OpticalLayer,\n                 tilt_angles : Array,\n                 name        : str = 'TiltWavefront') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TiltWavefront class.\n\n        Parameters\n        ----------\n        tilt_angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n        name : str = TiltWavefront\n            The name of the layer, which is used to index the layers dictionary.\n            Default is 'TiltWavefront'.\n        \"\"\"\n        super().__init__(name)\n        self.tilt_angles = np.asarray(tilt_angles, dtype=float)\n\n        # Input checks\n        assert self.tilt_angles.shape == (2,), \\\n        (\"tilt_angles must be an array of shape (2,), ie (x, y).\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the tilt_angle to the phase of the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the optical layer applied.\n        \"\"\"\n        return wavefront.tilt_wavefront(self.tilt_angles)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angles = convert_angular(self.tilt_angles, 'radians', angular_units)\n        return (f\"{self.name}: Tilts the wavefront by {angles:.{sigfigs}} \"\n                f\"{angular_units} in the (x, y) dimension.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the tilt_angle to the phase of the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the optical layer applied.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the tilt_angle to the phase of the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the optical layer applied.\n    \"\"\"\n    return wavefront.tilt_wavefront(self.tilt_angles)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.__init__","title":"<code>__init__(tilt_angles, name='TiltWavefront')</code>","text":"<p>Constructor for the TiltWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary. Default is 'TiltWavefront'.</p> <code>'TiltWavefront'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self        : OpticalLayer,\n             tilt_angles : Array,\n             name        : str = 'TiltWavefront') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the TiltWavefront class.\n\n    Parameters\n    ----------\n    tilt_angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n    name : str = TiltWavefront\n        The name of the layer, which is used to index the layers dictionary.\n        Default is 'TiltWavefront'.\n    \"\"\"\n    super().__init__(name)\n    self.tilt_angles = np.asarray(tilt_angles, dtype=float)\n\n    # Input checks\n    assert self.tilt_angles.shape == (2,), \\\n    (\"tilt_angles must be an array of shape (2,), ie (x, y).\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    angles = convert_angular(self.tilt_angles, 'radians', angular_units)\n    return (f\"{self.name}: Tilts the wavefront by {angles:.{sigfigs}} \"\n            f\"{angular_units} in the (x, y) dimension.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TiltWavefront","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TiltWavefront.summary","title":"Optics","text":""},{"location":"docs/API/optics/#transmissive-optic","title":"Transmissive Optic","text":"<p>This layer takes in an array of per-pixel tranmission values and multiplies the wavefront amplitude by these values. Input arrays must be the same size as the wavefront. Values should be between 0 and 1, but this is not enforced.</p> TransmissiveOptic API <p>         Bases: <code>OpticalLayer</code></p> <p>Represents an arbitrary transmissive optic.</p> <p>Note this class does not normalise the 'transmission' between 0 and 1, but simply multiplies the wavefront amplitude by the transmision array.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>An array representing the transmission of the optic.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class TransmissiveOptic(OpticalLayer):\n\"\"\"\n    Represents an arbitrary transmissive optic.\n\n    Note this class does not normalise the 'transmission' between 0 and 1, but\n    simply multiplies the wavefront amplitude by the transmision array.\n\n    Attributes\n    ----------\n    transmission : Array\n        An array representing the transmission of the optic.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    transmission: Array\n\n\n    def __init__(self         : OpticalLayer,\n                 transmission : Array,\n                 name         : str = 'TransmissiveOptic') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the TransmissiveOptic class.\n\n        Parameters\n        ----------\n        transmission : Array\n            The array representing the transmission of the aperture. This must\n            a 0, 2 or 3 dimensional array with equal to that of the wavefront\n            at time of aplication.\n        name : str = 'TransmissiveOptic'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.transmission = np.asarray(transmission, dtype=float)\n\n        # Input checks\n        assert self.transmission.ndim in (0, 2, 3), (\"transmission must be \"\n        \"either a scalar array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the tranmission of the optical to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the tranmission applied.\n        \"\"\"\n        return wavefront.multiply_amplitude(self.transmission)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies an array of tranmission values to the \"\n                \"Wavefront.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the tranmission of the optical to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the tranmission applied.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the tranmission of the optical to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the tranmission applied.\n    \"\"\"\n    return wavefront.multiply_amplitude(self.transmission)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.__init__","title":"<code>__init__(transmission, name='TransmissiveOptic')</code>","text":"<p>Constructor for the TransmissiveOptic class.</p> <p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The array representing the transmission of the aperture. This must a 0, 2 or 3 dimensional array with equal to that of the wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'TransmissiveOptic'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self         : OpticalLayer,\n             transmission : Array,\n             name         : str = 'TransmissiveOptic') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the TransmissiveOptic class.\n\n    Parameters\n    ----------\n    transmission : Array\n        The array representing the transmission of the aperture. This must\n        a 0, 2 or 3 dimensional array with equal to that of the wavefront\n        at time of aplication.\n    name : str = 'TransmissiveOptic'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.transmission = np.asarray(transmission, dtype=float)\n\n    # Input checks\n    assert self.transmission.ndim in (0, 2, 3), (\"transmission must be \"\n    \"either a scalar array, or a 2 or 3 dimensional array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies an array of tranmission values to the \"\n            \"Wavefront.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.TransmissiveOptic.summary","title":"Optics","text":""},{"location":"docs/API/optics/#add-phase","title":"Add Phase","text":"<p>This layer takes in an array of per-pixel phase values in radians and adds it to the wavefront. Input arrays must be the same size as the wavefront.</p> AddPhase API <p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of phase values to the wavefront.</p> <p>Attributes:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class AddPhase(OpticalLayer):\n\"\"\"\n    Adds an array of phase values to the wavefront.\n\n    Attributes\n    ----------\n    phase: Array, radians\n        The Array of phase values to be applied to the input wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    phase : Array\n\n\n    def __init__(self  : OpticalLayer,\n                 phase : Array,\n                 name  : str = 'AddPhase') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the AddPhase class.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            Array of phase values to be applied to the input wavefront. This\n            must a 0, 2 or 3 dimensional array with equal to that of the \n            wavefront at time of aplication.\n        name : str = 'AddPhase'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.phase = np.asarray(phase, dtype=float)\n\n        # Input checks\n        assert self.phase.ndim in (0, 2, 3), (\"phase must be either a scalar \"\n        \"array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Adds the phase to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the phase added.\n        \"\"\"\n        return wavefront.add_phase(self.phase)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return f\"{self.name}: Add an array of phase values to the wavefront.\"\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddPhase.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Adds the phase to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the phase added.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Adds the phase to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the phase added.\n    \"\"\"\n    return wavefront.add_phase(self.phase)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddPhase.__init__","title":"<code>__init__(phase, name='AddPhase')</code>","text":"<p>Constructor for the AddPhase class.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>Array of phase values to be applied to the input wavefront. This must a 0, 2 or 3 dimensional array with equal to that of the  wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddPhase'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self  : OpticalLayer,\n             phase : Array,\n             name  : str = 'AddPhase') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the AddPhase class.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        Array of phase values to be applied to the input wavefront. This\n        must a 0, 2 or 3 dimensional array with equal to that of the \n        wavefront at time of aplication.\n    name : str = 'AddPhase'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.phase = np.asarray(phase, dtype=float)\n\n    # Input checks\n    assert self.phase.ndim in (0, 2, 3), (\"phase must be either a scalar \"\n    \"array, or a 2 or 3 dimensional array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddPhase.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return f\"{self.name}: Add an array of phase values to the wavefront.\"\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddPhase","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddPhase.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddPhase.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddPhase.summary","title":"Optics","text":""},{"location":"docs/API/optics/#add-opd","title":"Add OPD","text":"<p>This layer takes in an array of per-pixel Optical Path Difference (OPD) values in meters and adds it to the wavefront. Input arrays must be the same size as the wavefront.</p> AddOPD API <p>         Bases: <code>OpticalLayer</code></p> <p>Adds an Optical Path Difference (OPD) to the wavefront.</p> <p>Attributes:</p> Name Type Description <code>opd</code> <code>Array, meters</code> <p>Array of OPD values to be applied to the input wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class AddOPD(OpticalLayer):\n\"\"\"\n    Adds an Optical Path Difference (OPD) to the wavefront.\n\n    Attributes\n    ----------\n    opd : Array, meters\n        Array of OPD values to be applied to the input wavefront.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    opd : Array\n\n\n    def __init__(self : OpticalLayer,\n                 opd  : Array,\n                 name : str = 'AddOPD') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyOPD class.\n\n        Parameters\n        ----------\n        opd : float, meters\n            The Array of OPDs to be applied to the input wavefront. This must\n            a 0, 2 or 3 dimensional array with equal to that of the wavefront\n            at time of aplication.\n        name : str = 'AddOPD'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.opd = np.asarray(opd, dtype=float)\n\n        # Input checks\n        assert self.opd.ndim in (0, 2, 3), (\"opd must be either a scalar \"\n        \"array, or a 2 or 3 dimensional array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Apply the OPD array to the input wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the OPD added.\n        \"\"\"\n        return wavefront.add_opd(self.opd)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Add an array of Optical Path Differences (OPD) \"\n                \"to the wavefront.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddOPD.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the OPD array to the input wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the OPD added.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Apply the OPD array to the input wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the OPD added.\n    \"\"\"\n    return wavefront.add_opd(self.opd)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddOPD.__init__","title":"<code>__init__(opd, name='AddOPD')</code>","text":"<p>Constructor for the ApplyOPD class.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>float, meters</code> <p>The Array of OPDs to be applied to the input wavefront. This must a 0, 2 or 3 dimensional array with equal to that of the wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddOPD'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self : OpticalLayer,\n             opd  : Array,\n             name : str = 'AddOPD') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the ApplyOPD class.\n\n    Parameters\n    ----------\n    opd : float, meters\n        The Array of OPDs to be applied to the input wavefront. This must\n        a 0, 2 or 3 dimensional array with equal to that of the wavefront\n        at time of aplication.\n    name : str = 'AddOPD'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.opd = np.asarray(opd, dtype=float)\n\n    # Input checks\n    assert self.opd.ndim in (0, 2, 3), (\"opd must be either a scalar \"\n    \"array, or a 2 or 3 dimensional array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddOPD.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Add an array of Optical Path Differences (OPD) \"\n            \"to the wavefront.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.AddOPD","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddOPD.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddOPD.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.AddOPD.summary","title":"Optics","text":""},{"location":"docs/API/optics/#apply-basis-opd","title":"Apply Basis OPD","text":"<p>This layer takes in a set of basis vectors and (optionally) coefficients, which is then used to calculate the total OPD and adds the resulting OPD to the wavefront. The basis vectors should have three dimensions and the coefficients one. This can be used to add a set of (typically) Zernike polynomials to the wavefront, although any set of basis vectors can be used.</p> ApplyBasisOPD API <p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of phase values to the input wavefront calculated from the Optical Path Difference (OPD). The OPDs are calculated from the basis arrays, and weighted by the coefficients, and converted to phases by the wavefront methods.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>Array, meters</code> <p>Arrays holding the pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class ApplyBasisOPD(OpticalLayer):\n\"\"\"\n    Adds an array of phase values to the input wavefront calculated from the\n    Optical Path Difference (OPD). The OPDs are calculated from the basis\n    arrays, and weighted by the coefficients, and converted to phases by the\n    wavefront methods.\n\n    Attributes\n    ----------\n    basis: Array, meters\n        Arrays holding the pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis        : Array\n    coefficients : Array\n\n\n    def __init__(self         : OpticalLayer,\n                 basis        : Array,\n                 coefficients : Array = None,\n                 name         : str = 'ApplyBasisOPD') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyBasisOPD class.\n\n        Parameters\n        ----------\n        basis : Array, meters\n            The Array of basis polynomials. This should be a 3 dimensional Array\n            with the first dimension being the number of basis vectors, and the\n            last two dimensions being equal to the wavefront shape at the time\n            of application to the wavefront.\n        coefficients : Array = None\n            The coefficients by which to weight the basis vectors. This must\n            have the same length as the first dimension of the basis Array. If\n            None is supplied an Array of zeros is constructed.\n        name : str = 'ApplyBasisOPD'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.basis        = np.asarray(basis, dtype=float)\n        self.coefficients = np.zeros(basis.shape[0]) if coefficients is None \\\n                            else np.asarray(coefficients, dtype=float)\n\n        # Input checks\n        assert self.basis.ndim == 3, \\\n        (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n        assert self.coefficients.ndim == 1 and \\\n        self.coefficients.shape[0] == self.basis.shape[0], \\\n        (\"coefficients must be a 1 dimensional array with length equal to the \"\n        \"First dimension of the basis array.\")\n\n\n    def get_opd(self : OpticalLayer) -&gt; Array:\n\"\"\"\n        A function to calculate the total OPD from the basis vector and the\n        coefficients.\n\n        Returns\n        -------\n        OPD : Array, meters\n            The total OPD calulated from the basis vectors and coefficients.\n        \"\"\"\n        return np.dot(self.basis.T, self.coefficients)\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\n\"\"\"\n        Calculate and apply the appropriate phase shift to the wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the appropriate phase applied.\n        \"\"\"\n        return wavefront.add_opd(self.get_opd())\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies an Optical Path Difference (OPD) to the \"\n            f\"wavefront calculated from the basis vectors and coefficients.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Calculate and apply the appropriate phase shift to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the appropriate phase applied.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\n\"\"\"\n    Calculate and apply the appropriate phase shift to the wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the appropriate phase applied.\n    \"\"\"\n    return wavefront.add_opd(self.get_opd())\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.__init__","title":"<code>__init__(basis, coefficients=None, name='ApplyBasisOPD')</code>","text":"<p>Constructor for the ApplyBasisOPD class.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array, meters</code> <p>The Array of basis polynomials. This should be a 3 dimensional Array with the first dimension being the number of basis vectors, and the last two dimensions being equal to the wavefront shape at the time of application to the wavefront.</p> required <code>coefficients</code> <code>Array</code> <p>The coefficients by which to weight the basis vectors. This must have the same length as the first dimension of the basis Array. If None is supplied an Array of zeros is constructed.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyBasisOPD'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self         : OpticalLayer,\n             basis        : Array,\n             coefficients : Array = None,\n             name         : str = 'ApplyBasisOPD') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the ApplyBasisOPD class.\n\n    Parameters\n    ----------\n    basis : Array, meters\n        The Array of basis polynomials. This should be a 3 dimensional Array\n        with the first dimension being the number of basis vectors, and the\n        last two dimensions being equal to the wavefront shape at the time\n        of application to the wavefront.\n    coefficients : Array = None\n        The coefficients by which to weight the basis vectors. This must\n        have the same length as the first dimension of the basis Array. If\n        None is supplied an Array of zeros is constructed.\n    name : str = 'ApplyBasisOPD'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.basis        = np.asarray(basis, dtype=float)\n    self.coefficients = np.zeros(basis.shape[0]) if coefficients is None \\\n                        else np.asarray(coefficients, dtype=float)\n\n    # Input checks\n    assert self.basis.ndim == 3, \\\n    (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n    assert self.coefficients.ndim == 1 and \\\n    self.coefficients.shape[0] == self.basis.shape[0], \\\n    (\"coefficients must be a 1 dimensional array with length equal to the \"\n    \"First dimension of the basis array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.get_opd","title":"<code>get_opd()</code>","text":"<p>A function to calculate the total OPD from the basis vector and the coefficients.</p> <p>Returns:</p> Name Type Description <code>OPD</code> <code>Array, meters</code> <p>The total OPD calulated from the basis vectors and coefficients.</p> Source code in <code>dLux/optics.py</code> <pre><code>def get_opd(self : OpticalLayer) -&gt; Array:\n\"\"\"\n    A function to calculate the total OPD from the basis vector and the\n    coefficients.\n\n    Returns\n    -------\n    OPD : Array, meters\n        The total OPD calulated from the basis vectors and coefficients.\n    \"\"\"\n    return np.dot(self.basis.T, self.coefficients)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies an Optical Path Difference (OPD) to the \"\n        f\"wavefront calculated from the basis vectors and coefficients.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.get_opd","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisOPD.summary","title":"Optics","text":""},{"location":"docs/API/optics/#rotate","title":"Rotate","text":"<p>This layer rotates the wavefront by a specified angle in radians.</p> Rotate API <p>         Bases: <code>OpticalLayer</code></p> <p>Applies a rotation to the wavefront using interpolation methods.</p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in the clockwise direction.</p> <code>real_imaginary</code> <code>bool</code> <p>Should the rotation be performed on the amplitude and phase array or the real and imaginary arrays.</p> <code>fourier</code> <code>bool</code> <p>Should the rotation be done using fourier methods or interpolation.</p> <code>order</code> <code>int = 1</code> <p>The order of the interpolation to use. Only applies if fourier is False. Must be 0, 1, or 3.</p> <code>padding</code> <code>int</code> <p>The amount of padding to use if the fourier method is used.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class Rotate(OpticalLayer):\n\"\"\"\n    Applies a rotation to the wavefront using interpolation methods.\n\n    Attributes\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in the clockwise direction.\n    real_imaginary : bool\n        Should the rotation be performed on the amplitude and phase array\n        or the real and imaginary arrays.\n    fourier : bool\n        Should the rotation be done using fourier methods or interpolation.\n    order : int = 1\n        The order of the interpolation to use. Only applies if fourier is\n        False. Must be 0, 1, or 3.\n    padding : int\n        The amount of padding to use if the fourier method is used.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    angle          : Array\n    real_imaginary : bool\n    fourier        : bool\n    order          : int\n    padding        : int\n\n\n    def __init__(self           : OpticalLayer,\n                 angle          : Array,\n                 real_imaginary : bool = False,\n                 fourier        : bool = False,\n                 order          : int  = 1,\n                 padding        : int  = None,\n                 name           : str  = 'Rotate') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the Rotate class.\n\n        Parameters\n        ----------\n        angle: float, radians\n            The angle by which to rotate the wavefront in the clockwise \n            direction.\n        real_imaginary : bool = False\n            Should the rotation be performed on the amplitude and phase array\n            or the real and imaginary arrays.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        order : int = 1\n            The order of the interpolation to use. Only applies if fourier is\n            False. Must be 0, 1, or 3.\n        padding : int = None\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n        name : str = 'Rotate'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.angle          = np.asarray(angle, dtype=float)\n        self.real_imaginary = bool(real_imaginary)\n        if order not in (0, 1, 3):\n            raise ValueError(\"Order must be 0, 1, or 3.\")\n        self.order = int(order)\n        self.fourier        = bool(fourier)\n        self.padding = padding if padding is None else int(padding)\n        assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Applies the rotation to a wavefront.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The rotated wavefront.\n        \"\"\"\n        args = [self.angle, self.real_imaginary, self.fourier, self.order]\n        args += [self.padding] if self.padding is not None else []\n        return wavefront.rotate(*args)\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        angle = convert_angular(self.angle, 'radians', angular_units)\n\n        if self.fourier:\n            method = f\"a Fourier method with padding of {self.padding}\"\n        else:\n            method = \"an Interpolation method of order 1\"\n\n        if self.real_imaginary:\n            wf_type = \"real and imaginary arrays\"\n        else:\n            wf_type = \"amplitude and phase arrays\"\n\n        return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n                f\"rotation to the wavefront {wf_type} using {method}.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.Rotate.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the rotation to a wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The rotated wavefront.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Applies the rotation to a wavefront.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The rotated wavefront.\n    \"\"\"\n    args = [self.angle, self.real_imaginary, self.fourier, self.order]\n    args += [self.padding] if self.padding is not None else []\n    return wavefront.rotate(*args)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.Rotate.__init__","title":"<code>__init__(angle, real_imaginary=False, fourier=False, order=1, padding=None, name='Rotate')</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the wavefront in the clockwise  direction.</p> required <code>real_imaginary</code> <code>bool</code> <p>Should the rotation be performed on the amplitude and phase array or the real and imaginary arrays.</p> <code>False</code> <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>order</code> <code>int</code> <p>The order of the interpolation to use. Only applies if fourier is False. Must be 0, 1, or 3.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self           : OpticalLayer,\n             angle          : Array,\n             real_imaginary : bool = False,\n             fourier        : bool = False,\n             order          : int  = 1,\n             padding        : int  = None,\n             name           : str  = 'Rotate') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the Rotate class.\n\n    Parameters\n    ----------\n    angle: float, radians\n        The angle by which to rotate the wavefront in the clockwise \n        direction.\n    real_imaginary : bool = False\n        Should the rotation be performed on the amplitude and phase array\n        or the real and imaginary arrays.\n    fourier : bool = False\n        Should the fourier rotation method be used (True), or regular\n        interpolation method be used (False).\n    order : int = 1\n        The order of the interpolation to use. Only applies if fourier is\n        False. Must be 0, 1, or 3.\n    padding : int = None\n        The amount of fourier padding to use. Only applies if fourier is\n        True.\n    name : str = 'Rotate'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.angle          = np.asarray(angle, dtype=float)\n    self.real_imaginary = bool(real_imaginary)\n    if order not in (0, 1, 3):\n        raise ValueError(\"Order must be 0, 1, or 3.\")\n    self.order = int(order)\n    self.fourier        = bool(fourier)\n    self.padding = padding if padding is None else int(padding)\n    assert self.angle.ndim == 0, (\"angle must be scalar array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.Rotate.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    angle = convert_angular(self.angle, 'radians', angular_units)\n\n    if self.fourier:\n        method = f\"a Fourier method with padding of {self.padding}\"\n    else:\n        method = \"an Interpolation method of order 1\"\n\n    if self.real_imaginary:\n        wf_type = \"real and imaginary arrays\"\n    else:\n        wf_type = \"amplitude and phase arrays\"\n\n    return (f\"{self.name}: Applies a {angle:.{sigfigs}} {angular_units} \"\n            f\"rotation to the wavefront {wf_type} using {method}.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.Rotate","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.Rotate.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.Rotate.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.Rotate.summary","title":"Optics","text":""},{"location":"docs/API/optics/#apply-basis-climb","title":"Apply Basis CLIMB","text":"<p>This layer takes a set of basis vectors and (optionally) coefficients, which is then used to calculate a binary version of the resulting output in a continuous manner using the \"CLIMB\" algorithm.</p> ApplyBasisCLIMB API <p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of binary phase values to the input wavefront from a set of continuous basis vectors. This uses the CLIMB algorithm in order to generate the binary values in a continous manner as described in the paper Wong et al. 2021. The basis vectors are taken as an Optical Path Difference (OPD), and applied to the phase of the wavefront. The ideal wavelength parameter described the wavelength that will have a perfect anti-phase relationship given by the Optical Path Difference.</p> <p>Note: Many of the methods in the class still need doccumentation. Note: This currently only outputs 256 pixel arrays and uses a 3x oversample, therefore requiring a 768 pixel basis array.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>Array</code> <p>Arrays holding the continous pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>ideal_wavelength</code> <code>Array</code> <p>The target wavelength at which a perfect anti-phase relationship is applied via the OPD.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> Source code in <code>dLux/optics.py</code> <pre><code>class ApplyBasisCLIMB(OpticalLayer):\n\"\"\"\n    Adds an array of binary phase values to the input wavefront from a set of\n    continuous basis vectors. This uses the CLIMB algorithm in order to\n    generate the binary values in a continous manner as described in the\n    paper Wong et al. 2021. The basis vectors are taken as an Optical Path\n    Difference (OPD), and applied to the phase of the wavefront. The ideal\n    wavelength parameter described the wavelength that will have a perfect\n    anti-phase relationship given by the Optical Path Difference.\n\n    Note: Many of the methods in the class still need doccumentation.\n    Note: This currently only outputs 256 pixel arrays and uses a 3x oversample,\n    therefore requiring a 768 pixel basis array.\n\n    Attributes\n    ----------\n    basis: Array\n        Arrays holding the continous pre-calculated basis vectors.\n    coefficients: Array\n        The Array of coefficients to be applied to each basis vector.\n    ideal_wavelength : Array\n        The target wavelength at which a perfect anti-phase relationship is\n        applied via the OPD.\n    name : str\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    basis            : Array\n    coefficients     : Array\n    ideal_wavelength : Array\n\n\n    def __init__(self             : OpticalLayer,\n                 basis            : Array,\n                 ideal_wavelength : Array,\n                 coefficients     : Array = None,\n                 name             : str   = 'ApplyBasisCLIMB') -&gt; OpticalLayer:\n\"\"\"\n        Constructor for the ApplyBasisCLIMB class.\n\n        Parameters\n        ----------\n        basis : Array\n            Arrays holding the continous pre-calculated basis vectors. This must\n            be a 3d array of shape (nterms, npixels, npixels), with the final\n            two dimensions matching that of the wavefront at time of\n            application. This is currently required to be a nx768x768 shaped\n            array. \n        ideal_wavelength : Array\n            The target wavelength at which a perfect anti-phase relationship is\n            applied via the OPD.\n        coefficients : Array = None\n            The Array of coefficients to be applied to each basis vector. This\n            must be a one dimensional array with leading dimension equal to the\n            leading dimension of the basis vectors. Default is None which\n            initialises an array of zeros.\n        name : str = 'ApplyBasisCLIMB'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name)\n        self.basis            = np.asarray(basis, dtype=float)\n        self.ideal_wavelength = np.asarray(ideal_wavelength, dtype=float)\n        self.coefficients     = np.array(coefficients).astype(float) \\\n                    if coefficients is not None else np.zeros(len(self.basis))\n\n        # Inputs checks\n        assert self.basis.ndim == 3, \\\n        (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n        assert self.basis.shape[-1] == 768, \\\n        (\"Basis must have shape (n, 768, 768).\")\n        assert self.coefficients.ndim == 1 and \\\n        self.coefficients.shape[0] == self.basis.shape[0], \\\n        (\"coefficients must be a 1 dimensional array with length equal to the \"\n        \"First dimension of the basis array.\")\n        assert self.ideal_wavelength.ndim == 0, (\"ideal_wavelength must be a \"\n                                                 \"scalar array.\")\n\n\n    def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Generates and applies the binary OPD array to the wavefront in a\n        differentiable manner.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to operate on.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The wavefront with the binary OPD applied.\n        \"\"\"\n        latent = self.get_opd(self.basis, self.coefficients)\n        binary_phase = np.pi*self.CLIMB(latent, ppsz=wavefront.npixels)\n        opd = self.phase_to_opd(binary_phase, self.ideal_wavelength)\n        return wavefront.add_opd(opd)\n\n\n    def opd_to_phase(self, opd, wavel):\n        return 2*np.pi*opd/wavel\n\n\n    def phase_to_opd(self, phase, wavel):\n        return phase*wavel/(2*np.pi)\n\n\n    def get_opd(self, basis, coefficients):\n        return np.dot(basis.T, coefficients)\n\n\n    def get_total_opd(self):\n        return self.get_opd(self.basis, self.coefficients)\n\n\n    def get_binary_phase(self):\n        latent = self.get_opd(self.basis, self.coefficients)\n        binary_phase = np.pi*self.CLIMB(latent)\n        return binary_phase\n\n\n    def lsq_params(self, img):\n        xx, yy = np.meshgrid(np.linspace(0,1,img.shape[0]),\n                             np.linspace(0,1,img.shape[1]))\n        A = np.vstack([xx.ravel(), yy.ravel(), np.ones_like(xx).ravel()]).T\n        matrix = np.linalg.inv(np.dot(A.T,A)).dot(A.T)\n        return matrix, xx, yy, A\n\n\n    def lsq(self, img):\n        matrix, _, _, _ = self.lsq_params(img)\n        return np.dot(matrix,img.ravel())\n\n\n    def area(self, img, epsilon = 1e-15):\n        a,b,c = self.lsq(img)\n        a = np.where(a==0,epsilon,a)\n        b = np.where(b==0,epsilon,b)\n        c = np.where(c==0,epsilon,c)\n        x1 = (-b-c)/(a) # don't divide by zero\n        x2 = -c/(a) # don't divide by zero\n        x1, x2 = np.min(np.array([x1,x2])), np.max(np.array([x1,x2]))\n        x1, x2 = np.max(np.array([x1,0])), np.min(np.array([x2,1]))\n\n        dummy = x1 + (-c/b)*x2-(0.5*a/b)*x2**2 - (-c/b)*x1+(0.5*a/b)*x1**2\n\n        # Set the regions where there is a defined gradient\n        dummy = np.where(dummy&gt;=0.5,dummy,1-dummy)\n\n        # Colour in regions\n        dummy = np.where(np.mean(img)&gt;=0,dummy,1-dummy)\n\n        # rescale between 0 and 1?\n        dummy = np.where(np.all(img&gt;0),1,dummy)\n        dummy = np.where(np.all(img&lt;=0),0,dummy)\n\n        # undecided region\n        dummy = np.where(np.any(img==0),np.mean(dummy&gt;0),dummy)\n\n        # rescale between 0 and 1\n        dummy = np.clip(dummy, 0, 1)\n\n        return dummy\n\n    def CLIMB(self, wf, ppsz = 256):\n        psz = ppsz * 3\n        dummy = np.array(np.split(wf, ppsz))\n        dummy = np.array(np.split(np.array(dummy), ppsz, axis = 2))\n        subarray = dummy[:,:,0,0]\n\n        flat = dummy.reshape(-1, 3, 3)\n        vmap_mask = vmap(self.area, in_axes=(0))\n\n        soft_bin = vmap_mask(flat).reshape(ppsz, ppsz)\n\n        return soft_bin\n\n\n    def summary(self            : OpticalLayer, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a binary OPD to the Wavefront using the \"\n                \"CLIMB algorithm.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Generates and applies the binary OPD array to the wavefront in a differentiable manner.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the binary OPD applied.</p> Source code in <code>dLux/optics.py</code> <pre><code>def __call__(self : OpticalLayer, wavefront : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Generates and applies the binary OPD array to the wavefront in a\n    differentiable manner.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to operate on.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The wavefront with the binary OPD applied.\n    \"\"\"\n    latent = self.get_opd(self.basis, self.coefficients)\n    binary_phase = np.pi*self.CLIMB(latent, ppsz=wavefront.npixels)\n    opd = self.phase_to_opd(binary_phase, self.ideal_wavelength)\n    return wavefront.add_opd(opd)\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.__init__","title":"<code>__init__(basis, ideal_wavelength, coefficients=None, name='ApplyBasisCLIMB')</code>","text":"<p>Constructor for the ApplyBasisCLIMB class.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array</code> <p>Arrays holding the continous pre-calculated basis vectors. This must be a 3d array of shape (nterms, npixels, npixels), with the final two dimensions matching that of the wavefront at time of application. This is currently required to be a nx768x768 shaped array.</p> required <code>ideal_wavelength</code> <code>Array</code> <p>The target wavelength at which a perfect anti-phase relationship is applied via the OPD.</p> required <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector. This must be a one dimensional array with leading dimension equal to the leading dimension of the basis vectors. Default is None which initialises an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyBasisCLIMB'</code> Source code in <code>dLux/optics.py</code> <pre><code>def __init__(self             : OpticalLayer,\n             basis            : Array,\n             ideal_wavelength : Array,\n             coefficients     : Array = None,\n             name             : str   = 'ApplyBasisCLIMB') -&gt; OpticalLayer:\n\"\"\"\n    Constructor for the ApplyBasisCLIMB class.\n\n    Parameters\n    ----------\n    basis : Array\n        Arrays holding the continous pre-calculated basis vectors. This must\n        be a 3d array of shape (nterms, npixels, npixels), with the final\n        two dimensions matching that of the wavefront at time of\n        application. This is currently required to be a nx768x768 shaped\n        array. \n    ideal_wavelength : Array\n        The target wavelength at which a perfect anti-phase relationship is\n        applied via the OPD.\n    coefficients : Array = None\n        The Array of coefficients to be applied to each basis vector. This\n        must be a one dimensional array with leading dimension equal to the\n        leading dimension of the basis vectors. Default is None which\n        initialises an array of zeros.\n    name : str = 'ApplyBasisCLIMB'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name)\n    self.basis            = np.asarray(basis, dtype=float)\n    self.ideal_wavelength = np.asarray(ideal_wavelength, dtype=float)\n    self.coefficients     = np.array(coefficients).astype(float) \\\n                if coefficients is not None else np.zeros(len(self.basis))\n\n    # Inputs checks\n    assert self.basis.ndim == 3, \\\n    (\"basis must be a 3 dimensional array, ie (nterms, npixels, npixels).\")\n    assert self.basis.shape[-1] == 768, \\\n    (\"Basis must have shape (n, 768, 768).\")\n    assert self.coefficients.ndim == 1 and \\\n    self.coefficients.shape[0] == self.basis.shape[0], \\\n    (\"coefficients must be a 1 dimensional array with length equal to the \"\n    \"First dimension of the basis array.\")\n    assert self.ideal_wavelength.ndim == 0, (\"ideal_wavelength must be a \"\n                                             \"scalar array.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/optics.py</code> <pre><code>def summary(self            : OpticalLayer, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies a binary OPD to the Wavefront using the \"\n            \"CLIMB algorithm.\")\n</code></pre>"},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.__call__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.__init__","title":"Optics","text":""},{"location":"docs/API/optics/#dLux.optics.ApplyBasisCLIMB.summary","title":"Optics","text":""},{"location":"docs/API/optics_util/","title":"Optics Utility Functions","text":"<p>This module contains a number of common equations used in optics, such as converting between OPDs and phases, and a few functions used to calcualte sampling rates in focal planes.</p>"},{"location":"docs/API/optics_util/#opd-to-phase","title":"OPD to Phase","text":"<p>Converts an input OPD and wavelength in meters to converts it to phase in radians.</p> OPD to Phase API <p>Converts the input Optical Path Difference (opd) in units of meters to phases in units of radians for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>Array, meters</code> <p>The Optical Path Difference (opd) to be converted into phase.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The equivilent phase value for the given opd and wavelength.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def opd_to_phase(opd : Array, wavelength : Array) -&gt; Array:\n\"\"\"\n    Converts the input Optical Path Difference (opd) in units of meters to\n    phases in units of radians for the given wavelength.\n\n    Parameters\n    ----------\n    opd : Array, meters\n        The Optical Path Difference (opd) to be converted into phase.\n    wavelength : Array, meters\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    phase : Array, radians\n        The equivilent phase value for the given opd and wavelength.\n    \"\"\"\n    return 2*np.pi*opd/wavelength\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.opd_to_phase","title":"Optics","text":""},{"location":"docs/API/optics_util/#phase-to-opd","title":"Phase to OPD","text":"<p>Converts an input phase in radians and wavelength in meters to converts it to OPD in meters.</p> Phase to OPD API <p>Converts the input phase in units of radians to the equivilent Optical Path Difference (opd) in meters for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phase to be converted into Optical Path Difference (opd)</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>opd</code> <code>Array, meters</code> <p>The equivilent opd value for the given phase and wavelength.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def phase_to_opd(phase : Array, wavelength : Array) -&gt; Array:\n\"\"\"\n    Converts the input phase in units of radians to the equivilent Optical Path\n    Difference (opd) in meters for the given wavelength.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phase to be converted into Optical Path Difference (opd)\n    wavelength : Array, meters\n        The wavelength at which to calculate the phase for.\n\n    Returns\n    -------\n    opd : Array, meters\n        The equivilent opd value for the given phase and wavelength.\n    \"\"\"\n    return phase*wavelength/(2*np.pi)\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.phase_to_opd","title":"Optics","text":""},{"location":"docs/API/optics_util/#get-fringe-size","title":"Get Fringe Size","text":"<p>Calcualtes the angular size in radians of the diffraction fringes in a focal plane based on the wavelength and aperture in meters.</p> Get Fringe Size API <p>Calcualtes the angular size of the diffraction fringes.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <p>Returns:</p> Name Type Description <code>fringe_size</code> <code>Array, radians</code> <p>The angular fringe size in units of radians.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_fringe_size(wavelength : Array, aperture : Array) -&gt; Array:\n\"\"\"\n    Calcualtes the angular size of the diffraction fringes.\n\n    Parameters\n    ----------\n    wavelength : Array, meters\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, meters\n        The size of the aperture.\n\n    Returns\n    -------\n    fringe_size : Array, radians\n        The angular fringe size in units of radians.\n    \"\"\"\n    return wavelength/aperture\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.get_fringe_size","title":"Optics","text":""},{"location":"docs/API/optics_util/#get-pixels-per-fringe","title":"Get Pixels Per Fringe","text":"<p>Calcualtes the number of pixels per diffraction fringe in a focal plane based on the wavelength and aperture in meters. A Nyquist sampled system will have 2 pixels per fringe.</p> Get Pixels Per Fringe API <p>Calculates the number of pixels per diffraction fringe, ie the fringe sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>pixel_scale</code> <code>Array, meters</code> <p>The size of each pixel. This is taken in units of radians per pixel if no focal length is provided, else it is taken in size of meters per pixel.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is taken in units of radians per pixel, else it is taken in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sampling</code> <code>Array</code> <p>The sampling rate of the fringes in units of pixels.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_pixels_per_fringe(wavelength   : Array,\n                          aperture     : Array,\n                          pixel_scale  : Array,\n                          focal_length : Array = None) -&gt; Array:\n\"\"\"\n    Calculates the number of pixels per diffraction fringe, ie the fringe\n    sampling rate.\n\n    Parameters\n    ----------\n    wavelength : Array, meters\n        The wavelength at which to calculate the diffraction fringe for.\n    aperture : Array, meters\n        The size of the aperture.\n    pixel_scale : Array, meters/pixel or radians/pixel\n        The size of each pixel. This is taken in units of radians per pixel if\n        no focal length is provided, else it is taken in size of meters per\n        pixel.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is taken in units of radians per pixel, else it is taken in\n        meters per pixel.\n\n    Returns\n    -------\n    sampling : Array\n        The sampling rate of the fringes in units of pixels.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to meters if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Return sampling\n    return fringe_size/pixel_scale\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.get_pixels_per_fringe","title":"Optics","text":""},{"location":"docs/API/optics_util/#get-pixel-scale","title":"Get Pixel Scale","text":"<p>Calcualtes the pixel scale in either radians or meters per pixel in a focal plane based on the wavelength and aperture in meters, in order to sample the diffraction fringes by some smapling rate. A sampling rate of 2 will give a Nyquist sampled system. If a focal length is provided the output will be in meters per pixel, otherwise it will be in radians per pixel.</p> Get Pixel Scale API <p>Calcaultes the pixel_size needed in order to sample the diffraction fringes at the given sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The observation wavelength.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or meters per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radans per pixel if no focal length is provided, else in units of meters per pixel.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_pixel_scale(sampling_rate : Array,\n                    wavelength    : Array,\n                    aperture      : Array,\n                    focal_length  : Array = None) -&gt; Array:\n\"\"\"\n    Calcaultes the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, meters\n        The observation wavelength.\n    aperture : Array, meters\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        meters per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or meters per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radans per pixel if no focal length is\n        provided, else in units of meters per pixel.\n    \"\"\"\n    # Get fringe size\n    fringe_size = get_fringe_size(wavelength, aperture)\n\n    # Convert to meters if focal_length is provided\n    if focal_length is not None:\n        fringe_size *= focal_length\n\n    # Get sampling rate\n    return fringe_size / sampling_rate\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.get_pixel_scale","title":"Optics","text":""},{"location":"docs/API/optics_util/#get-airy-pixel-scale","title":"Get Airy Pixel Scale","text":"<p>Calcualtes the pixel scale in either radians or meters per pixel in a focal plane based on the wavelength and aperture in meters, in order to sample the diffraction fringes by some smapling rate, based on the slightly larger diffraction fringes given by an airy disk PSF. A sampling rate of 2 will give a Nyquist sampled system. If a focal length is provided the output will be in meters per pixel, otherwise it will be in radians per pixel.</p> Get Airy Pixel Scale API <p>Calcaultes the pixel_size needed in order to sample the diffraction fringes at the given sampling rate. Applies the 1.22 multiplier for Airy disk diffraction fringes given by a circular aperture.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The observation wavelength.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or meters per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radans per pixel if no focal length is provided, else in units of meters per pixel.</p> Source code in <code>dLux/utils/optics.py</code> <pre><code>def get_airy_pixel_scale(sampling_rate : Array,\n                         wavelength    : Array,\n                         aperture      : Array,\n                         focal_length  : Array = None) -&gt; Array:\n\"\"\"\n    Calcaultes the pixel_size needed in order to sample the diffraction fringes\n    at the given sampling rate. Applies the 1.22 multiplier for Airy disk\n    diffraction fringes given by a circular aperture.\n\n    Parameters\n    ----------\n    sampling_rate : Array\n        The rate at which to sample the diffraction fringes. A value of 2 will\n        give nyquist sampled pixels.\n    wavelength : Array, meters\n        The observation wavelength.\n    aperture : Array, meters\n        The size of the aperture.\n    focal_length : Array = None\n        The focal length of the optical system. If none is provided, the pixel\n        scale is given in units of radians per pixel, else it is given in\n        meters per pixel.\n\n    Returns\n    -------\n    pixel_scale : Array, radians per pixel or meters per pixel\n        The pixel_size needed to sample the diffraction fringes at the input\n        sampling rate, in units of radans per pixel if no focal length is\n        provided, else in units of meters per pixel.\n    \"\"\"\n    return get_pixel_scale(sampling_rate, 1.22*wavelength, aperture,\n                           focal_length)\n</code></pre>"},{"location":"docs/API/optics_util/#dLux.utils.optics.get_airy_pixel_scale","title":"Optics","text":""},{"location":"docs/API/propagators/","title":"Propagators","text":"<p>The propagators module contains all the optical layers that transform wavefront between pupil and focal planes. There are several different types of propagators that are combined. Angular and Cartesian propagators define their output units in either angular or cartesian coordinates. MFT and FFT based propagators have either a dynamic or fixed sampling in the output plane respectively. There is also a FarFieldFresnel propagator that is used to propagate near-to the focal plane.</p> <p>This gives a total of 5 classes: <code>AngularMFT</code>, <code>AngularFFT</code>, <code>CartesianMFT</code>, <code>CartesianFFT</code> and <code>CartesianFresnel</code>. <code>AngularMFT</code> is the most commonly used propagator as it can easily model chromatic effects without interpolation and most optical systems are designed in angular coordinates.</p> <p>All of the propagators have an <code>inverse</code> parameter that used to designate the type of propagation. If <code>inverse=False</code> then the propagation will from the pupil plane to the focal plane, and vice versa if <code>inverse=True</code>.</p> <p>The MFT propagators all have an <code>npixels_out</code> and <code>pixel_scale_out</code> parameters that define the size and sampling of the output plane. They also have a <code>shift</code> and <code>pixel_shift</code> parameter which can be used to shift the output plane by a given amount. By default the shift values is in angular units, but if <code>shift_units='pixels'</code> then the shift will be in pixels. FFT propagators by their nature have a fixed sampling and output size, nor can they be shifted so these parameters are not used.</p> <p>Cartesian propagators also have a <code>focal_length</code> parameter that is required to calculate the correct sampling in the output plane.</p> Angular MFT API <p>         Bases: <code>AngularPropagator</code>, <code>VariableSamplingPropagator</code></p> <p>A Propagator class designed to propagate wavefronts, with pixel scale units defined in meters per pixel in pupil planes and radians/pixel in focal planes, with a variable output sampling in the output plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel in pupil plane and radians per pixel in focal planes.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class AngularMFT(AngularPropagator, VariableSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate wavefronts, with pixel scale units\n    defined in meters per pixel in pupil planes and radians/pixel in focal\n    planes, with a variable output sampling in the output plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel or radians/pixel\n        The pixel scale in the output plane, measured in meters per pixel in\n        pupil plane and radians per pixel in focal planes.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self            : Propagator,\n                 npixels_out     : int,\n                 pixel_scale_out : Array,\n                 inverse         : bool  = False,\n                 shift           : Array = np.array([0., 0.]),\n                 pixel_shift     : bool  = False,\n                 name            : str   = 'AngularMFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels in the output plane.\n        pixel_scale_out : Array, radians/pixel, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel in\n            pupil planes and radians per pixel in focal planes.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'AngularMFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name            = name,\n                         inverse         = inverse,\n                         shift           = shift,\n                         pixel_shift     = pixel_shift,\n                         pixel_scale_out = pixel_scale_out,\n                         npixels_out     = npixels_out)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        fringe_size = wavefront.wavelength / wavefront.diameter\n        detector_size = self.npixels_out * self.pixel_scale_out\n        return detector_size / fringe_size\n\n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        pixel_scale = convert_angular(self.pixel_scale_out, 'radians', \n                                        angular_units)\n        shift = convert_angular(self.shift, 'radians', angular_units) \\\n            if not self.pixel_shift else self.shift\n\n        prop_string = (f\"Propagates the Wavefront to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {angular_units} \")\n\n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  \"using a 2-sided MFT.\"\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {angular_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + \"using a 2-sided MFT.\"\n</code></pre> Angular FFT API <p>         Bases: <code>AngularPropagator</code>, <code>FixedSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane using a Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel in pupil planes and radians/pixel in focal planes.</p> <p>Attributes:</p> Name Type Description <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class AngularFFT(AngularPropagator, FixedSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel\n    in pupil planes and radians/pixel in focal planes.\n\n    Attributes\n    ----------\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self    : Propagator,\n                 inverse : bool = False,\n                 name    : str = 'AngularFFT') -&gt; Propagator:\n\"\"\"\n        Constructor for the AngularFFT propagator.\n\n        Parameters\n        ----------\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        name : str = 'AngularFFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name = name, inverse = inverse)\n\n\n    def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Calculate the pixel scale in the output plane in units of radians per\n        pixel.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront that is being propagated.\n\n        Returns\n        -------\n        pixel_scale_out : Array, radians/pixel\n            The pixel scale in the output plane.\n        \"\"\"\n        return wavefront.wavelength / wavefront.diameter\n\n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        return f\"Propagates the Wavefront to a {plane_out} plane using a FFT.\"\n</code></pre> Cartesian MFT API <p>         Bases: <code>CartesianPropagator</code>, <code>VariableSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane that is defined in cartesian units (ie meters/pixel), with a variable output sampling in that plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class CartesianMFT(CartesianPropagator, VariableSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane that is\n    defined in cartesian units (ie meters/pixel), with a variable output\n    sampling in that plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self            : Propagator,\n                 npixels_out     : int,\n                 pixel_scale_out : Array,\n                 focal_length    : Array,\n                 inverse         : bool  = False,\n                 shift           : Array = np.array([0., 0.]),\n                 pixel_shift     : bool  = False,\n                 name            : str   = 'CartesianMFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels in the output plane.\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel.\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'CartesianMFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name            = name,\n                         inverse         = inverse,\n                         shift           = shift,\n                         pixel_shift     = pixel_shift,\n                         focal_length    = focal_length,\n                         pixel_scale_out = pixel_scale_out,\n                         npixels_out     = npixels_out)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        size_in = wavefront.diameter\n        size_out = self.pixel_scale_out * self.npixels_out\n        return size_in * size_out / self.focal_length / wavefront.wavelength\n\n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                        cartesian_units)\n        focal_length = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n        shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n            if not self.pixel_shift else self.shift\n\n        prop_string = (f\"Propagates the Wavefront {focal_length} \"\n                       f\"{cartesian_units} to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n\n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  \"using a 2-sided MFT.\"\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + \"using a 2-sided MFT.\"\n</code></pre> Cartesian FFT API <p>         Bases: <code>CartesianPropagator</code>, <code>FixedSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane using a Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel.</p> <p>Attributes:</p> Name Type Description <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class CartesianFFT(CartesianPropagator, FixedSamplingPropagator):\n\"\"\"\n    A Propagator class designed to propagate a wavefront to a plane using a\n    Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel.\n\n    Attributes\n    ----------\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self         : Propagator,\n                 focal_length : Array,\n                 inverse      : bool = False,\n                 name         : str  = 'CartesianFFT') -&gt; Propagator:\n\"\"\"\n        Parameters\n        ----------\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        name : str = 'CartesianFFT'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name         = name,\n                         inverse      = inverse,\n                         focal_length = focal_length)\n\n\n    def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The pixel scale in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The `Wavefront` that is being propagted.\n\n        Returns\n        -------\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane.\n        \"\"\"\n        return self.focal_length * wavefront.wavelength / wavefront.diameter\n\n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n        focal_length = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n\n        return (f\"Propagates the Wavefront {focal_length} {cartesian_units} to \"\n                f\"a {plane_out} plane using a FFT.\")\n</code></pre> Cartesian Fresnel API <p>         Bases: <code>FarFieldFresnel</code>, <code>CartesianMFT</code></p> <p>A propagator class to for Far-Field fresnel propagations. This classes implements algorithms that use quadratic phase factors to better represent out-of-plane behaviour of wavefronts, close to the focal plane. This class is designed to work on Cartesian wavefronts, ie pixel units are in meters/pixel in the output plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p> Source code in <code>dLux/propagators.py</code> <pre><code>class CartesianFresnel(FarFieldFresnel, CartesianMFT):\n\"\"\"\n    A propagator class to for Far-Field fresnel propagations. This classes\n    implements algorithms that use quadratic phase factors to better represent\n    out-of-plane behaviour of wavefronts, close to the focal plane. This class\n    is designed to work on Cartesian wavefronts, ie pixel units are in\n    meters/pixel in the output plane.\n\n    Attributes\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    propagation_shift : Array, meters\n        The shift in the propagation distance of the wavefront.\n    inverse : bool\n        Is this an 'inverse' propagation. Non-inverse propagations represents\n        propagation from a pupil to a focal plane, and inverse represents\n        propagation from a focal to a pupil plane.\n    shift : Array\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool\n        Should the shift value be considered in units of pixels, or in the\n        physical units of the output plane (ie pixels or meters, radians). True\n        interprets the shift value in pixel units.\n    name : str\n        The name for this propagator.\n    \"\"\"\n\n\n    def __init__(self              : Propagator,\n                 npixels_out       : Array,\n                 pixel_scale_out   : Array,\n                 focal_length      : Array,\n                 propagation_shift : Array,\n                 inverse           : bool  = False,\n                 shift             : Array = np.array([0., 0.]),\n                 pixel_shift       : bool  = False,\n                 name              : str   = 'CartesianFresnel') -&gt; Propagator:\n\"\"\"\n        Constructor for the CartesianFresnel propagator\n\n        Parameters\n        ----------\n        pixel_scale_out : Array, meters/pixel\n            The pixel scale in the output plane, measured in meters per pixel.\n        npixels_out : int\n            The number of pixels in the output plane.\n        focal_length : Array, meters\n            The focal_length of the lens/mirror this propagator represents.\n        propagation_shift : Array, meters\n            The shift in the propagation distance of the wavefront.\n        inverse : bool = False\n            Is this an 'inverse' propagation. Non-inverse propagations\n            represents propagation from a pupil to a focal plane, and inverse\n            represents propagation from a focal to a pupil plane.\n        shift : Array = np.array([0., 0.])\n            The (x, y) shift to apply to the wavefront in the output plane.\n        pixel_shift : bool = False\n            Should the shift value be considered in units of pixel, or in the\n            physical units of the output plane (ie pixels or meters, radians).\n        name : str = 'CartesianFresnel'\n            The name of the layer, which is used to index the layers dictionary.\n        \"\"\"\n        super().__init__(name               = name,\n                         inverse            = inverse,\n                         shift              = shift,\n                         pixel_shift        = pixel_shift,\n                         focal_length       = focal_length,\n                         pixel_scale_out    = pixel_scale_out,\n                         npixels_out        = npixels_out,\n                         propagation_shift  = propagation_shift)\n\n\n    def get_nfringes(self      : Propagator,\n                     wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        The number of diffraction fringes in the output plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront being propagated.\n\n        Returns\n        -------\n        fringes : Array\n            The number of diffraction fringes in the output plane.\n        \"\"\"\n        propagation_distance = self.focal_length + self.propagation_shift\n        size_in = wavefront.diameter\n        size_out = self.pixel_scale_out * self.npixels_out\n        return size_in * size_out / wavefront.wavelength / propagation_distance\n\n\n    def quadratic_phase(self          : Propagator,\n                        x_coordinates : Array,\n                        y_coordinates : Array,\n                        wavelength    : Array,\n                        distance      : Array) -&gt; Array:\n\"\"\"\n        A convinience function for calculating quadratic phase factors.\n\n        Parameters\n        ----------\n        x_coordinates : Array\n            The x coordinates of the pixels in meters. This will be different\n            in the plane of propagation and the initial plane.\n        y_coordinates : Array\n            The y coordinates of the pixels in meters. This will be different\n            in the plane of propagation and the initial plane.\n        wavelength : Array, meters\n            The wavelength of the wavefront.\n        distance : Array, meters\n            The distance that is to be propagated in meters.\n\n        Returns\n        -------\n        quadratic_phase : Array\n            A set of phase factors that are useful in optical calculations.\n        \"\"\"\n        wavenumber = 2 * np.pi / wavelength\n        radial_coordinates = np.hypot(x_coordinates, y_coordinates)\n        return np.exp(0.5j * wavenumber * radial_coordinates ** 2 / distance)\n\n\n    def transfer_function(self      : Propagator,\n                          wavefront : Wavefront,\n                          distance  : Array) -&gt; Array:\n\"\"\"\n        The Optical Transfer Function defining the phase evolution of the\n        wavefront when propagating to a non-conjugate plane.\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n        distance : Array, meters\n            The distance that is being propagated in meters.\n\n        Returns\n        -------\n        field : Array\n            The field that represents the optical transfer.\n        \"\"\"\n        return np.exp(1.0j * wavefront.wavenumber * distance)\n\n\n    def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n        Propagates the wavefront from the input plane to the output plane using\n        a Matrix Fourier Transform.\n\n        TODO: Set plane type to intermediate\n\n        Parameters\n        ----------\n        wavefront : Wavefront\n            The wavefront to propagate.\n\n        Returns\n        -------\n        field : Array\n            The normalised electric field phasor after the propagation.\n        \"\"\"\n        # See gihub issue #52\n        offsets = self.get_shift()\n\n        input_positions = wavefront.pixel_coordinates\n        output_positions = get_pixel_positions(\n                            (self.npixels_out, self.npixels_out), \n                            (self.pixel_scale_out, self.pixel_scale_out))\n\n        propagation_distance = self.focal_length + self.propagation_shift\n\n        field = wavefront.phasor\n        field *= self.quadratic_phase(*input_positions,\n            wavefront.wavelength, - self.focal_length)\n        field *= self.quadratic_phase(*input_positions,\n            wavefront.wavelength, propagation_distance)\n        wavefront = wavefront.set_phasor(np.abs(field), np.angle(field))\n\n        field = super().propagate(wavefront)\n        field *= self.transfer_function(wavefront, propagation_distance)\n        field *= self.quadratic_phase(*output_positions,\n            wavefront.wavelength, propagation_distance)\n        return field\n\n\n    def summary(self            : Propagator, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        plane_out = 'pupil' if self.inverse else 'focal'\n\n        pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                        cartesian_units)\n        prop_distance = convert_cartesian(self.focal_length, 'meters', \n                                        cartesian_units)\n        defocus = convert_cartesian(self.propagation_shift, 'meters', \n                                        cartesian_units)\n        shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n            if not self.pixel_shift else self.shift\n\n\n        prop_string = (f\"Propagates the Wavefront {prop_distance} \"\n                       f\"{cartesian_units} to a {plane_out} plane \"\n                       f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                       f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n\n        defocus_string = (f\"with a defocus of {defocus} {cartesian_units} \"\n                           \"using a 2-sided MFT.\")\n\n        if (self.shift == np.zeros(2)).all():\n            return prop_string +  defocus_string\n        else:\n            if self.pixel_shift:\n                shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                                \"dimension \")\n            else:\n                shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                                \"(x, y) dimension \")\n            return prop_string + shift_string + defocus_string\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='AngularMFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>Array, radians</code> <p>The pixel scale in the output plane, measured in meters per pixel in pupil planes and radians per pixel in focal planes.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AngularMFT'</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self            : Propagator,\n             npixels_out     : int,\n             pixel_scale_out : Array,\n             inverse         : bool  = False,\n             shift           : Array = np.array([0., 0.]),\n             pixel_shift     : bool  = False,\n             name            : str   = 'AngularMFT') -&gt; Propagator:\n\"\"\"\n    Parameters\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, radians/pixel, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel in\n        pupil planes and radians per pixel in focal planes.\n    inverse : bool = False\n        Is this an 'inverse' propagation. Non-inverse propagations\n        represents propagation from a pupil to a focal plane, and inverse\n        represents propagation from a focal to a pupil plane.\n    shift : Array = np.array([0., 0.])\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool = False\n        Should the shift value be considered in units of pixel, or in the\n        physical units of the output plane (ie pixels or meters, radians).\n    name : str = 'AngularMFT'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name            = name,\n                     inverse         = inverse,\n                     shift           = shift,\n                     pixel_shift     = pixel_shift,\n                     pixel_scale_out = pixel_scale_out,\n                     npixels_out     = npixels_out)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def get_nfringes(self      : Propagator,\n                 wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    The number of diffraction fringes in the output plane.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront being propagated.\n\n    Returns\n    -------\n    fringes : Array\n        The number of diffraction fringes in the output plane.\n    \"\"\"\n    fringe_size = wavefront.wavelength / wavefront.diameter\n    detector_size = self.npixels_out * self.pixel_scale_out\n    return detector_size / fringe_size\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def summary(self            : Propagator, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    plane_out = 'pupil' if self.inverse else 'focal'\n\n    pixel_scale = convert_angular(self.pixel_scale_out, 'radians', \n                                    angular_units)\n    shift = convert_angular(self.shift, 'radians', angular_units) \\\n        if not self.pixel_shift else self.shift\n\n    prop_string = (f\"Propagates the Wavefront to a {plane_out} plane \"\n                   f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                   f\"size {pixel_scale:.{sigfigs}} {angular_units} \")\n\n    if (self.shift == np.zeros(2)).all():\n        return prop_string +  \"using a 2-sided MFT.\"\n    else:\n        if self.pixel_shift:\n            shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                            \"dimension \")\n        else:\n            shift_string = (f\"shifted by {shift} {angular_units} in the \"\n                            \"(x, y) dimension \")\n        return prop_string + shift_string + \"using a 2-sided MFT.\"\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.get_nfringes","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularMFT.summary","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.__init__","title":"<code>__init__(inverse=False, name='AngularFFT')</code>","text":"<p>Constructor for the AngularFFT propagator.</p> <p>Parameters:</p> Name Type Description Default <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AngularFFT'</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self    : Propagator,\n             inverse : bool = False,\n             name    : str = 'AngularFFT') -&gt; Propagator:\n\"\"\"\n    Constructor for the AngularFFT propagator.\n\n    Parameters\n    ----------\n    inverse : bool = False\n        Is this an 'inverse' propagation. Non-inverse propagations\n        represents propagation from a pupil to a focal plane, and inverse\n        represents propagation from a focal to a pupil plane.\n    name : str = 'AngularFFT'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name = name, inverse = inverse)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.get_pixel_scale_out","title":"<code>get_pixel_scale_out(wavefront)</code>","text":"<p>Calculate the pixel scale in the output plane in units of radians per pixel.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is being propagated.</p> required <p>Returns:</p> Name Type Description <code>pixel_scale_out</code> <code>Array, radians</code> <p>The pixel scale in the output plane.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    Calculate the pixel scale in the output plane in units of radians per\n    pixel.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront that is being propagated.\n\n    Returns\n    -------\n    pixel_scale_out : Array, radians/pixel\n        The pixel scale in the output plane.\n    \"\"\"\n    return wavefront.wavelength / wavefront.diameter\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def summary(self            : Propagator, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    plane_out = 'pupil' if self.inverse else 'focal'\n\n    return f\"Propagates the Wavefront to a {plane_out} plane using a FFT.\"\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.get_pixel_scale_out","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.AngularFFT.summary","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, focal_length, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='CartesianMFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> required <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianMFT'</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self            : Propagator,\n             npixels_out     : int,\n             pixel_scale_out : Array,\n             focal_length    : Array,\n             inverse         : bool  = False,\n             shift           : Array = np.array([0., 0.]),\n             pixel_shift     : bool  = False,\n             name            : str   = 'CartesianMFT') -&gt; Propagator:\n\"\"\"\n    Parameters\n    ----------\n    npixels_out : int\n        The number of pixels in the output plane.\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool = False\n        Is this an 'inverse' propagation. Non-inverse propagations\n        represents propagation from a pupil to a focal plane, and inverse\n        represents propagation from a focal to a pupil plane.\n    shift : Array = np.array([0., 0.])\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool = False\n        Should the shift value be considered in units of pixel, or in the\n        physical units of the output plane (ie pixels or meters, radians).\n    name : str = 'CartesianMFT'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name            = name,\n                     inverse         = inverse,\n                     shift           = shift,\n                     pixel_shift     = pixel_shift,\n                     focal_length    = focal_length,\n                     pixel_scale_out = pixel_scale_out,\n                     npixels_out     = npixels_out)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def get_nfringes(self      : Propagator,\n                 wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    The number of diffraction fringes in the output plane.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront being propagated.\n\n    Returns\n    -------\n    fringes : Array\n        The number of diffraction fringes in the output plane.\n    \"\"\"\n    size_in = wavefront.diameter\n    size_out = self.pixel_scale_out * self.npixels_out\n    return size_in * size_out / self.focal_length / wavefront.wavelength\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def summary(self            : Propagator, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    plane_out = 'pupil' if self.inverse else 'focal'\n\n    pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                    cartesian_units)\n    focal_length = convert_cartesian(self.focal_length, 'meters', \n                                    cartesian_units)\n    shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n        if not self.pixel_shift else self.shift\n\n    prop_string = (f\"Propagates the Wavefront {focal_length} \"\n                   f\"{cartesian_units} to a {plane_out} plane \"\n                   f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                   f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n\n    if (self.shift == np.zeros(2)).all():\n        return prop_string +  \"using a 2-sided MFT.\"\n    else:\n        if self.pixel_shift:\n            shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                            \"dimension \")\n        else:\n            shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                            \"(x, y) dimension \")\n        return prop_string + shift_string + \"using a 2-sided MFT.\"\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.get_nfringes","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianMFT.summary","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.__init__","title":"<code>__init__(focal_length, inverse=False, name='CartesianFFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianFFT'</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self         : Propagator,\n             focal_length : Array,\n             inverse      : bool = False,\n             name         : str  = 'CartesianFFT') -&gt; Propagator:\n\"\"\"\n    Parameters\n    ----------\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    inverse : bool = False\n        Is this an 'inverse' propagation. Non-inverse propagations\n        represents propagation from a pupil to a focal plane, and inverse\n        represents propagation from a focal to a pupil plane.\n    name : str = 'CartesianFFT'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name         = name,\n                     inverse      = inverse,\n                     focal_length = focal_length)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.get_pixel_scale_out","title":"<code>get_pixel_scale_out(wavefront)</code>","text":"<p>The pixel scale in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The <code>Wavefront</code> that is being propagted.</p> required <p>Returns:</p> Name Type Description <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def get_pixel_scale_out(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    The pixel scale in the output plane.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The `Wavefront` that is being propagted.\n\n    Returns\n    -------\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane.\n    \"\"\"\n    return self.focal_length * wavefront.wavelength / wavefront.diameter\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def summary(self            : Propagator, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    plane_out = 'pupil' if self.inverse else 'focal'\n    focal_length = convert_cartesian(self.focal_length, 'meters', \n                                    cartesian_units)\n\n    return (f\"Propagates the Wavefront {focal_length} {cartesian_units} to \"\n            f\"a {plane_out} plane using a FFT.\")\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.get_pixel_scale_out","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFFT.summary","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, focal_length, propagation_shift, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='CartesianFresnel')</code>","text":"<p>Constructor for the CartesianFresnel propagator</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianFresnel'</code> Source code in <code>dLux/propagators.py</code> <pre><code>def __init__(self              : Propagator,\n             npixels_out       : Array,\n             pixel_scale_out   : Array,\n             focal_length      : Array,\n             propagation_shift : Array,\n             inverse           : bool  = False,\n             shift             : Array = np.array([0., 0.]),\n             pixel_shift       : bool  = False,\n             name              : str   = 'CartesianFresnel') -&gt; Propagator:\n\"\"\"\n    Constructor for the CartesianFresnel propagator\n\n    Parameters\n    ----------\n    pixel_scale_out : Array, meters/pixel\n        The pixel scale in the output plane, measured in meters per pixel.\n    npixels_out : int\n        The number of pixels in the output plane.\n    focal_length : Array, meters\n        The focal_length of the lens/mirror this propagator represents.\n    propagation_shift : Array, meters\n        The shift in the propagation distance of the wavefront.\n    inverse : bool = False\n        Is this an 'inverse' propagation. Non-inverse propagations\n        represents propagation from a pupil to a focal plane, and inverse\n        represents propagation from a focal to a pupil plane.\n    shift : Array = np.array([0., 0.])\n        The (x, y) shift to apply to the wavefront in the output plane.\n    pixel_shift : bool = False\n        Should the shift value be considered in units of pixel, or in the\n        physical units of the output plane (ie pixels or meters, radians).\n    name : str = 'CartesianFresnel'\n        The name of the layer, which is used to index the layers dictionary.\n    \"\"\"\n    super().__init__(name               = name,\n                     inverse            = inverse,\n                     shift              = shift,\n                     pixel_shift        = pixel_shift,\n                     focal_length       = focal_length,\n                     pixel_scale_out    = pixel_scale_out,\n                     npixels_out        = npixels_out,\n                     propagation_shift  = propagation_shift)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def get_nfringes(self      : Propagator,\n                 wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    The number of diffraction fringes in the output plane.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront being propagated.\n\n    Returns\n    -------\n    fringes : Array\n        The number of diffraction fringes in the output plane.\n    \"\"\"\n    propagation_distance = self.focal_length + self.propagation_shift\n    size_in = wavefront.diameter\n    size_out = self.pixel_scale_out * self.npixels_out\n    return size_in * size_out / wavefront.wavelength / propagation_distance\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.propagate","title":"<code>propagate(wavefront)</code>","text":"<p>Propagates the wavefront from the input plane to the output plane using a Matrix Fourier Transform.</p> <p>TODO: Set plane type to intermediate</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The normalised electric field phasor after the propagation.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def propagate(self : Propagator, wavefront : Wavefront) -&gt; Array:\n\"\"\"\n    Propagates the wavefront from the input plane to the output plane using\n    a Matrix Fourier Transform.\n\n    TODO: Set plane type to intermediate\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to propagate.\n\n    Returns\n    -------\n    field : Array\n        The normalised electric field phasor after the propagation.\n    \"\"\"\n    # See gihub issue #52\n    offsets = self.get_shift()\n\n    input_positions = wavefront.pixel_coordinates\n    output_positions = get_pixel_positions(\n                        (self.npixels_out, self.npixels_out), \n                        (self.pixel_scale_out, self.pixel_scale_out))\n\n    propagation_distance = self.focal_length + self.propagation_shift\n\n    field = wavefront.phasor\n    field *= self.quadratic_phase(*input_positions,\n        wavefront.wavelength, - self.focal_length)\n    field *= self.quadratic_phase(*input_positions,\n        wavefront.wavelength, propagation_distance)\n    wavefront = wavefront.set_phasor(np.abs(field), np.angle(field))\n\n    field = super().propagate(wavefront)\n    field *= self.transfer_function(wavefront, propagation_distance)\n    field *= self.quadratic_phase(*output_positions,\n        wavefront.wavelength, propagation_distance)\n    return field\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.quadratic_phase","title":"<code>quadratic_phase(x_coordinates, y_coordinates, wavelength, distance)</code>","text":"<p>A convinience function for calculating quadratic phase factors.</p> <p>Parameters:</p> Name Type Description Default <code>x_coordinates</code> <code>Array</code> <p>The x coordinates of the pixels in meters. This will be different in the plane of propagation and the initial plane.</p> required <code>y_coordinates</code> <code>Array</code> <p>The y coordinates of the pixels in meters. This will be different in the plane of propagation and the initial plane.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront.</p> required <code>distance</code> <code>Array, meters</code> <p>The distance that is to be propagated in meters.</p> required <p>Returns:</p> Name Type Description <code>quadratic_phase</code> <code>Array</code> <p>A set of phase factors that are useful in optical calculations.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def quadratic_phase(self          : Propagator,\n                    x_coordinates : Array,\n                    y_coordinates : Array,\n                    wavelength    : Array,\n                    distance      : Array) -&gt; Array:\n\"\"\"\n    A convinience function for calculating quadratic phase factors.\n\n    Parameters\n    ----------\n    x_coordinates : Array\n        The x coordinates of the pixels in meters. This will be different\n        in the plane of propagation and the initial plane.\n    y_coordinates : Array\n        The y coordinates of the pixels in meters. This will be different\n        in the plane of propagation and the initial plane.\n    wavelength : Array, meters\n        The wavelength of the wavefront.\n    distance : Array, meters\n        The distance that is to be propagated in meters.\n\n    Returns\n    -------\n    quadratic_phase : Array\n        A set of phase factors that are useful in optical calculations.\n    \"\"\"\n    wavenumber = 2 * np.pi / wavelength\n    radial_coordinates = np.hypot(x_coordinates, y_coordinates)\n    return np.exp(0.5j * wavenumber * radial_coordinates ** 2 / distance)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def summary(self            : Propagator, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    plane_out = 'pupil' if self.inverse else 'focal'\n\n    pixel_scale = convert_cartesian(self.pixel_scale_out, 'meters', \n                                    cartesian_units)\n    prop_distance = convert_cartesian(self.focal_length, 'meters', \n                                    cartesian_units)\n    defocus = convert_cartesian(self.propagation_shift, 'meters', \n                                    cartesian_units)\n    shift = convert_cartesian(self.shift, 'meters', cartesian_units) \\\n        if not self.pixel_shift else self.shift\n\n\n    prop_string = (f\"Propagates the Wavefront {prop_distance} \"\n                   f\"{cartesian_units} to a {plane_out} plane \"\n                   f\"with {self.npixels_out}x{self.npixels_out} pixels of \"\n                   f\"size {pixel_scale:.{sigfigs}} {cartesian_units} \")\n\n    defocus_string = (f\"with a defocus of {defocus} {cartesian_units} \"\n                       \"using a 2-sided MFT.\")\n\n    if (self.shift == np.zeros(2)).all():\n        return prop_string +  defocus_string\n    else:\n        if self.pixel_shift:\n            shift_string = (f\"shifted by {shift} pixels in the (x, y) \"\n                            \"dimension \")\n        else:\n            shift_string = (f\"shifted by {shift} {cartesian_units} in the \"\n                            \"(x, y) dimension \")\n        return prop_string + shift_string + defocus_string\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.transfer_function","title":"<code>transfer_function(wavefront, distance)</code>","text":"<p>The Optical Transfer Function defining the phase evolution of the wavefront when propagating to a non-conjugate plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <code>distance</code> <code>Array, meters</code> <p>The distance that is being propagated in meters.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The field that represents the optical transfer.</p> Source code in <code>dLux/propagators.py</code> <pre><code>def transfer_function(self      : Propagator,\n                      wavefront : Wavefront,\n                      distance  : Array) -&gt; Array:\n\"\"\"\n    The Optical Transfer Function defining the phase evolution of the\n    wavefront when propagating to a non-conjugate plane.\n\n    Parameters\n    ----------\n    wavefront : Wavefront\n        The wavefront to propagate.\n    distance : Array, meters\n        The distance that is being propagated in meters.\n\n    Returns\n    -------\n    field : Array\n        The field that represents the optical transfer.\n    \"\"\"\n    return np.exp(1.0j * wavefront.wavenumber * distance)\n</code></pre>"},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.__init__","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.get_nfringes","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.propagate","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.quadratic_phase","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.summary","title":"Propagators","text":""},{"location":"docs/API/propagators/#dLux.propagators.CartesianFresnel.transfer_function","title":"Propagators","text":""},{"location":"docs/API/sources/","title":"Sources","text":"<p>The sources module contains different parametrisations of source objects. These are used to model the light sources that are being observed. Each source class must have at least a <code>position</code> <code>flux</code> and <code>spectrum</code> attribute. The position defaults to the center of the image, ie aligned with the optical axis. Flux defaults to one, giving a unit psf. The only parameter that must be specific is the the <code>spectrum</code>, however we can instead pass in an array of wavelengths and an appropriate spectrum object will be generated. Resolved sources can also be modelled and are applied via a convolution.</p> <p>All source positions are defined in radians and all fluxes are in units of photons.</p> <p>Acessing Parameters</p> <p>The <code>Source</code> class has an in-built <code>__getattr__</code> class that allows for the spectrum parameters to be accessed from the <code>Source</code> object. That means if we wanted to access the <code>wavelengths</code> parameter  of a <code>PointSource</code> we could do so like this:</p> <pre><code>wavelengths = PointSource.wavelengths\n</code></pre> <p>As opposed to the longer:</p> <pre><code>wavelengths = PointSource.spectrum.wavelengths\n</code></pre> <p>There are also a series of different parametrisation of source objects, lets have a look:</p>"},{"location":"docs/API/sources/#point-source","title":"Point Source","text":"<p>A simple point source objects.</p> Point Source API <p>         Bases: <code>Source</code></p> <p>Concrete Class for unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointSource(Source):\n\"\"\"\n    Concrete Class for unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self        : Source,\n                 position    : Array    = np.array([0., 0.]),\n                 flux        : Array    = np.array(1.),\n                 spectrum    : Spectrum = None,\n                 wavelengths : Array    = None,\n                 name        : str      = 'PointSource') -&gt; Source:\n\"\"\"\n        Constructor for the PointSource class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n        super().__init__(position, flux, spectrum, name=name)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        flux = self.flux\n        return (f\"{self.name}: A Point Source with flux {flux:.{sigfigs}} \"\n                f\"photons at offset from the optical axis by {position} \"\n                f\"{angular_units} with spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), spectrum=None, wavelengths=None, name='PointSource')</code>","text":"<p>Constructor for the PointSource class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointSource'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self        : Source,\n             position    : Array    = np.array([0., 0.]),\n             flux        : Array    = np.array(1.),\n             spectrum    : Spectrum = None,\n             wavelengths : Array    = None,\n             name        : str      = 'PointSource') -&gt; Source:\n\"\"\"\n    Constructor for the PointSource class.\n\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The flux of the object.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'PointSource'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n    else:\n        spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n    super().__init__(position, flux, spectrum, name=name)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    flux = self.flux\n    return (f\"{self.name}: A Point Source with flux {flux:.{sigfigs}} \"\n            f\"photons at offset from the optical axis by {position} \"\n            f\"{angular_units} with spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointSource.summary","title":"Sources","text":""},{"location":"docs/API/sources/#multi-point-source","title":"Multi-Point Source","text":"<p>Models a series of point sources at different positions and fluxes with a single spectrum.</p> Multi-Point Source API <p>         Bases: <code>Source</code></p> <p>Concrete Class for multiple unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky positions of these sources.</p> <code>flux</code> <code>Array, photons</code> <p>The fluxes of the sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class MultiPointSource(Source):\n\"\"\"\n    Concrete Class for multiple unresolved point source objects.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky positions of these sources.\n    flux : Array, photons\n        The fluxes of the sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self        : Source,\n                 position    : Array,\n                 flux        : Array    = None,\n                 spectrum    : Spectrum = None,\n                 wavelengths : Array    = None,\n                 name        : str      = 'MultiPointSource') -&gt; Source:\n\"\"\"\n        Constructor for the MultiPointSource class.\n\n        Parameters\n        ----------\n        position : Array, radians\n            The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.\n        flux : Array, photons = None\n            The fluxes of the sources.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n            Every source in this class will have an identical spectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'MultiPointSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n        # Only call super, not __init__ since we are overwriting all the attrs\n        super().__init__(spectrum=spectrum, name=name)\n\n        self.position = np.asarray(position, dtype=float)\n\n        # Input position checking\n        assert self.position.ndim == 2, \\\n        (\"position must be a 2d array.\")\n        assert self.position.shape[-1] == 2, \\\n        (\"positions must be shape (nstars, 2), ie [(x0, y0), (x1, y1), ...].\")\n\n        # Get flux\n        self.flux = np.ones(len(self.positions)) if flux is None else \\\n                    np.asarray(flux, dtype=float)\n\n        # Input flux checking\n        assert self.flux.ndim == 1, \\\n        (\"flux must be a 1d array.\")\n\n        # Ensure same dimensionality\n        assert self.flux.shape[0] == self.position.shape[0], (\"position and \"\n        \"flux must have the same length leading dimension, ie nstars\")\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self        = self.normalise()\n        wavelengths = self.get_wavelengths()\n        weights     = self.get_weights()\n        positions   = self.get_position()\n        fluxes      = self.get_flux()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        propagator = vmap(source_propagator, in_axes=(None, 0))\n\n        # Model Psf\n        psfs = propagator(wavelengths, positions)\n        psfs *= weights[None, :, None, None] * fluxes[:, None, None, None]\n        psf = psfs.sum((0, 1))\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        n = len(self.flux)\n        return (f\"{self.name}: {n} Point Sources with fluxes \"\n                f\"{self.flux:.{sigfigs}} photons at offsets from the optical \"\n                f\"axis by {position} {angular_units} with spectrum\\n  \"\n                f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.__init__","title":"<code>__init__(position, flux=None, spectrum=None, wavelengths=None, name='MultiPointSource')</code>","text":"<p>Constructor for the MultiPointSource class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.</p> required <code>flux</code> <code>Array, photons</code> <p>The fluxes of the sources.</p> <code>None</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'MultiPointSource'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self        : Source,\n             position    : Array,\n             flux        : Array    = None,\n             spectrum    : Spectrum = None,\n             wavelengths : Array    = None,\n             name        : str      = 'MultiPointSource') -&gt; Source:\n\"\"\"\n    Constructor for the MultiPointSource class.\n\n    Parameters\n    ----------\n    position : Array, radians\n        The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.\n    flux : Array, photons = None\n        The fluxes of the sources.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n        Every source in this class will have an identical spectrum.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'MultiPointSource'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n    else:\n        spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n    # Only call super, not __init__ since we are overwriting all the attrs\n    super().__init__(spectrum=spectrum, name=name)\n\n    self.position = np.asarray(position, dtype=float)\n\n    # Input position checking\n    assert self.position.ndim == 2, \\\n    (\"position must be a 2d array.\")\n    assert self.position.shape[-1] == 2, \\\n    (\"positions must be shape (nstars, 2), ie [(x0, y0), (x1, y1), ...].\")\n\n    # Get flux\n    self.flux = np.ones(len(self.positions)) if flux is None else \\\n                np.asarray(flux, dtype=float)\n\n    # Input flux checking\n    assert self.flux.ndim == 1, \\\n    (\"flux must be a 1d array.\")\n\n    # Ensure same dimensionality\n    assert self.flux.shape[0] == self.position.shape[0], (\"position and \"\n    \"flux must have the same length leading dimension, ie nstars\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self      : Source,\n          optics    : Optics,\n          detector  : Detector = None,\n          filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n    Method to model the psf of the point source through the optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n    detector : Detector = None\n        The detector object that is observing the psf.\n    filter_in : Filter = None\n        The filter through which the source is being observed.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self        = self.normalise()\n    wavelengths = self.get_wavelengths()\n    weights     = self.get_weights()\n    positions   = self.get_position()\n    fluxes      = self.get_flux()\n\n    # Get filter throughput\n    if filter_in is not None:\n        raise NotImplementedError(\"Filter modelling is under development.\")\n\n    # Vmap propagator\n    source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n    propagator = vmap(source_propagator, in_axes=(None, 0))\n\n    # Model Psf\n    psfs = propagator(wavelengths, positions)\n    psfs *= weights[None, :, None, None] * fluxes[:, None, None, None]\n    psf = psfs.sum((0, 1))\n\n    # Apply detector if supplied\n    return psf if detector is None else detector.apply_detector(psf)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    n = len(self.flux)\n    return (f\"{self.name}: {n} Point Sources with fluxes \"\n            f\"{self.flux:.{sigfigs}} photons at offsets from the optical \"\n            f\"axis by {position} {angular_units} with spectrum\\n  \"\n            f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.MultiPointSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.MultiPointSource.summary","title":"Sources","text":""},{"location":"docs/API/sources/#binary-source","title":"Binary Source","text":"<p>Models a binary source with a differing spectra. Parametrised by separation, position angle, and flux ratio.</p> Binary Source API <p>         Bases: <code>RelativePositionSource</code>, <code>RelativeFluxSource</code></p> <p>A parameterised binary source.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the sources.</p> <code>separation</code> <code>Array, radians</code> <p>The separation of the two sources in radians.</p> <code>position_angle</code> <code>Array, radians</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the two sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class BinarySource(RelativePositionSource, RelativeFluxSource):\n\"\"\"\n    A parameterised binary source.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the sources.\n    separation : Array, radians\n        The separation of the two sources in radians.\n    position_angle : Array, radians\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array\n        The contrast ratio between the two sources.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a CombinedSpectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self           : Source,\n                 position       : Array    = np.array([0., 0.]),\n                 flux           : Array    = np.array(1.),\n                 separation     : Array    = None,\n                 position_angle : Array    = np.pi/2,\n                 contrast       : Array    = np.array(1.),\n                 spectrum       : Spectrum = None,\n                 wavelengths    : Array    = None,\n                 name           : str      = 'BinarySource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the sources.\n        separation : Array, radians = None\n            The separation of the two sources in radians.\n        position_angle : Array, radians = np.pi/2\n            The position angle between the two sources measured clockwise from\n            the vertical axis.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the two sources.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'BinarySource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n            assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n            (\"The input spectrum must be a CombinedSpectrum object.\")\n        else:\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n        # Check separation\n        assert separation is not None, (\"separation must be provided.\")\n\n        super().__init__(position=position,\n                         flux=flux,\n                         spectrum=spectrum,\n                         separation=separation,\n                         position_angle=position_angle,\n                         contrast=contrast,\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the point source through the optics.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self        = self.normalise()\n        wavelengths = self.get_wavelengths()[0]\n        weights     = self.get_weights()\n        positions   = self.get_position()\n        fluxes      = self.get_flux()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n        propagator = vmap(source_propagator, in_axes=(None, 0))\n\n        # Model Psf\n        psfs = propagator(wavelengths, positions)\n        psfs *= weights[:, :, None, None] * fluxes[:, None, None, None]\n        psf = psfs.sum((0, 1))\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        separation = convert_angular(self.separation, 'radians', angular_units)\n        position_angle = convert_angular(self.position_angle, 'radians', \n                                         angular_units)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Binary Source with mean flux \"\n                f\"{self.flux:.{sigfigs}} photons and constrast {self.contrast} \"\n                f\"offset from the optical axis by {position} \"\n                f\"{angular_units} with separation {separation:.{sigfigs}} \"\n                f\"{angular_units}, position angle {position_angle:.{sigfigs}} \"\n                f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), separation=None, position_angle=np.pi / 2, contrast=np.array(1.0), spectrum=None, wavelengths=None, name='BinarySource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the sources.</p> <code>np.array(1.0)</code> <code>separation</code> <code>Array, radians</code> <p>The separation of the two sources in radians.</p> <code>None</code> <code>position_angle</code> <code>Array, radians</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>np.pi / 2</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the two sources.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>CombinedSpectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'BinarySource'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self           : Source,\n             position       : Array    = np.array([0., 0.]),\n             flux           : Array    = np.array(1.),\n             separation     : Array    = None,\n             position_angle : Array    = np.pi/2,\n             contrast       : Array    = np.array(1.),\n             spectrum       : Spectrum = None,\n             wavelengths    : Array    = None,\n             name           : str      = 'BinarySource') -&gt; Source:\n\"\"\"\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The mean flux of the sources.\n    separation : Array, radians = None\n        The separation of the two sources in radians.\n    position_angle : Array, radians = np.pi/2\n        The position angle between the two sources measured clockwise from\n        the vertical axis.\n    contrast : Array = np.array(1.)\n        The contrast ratio between the two sources.\n    spectrum : CombinedSpectrum = None\n        The spectrum of this object, represented by a CombinedSpectrum.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'BinarySource'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n        assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n        (\"The input spectrum must be a CombinedSpectrum object.\")\n    else:\n        spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n    # Check separation\n    assert separation is not None, (\"separation must be provided.\")\n\n    super().__init__(position=position,\n                     flux=flux,\n                     spectrum=spectrum,\n                     separation=separation,\n                     position_angle=position_angle,\n                     contrast=contrast,\n                     name=name)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self      : Source,\n          optics    : Optics,\n          detector  : Detector = None,\n          filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n    Method to model the psf of the point source through the optics.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n    detector : Detector = None\n        The detector object that is observing the psf.\n    filter_in : Filter = None\n        The filter through which the source is being observed.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self        = self.normalise()\n    wavelengths = self.get_wavelengths()[0]\n    weights     = self.get_weights()\n    positions   = self.get_position()\n    fluxes      = self.get_flux()\n\n    # Get filter throughput\n    if filter_in is not None:\n        raise NotImplementedError(\"Filter modelling is under development.\")\n\n    # Vmap propagator\n    source_propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n    propagator = vmap(source_propagator, in_axes=(None, 0))\n\n    # Model Psf\n    psfs = propagator(wavelengths, positions)\n    psfs *= weights[:, :, None, None] * fluxes[:, None, None, None]\n    psf = psfs.sum((0, 1))\n\n    # Apply detector if supplied\n    return psf if detector is None else detector.apply_detector(psf)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    separation = convert_angular(self.separation, 'radians', angular_units)\n    position_angle = convert_angular(self.position_angle, 'radians', \n                                     angular_units)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    return (f\"{self.name}: A Binary Source with mean flux \"\n            f\"{self.flux:.{sigfigs}} photons and constrast {self.contrast} \"\n            f\"offset from the optical axis by {position} \"\n            f\"{angular_units} with separation {separation:.{sigfigs}} \"\n            f\"{angular_units}, position angle {position_angle:.{sigfigs}} \"\n            f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.BinarySource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.BinarySource.summary","title":"Sources","text":""},{"location":"docs/API/sources/#array-distribution","title":"Array Distribution","text":"<p>Models a single resolved source source object stored as an array of relative intensities.</p> Array Distribution API <p>         Bases: <code>ResolvedSource</code></p> <p>A class for modelling resolved sources that parameterise their resolved component using an array of intensities.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class ArrayDistribution(ResolvedSource):\n\"\"\"\n    A class for modelling resolved sources that parameterise their resolved\n    component using an array of intensities.\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The flux of the object.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n    distribution : Array\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'ArrayDistribution',\n                 **kwargs) -&gt; Source:\n\"\"\"\n        Constructor for the ArrayDistribution class.\n\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'ArrayDistribution'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n        super().__init__(position, flux, spectrum, name=name, **kwargs)\n        distribution = np.asarray(distribution, dtype=float)\n        distribution = np.maximum(distribution, 0.)\n        self.distribution = distribution/distribution.sum()\n\n        # Input checking\n        assert self.distribution.ndim == 2, \\\n        (\"distribution must be a 2d array.\")\n        assert len(self.distribution) &gt; 0, \\\n        (\"Length of distribution must be greater than 1.\")\n\n\n    def get_distribution(self : Source) -&gt; Array:\n\"\"\"\n        Getter method for the source distribution.\n\n        Returns\n        -------\n        distribution : Array, intensity\n            The distribution of the source intensity.\n        \"\"\"\n        return self.distribution\n\n\n    def normalise(self : Source) -&gt; Source:\n\"\"\"\n        Method for returning a new source object with a normalised total\n        spectrum and source distribution.\n\n        Returns\n        -------\n        source : Source\n            The source object with the normalised spectrum and distribution.\n        \"\"\"\n        normalised_spectrum = self.spectrum.normalise()\n        distribution_floor = np.maximum(self.distribution, 0.)\n        normalised_distribution = distribution_floor/distribution_floor.sum()\n        return tree_at(\n            lambda source : (source.spectrum, source.distribution), self, \\\n                            (normalised_spectrum, normalised_distribution))\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Resolved Source with flux \"\n                f\"{self.flux:.{sigfigs}} photons at offset from the optical \"\n                f\"axis by {position} {angular_units} with spectrum\\n  \"\n                f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), spectrum=None, wavelengths=None, name='ArrayDistribution', **kwargs)</code>","text":"<p>Constructor for the ArrayDistribution class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'ArrayDistribution'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self         : Source,\n             position     : Array    = np.array([0., 0.]),\n             flux         : Array    = np.array(1.),\n             distribution : Array    = np.ones((3, 3)),\n             spectrum     : Spectrum = None,\n             wavelengths  : Array    = None,\n             name         : str      = 'ArrayDistribution',\n             **kwargs) -&gt; Source:\n\"\"\"\n    Constructor for the ArrayDistribution class.\n\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The flux of the object.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities respresenting the resolved source.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'ArrayDistribution'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n    else:\n        spectrum = dLux.spectrums.ArraySpectrum(wavelengths)\n\n    super().__init__(position, flux, spectrum, name=name, **kwargs)\n    distribution = np.asarray(distribution, dtype=float)\n    distribution = np.maximum(distribution, 0.)\n    self.distribution = distribution/distribution.sum()\n\n    # Input checking\n    assert self.distribution.ndim == 2, \\\n    (\"distribution must be a 2d array.\")\n    assert len(self.distribution) &gt; 0, \\\n    (\"Length of distribution must be greater than 1.\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.get_distribution","title":"<code>get_distribution()</code>","text":"<p>Getter method for the source distribution.</p> <p>Returns:</p> Name Type Description <code>distribution</code> <code>Array, intensity</code> <p>The distribution of the source intensity.</p> Source code in <code>dLux/sources.py</code> <pre><code>def get_distribution(self : Source) -&gt; Array:\n\"\"\"\n    Getter method for the source distribution.\n\n    Returns\n    -------\n    distribution : Array, intensity\n        The distribution of the source intensity.\n    \"\"\"\n    return self.distribution\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new source object with a normalised total spectrum and source distribution.</p> <p>Returns:</p> Name Type Description <code>source</code> <code>Source</code> <p>The source object with the normalised spectrum and distribution.</p> Source code in <code>dLux/sources.py</code> <pre><code>def normalise(self : Source) -&gt; Source:\n\"\"\"\n    Method for returning a new source object with a normalised total\n    spectrum and source distribution.\n\n    Returns\n    -------\n    source : Source\n        The source object with the normalised spectrum and distribution.\n    \"\"\"\n    normalised_spectrum = self.spectrum.normalise()\n    distribution_floor = np.maximum(self.distribution, 0.)\n    normalised_distribution = distribution_floor/distribution_floor.sum()\n    return tree_at(\n        lambda source : (source.spectrum, source.distribution), self, \\\n                        (normalised_spectrum, normalised_distribution))\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    return (f\"{self.name}: A Resolved Source with flux \"\n            f\"{self.flux:.{sigfigs}} photons at offset from the optical \"\n            f\"axis by {position} {angular_units} with spectrum\\n  \"\n            f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.get_distribution","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.normalise","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.ArrayDistribution.summary","title":"Sources","text":""},{"location":"docs/API/sources/#point-extended-source","title":"Point Extended Source","text":"<p>Models a single unresolved source and a single resolved source with a shared spectrum. An example would be a star and its dust-shell.</p> Point Extended Source API <p>         Bases: <code>RelativeFluxSource</code>, <code>ArrayDistribution</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source. An example would be an unresolved star with a resolved dust shell or debris disk. These two objects share the same spectra but have their fluxes defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array (ie this class inherits from ArrayDistribution).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolved source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointExtendedSource(RelativeFluxSource, ArrayDistribution):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source. An example would be an unresolved star with\n    a resolved dust shell or debris disk. These two objects share the same\n    spectra but have their fluxes defined by flux (the mean flux) and the flux\n    ratio (contrast) between the point source and resolved distribution. The\n    resolved component is defined by an array (ie this class inherits from\n    ArrayDistribution).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolved source.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 contrast     : Array    = np.array(1.),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'PointExtendedSource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The mean flux of the point and resolved source.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : Spectrum = None\n            The spectrum of this object, represented by a Spectrum object.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointExtendedSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n        else:\n            spectrum = dLux.spectrums.Spectrum(wavelengths)\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                         distribution=distribution, contrast=contrast, \\\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the soource objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed. Default is \n            None which is uniform throughput.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self         = self.normalise()\n        wavelengths  = self.get_wavelengths()\n        weights      = self.get_weights()\n        position     = self.get_position()\n        fluxes       = self.get_flux()\n        distribution = self.get_distribution()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n        # Model psfs\n        psfs = propagator(wavelengths, position)\n        single_psf = (weights[:, None, None] * psfs).sum(0)\n        point_psf = fluxes[0] * single_psf\n        extended_psf = fluxes[1] * single_psf\n        convolved = convolve(extended_psf, distribution, mode='same')\n        psf = convolved + point_psf\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n                f\"{self.flux:.{sigfigs}} photons and constrast \"\n                f\"{self.contrast:.{sigfigs}} offset from the optical axis by \"\n                f\"{position} {angular_units} and spectrum\\n  \"\n                f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), contrast=np.array(1.0), spectrum=None, wavelengths=None, name='PointExtendedSource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolved source.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointExtendedSource'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self         : Source,\n             position     : Array    = np.array([0., 0.]),\n             flux         : Array    = np.array(1.),\n             distribution : Array    = np.ones((3, 3)),\n             contrast     : Array    = np.array(1.),\n             spectrum     : Spectrum = None,\n             wavelengths  : Array    = None,\n             name         : str      = 'PointExtendedSource') -&gt; Source:\n\"\"\"\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The mean flux of the point and resolved source.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities respresenting the resolved source.\n    contrast : Array = np.array(1.)\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum = None\n        The spectrum of this object, represented by a Spectrum object.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'PointExtendedSource'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n    else:\n        spectrum = dLux.spectrums.Spectrum(wavelengths)\n\n    super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                     distribution=distribution, contrast=contrast, \\\n                     name=name)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution, while also modelling the single point source psf.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the soource objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed. Default is  None which is uniform throughput.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self      : Source,\n          optics    : Optics,\n          detector  : Detector = None,\n          filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n    Method to model the psf of the source through the optics. Implements a\n    basic convolution with the psf and source distribution, while also\n    modelling the single point source psf.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the soource objects.\n    detector : Detector = None\n        The detector object that is observing the psf.\n    filter_in : Filter = None\n        The filter through which the source is being observed. Default is \n        None which is uniform throughput.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self         = self.normalise()\n    wavelengths  = self.get_wavelengths()\n    weights      = self.get_weights()\n    position     = self.get_position()\n    fluxes       = self.get_flux()\n    distribution = self.get_distribution()\n\n    # Get filter throughput\n    if filter_in is not None:\n        raise NotImplementedError(\"Filter modelling is under development.\")\n\n    # Vmap propagator\n    propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n    # Model psfs\n    psfs = propagator(wavelengths, position)\n    single_psf = (weights[:, None, None] * psfs).sum(0)\n    point_psf = fluxes[0] * single_psf\n    extended_psf = fluxes[1] * single_psf\n    convolved = convolve(extended_psf, distribution, mode='same')\n    psf = convolved + point_psf\n\n    # Apply detector if supplied\n    return psf if detector is None else detector.apply_detector(psf)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n            f\"{self.flux:.{sigfigs}} photons and constrast \"\n            f\"{self.contrast:.{sigfigs}} offset from the optical axis by \"\n            f\"{position} {angular_units} and spectrum\\n  \"\n            f\"{spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointExtendedSource.summary","title":"Sources","text":""},{"location":"docs/API/sources/#point-and-extended-source","title":"Point and Extended Source","text":"<p>Models a single unresolved source and a single resolved source with a unique spectrums. An example would be a quasar and its host galaxy.</p> Point and Extended Source API <p>         Bases: <code>RelativeFluxSource</code>, <code>ArrayDistribution</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source, but with its own spectra. An example would be an unresolved quasar within a resolved galaxy. These two objects have independent spectra but have their fluxes defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array (ie this class inherits from ArrayDistribution).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolves source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p> Source code in <code>dLux/sources.py</code> <pre><code>class PointAndExtendedSource(RelativeFluxSource, ArrayDistribution):\n\"\"\"\n    A class for modelling a point source and a resolved source that is defined\n    relative to the point source, but with its own spectra. An example would be\n    an unresolved quasar within a resolved galaxy. These two objects have\n    independent spectra but have their fluxes defined by flux (the mean flux)\n    and the flux ratio (contrast) between the point source and resolved\n    distribution. The resolved component is defined by an array (ie this class\n    inherits from ArrayDistribution).\n\n    Attributes\n    ----------\n    position : Array, radians\n        The (x, y) on-sky position of this object.\n    flux : Array, photons\n        The mean flux of the point and resolves source.\n    distribution : Array\n        The array of intensities respresenting the resolved source.\n    contrast : Array\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : Spectrum\n        The spectrum of this object, represented by a Spectrum object.\n    name : str\n        The name for this object.\n    \"\"\"\n\n\n    def __init__(self         : Source,\n                 position     : Array    = np.array([0., 0.]),\n                 flux         : Array    = np.array(1.),\n                 distribution : Array    = np.ones((3, 3)),\n                 contrast     : Array    = np.array(1.),\n                 spectrum     : Spectrum = None,\n                 wavelengths  : Array    = None,\n                 name         : str      = 'PointAndExtendedSource') -&gt; Source:\n\"\"\"\n        Parameters\n        ----------\n        position : Array, radians = np.array([0., 0.])\n            The (x, y) on-sky position of this object.\n        flux : Array, photons = np.array(1.)\n            The flux of the object.\n        distribution : Array = np.ones((3, 3))\n            The array of intensities respresenting the resolved source.\n        contrast : Array = np.array(1.)\n            The contrast ratio between the point source and the resolved\n            source.\n        spectrum : CombinedSpectrum = None\n            The spectrum of this object, represented by a CombinedSpectrum.\n        wavelengths : Array, meters = None\n            The array of wavelengths at which the spectrum is defined.\n        name : str = 'PointAndExtendedSource'\n            The name for this object.\n        \"\"\"\n        # Check spectrum &amp; wavelengths\n        assert spectrum is not None or wavelengths is not None, \\\n        (\"Either spectrum or wavelengths must be specified.\")\n        if spectrum is not None:\n            assert wavelengths is None, \\\n            (\"wavelengths can not be specified if spectrum is specified.\")\n            assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n            (\"The input spectrum must be a CombinedSpectrum object.\")\n        else:\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n        super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                         distribution=distribution, contrast=contrast, \\\n                         name=name)\n\n\n    def model(self      : Source,\n              optics    : Optics,\n              detector  : Detector = None,\n              filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n        Method to model the psf of the source through the optics. Implements a\n        basic convolution with the psf and source distribution, while also\n        modelling the single point source psf. Applied a different spectrum to\n        the point source and resolved source.\n\n        Parameters\n        ----------\n        optics : Optics\n            The optics through which to model the source objects.\n        detector : Detector = None\n            The detector object that is observing the psf.\n        filter_in : Filter = None\n            The filter through which the source is being observed. Default is\n            None which is uniform throughput.\n\n        Returns\n        -------\n        psf : Array\n            The psf of the source modelled through the optics.\n        \"\"\"\n        # Normalise and get parameters\n        self         = self.normalise()\n        wavelengths  = self.get_wavelengths()[0]\n        weights      = self.get_weights()\n        position     = self.get_position()\n        fluxes       = self.get_flux()\n        distribution = self.get_distribution()\n\n        # Get filter throughput\n        if filter_in is not None:\n            raise NotImplementedError(\"Filter modelling is under development.\")\n\n        # Vmap propagator\n        propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n        # Model psfs\n        psfs = propagator(wavelengths, position)\n        point_psf    = fluxes[0] * (weights[0, :, None, None] * psfs).sum(0)\n        extended_psf = fluxes[1] * (weights[1, :, None, None] * psfs).sum(0)\n        convolved = convolve(extended_psf, distribution, mode='same')\n        psf = convolved + point_psf\n\n        # Apply detector if supplied\n        return psf if detector is None else detector.apply_detector(psf)\n\n\n    def summary(self            : Source, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        position = np.array_str(convert_angular(self.position, 'radians', \n                                            angular_units), precision=sigfigs)\n        spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                                sigfigs)\n        return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n                f\"{self.flux} photons and constrast {self.contrast} offset \"\n                f\"from the optical axis by {position} \"\n                f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), contrast=np.array(1.0), spectrum=None, wavelengths=None, name='PointAndExtendedSource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>CombinedSpectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointAndExtendedSource'</code> Source code in <code>dLux/sources.py</code> <pre><code>def __init__(self         : Source,\n             position     : Array    = np.array([0., 0.]),\n             flux         : Array    = np.array(1.),\n             distribution : Array    = np.ones((3, 3)),\n             contrast     : Array    = np.array(1.),\n             spectrum     : Spectrum = None,\n             wavelengths  : Array    = None,\n             name         : str      = 'PointAndExtendedSource') -&gt; Source:\n\"\"\"\n    Parameters\n    ----------\n    position : Array, radians = np.array([0., 0.])\n        The (x, y) on-sky position of this object.\n    flux : Array, photons = np.array(1.)\n        The flux of the object.\n    distribution : Array = np.ones((3, 3))\n        The array of intensities respresenting the resolved source.\n    contrast : Array = np.array(1.)\n        The contrast ratio between the point source and the resolved\n        source.\n    spectrum : CombinedSpectrum = None\n        The spectrum of this object, represented by a CombinedSpectrum.\n    wavelengths : Array, meters = None\n        The array of wavelengths at which the spectrum is defined.\n    name : str = 'PointAndExtendedSource'\n        The name for this object.\n    \"\"\"\n    # Check spectrum &amp; wavelengths\n    assert spectrum is not None or wavelengths is not None, \\\n    (\"Either spectrum or wavelengths must be specified.\")\n    if spectrum is not None:\n        assert wavelengths is None, \\\n        (\"wavelengths can not be specified if spectrum is specified.\")\n        assert isinstance(spectrum, dLux.CombinedSpectrum), \\\n        (\"The input spectrum must be a CombinedSpectrum object.\")\n    else:\n        spectrum = dLux.spectrums.CombinedSpectrum(wavelengths)\n\n    super().__init__(position=position, flux=flux, spectrum=spectrum, \\\n                     distribution=distribution, contrast=contrast, \\\n                     name=name)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution, while also modelling the single point source psf. Applied a different spectrum to the point source and resolved source.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed. Default is None which is uniform throughput.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p> Source code in <code>dLux/sources.py</code> <pre><code>def model(self      : Source,\n          optics    : Optics,\n          detector  : Detector = None,\n          filter_in : Filter   = None) -&gt; Array:\n\"\"\"\n    Method to model the psf of the source through the optics. Implements a\n    basic convolution with the psf and source distribution, while also\n    modelling the single point source psf. Applied a different spectrum to\n    the point source and resolved source.\n\n    Parameters\n    ----------\n    optics : Optics\n        The optics through which to model the source objects.\n    detector : Detector = None\n        The detector object that is observing the psf.\n    filter_in : Filter = None\n        The filter through which the source is being observed. Default is\n        None which is uniform throughput.\n\n    Returns\n    -------\n    psf : Array\n        The psf of the source modelled through the optics.\n    \"\"\"\n    # Normalise and get parameters\n    self         = self.normalise()\n    wavelengths  = self.get_wavelengths()[0]\n    weights      = self.get_weights()\n    position     = self.get_position()\n    fluxes       = self.get_flux()\n    distribution = self.get_distribution()\n\n    # Get filter throughput\n    if filter_in is not None:\n        raise NotImplementedError(\"Filter modelling is under development.\")\n\n    # Vmap propagator\n    propagator = vmap(optics.propagate_mono, in_axes=(0, None))\n\n    # Model psfs\n    psfs = propagator(wavelengths, position)\n    point_psf    = fluxes[0] * (weights[0, :, None, None] * psfs).sum(0)\n    extended_psf = fluxes[1] * (weights[1, :, None, None] * psfs).sum(0)\n    convolved = convolve(extended_psf, distribution, mode='same')\n    psf = convolved + point_psf\n\n    # Apply detector if supplied\n    return psf if detector is None else detector.apply_detector(psf)\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/sources.py</code> <pre><code>def summary(self            : Source, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    position = np.array_str(convert_angular(self.position, 'radians', \n                                        angular_units), precision=sigfigs)\n    spectrum_str = self.spectrum.summary(angular_units, cartesian_units,\n                                            sigfigs)\n    return (f\"{self.name}: A Point and Resolved Source with mean flux \"\n            f\"{self.flux} photons and constrast {self.contrast} offset \"\n            f\"from the optical axis by {position} \"\n            f\"{angular_units} and spectrum\\n  {spectrum_str}\")\n</code></pre>"},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.__init__","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.model","title":"Sources","text":""},{"location":"docs/API/sources/#dLux.sources.PointAndExtendedSource.summary","title":"Sources","text":""},{"location":"docs/API/spectrums/","title":"Spectra","text":"<p>The spectrums module just provides some simple parametrisations of spectra. These are used to model the spectra of the sources that are being observed. Each spectrum class must have an array of <code>wavelengths</code> in units of meters.</p>"},{"location":"docs/API/spectrums/#array-spectrum","title":"Array Spectrum","text":"<p>A simple spectrum object that takes in an array of wavelengths and an array of relative intensities.</p> Array Spectrum API <p>         Bases: <code>Spectrum</code></p> <p>A Spectrum class that interally parametersises the spectrum via arrays (ie wavelengths and weights)</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>class ArraySpectrum(Spectrum):\n\"\"\"\n    A Spectrum class that interally parametersises the spectrum via arrays (ie\n    wavelengths and weights)\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array\n        The relative weights of each wavelength.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n    weights : Array\n\n\n    def __init__(self        : Spectrum,\n                 wavelengths : Array,\n                 weights     : Array = None,\n                 name        : str = 'ArraySpectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the ArraySpectrum class.\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The array of wavelengths at which the spectrum is defined.\n        weights : Array = None\n            The relative weights of each wavelength. Defaults to uniform\n            spectrum. Weights are automatically normalised to a sum of 1.\n        name : str = 'ArraySpectrum'\n            The name of the spectrum.\n        \"\"\"\n        super().__init__(wavelengths, name)\n        weights = np.ones(len(self.wavelengths))/len(wavelengths) \\\n                                    if weights is None else weights\n        weights = np.asarray(weights, dtype=float)\n        self.weights = weights/np.sum(weights)\n\n        # Input checks\n        assert self.weights.ndim == 1, \\\n        (\"weights must be a 1d array.\")\n        assert len(self.weights) &gt; 0, \\\n        (\"Length of weights must be greater than 1.\")\n        assert len(self.wavelengths) == len(self.weights), \\\n        (\"wavelengths and weights must have the same length.\")\n\n\n    def get_weights(self : Spectrum) -&gt; Array:\n\"\"\"\n        Getter method for the weights.\n\n        Returns\n        -------\n        weights : Array\n            The relative weights of each wavelength.\n        \"\"\"\n        return self.weights\n\n\n    def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum.\n\n        Returns\n        -------\n        spectrum : Specturm\n            The spectrum object with the normalised spectrum.\n        \"\"\"\n        total_power = self.get_weights().sum()\n        norm_weights = self.get_weights()/total_power\n        return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n\n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a spectrum with weights stored as an \"\n                \"array.\")\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.__init__","title":"<code>__init__(wavelengths, weights=None, name='ArraySpectrum')</code>","text":"<p>Constructor for the ArraySpectrum class.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength. Defaults to uniform spectrum. Weights are automatically normalised to a sum of 1.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> <code>'ArraySpectrum'</code> Source code in <code>dLux/spectrums.py</code> <pre><code>def __init__(self        : Spectrum,\n             wavelengths : Array,\n             weights     : Array = None,\n             name        : str = 'ArraySpectrum') -&gt; Spectrum:\n\"\"\"\n    Constructor for the ArraySpectrum class.\n\n    Parameters\n    ----------\n    wavelengths : Array, meters\n        The array of wavelengths at which the spectrum is defined.\n    weights : Array = None\n        The relative weights of each wavelength. Defaults to uniform\n        spectrum. Weights are automatically normalised to a sum of 1.\n    name : str = 'ArraySpectrum'\n        The name of the spectrum.\n    \"\"\"\n    super().__init__(wavelengths, name)\n    weights = np.ones(len(self.wavelengths))/len(wavelengths) \\\n                                if weights is None else weights\n    weights = np.asarray(weights, dtype=float)\n    self.weights = weights/np.sum(weights)\n\n    # Input checks\n    assert self.weights.ndim == 1, \\\n    (\"weights must be a 1d array.\")\n    assert len(self.weights) &gt; 0, \\\n    (\"Length of weights must be greater than 1.\")\n    assert len(self.wavelengths) == len(self.weights), \\\n    (\"wavelengths and weights must have the same length.\")\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.get_weights","title":"<code>get_weights()</code>","text":"<p>Getter method for the weights.</p> <p>Returns:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>def get_weights(self : Spectrum) -&gt; Array:\n\"\"\"\n    Getter method for the weights.\n\n    Returns\n    -------\n    weights : Array\n        The relative weights of each wavelength.\n    \"\"\"\n    return self.weights\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new spectrum object with a normalised total spectrum.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Specturm</code> <p>The spectrum object with the normalised spectrum.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n    Method for returning a new spectrum object with a normalised total\n    spectrum.\n\n    Returns\n    -------\n    spectrum : Specturm\n        The spectrum object with the normalised spectrum.\n    \"\"\"\n    total_power = self.get_weights().sum()\n    norm_weights = self.get_weights()/total_power\n    return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>def summary(self            : Spectrum, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies a spectrum with weights stored as an \"\n            \"array.\")\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.__init__","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.get_weights","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.normalise","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.ArraySpectrum.summary","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#combined-spectra","title":"Combined Spectra","text":"<p>Multiple array spectra combined together defined on the same set of wavelenghts. This is primarily used for <code>MultiPointSource</code>, <code>BinarySource</code> and <code>PointAndExtendedSource</code> objects.</p> Combined Spectrum API <p>         Bases: <code>ArraySpectrum</code></p> <p>Implements a combined spectrum, in order to have only a single spectrum object for parameterised sources such as binary stars.</p> <p>TODO: Expand to be arbitrary number of spectrums, store only a single wavelengths array and tile it on the get_wavelengths method. (ie make work for MultiPointSource)</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, meters</code> <p>The (nspectra, nwavels) array of wavelengths at which the spectrum is  defined. Input can also be a 1d</p> <code>weights</code> <code>Array</code> <p>The (nspectra, nwavels) relative weights of each wavelength. Defaults  to uniform throughput.</p> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>class CombinedSpectrum(ArraySpectrum):\n\"\"\"\n    Implements a combined spectrum, in order to have only a single spectrum\n    object for parameterised sources such as binary stars.\n\n    TODO: Expand to be arbitrary number of spectrums, store only a single\n    wavelengths array and tile it on the get_wavelengths method. (ie make work\n    for MultiPointSource)\n\n    Attributes\n    ----------\n    wavelengths : Array, meters\n        The (nspectra, nwavels) array of wavelengths at which the spectrum is \n        defined. Input can also be a 1d\n    weights : Array\n        The (nspectra, nwavels) relative weights of each wavelength. Defaults \n        to uniform throughput.\n    name : str\n        The name of the spectrum.\n    \"\"\"\n\n\n    def __init__(self        : Spectrum,\n                 wavelengths : Array,\n                 weights     : Array = None,\n                 name        : str = 'CombinedSpectrum') -&gt; Spectrum:\n\"\"\"\n        Constructor for the CombinedSpectrum class. Expects wavelengths and\n        weights to have the same dimensionality, ie (nsources, nwavelengths).\n\n        Parameters\n        ----------\n        wavelengths : Array, meters\n            The (nspectra, nwavels) array of wavelengths at which the spectrum \n            is defined. Input can also be a 1d\n        weights : Array (optional)\n            The (nspectra, nwavels) relative weights of each wavelength. \n            Defaults to uniform throughput.\n        name : str = 'CombinedSpectrum'\n            The name of the spectrum.\n        \"\"\"\n        super() # Access methods but don't instatiate attributes\n        self.name = str(name)\n        self.wavelengths = np.asarray(wavelengths, dtype=float)\n\n        # Wavelengths\n        # Tile single dimension wavelengths inputs\n        if self.wavelengths.ndim == 1:\n            self.wavelengths = np.tile(self.wavelengths, (2, 1))\n\n        # Input checking\n        assert self.wavelengths.ndim == 2, \\\n        (\"Wavelengths must be a 2d array.\")\n        assert len(self.wavelengths[0]) &gt; 0, \\\n        (\"Length of wavelengths must be greater than 1.\")\n\n        # Weights\n        weights = np.ones(self.wavelengths.shape)/self.wavelengths.shape[1] \\\n                                                if weights is None else weights\n        self.weights = np.asarray(weights, dtype=float)\n\n        # Tile single dimension weights inputs\n        if self.weights.ndim == 1:\n            self.weights = np.tile(self.weights, (len(self.wavelengths), 1))\n\n        # Input checking\n        assert self.weights.ndim == 2, \\\n        (\"weights must be a 2d array.\")\n        assert len(self.weights[0]) &gt; 0, \\\n        (\"Length of weights must be greater than 1.\")\n\n        # Check consistency between wavelenghts and weights\n        assert self.wavelengths.shape == self.weights.shape, \"Weights and \\\n        Wavelengths must have the same shape.\"\n\n\n    def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n        Method for returning a new spectrum object with a normalised total\n        spectrum for each individual source.\n\n        Returns\n        -------\n        spectrum : Specturm\n            The spectrum object with the normalised spectrums.\n        \"\"\"\n        weights = self.get_weights()\n        total_power = weights.sum(1).reshape((len(weights), 1))\n        norm_weights = weights/total_power\n        return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n\n\n    def summary(self            : Spectrum, \n                angular_units   : str = 'radians', \n                cartesian_units : str = 'meters', \n                sigfigs         : int = 4) -&gt; str:\n\"\"\"\n        Returns a summary of the class.\n\n        Parameters\n        ----------\n        angular_units : str = 'radians'\n            The angular units to use in the summary. Options are 'radians', \n            'degrees', 'arcseconds' and 'arcminutes'.\n        cartesian_units : str = 'meters'\n            The cartesian units to use in the summary. Options are 'meters',\n            'millimeters' and 'microns'.\n        sigfigs : int = 4\n            The number of significant figures to use in the summary.\n\n        Returns\n        -------\n        summary : str\n            A summary of the class.\n        \"\"\"\n        return (f\"{self.name}: Applies a two spectrums with weights stored as \"\n                \"arrays.\")\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.__init__","title":"<code>__init__(wavelengths, weights=None, name='CombinedSpectrum')</code>","text":"<p>Constructor for the CombinedSpectrum class. Expects wavelengths and weights to have the same dimensionality, ie (nsources, nwavelengths).</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The (nspectra, nwavels) array of wavelengths at which the spectrum  is defined. Input can also be a 1d</p> required <code>weights</code> <code>Array(optional)</code> <p>The (nspectra, nwavels) relative weights of each wavelength.  Defaults to uniform throughput.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> <code>'CombinedSpectrum'</code> Source code in <code>dLux/spectrums.py</code> <pre><code>def __init__(self        : Spectrum,\n             wavelengths : Array,\n             weights     : Array = None,\n             name        : str = 'CombinedSpectrum') -&gt; Spectrum:\n\"\"\"\n    Constructor for the CombinedSpectrum class. Expects wavelengths and\n    weights to have the same dimensionality, ie (nsources, nwavelengths).\n\n    Parameters\n    ----------\n    wavelengths : Array, meters\n        The (nspectra, nwavels) array of wavelengths at which the spectrum \n        is defined. Input can also be a 1d\n    weights : Array (optional)\n        The (nspectra, nwavels) relative weights of each wavelength. \n        Defaults to uniform throughput.\n    name : str = 'CombinedSpectrum'\n        The name of the spectrum.\n    \"\"\"\n    super() # Access methods but don't instatiate attributes\n    self.name = str(name)\n    self.wavelengths = np.asarray(wavelengths, dtype=float)\n\n    # Wavelengths\n    # Tile single dimension wavelengths inputs\n    if self.wavelengths.ndim == 1:\n        self.wavelengths = np.tile(self.wavelengths, (2, 1))\n\n    # Input checking\n    assert self.wavelengths.ndim == 2, \\\n    (\"Wavelengths must be a 2d array.\")\n    assert len(self.wavelengths[0]) &gt; 0, \\\n    (\"Length of wavelengths must be greater than 1.\")\n\n    # Weights\n    weights = np.ones(self.wavelengths.shape)/self.wavelengths.shape[1] \\\n                                            if weights is None else weights\n    self.weights = np.asarray(weights, dtype=float)\n\n    # Tile single dimension weights inputs\n    if self.weights.ndim == 1:\n        self.weights = np.tile(self.weights, (len(self.wavelengths), 1))\n\n    # Input checking\n    assert self.weights.ndim == 2, \\\n    (\"weights must be a 2d array.\")\n    assert len(self.weights[0]) &gt; 0, \\\n    (\"Length of weights must be greater than 1.\")\n\n    # Check consistency between wavelenghts and weights\n    assert self.wavelengths.shape == self.weights.shape, \"Weights and \\\n    Wavelengths must have the same shape.\"\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new spectrum object with a normalised total spectrum for each individual source.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Specturm</code> <p>The spectrum object with the normalised spectrums.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>def normalise(self : Spectrum) -&gt; Spectrum:\n\"\"\"\n    Method for returning a new spectrum object with a normalised total\n    spectrum for each individual source.\n\n    Returns\n    -------\n    spectrum : Specturm\n        The spectrum object with the normalised spectrums.\n    \"\"\"\n    weights = self.get_weights()\n    total_power = weights.sum(1).reshape((len(weights), 1))\n    norm_weights = weights/total_power\n    return tree_at(lambda spectrum: spectrum.weights, self, norm_weights)\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p> Source code in <code>dLux/spectrums.py</code> <pre><code>def summary(self            : Spectrum, \n            angular_units   : str = 'radians', \n            cartesian_units : str = 'meters', \n            sigfigs         : int = 4) -&gt; str:\n\"\"\"\n    Returns a summary of the class.\n\n    Parameters\n    ----------\n    angular_units : str = 'radians'\n        The angular units to use in the summary. Options are 'radians', \n        'degrees', 'arcseconds' and 'arcminutes'.\n    cartesian_units : str = 'meters'\n        The cartesian units to use in the summary. Options are 'meters',\n        'millimeters' and 'microns'.\n    sigfigs : int = 4\n        The number of significant figures to use in the summary.\n\n    Returns\n    -------\n    summary : str\n        A summary of the class.\n    \"\"\"\n    return (f\"{self.name}: Applies a two spectrums with weights stored as \"\n            \"arrays.\")\n</code></pre>"},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.__init__","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.normalise","title":"Spectrums","text":""},{"location":"docs/API/spectrums/#dLux.spectrums.CombinedSpectrum.summary","title":"Spectrums","text":""},{"location":"docs/API/units/","title":"Units Utility Functions","text":"<p>This module contains functions for converting scales of cartesian and angular coordinates, and for converting between the different angular units.</p>"},{"location":"docs/API/units/#convert-cartesian","title":"Convert Cartesian","text":"<p>Converts between meters, millimeters, microns.</p> Convert Cartesian API <p>Converts the input values from one unit to another.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array</code> <p>The input values to be converted.</p> required <code>input</code> <code>str</code> <p>The input units. Must be one of 'meters', 'millimeters', or 'microns'.</p> <code>'meters'</code> <code>output</code> <code>str</code> <p>The output units. Must be one of 'meters', 'millimeters', or 'microns'.</p> <code>'meters'</code> <p>Returns:</p> Name Type Description <code>values</code> <code>Array</code> <p>The input values converted into the output units.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def convert_cartesian(values : Array, \n                      input  : str = 'meters', \n                      output : str = 'meters') -&gt; Array:\n\"\"\"\n    Converts the input values from one unit to another.\n\n    Parameters\n    ----------\n    values : Array\n        The input values to be converted.\n    input : str = 'meters'\n        The input units. Must be one of 'meters', 'millimeters', or 'microns'.\n    output : str = 'meters'\n        The output units. Must be one of 'meters', 'millimeters', or 'microns'.\n\n    Returns\n    -------\n    values : Array\n        The input values converted into the output units.\n    \"\"\"\n    if input not in ('meters', 'millimeters', 'microns'):\n        raise ValueError(\"input must be 'meters', 'millimeters', or 'microns'.\")\n    if output not in ('meters', 'millimeters', 'microns'):\n        raise ValueError(\"output must be 'meters', 'millimeters', or \"\n                         \"'microns'.\")\n\n    if input == output:\n        factor = 1\n    elif input == 'meters':\n        if output == 'millimeters':\n            factor = 1e-3\n        elif output == 'microns':\n            factor = 1e-6\n    elif input == 'millimeter':\n        if output == 'meters':\n            factor = 1e3\n        elif output == 'microns':\n            factor = 1e-3\n    elif input == 'microns':\n        if output == 'meters':\n            factor = 1e6\n        elif output == 'millimeters':\n            factor = 1e3\n    return values * factor\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.convert_cartesian","title":"Units","text":""},{"location":"docs/API/units/#convert-angular","title":"Convert Angular","text":"<p>Converts between radians, arcseconds, arcminutes, degrees.</p> Convert Angular API <p>Converts the input values from one unit to another.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array</code> <p>The input values to be converted.</p> required <code>input</code> <code>str</code> <p>The input units. Must be one of 'radians', 'degrees', 'arcseconds', or 'arcminutes'.</p> <code>'radians'</code> <code>output</code> <code>str</code> <p>The output units. Must be one of 'radians', 'degrees', 'arcseconds', or 'arcminutes'.</p> <code>'radians'</code> <p>Returns:</p> Name Type Description <code>values</code> <code>Array</code> <p>The input values converted into the output units.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def convert_angular(values : Array,\n                    input  : str = 'radians',\n                    output : str = 'radians') -&gt; Array:\n\"\"\"\n    Converts the input values from one unit to another.\n\n    Parameters\n    ----------\n    values : Array\n        The input values to be converted.\n    input : str = 'radians'\n        The input units. Must be one of 'radians', 'degrees', 'arcseconds', or\n        'arcminutes'.\n    output : str = 'radians'\n        The output units. Must be one of 'radians', 'degrees', 'arcseconds', or\n        'arcminutes'.\n\n    Returns\n    -------\n    values : Array\n        The input values converted into the output units.\n    \"\"\"\n    if input not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):\n        raise ValueError(f\"input must be one of 'radians', 'degrees', \"\n                         f\"'arcseconds' or 'arcminutes'.\")\n    if output not in ('radians', 'degrees', 'arcseconds', 'arcminutes'):\n        raise ValueError(f\"output must be one of 'radians', 'degrees', \"\n                         f\"'arcseconds' or 'arcminutes'.\")\n\n    if input == output:\n        factor = 1\n    elif input == 'radians':\n        if output == 'degrees':\n            factor = r2d(1)\n        elif output == 'arcminutes':\n            factor = r2m(1)\n        elif output == 'arcseconds':\n            factor = r2s(1)\n    elif input == 'degrees':\n        if output == 'radians':\n            factor = d2r(1)\n        elif output == 'arcminutes':\n            factor = d2m(1)\n        elif output == 'arcseconds':\n            factor = d2s(1)\n    elif input == 'arcminutes':\n        if output == 'radians':\n            factor = m2r(1)\n        elif output == 'degrees':\n            factor = m2d(1)\n        elif output == 'arcseconds':\n            factor = m2s(1)\n    elif input == 'arcseconds':\n        if output == 'radians':\n            factor = s2r(1)\n        elif output == 'degrees':\n            factor = s2d(1)\n        elif output == 'arcminutes':\n            factor = s2m(1)\n    return values * factor\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.convert_angular","title":"Units","text":""},{"location":"docs/API/units/#radians-to-degrees","title":"Radians to Degrees","text":"<p>Converts radians to degrees.</p> Radians to Degrees API <p>Converts the inputs values from radians to degrees.</p> <p>Can also be imported as r2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def radians_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to degrees.\n\n    Can also be imported as r2d.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values * 180 / np.pi\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.radians_to_degrees","title":"Units","text":""},{"location":"docs/API/units/#radians-to-arcminutes","title":"Radians to Arcminutes","text":"<p>Converts radians to arcminutes.</p> Radians to Arcminutes API <p>Converts the inputs values from radians to arcminutes.</p> <p>Can also be imported as r2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def radians_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcminutes.\n\n    Can also be imported as r2m.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60 * 180 / np.pi\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.radians_to_arcminutes","title":"Units","text":""},{"location":"docs/API/units/#radians-to-arcseconds","title":"Radians to Arcseconds","text":"<p>Converts radians to arcseconds.</p> Radians to Arcseconds API <p>Converts the inputs values from radians to arcseconds.</p> <p>Can also be imported as r2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def radians_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from radians to arcseconds.\n\n    Can also be imported as r2s.\n\n    Parameters\n    ----------\n    values : Array, radians\n        The input values in units of radians to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600 * 180 / np.pi\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.radians_to_arcseconds","title":"Units","text":""},{"location":"docs/API/units/#degrees-to-radians","title":"Degrees to Radians","text":"<p>Converts degrees to radians.</p> Degrees to Radians API <p>Converts the inputs values from degrees to radians.</p> <p>Can also be imported as d2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def degrees_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to radians.\n\n    Can also be imported as d2r.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / 180\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.degrees_to_radians","title":"Units","text":""},{"location":"docs/API/units/#degrees-to-arcminutes","title":"Degrees to Arcminutes","text":"<p>Converts degrees to arcminutes.</p> Degrees to Arcminutes API <p>Converts the inputs values from degrees to arcminutes.</p> <p>Can also be imported as d2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def degrees_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcminutes.\n\n    Can also be imported as d2m.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values * 60\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.degrees_to_arcminutes","title":"Units","text":""},{"location":"docs/API/units/#degrees-to-arcseconds","title":"Degrees to Arcseconds","text":"<p>Converts degrees to arcseconds.</p> Degrees to Arcseconds API <p>Converts the inputs values from degrees to arcseconds.</p> <p>Can also be imported as d2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def degrees_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from degrees to arcseconds.\n\n    Can also be imported as d2s.\n\n    Parameters\n    ----------\n    values : Array, degrees\n        The input values in units of degrees to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 3600\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.degrees_to_arcseconds","title":"Units","text":""},{"location":"docs/API/units/#arcminutes-to-radians","title":"Arcminutes to Radians","text":"<p>Converts arcminutes to radians.</p> Arcminutes to Radians API <p>Converts the inputs values from arcminutes to radians.</p> <p>Can also be imported as m2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcminutes_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to radians.\n\n    Can also be imported as m2r.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (60 * 180)\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcminutes_to_radians","title":"Units","text":""},{"location":"docs/API/units/#arcminutes-to-degrees","title":"Arcminutes to Degrees","text":"<p>Converts arcminutes to degrees.</p> Arcminutes to Degrees API <p>Converts the inputs values from arcminutes to degrees.</p> <p>Can also be imported as m2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcminutes_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to degrees.\n\n    Can also be imported as m2d.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 60\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcminutes_to_degrees","title":"Units","text":""},{"location":"docs/API/units/#arcminutes-to-arcseconds","title":"Arcminutes to Arcseconds","text":"<p>Converts arcminutes to arcseconds.</p> Arcminutes to Arcseconds API <p>Converts the inputs values from arcminutes to arcseconds.</p> <p>Can also be imported as m2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcminutes_to_arcseconds(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcminutes to arcseconds.\n\n    Can also be imported as m2s.\n\n    Parameters\n    ----------\n    values : Array, arcminutes\n        The input values in units of arcminutes to be converted into arcseconds.\n\n    Returns\n    -------\n    values : Array, arcseconds\n        The input values converted into arcseconds.\n    \"\"\"\n    return values * 60\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcminutes_to_arcseconds","title":"Units","text":""},{"location":"docs/API/units/#arcseconds-to-radians","title":"Arcseconds to Radians","text":"<p>Converts arcseconds to radians.</p> Arcseconds to Radians API <p>Converts the inputs values from arcseconds to radians.</p> <p>Can also be imported as s2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcseconds_to_radians(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to radians.\n\n    Can also be imported as s2r.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into radians.\n\n    Returns\n    -------\n    values : Array, radians\n        The input values converted into radians.\n    \"\"\"\n    return values * np.pi / (3600 * 180)\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcseconds_to_radians","title":"Units","text":""},{"location":"docs/API/units/#arcseconds-to-degrees","title":"Arcseconds to Degrees","text":"<p>Converts arcseconds to degrees.</p> Arcseconds to Degrees API <p>Converts the inputs values from arcseconds to degrees.</p> <p>Can also be imported as s2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcseconds_to_degrees(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to degrees.\n\n    Can also be imported as s2d.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into degrees.\n\n    Returns\n    -------\n    values : Array, degrees\n        The input values converted into degrees.\n    \"\"\"\n    return values / 3600\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcseconds_to_degrees","title":"Units","text":""},{"location":"docs/API/units/#arcseconds-to-arcminutes","title":"Arcseconds to Arcminutes","text":"<p>Converts arcseconds to arcminutes.</p> Arcseconds to Arcminutes API <p>Converts the inputs values from arcseconds to arcminutes.</p> <p>Can also be imported as s2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p> Source code in <code>dLux/utils/units.py</code> <pre><code>def arcseconds_to_arcminutes(values : Array) -&gt; Array:\n\"\"\"\n    Converts the inputs values from arcseconds to arcminutes.\n\n    Can also be imported as s2m.\n\n    Parameters\n    ----------\n    values : Array, arcseconds\n        The input values in units of arcseconds to be converted into arcminutes.\n\n    Returns\n    -------\n    values : Array, arcminutes\n        The input values converted into arcminutes.\n    \"\"\"\n    return values / 60\n</code></pre>"},{"location":"docs/API/units/#dLux.utils.units.arcseconds_to_arcminutes","title":"Units","text":""},{"location":"docs/API/utils/","title":"Utilities Module","text":"<p>The utilities module contains a number of useful functions that are used throughout the package. It is split into 8 sub-modules: <code>optics</code>, <code>models</code>, <code>units</code>, <code>math</code>, <code>coordinates</code>, <code>interpolation</code>, <code>bayes</code>, <code>helpers</code>.</p>"},{"location":"docs/API/utils/#optics-module","title":"Optics Module","text":"<p>The optics module contains a number of common equations used in optics, such as converting between OPDs and phases, and a few functions used to calcualte sampling rates in focal planes.</p>"},{"location":"docs/API/utils/#models-module","title":"Models Module","text":"<p>The models module contains a few functions that can generate pre-built optical models.</p>"},{"location":"docs/API/utils/#units-module","title":"Units Module","text":"<p>The units module contains functions for converting scales of cartesian and angular coordinates, and for converting between the different angular units.</p>"},{"location":"docs/API/utils/#math-module","title":"Math Module","text":"<p>This module only contains a single function used to calcluate factorials differentiably.</p>"},{"location":"docs/API/utils/#coordinates-module","title":"Coordinates Module","text":"<p>This module contains a series of functions that are used to calculate coordinates arrays, apply transformations to coordinate those arrays, and convert between cartesian and polar coordiantes.</p>"},{"location":"docs/API/utils/#interpolation-module","title":"Interpolation Module","text":"<p>This module contains some basic interpolation functions that can be used on arrays and wavefronts.</p>"},{"location":"docs/API/utils/#bayes-module","title":"Bayes Module","text":"<p>This module contains a few likelihood functions. plus functions to calcualte things like covariance matrices and its entropy. This module is likely to be moved in the base package of dLux, Zodiax.</p>"},{"location":"docs/API/utils/#helpers-module","title":"Helpers Module","text":"<p>This module contains any other remaining functions that don't fit into the above scripts!</p>"},{"location":"docs/API/wavefronts/","title":"Wavefronts","text":"<p>The wavefront classes primarily track all the relevant parameters of a wavefront and provide a number of methods for manipulating them. The wavefront class will rarely be interacted with directly by users unless they are creating their own custom classes. The bulk of the code is in the <code>Wavefront</code> class, which is the base class for all wavefronts. The concrete wavefront classes <code>AngularWavefront</code>, <code>CartesianWavefront</code> and <code>FarFieldFresnelWavefront</code> are very minimal and mostly just provide functions to track the different parameters units through the propagations.</p> Wavefront API <p>         Bases: <code>Base</code>, <code>ABC</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type.</p> <p>All wavefronts currently only support square amplitude and phase arrays.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel or radians/pixel</code> <p>The physical dimensions of the pixels representing the wavefront. This can be in units of either meters per pixel or radians per pixel depending on both the plane type and the wavfront type (Cartesian or Angular).</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>class Wavefront(Base, ABC):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type.\n\n    All wavefronts currently only support square amplitude and phase arrays.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        can be in units of either meters per pixel or radians per pixel\n        depending on both the plane type and the wavfront type (Cartesian or\n        Angular).\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n    wavelength  : Array\n    pixel_scale : Array\n    plane_type  : PlaneType\n    amplitude   : Array\n    phase       : Array\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for the wavefront.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel\n            The physical dimensions of each square pixel.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        self.wavelength  = np.asarray(wavelength,  dtype=float)\n        self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n        self.amplitude   = np.asarray(amplitude,   dtype=float)\n        self.phase       = np.asarray(phase,       dtype=float)\n        self.plane_type  = plane_type\n\n        # Input checks\n        assert self.wavelength.shape == (), \\\n        (\"wavelength must be a scalar Array.\")\n        assert self.pixel_scale.shape == (), \\\n        (\"pixel_scale must be a scalar Array.\")\n        assert self.amplitude.ndim == 3, \\\n        (\"amplitude must a 3d array (nfields, npix, npix).\")\n        assert self.phase.ndim == 3, \\\n        (\"phase must a 3d array (nfields, npix, npix).\")\n        assert self.amplitude.shape == self.phase.shape, \\\n        (\"The amplitude and phase arrays must have the same shape.\")\n        assert isinstance(plane_type, PlaneType), \\\n        (\"plane_type must a PlaneType object.\")\n\n\n    ########################\n    ### Getter Functions ###\n    ########################\n    @property\n    def diameter(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the current wavefront diameter calulated using the pixel scale\n        and number of pixels.\n\n        Returns\n        -------\n        diameter : Array, meters or radians\n            The current diameter of the wavefront.\n        \"\"\"\n        return self.npixels * self.pixel_scale\n\n\n    @property\n    def npixels(self : Wavefront) -&gt; int:\n\"\"\"\n        Returns the side length of the arrays currently representing the\n        wavefront. Taken from the amplitude array.\n\n        Returns\n        -------\n        pixels : int\n            The number of pixels that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[-1]\n\n\n    @property\n    def nfields(self : Wavefront) -&gt; int:\n\"\"\"\n        Returns the number of polarisation fields currently representing the\n        wavefront. Taken from the amplitude array first dimension.\n\n        Returns\n        -------\n        pixels : int\n            The number of polarisation fields that represent the `Wavefront`.\n        \"\"\"\n        return self.amplitude.shape[0]\n\n\n    @property\n    def real(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the real component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The real component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.cos(self.phase)\n\n\n    @property\n    def imaginary(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the imaginary component of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Array\n            The imaginary component of the `Wavefront` phasor.\n        \"\"\"\n        return self.amplitude * np.sin(self.phase)\n\n\n    @property\n    def phasor(self : Wavefront) -&gt; Array:\n\"\"\"\n        The electric field phasor described by this Wavefront in complex form.\n\n        Returns\n        -------\n        field : Array\n            The electric field phasor of the wavefront.\n        \"\"\"\n        return self.amplitude * np.exp(1j * self.phase)\n\n\n    @property\n    def psf(self : Wavefront) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), ie the squared modulus\n        of the complex wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return np.sum(self.amplitude ** 2, axis=0)\n\n\n    @property\n    def pixel_coordinates(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the physical positions of the wavefront pixels in meters.\n\n        Returns\n        -------\n        pixel_positions : Array\n            The coordinates of the centers of each pixel representing the\n            wavefront.\n        \"\"\"\n        # return get_pixel_coordinates(self.npixels, self.pixel_scale)\n        return get_pixel_positions((self.npixels, self.npixels), \n                                   (self.pixel_scale, self.pixel_scale))\n\n\n    @property\n    def wavenumber(self : Wavefront) -&gt; Array:\n\"\"\"\n        Returns the wavenumber of the wavefront (2 * pi / wavelength).\n\n        Returns\n        -------\n        wavenumber : Array, 1/meters\n            The wavenumber of the wavefront.\n        \"\"\"\n        return 2 * np.pi / self.wavelength\n\n\n    ########################\n    ### Setter Functions ###\n    ########################\n    def set_amplitude(self : Wavefront, amplitude : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the amplitude attribute.\n\n        Parameters\n        ---------\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated amplitude.\n        \"\"\"\n        assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n        (\"amplitude must be a 3d array.\")\n        return tree_at(\n            lambda wavefront : wavefront.amplitude, self, amplitude)\n\n\n    def set_phase(self : Wavefront, phase : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the phase attribute.\n\n        Parameters\n        ----------\n        phase : Array, radians\n            The phases of each pixel on the `Wavefront`.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated phase.\n        \"\"\"\n        assert isinstance(phase, Array) and phase.ndim == 3, \\\n        (\"phase must be a 3d array.\")\n        return tree_at(\n            lambda wavefront : wavefront.phase, self, phase)\n\n\n    def set_pixel_scale(self : Wavefront, pixel_scale : Array) -&gt; Wavefront:\n\"\"\"\n        Mutator for the pixel_scale attribute.\n\n        Parameters\n        ----------\n        pixel_scale : Array\n            The new pixel_scale associated with the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new Wavefront object with the updated pixel_scale.\n        \"\"\"\n        assert isinstance(pixel_scale, Array) and pixel_scale.ndim == 0, \\\n        (\"pixel_scale must be a scalar array.\")\n        return tree_at(\n            lambda wavefront : wavefront.pixel_scale, self, pixel_scale)\n\n\n    def set_plane_type(self : Wavefront, plane : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Mutator for the PlaneType attribute.\n\n        Parameters\n        ----------\n        plane : PlaneType\n            A PlaneType object describing the plane that the `Wavefront` is\n            currently in.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the update plate_type information.\n        \"\"\"\n        assert isinstance(plane, PlaneType), \\\n        (\"plane must be a PlaneType object.\")\n        return tree_at(\n            lambda wavefront : wavefront.plane_type, self, plane)\n\n\n    def set_phasor(self      : Wavefront,\n                      amplitude : Array,\n                      phase     : Array) -&gt; Wavefront:\n\"\"\"\n        Updates the phasor of the wavefront (ie both the amplitude and the\n        phase).\n\n        Parameters\n        ----------\n        amplitude : Array, power\n            The new electric field amplitude of the wavefront.\n        phase : Array, radians\n            The new electric field phase of the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with updated amplitude and phase.\n        \"\"\"\n        assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n        (\"amplitude must be a 3d array.\")\n        assert isinstance(phase, Array) and phase.ndim == 3, \\\n        (\"phase must be a 3d array.\")\n        assert amplitude.shape == phase.shape, \\\n        (\"amplitude and phase arrays must have the same shape.\")\n        return tree_at(\n            lambda wavefront : (wavefront.amplitude, wavefront.phase), self,\n                               (amplitude, phase))\n\n\n    #######################\n    ### Other Functions ###\n    #######################\n    def tilt_wavefront(self : Wavefront, tilt_angles : Array) -&gt; Wavefront:\n\"\"\"\n        Tilts the wavefront by the tilt_angles.\n\n        Parameters\n        ----------\n        tilt_angles : Array, radians\n            The (x, y) angles by which to tilt the wavefront.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the (x, y) tilts applied.\n        \"\"\"\n        assert isinstance(tilt_angles, Array) and tilt_angles.shape == (2,), \\\n        (\"tilt_angles must be an array with shape (2,) ie. (x, y).\")\n\n        opds = tilt_angles[:, None, None] * self.pixel_coordinates\n        return self.add_phase(- self.wavenumber * opds.sum(0))\n\n\n    def multiply_amplitude(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n        Multiply the amplitude of the `Wavefront` by either a float or array.\n\n        Parameters\n        ----------\n        array_like : Array\n            An array or float that has the same dimensions as amplitude that is\n            multipled by the current ampltide.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated amplitude.\n        \"\"\"\n        amplitude = self.amplitude\n        assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n        (\"array_like must be either a scalar array or array with 2 or 3 \"\n         \"dimensions.\")\n        if array_like.ndim in (2, 3):\n            assert array_like.shape[-2:] == amplitude.shape[-2:], \\\n            (\"array_like shape must be equal to the current ampltude array.\")\n        return self.set_amplitude(amplitude * array_like)\n\n\n    def add_phase(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n        Add to the phase of the `Wavefront` by either a float or array.\n\n        Parameters\n        ----------\n        array_like : Array\n            An array or float that has the same dimensions as phase that is\n            added to the current phase.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the updated phase.\n        \"\"\"\n        phase = self.phase\n        assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n        (\"array_like must be either a scalar array or array with 2 or 3 \"\n         \"dimensions.\")\n        if array_like.ndim in (2, 3):\n            assert array_like.shape[-2:] == phase.shape[-2:], \\\n            (\"array_like shape must be equal to the current phase array.\")\n        return self.set_phase(phase + array_like)\n\n\n    def add_opd(self: Wavefront, path_difference : Array) -&gt; Wavefront:\n\"\"\"\n        Applies the wavelength-dependent phase based on the supplied optical\n        path difference.\n\n        Parameters\n        ----------\n        path_difference : Array, meters\n            The physical optical path difference of either the entire wavefront\n            or each pixel individually.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phases updated according to the supplied\n            path_difference\n        \"\"\"\n        assert isinstance(path_difference, Array) and \\\n        path_difference.ndim in (0, 2, 3), (\"path_difference must be either a \"\n        \"scalar array or array with 2 or 3 dimensions.\")\n        phase_difference = self.wavenumber * path_difference\n        return self.add_phase(phase_difference)\n\n\n    def normalise(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Normalises the total power of the wavefront to 1.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the normalised electric field amplitudes.\n        \"\"\"\n        return self.multiply_amplitude(1 / np.linalg.norm(self.amplitude))\n\n\n    def wavefront_to_psf(self             : Wavefront,\n                         return_polarised : bool = False) -&gt; Array:\n\"\"\"\n        Calculates the Point Spread Function (PSF), ie the squared modulus\n        of the complex wavefront.\n\n        TODO: Take in the parameters dictionary and use the parameters in that\n        to determine the way to output the wavefront.\n\n        Returns\n        -------\n        psf : Array\n            The PSF of the wavefront.\n        \"\"\"\n        return np.sum(self.amplitude ** 2, axis=0)\n\n\n    def invert_x_and_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about both axes.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the phase and amplitude arrays reversed\n            along both axes.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=(-1, -2))\n        new_phase = np.flip(self.phase, axis=(-1, -2))\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def invert_x(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about the x axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` with the phase and amplitude arrays reversed\n            along the x axis.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=-1)\n        new_phase = np.flip(self.phase, axis=-1)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def invert_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n        Reflects the wavefront about the y axis.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront with the phase and amplitude arrays reversed\n            along the y axis.\n        \"\"\"\n        new_amplitude = np.flip(self.amplitude, axis=-2)\n        new_phase = np.flip(self.phase, axis=-2)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def interpolate(self            : Wavefront,\n                    npixels_out     : int,\n                    pixel_scale_out : Array,\n                    real_imaginary  : bool = False) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial interpolation on the wavefront, determined by the\n        the pixel_scale_out and npixels_out parameters. By default the\n        interpolation is done on the amplitude and phase arrays, however by\n        passing `real_imgainary=True` the interpolation is done on the real and\n        imaginary components. This option allows for consistent interpolation\n        behaviour when the phase array has a large amount of wrapping.\n        Automatically conserves energy though the interpolation.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The number of pixels representing the wavefront after the\n            interpolation.\n        pixel_scale_out : Array\n            The pixel scale of the array after the interpolation.\n        real_imaginary : bool = False\n            Whether to interpolate the real and imaginary representation of the\n            wavefront as opposed to the the amplitude and phase representation.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront interpolated to the size and shape determined by\n            npixels_out and pixel_scale_out, with the updated pixel_scale.\n        \"\"\"\n        sampling_ratio = pixel_scale_out / self.pixel_scale\n        if real_imaginary:\n            field = np.array([self.real, self.imaginary])\n        else:\n            field = np.array([self.amplitude, self.phase])\n\n        if field.shape[1] == 1:\n            new_amplitude, new_phase = \\\n            interpolate_field(field[:, 0], npixels_out, sampling_ratio,\n                              real_imaginary=real_imaginary)[:, None, :, :]\n        else:\n            interpolator = vmap(interpolate_field, in_axes=(1, None, None))\n            new_amplitude, new_phase = interpolator(field, npixels_out,\n                                sampling_ratio, real_imaginary=real_imaginary)\n\n        # Update parameters\n        return tree_at(lambda wavefront:\n                 (wavefront.amplitude, wavefront.phase, wavefront.pixel_scale),\n                        self, (new_amplitude, new_phase, pixel_scale_out))\n\n\n    def rotate(self           : Wavefront,\n               angle          : Array,\n               real_imaginary : bool = False,\n               fourier        : bool = False,\n               order          : int  = 1,\n               padding        : int  = 2) -&gt; Wavefront:\n\"\"\"\n        Performs a paraxial rotation on the wavefront, determined by the\n        the angle parameter. By default the rotation is performed using a\n        simple linear interpolation, but an information perserving rotation\n        using fourier methods can be done by setting `fourier = True`. By\n        default rotation is done on the amplitude and phase arrays, however by\n        passing `real_imgainary=True` the rotation is done on the real and\n        imaginary components.\n\n        Parameters\n        ----------\n        angle : Array, radians\n            The angle by which to rotate the wavefront in a clockwise direction.\n        real_imaginary : bool = False\n            Whether to rotate the real and imaginary representation of the\n            wavefront as opposed to the the amplitude and phase representation.\n        fourier : bool = False\n            Should the fourier rotation method be used (True), or regular\n            interpolation method be used (False).\n        order : int = 2\n            The interpolation order to use. Must be 0, 1, or 3.\n        padding : int = 2\n            The amount of fourier padding to use. Only applies if fourier is\n            True.\n\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new wavefront rotated by angle in the clockwise direction.\n        \"\"\"\n        # Get Field\n        if real_imaginary:\n            field = np.array([self.real, self.imaginary])\n        else:\n            field = np.array([self.amplitude, self.phase])\n\n        # Rotate\n        if field.shape[1] == 1:\n            new_amplitude, new_phase = \\\n            rotate_field(field[:, 0], angle, fourier=fourier,\n                    real_imaginary=real_imaginary, order=order)[:, None, :, :]\n        else:\n            rotator = vmap(rotate_field, in_axes=(1, None))\n            new_amplitude, new_phase = rotator(field, angle, fourier=fourier,\n                                    real_imaginary=real_imaginary, order=order)\n\n        # Update parameters\n        return tree_at(lambda wavefront: (wavefront.amplitude, wavefront.phase),\n                                   self, (new_amplitude, new_phase))\n\n\n    def pad_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n        Paraxially zero-pads the `Wavefront` to the size determined by\n        npixels_out. Note this only supports padding arrays of even dimension\n        to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or\n        3 -&gt; 5.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The size of the array to pad to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` zero-padded to the size npixels_out.\n        \"\"\"\n        npixels_in  = self.npixels\n        assert npixels_in  % 2 == npixels_out % 2, \\\n        (\"Only supports even -&gt; even or odd -&gt; odd padding\")\n        assert npixels_out &gt; npixels_in, (\"npixels_out must be larger than the\"\n        \" current array size: {}\".format(npixels_in))\n\n        new_centre = npixels_out // 2\n        centre = npixels_in  // 2\n        remainder = npixels_in  % 2\n        padded = np.zeros([self.nfields, npixels_out, npixels_out])\n\n        new_amplitude = padded.at[:,\n                new_centre - centre : centre + new_centre + remainder,\n                new_centre - centre : centre + new_centre + remainder\n            ].set(self.amplitude)\n        new_phase = padded.at[:,\n                new_centre - centre : centre + new_centre + remainder,\n                new_centre - centre : centre + new_centre + remainder\n            ].set(self.phase)\n        return self.set_phasor(new_amplitude, new_phase)\n\n\n    def crop_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n        Paraxially crops the `Wavefront` to the size determined by npixels_out.\n        Note this only supports padding arrays of even dimension to even\n        dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.\n\n        Parameters\n        ----------\n        npixels_out : int\n            The size of the array to crop to the wavefront to.\n\n        Returns\n        -------\n        wavefront : Wavefront\n            The new `Wavefront` cropped to the size npixels_out.\n        \"\"\"\n        npixels_in  = self.npixels\n\n        assert npixels_in%2 == npixels_out%2, \\\n        (\"Only supports even -&gt; even or odd -&gt; odd cropping\")\n        assert npixels_out &lt; npixels_in, (\"npixels_out must be smaller than the\"\n        \" current array size: {}\".format(npixels_in))\n\n        new_centre = npixels_in  // 2\n        centre = npixels_out // 2\n\n        new_amplitude = self.amplitude[:,\n            new_centre - centre : new_centre + centre,\n            new_centre - centre : new_centre + centre]\n        new_phase = self.phase[:,\n            new_centre - centre : new_centre + centre,\n            new_centre - centre : new_centre + centre]\n\n        return self.set_phasor(new_amplitude, new_phase)\n</code></pre> Angular Wavefront API <p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. AngularWavefronts have pixel scales in units of meters per pixel in Pupil planes and radians per pixel in Focal planes.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel or radians/pixel</code> <p>The physical dimensions of the pixels representing the wavefront. This is in units of meters per pixel in pupil planes and radians per pixel in focal planes.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>class AngularWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. AngularWavefronts have pixel scales in\n    units of meters per pixel in Pupil planes and radians per pixel in Focal\n    planes.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The physical dimensions of the pixels representing the wavefront. This\n        is in units of meters per pixel in pupil planes and radians per pixel\n        in focal planes.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for Angular wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel or radians/pixel\n            The physical dimensions of each pixel. Units are in meters\n            per pixel in Pupil planes and radians per pixel in Focal planes.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</code></pre> Cartesian Wavefront API <p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. CartesianWavefronts have pixel scales in units of meters per pixel in all planes.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel</code> <p>The physical dimensions of the pixels representing the wavefront.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>class CartesianWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. CartesianWavefronts have pixel scales in\n    units of meters per pixel in all planes.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of the pixels representing the wavefront.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for Cartesian wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel\n            The physical dimensions of each pixel.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</code></pre> Far Field Fresnel Wavefront API <p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. FarFieldFresnelWavefronts are designed to work with FarFieldFresnel Propagators, and are better able to represent the behaviour of wavefronts outside of the focal planes, in the far-field approximation.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel</code> <p>The physical dimensions of the pixels representing the wavefront.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>class FarFieldFresnelWavefront(Wavefront):\n\"\"\"\n    A class representing some wavefront, designed to track the various\n    parameters such as wavelength, pixel_scale, amplitude and phase, as well as\n    a helper parmeter, plane_type. FarFieldFresnelWavefronts are designed to\n    work with FarFieldFresnel Propagators, and are better able to represent the\n    behaviour of wavefronts outside of the focal planes, in the far-field\n    approximation.\n\n    Attributes\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of the pixels representing the wavefront.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane type of wavefront, can be Pupil, Focal or\n        Intermediate.\n    \"\"\"\n\n\n    def __init__(self        : Wavefront,\n                 wavelength  : Array,\n                 pixel_scale : Array,\n                 amplitude   : Array,\n                 phase       : Array,\n                 plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n        Constructor for FarFieldFresnel wavefronts.\n\n        Parameters\n        ----------\n        wavelength : float, meters\n            The wavelength of the `Wavefront`.\n        pixel_scale : float, meters/pixel or radians.pixl\n            The physical dimensions of each pixel. Units are in meters\n            per pixel in Pupil planes and meters per pixel or radians per pixel\n            in Focal planes depending on if Cartesian or Angular Propagators\n            are used respectively.\n        amplitude : Array, power\n            The electric field amplitude of the `Wavefront`.\n        phase : Array, radians\n            The electric field phase of the `Wavefront`.\n        plane_type : enum.IntEnum.PlaneType\n            The current plane of wavefront, can be Pupil, Focal.\n        \"\"\"\n        super().__init__(wavelength, pixel_scale,\n                         amplitude, phase, plane_type)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"<code>diameter: Array</code>  <code>property</code>","text":"<p>Returns the current wavefront diameter calulated using the pixel scale and number of pixels.</p> <p>Returns:</p> Name Type Description <code>diameter</code> <code>Array, meters or radians</code> <p>The current diameter of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"<code>imaginary: Array</code>  <code>property</code>","text":"<p>Returns the imaginary component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The imaginary component of the <code>Wavefront</code> phasor.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.nfields","title":"<code>nfields: int</code>  <code>property</code>","text":"<p>Returns the number of polarisation fields currently representing the wavefront. Taken from the amplitude array first dimension.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of polarisation fields that represent the <code>Wavefront</code>.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the wavefront. Taken from the amplitude array.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"<code>phasor: Array</code>  <code>property</code>","text":"<p>The electric field phasor described by this Wavefront in complex form.</p> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The electric field phasor of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pixel_coordinates","title":"<code>pixel_coordinates: Array</code>  <code>property</code>","text":"<p>Returns the physical positions of the wavefront pixels in meters.</p> <p>Returns:</p> Name Type Description <code>pixel_positions</code> <code>Array</code> <p>The coordinates of the centers of each pixel representing the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"<code>psf: Array</code>  <code>property</code>","text":"<p>Calculates the Point Spread Function (PSF), ie the squared modulus of the complex wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.real","title":"<code>real: Array</code>  <code>property</code>","text":"<p>Returns the real component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The real component of the <code>Wavefront</code> phasor.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"<code>wavenumber: Array</code>  <code>property</code>","text":"<p>Returns the wavenumber of the wavefront (2 * pi / wavelength).</p> <p>Returns:</p> Name Type Description <code>wavenumber</code> <code>Array, 1</code> <p>The wavenumber of the wavefront.</p>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each square pixel.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self        : Wavefront,\n             wavelength  : Array,\n             pixel_scale : Array,\n             amplitude   : Array,\n             phase       : Array,\n             plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n    Constructor for the wavefront.\n\n    Parameters\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of each square pixel.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane of wavefront, can be Pupil, Focal.\n    \"\"\"\n    self.wavelength  = np.asarray(wavelength,  dtype=float)\n    self.pixel_scale = np.asarray(pixel_scale, dtype=float)\n    self.amplitude   = np.asarray(amplitude,   dtype=float)\n    self.phase       = np.asarray(phase,       dtype=float)\n    self.plane_type  = plane_type\n\n    # Input checks\n    assert self.wavelength.shape == (), \\\n    (\"wavelength must be a scalar Array.\")\n    assert self.pixel_scale.shape == (), \\\n    (\"pixel_scale must be a scalar Array.\")\n    assert self.amplitude.ndim == 3, \\\n    (\"amplitude must a 3d array (nfields, npix, npix).\")\n    assert self.phase.ndim == 3, \\\n    (\"phase must a 3d array (nfields, npix, npix).\")\n    assert self.amplitude.shape == self.phase.shape, \\\n    (\"The amplitude and phase arrays must have the same shape.\")\n    assert isinstance(plane_type, PlaneType), \\\n    (\"plane_type must a PlaneType object.\")\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"<code>add_opd(path_difference)</code>","text":"<p>Applies the wavelength-dependent phase based on the supplied optical path difference.</p> <p>Parameters:</p> Name Type Description Default <code>path_difference</code> <code>Array, meters</code> <p>The physical optical path difference of either the entire wavefront or each pixel individually.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phases updated according to the supplied path_difference</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def add_opd(self: Wavefront, path_difference : Array) -&gt; Wavefront:\n\"\"\"\n    Applies the wavelength-dependent phase based on the supplied optical\n    path difference.\n\n    Parameters\n    ----------\n    path_difference : Array, meters\n        The physical optical path difference of either the entire wavefront\n        or each pixel individually.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the phases updated according to the supplied\n        path_difference\n    \"\"\"\n    assert isinstance(path_difference, Array) and \\\n    path_difference.ndim in (0, 2, 3), (\"path_difference must be either a \"\n    \"scalar array or array with 2 or 3 dimensions.\")\n    phase_difference = self.wavenumber * path_difference\n    return self.add_phase(phase_difference)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"<code>add_phase(array_like)</code>","text":"<p>Add to the phase of the <code>Wavefront</code> by either a float or array.</p> <p>Parameters:</p> Name Type Description Default <code>array_like</code> <code>Array</code> <p>An array or float that has the same dimensions as phase that is added to the current phase.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated phase.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def add_phase(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n    Add to the phase of the `Wavefront` by either a float or array.\n\n    Parameters\n    ----------\n    array_like : Array\n        An array or float that has the same dimensions as phase that is\n        added to the current phase.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the updated phase.\n    \"\"\"\n    phase = self.phase\n    assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n    (\"array_like must be either a scalar array or array with 2 or 3 \"\n     \"dimensions.\")\n    if array_like.ndim in (2, 3):\n        assert array_like.shape[-2:] == phase.shape[-2:], \\\n        (\"array_like shape must be equal to the current phase array.\")\n    return self.set_phase(phase + array_like)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.crop_to","title":"<code>crop_to(npixels_out)</code>","text":"<p>Paraxially crops the <code>Wavefront</code> to the size determined by npixels_out. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The size of the array to crop to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> cropped to the size npixels_out.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def crop_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n    Paraxially crops the `Wavefront` to the size determined by npixels_out.\n    Note this only supports padding arrays of even dimension to even\n    dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.\n\n    Parameters\n    ----------\n    npixels_out : int\n        The size of the array to crop to the wavefront to.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` cropped to the size npixels_out.\n    \"\"\"\n    npixels_in  = self.npixels\n\n    assert npixels_in%2 == npixels_out%2, \\\n    (\"Only supports even -&gt; even or odd -&gt; odd cropping\")\n    assert npixels_out &lt; npixels_in, (\"npixels_out must be smaller than the\"\n    \" current array size: {}\".format(npixels_in))\n\n    new_centre = npixels_in  // 2\n    centre = npixels_out // 2\n\n    new_amplitude = self.amplitude[:,\n        new_centre - centre : new_centre + centre,\n        new_centre - centre : new_centre + centre]\n    new_phase = self.phase[:,\n        new_centre - centre : new_centre + centre,\n        new_centre - centre : new_centre + centre]\n\n    return self.set_phasor(new_amplitude, new_phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.interpolate","title":"<code>interpolate(npixels_out, pixel_scale_out, real_imaginary=False)</code>","text":"<p>Performs a paraxial interpolation on the wavefront, determined by the the pixel_scale_out and npixels_out parameters. By default the interpolation is done on the amplitude and phase arrays, however by passing <code>real_imgainary=True</code> the interpolation is done on the real and imaginary components. This option allows for consistent interpolation behaviour when the phase array has a large amount of wrapping. Automatically conserves energy though the interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels representing the wavefront after the interpolation.</p> required <code>pixel_scale_out</code> <code>Array</code> <p>The pixel scale of the array after the interpolation.</p> required <code>real_imaginary</code> <code>bool</code> <p>Whether to interpolate the real and imaginary representation of the wavefront as opposed to the the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront interpolated to the size and shape determined by npixels_out and pixel_scale_out, with the updated pixel_scale.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def interpolate(self            : Wavefront,\n                npixels_out     : int,\n                pixel_scale_out : Array,\n                real_imaginary  : bool = False) -&gt; Wavefront:\n\"\"\"\n    Performs a paraxial interpolation on the wavefront, determined by the\n    the pixel_scale_out and npixels_out parameters. By default the\n    interpolation is done on the amplitude and phase arrays, however by\n    passing `real_imgainary=True` the interpolation is done on the real and\n    imaginary components. This option allows for consistent interpolation\n    behaviour when the phase array has a large amount of wrapping.\n    Automatically conserves energy though the interpolation.\n\n    Parameters\n    ----------\n    npixels_out : int\n        The number of pixels representing the wavefront after the\n        interpolation.\n    pixel_scale_out : Array\n        The pixel scale of the array after the interpolation.\n    real_imaginary : bool = False\n        Whether to interpolate the real and imaginary representation of the\n        wavefront as opposed to the the amplitude and phase representation.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront interpolated to the size and shape determined by\n        npixels_out and pixel_scale_out, with the updated pixel_scale.\n    \"\"\"\n    sampling_ratio = pixel_scale_out / self.pixel_scale\n    if real_imaginary:\n        field = np.array([self.real, self.imaginary])\n    else:\n        field = np.array([self.amplitude, self.phase])\n\n    if field.shape[1] == 1:\n        new_amplitude, new_phase = \\\n        interpolate_field(field[:, 0], npixels_out, sampling_ratio,\n                          real_imaginary=real_imaginary)[:, None, :, :]\n    else:\n        interpolator = vmap(interpolate_field, in_axes=(1, None, None))\n        new_amplitude, new_phase = interpolator(field, npixels_out,\n                            sampling_ratio, real_imaginary=real_imaginary)\n\n    # Update parameters\n    return tree_at(lambda wavefront:\n             (wavefront.amplitude, wavefront.phase, wavefront.pixel_scale),\n                    self, (new_amplitude, new_phase, pixel_scale_out))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_x","title":"<code>invert_x()</code>","text":"<p>Reflects the wavefront about the x axis.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the phase and amplitude arrays reversed along the x axis.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def invert_x(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Reflects the wavefront about the x axis.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the phase and amplitude arrays reversed\n        along the x axis.\n    \"\"\"\n    new_amplitude = np.flip(self.amplitude, axis=-1)\n    new_phase = np.flip(self.phase, axis=-1)\n    return self.set_phasor(new_amplitude, new_phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_x_and_y","title":"<code>invert_x_and_y()</code>","text":"<p>Reflects the wavefront about both axes.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the phase and amplitude arrays reversed along both axes.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def invert_x_and_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Reflects the wavefront about both axes.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the phase and amplitude arrays reversed\n        along both axes.\n    \"\"\"\n    new_amplitude = np.flip(self.amplitude, axis=(-1, -2))\n    new_phase = np.flip(self.phase, axis=(-1, -2))\n    return self.set_phasor(new_amplitude, new_phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_y","title":"<code>invert_y()</code>","text":"<p>Reflects the wavefront about the y axis.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phase and amplitude arrays reversed along the y axis.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def invert_y(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Reflects the wavefront about the y axis.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the phase and amplitude arrays reversed\n        along the y axis.\n    \"\"\"\n    new_amplitude = np.flip(self.amplitude, axis=-2)\n    new_phase = np.flip(self.phase, axis=-2)\n    return self.set_phasor(new_amplitude, new_phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.multiply_amplitude","title":"<code>multiply_amplitude(array_like)</code>","text":"<p>Multiply the amplitude of the <code>Wavefront</code> by either a float or array.</p> <p>Parameters:</p> Name Type Description Default <code>array_like</code> <code>Array</code> <p>An array or float that has the same dimensions as amplitude that is multipled by the current ampltide.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated amplitude.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def multiply_amplitude(self : Wavefront, array_like : Array) -&gt; Wavefront:\n\"\"\"\n    Multiply the amplitude of the `Wavefront` by either a float or array.\n\n    Parameters\n    ----------\n    array_like : Array\n        An array or float that has the same dimensions as amplitude that is\n        multipled by the current ampltide.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the updated amplitude.\n    \"\"\"\n    amplitude = self.amplitude\n    assert isinstance(array_like, Array) and array_like.ndim in (0, 2, 3), \\\n    (\"array_like must be either a scalar array or array with 2 or 3 \"\n     \"dimensions.\")\n    if array_like.ndim in (2, 3):\n        assert array_like.shape[-2:] == amplitude.shape[-2:], \\\n        (\"array_like shape must be equal to the current ampltude array.\")\n    return self.set_amplitude(amplitude * array_like)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the total power of the wavefront to 1.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the normalised electric field amplitudes.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def normalise(self : Wavefront) -&gt; Wavefront:\n\"\"\"\n    Normalises the total power of the wavefront to 1.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront with the normalised electric field amplitudes.\n    \"\"\"\n    return self.multiply_amplitude(1 / np.linalg.norm(self.amplitude))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pad_to","title":"<code>pad_to(npixels_out)</code>","text":"<p>Paraxially zero-pads the <code>Wavefront</code> to the size determined by npixels_out. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or 3 -&gt; 5.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The size of the array to pad to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> zero-padded to the size npixels_out.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def pad_to(self : Wavefront, npixels_out : int) -&gt; Wavefront:\n\"\"\"\n    Paraxially zero-pads the `Wavefront` to the size determined by\n    npixels_out. Note this only supports padding arrays of even dimension\n    to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or\n    3 -&gt; 5.\n\n    Parameters\n    ----------\n    npixels_out : int\n        The size of the array to pad to the wavefront to.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` zero-padded to the size npixels_out.\n    \"\"\"\n    npixels_in  = self.npixels\n    assert npixels_in  % 2 == npixels_out % 2, \\\n    (\"Only supports even -&gt; even or odd -&gt; odd padding\")\n    assert npixels_out &gt; npixels_in, (\"npixels_out must be larger than the\"\n    \" current array size: {}\".format(npixels_in))\n\n    new_centre = npixels_out // 2\n    centre = npixels_in  // 2\n    remainder = npixels_in  % 2\n    padded = np.zeros([self.nfields, npixels_out, npixels_out])\n\n    new_amplitude = padded.at[:,\n            new_centre - centre : centre + new_centre + remainder,\n            new_centre - centre : centre + new_centre + remainder\n        ].set(self.amplitude)\n    new_phase = padded.at[:,\n            new_centre - centre : centre + new_centre + remainder,\n            new_centre - centre : centre + new_centre + remainder\n        ].set(self.phase)\n    return self.set_phasor(new_amplitude, new_phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"<code>rotate(angle, real_imaginary=False, fourier=False, order=1, padding=2)</code>","text":"<p>Performs a paraxial rotation on the wavefront, determined by the the angle parameter. By default the rotation is performed using a simple linear interpolation, but an information perserving rotation using fourier methods can be done by setting <code>fourier = True</code>. By default rotation is done on the amplitude and phase arrays, however by passing <code>real_imgainary=True</code> the rotation is done on the real and imaginary components.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in a clockwise direction.</p> required <code>real_imaginary</code> <code>bool</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the the amplitude and phase representation.</p> <code>False</code> <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>order</code> <code>int</code> <p>The interpolation order to use. Must be 0, 1, or 3.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront rotated by angle in the clockwise direction.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def rotate(self           : Wavefront,\n           angle          : Array,\n           real_imaginary : bool = False,\n           fourier        : bool = False,\n           order          : int  = 1,\n           padding        : int  = 2) -&gt; Wavefront:\n\"\"\"\n    Performs a paraxial rotation on the wavefront, determined by the\n    the angle parameter. By default the rotation is performed using a\n    simple linear interpolation, but an information perserving rotation\n    using fourier methods can be done by setting `fourier = True`. By\n    default rotation is done on the amplitude and phase arrays, however by\n    passing `real_imgainary=True` the rotation is done on the real and\n    imaginary components.\n\n    Parameters\n    ----------\n    angle : Array, radians\n        The angle by which to rotate the wavefront in a clockwise direction.\n    real_imaginary : bool = False\n        Whether to rotate the real and imaginary representation of the\n        wavefront as opposed to the the amplitude and phase representation.\n    fourier : bool = False\n        Should the fourier rotation method be used (True), or regular\n        interpolation method be used (False).\n    order : int = 2\n        The interpolation order to use. Must be 0, 1, or 3.\n    padding : int = 2\n        The amount of fourier padding to use. Only applies if fourier is\n        True.\n\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new wavefront rotated by angle in the clockwise direction.\n    \"\"\"\n    # Get Field\n    if real_imaginary:\n        field = np.array([self.real, self.imaginary])\n    else:\n        field = np.array([self.amplitude, self.phase])\n\n    # Rotate\n    if field.shape[1] == 1:\n        new_amplitude, new_phase = \\\n        rotate_field(field[:, 0], angle, fourier=fourier,\n                real_imaginary=real_imaginary, order=order)[:, None, :, :]\n    else:\n        rotator = vmap(rotate_field, in_axes=(1, None))\n        new_amplitude, new_phase = rotator(field, angle, fourier=fourier,\n                                real_imaginary=real_imaginary, order=order)\n\n    # Update parameters\n    return tree_at(lambda wavefront: (wavefront.amplitude, wavefront.phase),\n                               self, (new_amplitude, new_phase))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_amplitude","title":"<code>set_amplitude(amplitude)</code>","text":"<p>Mutator for the amplitude attribute.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated amplitude.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def set_amplitude(self : Wavefront, amplitude : Array) -&gt; Wavefront:\n\"\"\"\n    Mutator for the amplitude attribute.\n\n    Parameters\n    ---------\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the updated amplitude.\n    \"\"\"\n    assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n    (\"amplitude must be a 3d array.\")\n    return tree_at(\n        lambda wavefront : wavefront.amplitude, self, amplitude)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_phase","title":"<code>set_phase(phase)</code>","text":"<p>Mutator for the phase attribute.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phases of each pixel on the <code>Wavefront</code>.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated phase.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def set_phase(self : Wavefront, phase : Array) -&gt; Wavefront:\n\"\"\"\n    Mutator for the phase attribute.\n\n    Parameters\n    ----------\n    phase : Array, radians\n        The phases of each pixel on the `Wavefront`.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the updated phase.\n    \"\"\"\n    assert isinstance(phase, Array) and phase.ndim == 3, \\\n    (\"phase must be a 3d array.\")\n    return tree_at(\n        lambda wavefront : wavefront.phase, self, phase)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_phasor","title":"<code>set_phasor(amplitude, phase)</code>","text":"<p>Updates the phasor of the wavefront (ie both the amplitude and the phase).</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>Array, power</code> <p>The new electric field amplitude of the wavefront.</p> required <code>phase</code> <code>Array, radians</code> <p>The new electric field phase of the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with updated amplitude and phase.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def set_phasor(self      : Wavefront,\n                  amplitude : Array,\n                  phase     : Array) -&gt; Wavefront:\n\"\"\"\n    Updates the phasor of the wavefront (ie both the amplitude and the\n    phase).\n\n    Parameters\n    ----------\n    amplitude : Array, power\n        The new electric field amplitude of the wavefront.\n    phase : Array, radians\n        The new electric field phase of the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with updated amplitude and phase.\n    \"\"\"\n    assert isinstance(amplitude, Array) and amplitude.ndim == 3, \\\n    (\"amplitude must be a 3d array.\")\n    assert isinstance(phase, Array) and phase.ndim == 3, \\\n    (\"phase must be a 3d array.\")\n    assert amplitude.shape == phase.shape, \\\n    (\"amplitude and phase arrays must have the same shape.\")\n    return tree_at(\n        lambda wavefront : (wavefront.amplitude, wavefront.phase), self,\n                           (amplitude, phase))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_pixel_scale","title":"<code>set_pixel_scale(pixel_scale)</code>","text":"<p>Mutator for the pixel_scale attribute.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale</code> <code>Array</code> <p>The new pixel_scale associated with the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new Wavefront object with the updated pixel_scale.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def set_pixel_scale(self : Wavefront, pixel_scale : Array) -&gt; Wavefront:\n\"\"\"\n    Mutator for the pixel_scale attribute.\n\n    Parameters\n    ----------\n    pixel_scale : Array\n        The new pixel_scale associated with the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new Wavefront object with the updated pixel_scale.\n    \"\"\"\n    assert isinstance(pixel_scale, Array) and pixel_scale.ndim == 0, \\\n    (\"pixel_scale must be a scalar array.\")\n    return tree_at(\n        lambda wavefront : wavefront.pixel_scale, self, pixel_scale)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_plane_type","title":"<code>set_plane_type(plane)</code>","text":"<p>Mutator for the PlaneType attribute.</p> <p>Parameters:</p> Name Type Description Default <code>plane</code> <code>PlaneType</code> <p>A PlaneType object describing the plane that the <code>Wavefront</code> is currently in.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the update plate_type information.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def set_plane_type(self : Wavefront, plane : PlaneType) -&gt; Wavefront:\n\"\"\"\n    Mutator for the PlaneType attribute.\n\n    Parameters\n    ----------\n    plane : PlaneType\n        A PlaneType object describing the plane that the `Wavefront` is\n        currently in.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the update plate_type information.\n    \"\"\"\n    assert isinstance(plane, PlaneType), \\\n    (\"plane must be a PlaneType object.\")\n    return tree_at(\n        lambda wavefront : wavefront.plane_type, self, plane)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.tilt_wavefront","title":"<code>tilt_wavefront(tilt_angles)</code>","text":"<p>Tilts the wavefront by the tilt_angles.</p> <p>Parameters:</p> Name Type Description Default <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the (x, y) tilts applied.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def tilt_wavefront(self : Wavefront, tilt_angles : Array) -&gt; Wavefront:\n\"\"\"\n    Tilts the wavefront by the tilt_angles.\n\n    Parameters\n    ----------\n    tilt_angles : Array, radians\n        The (x, y) angles by which to tilt the wavefront.\n\n    Returns\n    -------\n    wavefront : Wavefront\n        The new `Wavefront` with the (x, y) tilts applied.\n    \"\"\"\n    assert isinstance(tilt_angles, Array) and tilt_angles.shape == (2,), \\\n    (\"tilt_angles must be an array with shape (2,) ie. (x, y).\")\n\n    opds = tilt_angles[:, None, None] * self.pixel_coordinates\n    return self.add_phase(- self.wavenumber * opds.sum(0))\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavefront_to_psf","title":"<code>wavefront_to_psf(return_polarised=False)</code>","text":"<p>Calculates the Point Spread Function (PSF), ie the squared modulus of the complex wavefront.</p> <p>TODO: Take in the parameters dictionary and use the parameters in that to determine the way to output the wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p> Source code in <code>dLux/wavefronts.py</code> <pre><code>def wavefront_to_psf(self             : Wavefront,\n                     return_polarised : bool = False) -&gt; Array:\n\"\"\"\n    Calculates the Point Spread Function (PSF), ie the squared modulus\n    of the complex wavefront.\n\n    TODO: Take in the parameters dictionary and use the parameters in that\n    to determine the way to output the wavefront.\n\n    Returns\n    -------\n    psf : Array\n        The PSF of the wavefront.\n    \"\"\"\n    return np.sum(self.amplitude ** 2, axis=0)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.diameter","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.imaginary","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.nfields","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.npixels","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.phasor","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pixel_coordinates","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.psf","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.real","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavenumber","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_opd","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.add_phase","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.crop_to","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.interpolate","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_x","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_x_and_y","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.invert_y","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.multiply_amplitude","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.normalise","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.pad_to","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.rotate","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_amplitude","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_phase","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_phasor","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_pixel_scale","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.set_plane_type","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.tilt_wavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.Wavefront.wavefront_to_psf","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.AngularWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for Angular wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel. Units are in meters per pixel in Pupil planes and radians per pixel in Focal planes.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self        : Wavefront,\n             wavelength  : Array,\n             pixel_scale : Array,\n             amplitude   : Array,\n             phase       : Array,\n             plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n    Constructor for Angular wavefronts.\n\n    Parameters\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians/pixel\n        The physical dimensions of each pixel. Units are in meters\n        per pixel in Pupil planes and radians per pixel in Focal planes.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane of wavefront, can be Pupil, Focal.\n    \"\"\"\n    super().__init__(wavelength, pixel_scale,\n                     amplitude, phase, plane_type)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.AngularWavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.AngularWavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.CartesianWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for Cartesian wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self        : Wavefront,\n             wavelength  : Array,\n             pixel_scale : Array,\n             amplitude   : Array,\n             phase       : Array,\n             plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n    Constructor for Cartesian wavefronts.\n\n    Parameters\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, meters/pixel\n        The physical dimensions of each pixel.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane of wavefront, can be Pupil, Focal.\n    \"\"\"\n    super().__init__(wavelength, pixel_scale,\n                     amplitude, phase, plane_type)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.CartesianWavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.CartesianWavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FarFieldFresnelWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for FarFieldFresnel wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel. Units are in meters per pixel in Pupil planes and meters per pixel or radians per pixel in Focal planes depending on if Cartesian or Angular Propagators are used respectively.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required Source code in <code>dLux/wavefronts.py</code> <pre><code>def __init__(self        : Wavefront,\n             wavelength  : Array,\n             pixel_scale : Array,\n             amplitude   : Array,\n             phase       : Array,\n             plane_type  : PlaneType) -&gt; Wavefront:\n\"\"\"\n    Constructor for FarFieldFresnel wavefronts.\n\n    Parameters\n    ----------\n    wavelength : float, meters\n        The wavelength of the `Wavefront`.\n    pixel_scale : float, meters/pixel or radians.pixl\n        The physical dimensions of each pixel. Units are in meters\n        per pixel in Pupil planes and meters per pixel or radians per pixel\n        in Focal planes depending on if Cartesian or Angular Propagators\n        are used respectively.\n    amplitude : Array, power\n        The electric field amplitude of the `Wavefront`.\n    phase : Array, radians\n        The electric field phase of the `Wavefront`.\n    plane_type : enum.IntEnum.PlaneType\n        The current plane of wavefront, can be Pupil, Focal.\n    \"\"\"\n    super().__init__(wavelength, pixel_scale,\n                     amplitude, phase, plane_type)\n</code></pre>"},{"location":"docs/API/wavefronts/#dLux.wavefronts.FarFieldFresnelWavefront","title":"Wavefronts","text":""},{"location":"docs/API/wavefronts/#dLux.wavefronts.FarFieldFresnelWavefront.__init__","title":"Wavefronts","text":""},{"location":"docs/notebooks/Core_classes/","title":"\u2202Lux Overview!","text":"In\u00a0[\u00a0]: Copied!"},{"location":"docs/notebooks/Core_classes/#lux-overview","title":"\u2202Lux Overview!\u00b6","text":"<p>This tutorial is designed to give users a gentle introduction to \u2202Lux, how it works and how to use it! Unfortunatly it is still under development, but please check out all of our other tutorials, which still show how to use \u2202Lux!</p>"},{"location":"docs/notebooks/HMC/","title":"Numpyro and Hamiltonian Monte Carlo","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# PPL\nimport numpyro as npy\nimport numpyro.distributions as dist\n\n# Set CPU count for numpyro multi-chain multi-thread\nimport os\nos.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nimport chainconsumer as cc\n\n# Set global plotting parameters\n%matplotlib inline\nplt.figure()\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = 'serif'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # PPL import numpyro as npy import numpyro.distributions as dist  # Set CPU count for numpyro multi-chain multi-thread import os os.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt import chainconsumer as cc  # Set global plotting parameters %matplotlib inline plt.figure() plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = 'serif' plt.rcParams[\"text.usetex\"] = 'true' plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> <p>First we want to create our spectral object for our binary star source, and then create the binary star object</p> In\u00a0[2]: Copied! <pre># Create Combined Spectrum for Binary\nwavels = np.linspace(400e-9, 500e-9, 3)\n\n# Create Binary Source\ntrue_position = np.zeros(2)\ntrue_separation = dl.utils.arcseconds_to_radians(8e-2)\ntrue_position_angle = np.pi/2\ntrue_flux = 1e3\ntrue_contrast = 2\nsource = dl.BinarySource(true_position, true_flux, true_separation, \n                         true_position_angle, true_contrast, \n                         wavelengths=wavels, name=\"Binary\")\n</pre> # Create Combined Spectrum for Binary wavels = np.linspace(400e-9, 500e-9, 3)  # Create Binary Source true_position = np.zeros(2) true_separation = dl.utils.arcseconds_to_radians(8e-2) true_position_angle = np.pi/2 true_flux = 1e3 true_contrast = 2 source = dl.BinarySource(true_position, true_flux, true_separation,                           true_position_angle, true_contrast,                           wavelengths=wavels, name=\"Binary\") <p>Next we define the optical system and detector, and combine then with the binary soure in order to create a telescope object that we will use to model all of these components simultaneously.</p> In\u00a0[3]: Copied! <pre># Construct Optical system\nwf_npix = 128\ndet_npix = 16\n\n# Zernike aberrations\nzernike_basis = np.arange(3, 10)\ntrue_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (zernike_basis.shape[0],))\n\n# Construct optical layers\ntrue_pixel_scale = dl.utils.arcseconds_to_radians(30e-3)\nlayers = [dl.CreateWavefront(wf_npix, 1),\n          dl.ApertureFactory(wf_npix, zernikes=zernike_basis, coefficients=true_coeffs),\n          dl.NormaliseWavefront(),\n          dl.AngularMFT(det_npix, true_pixel_scale)]\noptics = dl.Optics(layers)\n\n# Construct Detector\ntrue_bg = 10.\ndetector_layers = [dl.AddConstant(true_bg)]\ndetector = dl.Detector(detector_layers)\n\n# Construct Telescope\ntelescope = dl.Instrument(optics, source, detector)\n</pre> # Construct Optical system wf_npix = 128 det_npix = 16  # Zernike aberrations zernike_basis = np.arange(3, 10) true_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (zernike_basis.shape[0],))  # Construct optical layers true_pixel_scale = dl.utils.arcseconds_to_radians(30e-3) layers = [dl.CreateWavefront(wf_npix, 1),           dl.ApertureFactory(wf_npix, zernikes=zernike_basis, coefficients=true_coeffs),           dl.NormaliseWavefront(),           dl.AngularMFT(det_npix, true_pixel_scale)] optics = dl.Optics(layers)  # Construct Detector true_bg = 10. detector_layers = [dl.AddConstant(true_bg)] detector = dl.Detector(detector_layers)  # Construct Telescope telescope = dl.Instrument(optics, source, detector) <p>Now lets create the fake data and examine it. Note that for Numpyro we will flatten our data to make it easier to interact with</p> In\u00a0[4]: Copied! <pre>## Gerenate psf\npsf = telescope.model()\npsf_photon = jr.poisson(jr.PRNGKey(0), psf)\nbg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape)\nimage = psf_photon + bg_noise\ndata = image.flatten()\n\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 2)\nplt.title(\"PSF with photon noise\")\nplt.imshow(psf_photon)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Data\")\nplt.imshow(image)\nplt.colorbar()\nplt.show()\n</pre> ## Gerenate psf psf = telescope.model() psf_photon = jr.poisson(jr.PRNGKey(0), psf) bg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape) image = psf_photon + bg_noise data = image.flatten()  plt.figure(figsize=(15, 4)) plt.subplot(1, 3, 1) plt.title(\"PSF\") plt.imshow(psf) plt.colorbar()  plt.subplot(1, 3, 2) plt.title(\"PSF with photon noise\") plt.imshow(psf_photon) plt.colorbar()  plt.subplot(1, 3, 3) plt.title(\"Data\") plt.imshow(image) plt.colorbar() plt.show() <p>Now we construct our Numpyro sampling function. In this function we need to define priors distribution variables for our parameters, and feed them (along with the corresponsing path to that parameter in the model) into the .update_and_model() function. This allows for Numpyro to simulatensly sample the posterior for all of the parameters by taking advantage of the differentiable nature of these models.</p> <p>With these parameters we define a 'plate' which defines our data, using a Possion likelihood since this is our dominant noise source.</p> In\u00a0[5]: Copied! <pre>def psf_model(data, model, path_dict=None):\n\"\"\"\n    Define the numpyro function\n    \"\"\"\n    # Define empty paths and values lists to append to\n    paths, values = [], []\n    \n    # Position\n    position_pix = npy.sample(\"position_pix\", dist.Uniform(-5, 5), sample_shape=(2,))\n    position     = npy.deterministic('position', position_pix*true_pixel_scale)\n    paths.append('Binary.position'), values.append(position)\n    \n    # Separation\n    separation_log = npy.sample(\"log_separation\", dist.Uniform(-12, -6))\n    separation     = npy.deterministic('separation', 10**(separation_log))\n    paths.append('Binary.separation'), values.append(separation)\n    \n    # Field Angle (Position Angle)\n    theta_x = npy.sample(\"theta_x\", dist.Normal(0, 1))\n    theta_y = npy.sample(\"theta_y\", dist.HalfNormal(1))\n    position_angle = npy.deterministic('position_angle', np.arctan2(theta_y, theta_x))\n    paths.append('Binary.position_angle'), values.append(position_angle)\n    \n    # Flux\n    flux_log = npy.sample(\"log_flux\", dist.Uniform(0, 5))\n    flux     = npy.deterministic('flux', 10**flux_log)\n    paths.append('Binary.flux'), values.append(flux)\n    \n    # Flux ratio\n    contrast_log = npy.sample(\"log_contrast\", dist.Uniform(-4, 2))\n    contrast     = npy.deterministic('contrast', 10**contrast_log)\n    paths.append('Binary.contrast'), values.append(contrast)\n\n    # Background\n    bg = npy.sample(\"bg\", dist.Uniform(5, 15))\n    paths.append('AddConstant.value'), values.append(bg)\n    \n    # Zernikes\n    coeffs_norm = npy.sample(\"coeffs_norm\", dist.Normal(0, 1), sample_shape=true_coeffs.shape)\n    coeffs = npy.deterministic('coeffs', 1e-9*coeffs_norm)\n    paths.append('CircularAperture.coefficients'), values.append(coeffs)\n\n    with npy.plate(\"data\", len(data)):\n        poisson_model = dist.Poisson(model.set_and_call(\n            paths, values, \"model\", flatten=True))\n        return npy.sample(\"psf\", poisson_model, obs=data)\n</pre> def psf_model(data, model, path_dict=None):     \"\"\"     Define the numpyro function     \"\"\"     # Define empty paths and values lists to append to     paths, values = [], []          # Position     position_pix = npy.sample(\"position_pix\", dist.Uniform(-5, 5), sample_shape=(2,))     position     = npy.deterministic('position', position_pix*true_pixel_scale)     paths.append('Binary.position'), values.append(position)          # Separation     separation_log = npy.sample(\"log_separation\", dist.Uniform(-12, -6))     separation     = npy.deterministic('separation', 10**(separation_log))     paths.append('Binary.separation'), values.append(separation)          # Field Angle (Position Angle)     theta_x = npy.sample(\"theta_x\", dist.Normal(0, 1))     theta_y = npy.sample(\"theta_y\", dist.HalfNormal(1))     position_angle = npy.deterministic('position_angle', np.arctan2(theta_y, theta_x))     paths.append('Binary.position_angle'), values.append(position_angle)          # Flux     flux_log = npy.sample(\"log_flux\", dist.Uniform(0, 5))     flux     = npy.deterministic('flux', 10**flux_log)     paths.append('Binary.flux'), values.append(flux)          # Flux ratio     contrast_log = npy.sample(\"log_contrast\", dist.Uniform(-4, 2))     contrast     = npy.deterministic('contrast', 10**contrast_log)     paths.append('Binary.contrast'), values.append(contrast)      # Background     bg = npy.sample(\"bg\", dist.Uniform(5, 15))     paths.append('AddConstant.value'), values.append(bg)          # Zernikes     coeffs_norm = npy.sample(\"coeffs_norm\", dist.Normal(0, 1), sample_shape=true_coeffs.shape)     coeffs = npy.deterministic('coeffs', 1e-9*coeffs_norm)     paths.append('CircularAperture.coefficients'), values.append(coeffs)      with npy.plate(\"data\", len(data)):         poisson_model = dist.Poisson(model.set_and_call(             paths, values, \"model\", flatten=True))         return npy.sample(\"psf\", poisson_model, obs=data) <p>Now we can use the numpyro.render_model() function to check to make sure everything is being fed in correctly</p> In\u00a0[6]: Copied! <pre># npy.render_model(psf_model, model_args=(data, telescope))\n</pre> # npy.render_model(psf_model, model_args=(data, telescope)) <p>Using the model above, we can now sample from the posterior distribution using the No U-Turn Sampler (NUTS).</p> In\u00a0[7]: Copied! <pre>sampler = npy.infer.MCMC(\n    npy.infer.NUTS(psf_model),    \n    num_warmup=2000,\n    num_samples=2000,\n    num_chains=jax.device_count(),\n    progress_bar=True,\n)\n%time sampler.run(jr.PRNGKey(0), data, telescope)\n</pre> sampler = npy.infer.MCMC(     npy.infer.NUTS(psf_model),         num_warmup=2000,     num_samples=2000,     num_chains=jax.device_count(),     progress_bar=True, ) %time sampler.run(jr.PRNGKey(0), data, telescope) <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 8min 52s, sys: 40.4 s, total: 9min 32s\nWall time: 1min 38s\n</pre> <p>Now we examine the summary - Note here we want to make sure that all of the r_hat values are ~1</p> In\u00a0[8]: Copied! <pre>sampler.print_summary()\nvalues_out = sampler.get_samples()\n</pre> sampler.print_summary() values_out = sampler.get_samples() <pre>\n                      mean       std    median      5.0%     95.0%     n_eff     r_hat\n              bg     10.27      0.24     10.27      9.86     10.64   6743.19      1.00\n  coeffs_norm[0]     -0.00      0.99     -0.01     -1.59      1.64   6946.62      1.00\n  coeffs_norm[1]     -0.02      1.02     -0.02     -1.71      1.62   7362.42      1.00\n  coeffs_norm[2]      0.02      1.00      0.02     -1.65      1.62   7860.50      1.00\n  coeffs_norm[3]      0.01      0.99      0.03     -1.68      1.58   8307.07      1.00\n  coeffs_norm[4]      0.26      0.96      0.24     -1.31      1.83   7908.65      1.00\n  coeffs_norm[5]     -0.29      0.97     -0.29     -1.90      1.28   8527.31      1.00\n  coeffs_norm[6]      0.33      0.97      0.33     -1.32      1.87   7091.66      1.00\n    log_contrast      0.38      0.05      0.38      0.30      0.46   5848.75      1.00\n        log_flux      2.98      0.01      2.98      2.96      3.00   7451.86      1.00\n  log_separation     -6.39      0.02     -6.39     -6.42     -6.36   6620.59      1.00\n position_pix[0]     -0.11      0.09     -0.11     -0.25      0.04   5589.99      1.00\n position_pix[1]     -0.02      0.05     -0.02     -0.12      0.06   6676.25      1.00\n         theta_x     -0.01      0.06     -0.01     -0.11      0.08   5806.88      1.00\n         theta_y      1.27      0.65      1.18      0.24      2.19   4141.45      1.00\n\nNumber of divergences: 268\n</pre> <p>This is just a helper function to recast the names of the parameters, and to re-order them for plotting. It it not important.</p> In\u00a0[9]: Copied! <pre>def make_dict(dict_in, truth=False):\n\"\"\"\n    Just a convenience formatting function to latexise parameter names\n    for plotting\n    \"\"\"\n    znames = ['Focus', 'Astig45', 'Astig0', 'ComaY', 'ComaX', 'TfoilY', 'TfoilX']\n    name_dict = {'separation'    : 'r', \n                 'position_angle': r'$\\phi$',\n                 'field_angle'   : r'$\\phi$',\n                 'contrast'      : 'Contrast', \n                 'flux_ratio'    : 'Contrast', \n                 'flux'          :  r'$\\overline{flux}$',\n                 'bg'            : '$\\mu_{BG}$'}\n    \n    dict_out = {}\n    keys = list(dict_in.keys())\n    for i in range(len(keys)):\n        key = keys[i]\n        if 'log' in key or 'theta' in key or '_pix' in key:\n            continue\n        item = dict_in[key]\n        if key == 'position':\n            for j in range(item.shape[-1]):\n                dict_out[['Posx', 'Posy'][j]] = item[j] if truth else item[:, j]\n                    \n        elif key == 'coefficients' or key == 'coeffs' or key == 'coeffs_norm':\n            for j in range(item.shape[-1]):\n                dict_out[znames[j]] = item[j] if truth else item[:, j]\n        else:\n            dict_out[name_dict[key]] = item\n    \n    # Now re-order for nicer plotting\n    order = ['r', \n             r'$\\phi$', \n             'Posx', \n             'Posy', \n             r'$\\overline{flux}$', \n             'Contrast', \n             '$\\\\mu_{BG}$', \n             # 'Focus', \n             # 'Astig45', \n             # 'Astig0', \n             # 'ComaY', \n             # 'ComaX', \n             # 'TfoilY', \n             # 'TfoilX',\n            ]\n\n    new_dict = {}\n    for key in order:\n        new_dict[key] = dict_out[key]\n    return new_dict\n</pre> def make_dict(dict_in, truth=False):     \"\"\"     Just a convenience formatting function to latexise parameter names     for plotting     \"\"\"     znames = ['Focus', 'Astig45', 'Astig0', 'ComaY', 'ComaX', 'TfoilY', 'TfoilX']     name_dict = {'separation'    : 'r',                   'position_angle': r'$\\phi$',                  'field_angle'   : r'$\\phi$',                  'contrast'      : 'Contrast',                   'flux_ratio'    : 'Contrast',                   'flux'          :  r'$\\overline{flux}$',                  'bg'            : '$\\mu_{BG}$'}          dict_out = {}     keys = list(dict_in.keys())     for i in range(len(keys)):         key = keys[i]         if 'log' in key or 'theta' in key or '_pix' in key:             continue         item = dict_in[key]         if key == 'position':             for j in range(item.shape[-1]):                 dict_out[['Posx', 'Posy'][j]] = item[j] if truth else item[:, j]                              elif key == 'coefficients' or key == 'coeffs' or key == 'coeffs_norm':             for j in range(item.shape[-1]):                 dict_out[znames[j]] = item[j] if truth else item[:, j]         else:             dict_out[name_dict[key]] = item          # Now re-order for nicer plotting     order = ['r',               r'$\\phi$',               'Posx',               'Posy',               r'$\\overline{flux}$',               'Contrast',               '$\\\\mu_{BG}$',               # 'Focus',               # 'Astig45',               # 'Astig0',               # 'ComaY',               # 'ComaX',               # 'TfoilY',               # 'TfoilX',             ]      new_dict = {}     for key in order:         new_dict[key] = dict_out[key]     return new_dict <p>Now we can create our truth dictionary and format our chains in order to create nice corner plots using chain consumer</p> In\u00a0[10]: Copied! <pre># Format chains for plotting\ntruth_dict = {'bg':             true_bg,          \n              'coefficients':   true_coeffs, \n              'position_angle': true_position_angle, \n              'flux':           true_flux, \n              'contrast':       true_contrast,  \n              'position':       true_position, \n              'separation':     true_separation,  \n              }\n\ntruth_dict_in = make_dict(truth_dict, truth=True)\nchain_dict = make_dict(values_out)\n</pre> # Format chains for plotting truth_dict = {'bg':             true_bg,                         'coefficients':   true_coeffs,                'position_angle': true_position_angle,                'flux':           true_flux,                'contrast':       true_contrast,                 'position':       true_position,                'separation':     true_separation,                 }  truth_dict_in = make_dict(truth_dict, truth=True) chain_dict = make_dict(values_out) In\u00a0[11]: Copied! <pre>chain = cc.ChainConsumer()\nchain.add_chain(chain_dict)\nchain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\nfig = chain.plotter.plot(truth=truth_dict_in)\nfig.set_size_inches((15,15));\n</pre> chain = cc.ChainConsumer() chain.add_chain(chain_dict) chain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  fig = chain.plotter.plot(truth=truth_dict_in) fig.set_size_inches((15,15)); <p>Excellent! As we can see all of the praameters are well constrained!</p>"},{"location":"docs/notebooks/HMC/#numpyro-and-hamiltonian-monte-carlo","title":"Numpyro and Hamiltonian Monte Carlo\u00b6","text":"<p>In this tutorial we will see how we to integrate our \u2202Lux optical models with a Probablistic Programming Language (PPL) Numpyro. This allows us to run a subset of MCMC algorithms known as HMC, that take advantage of autodiff in order to infer the relationship between a large number of parameters.</p> <p>In this example we will simulate a binary star through a simple optical system, and simultanesouly infer the parameters of the stars and the state of the optical system at the same time.</p>"},{"location":"docs/notebooks/HMC/#inference-with-numpyro","title":"Inference with Numpyro\u00b6","text":"<p>Awesome, now we are going to try and infer these parameters using an MCMC algortihm. There a few different parameters we want to learn:</p>"},{"location":"docs/notebooks/HMC/#binary-parameters","title":"Binary parameters\u00b6","text":"<ul> <li>The (x,y) mean position (2 parameters)</li> <li>The separation (1 parameter)</li> <li>The position angle (1 parameter)</li> <li>The mean flux (1 parameter)</li> <li>The contrast ratio (1 parameter)</li> </ul>"},{"location":"docs/notebooks/HMC/#optical-parameters","title":"Optical parameters\u00b6","text":"<ul> <li>The zernike aberration coefficients (7 parameters)</li> </ul>"},{"location":"docs/notebooks/HMC/#detector-parameters","title":"Detector parameters\u00b6","text":"<ul> <li>The mean detector noise (1 parameter)</li> </ul> <p>This gives us a total of 14 parameters, which is quite high dimensional for regular MCMC algortihms.</p>"},{"location":"docs/notebooks/designing_a_mask/","title":"Phase Mask Design","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax.numpy as np\nimport jax.random as jr\nfrom jax import vmap\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax.numpy as np import jax.random as jr from jax import vmap  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>We will first generate an orthonormal basis for the pupil phases, and then threshold this to {0, 1} while preserving soft edges using the Continuous Latent Image Mask Binarization (CLIMB) algorithm from the Wong et al paper.</p> <p>Generate basis vectors however you like - in this case we are using logarithmic radial harmonics and sines and cosines in \u03b8., but you can do whatever you like here. This code is not important; just generate your favourite not-necessarily-orthonormal basis, and we will use PCA to orthonormalize it later on.</p> In\u00a0[2]: Copied! <pre># Define arrays sizes, samplings, symmetries\nwf_npix = 256\noversample = 3\nnslice = 3\n\n# Define basis hyper parameters\na = 10\nb = 8\nith = 10\n</pre> # Define arrays sizes, samplings, symmetries wf_npix = 256 oversample = 3 nslice = 3  # Define basis hyper parameters a = 10 b = 8 ith = 10 In\u00a0[3]: Copied! <pre># Define coordinate grids\nnpix = wf_npix * oversample\nc = (npix - 1) / 2.\nxs = (np.arange(npix) - c) / c\nXX, YY = np.meshgrid(xs, xs)\nRR = np.sqrt(XX ** 2 + YY ** 2)\nPHI = np.arctan2(YY, XX)\n\n# Generate basis vectors to map over\nAs = np.arange(-a, a+1)\nBs = nslice * np.arange(0, b+1)\nCs = np.array([-np.pi/2, np.pi/2])\nIs = np.arange(-ith, ith+1)\n\n# Define basis functions\nLRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C)\nsine_fn = lambda i, RR: np.sin(i * np.pi * RR)\ncose_fn = lambda i, RR: np.cos(i * np.pi * RR)\n\n# Map over basis functions\ngen_LRHF_basis = vmap(vmap(vmap( \\\n                            LRHF_fn, (None, 0, None, None, None)), \n                                     (0, None, None, None, None)), \n                                     (None, None, 0, None, None))\ngen_sine_basis = vmap(sine_fn, in_axes=(0, None))\ngen_cose_basis = vmap(cose_fn, in_axes=(0, None))\n\n# Generate basis\nLRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\\n            .reshape([len(As)*len(Bs)*len(Cs), npix, npix])\nsine_basis = gen_sine_basis(Is, RR)\ncose_basis = gen_cose_basis(Is, RR)\n\n# Format shapes and combine\nLRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix])\nsine_flat = sine_basis.reshape([len(sine_basis), npix*npix])\ncose_flat = cose_basis.reshape([len(cose_basis), npix*npix])\nfull_basis = np.concatenate([\n    LRHF_flat,\n    sine_flat,\n    cose_flat\n])\n</pre> # Define coordinate grids npix = wf_npix * oversample c = (npix - 1) / 2. xs = (np.arange(npix) - c) / c XX, YY = np.meshgrid(xs, xs) RR = np.sqrt(XX ** 2 + YY ** 2) PHI = np.arctan2(YY, XX)  # Generate basis vectors to map over As = np.arange(-a, a+1) Bs = nslice * np.arange(0, b+1) Cs = np.array([-np.pi/2, np.pi/2]) Is = np.arange(-ith, ith+1)  # Define basis functions LRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C) sine_fn = lambda i, RR: np.sin(i * np.pi * RR) cose_fn = lambda i, RR: np.cos(i * np.pi * RR)  # Map over basis functions gen_LRHF_basis = vmap(vmap(vmap( \\                             LRHF_fn, (None, 0, None, None, None)),                                       (0, None, None, None, None)),                                       (None, None, 0, None, None)) gen_sine_basis = vmap(sine_fn, in_axes=(0, None)) gen_cose_basis = vmap(cose_fn, in_axes=(0, None))  # Generate basis LRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\             .reshape([len(As)*len(Bs)*len(Cs), npix, npix]) sine_basis = gen_sine_basis(Is, RR) cose_basis = gen_cose_basis(Is, RR)  # Format shapes and combine LRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix]) sine_flat = sine_basis.reshape([len(sine_basis), npix*npix]) cose_flat = cose_basis.reshape([len(cose_basis), npix*npix]) full_basis = np.concatenate([     LRHF_flat,     sine_flat,     cose_flat ]) <p>Orthonormalize with PCA - could also use Gram-Schmidt if you prefer.</p> In\u00a0[4]: Copied! <pre># %%time\n# from sklearn.decomposition import PCA\n# pca = PCA().fit(full_basis)\n\n# components = pca.components_.reshape([len(full_basis), npix, npix])\n# components = np.copy(components[:99,:,:])\n# basis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])\n\n# # save for use later\n# np.save('files/basis', basis)\n\n# Load if already generated\nbasis = np.load('files/basis.npy')\n</pre> # %%time # from sklearn.decomposition import PCA # pca = PCA().fit(full_basis)  # components = pca.components_.reshape([len(full_basis), npix, npix]) # components = np.copy(components[:99,:,:]) # basis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])  # # save for use later # np.save('files/basis', basis)  # Load if already generated basis = np.load('files/basis.npy') <p>Show the pretty basis vectors:</p> In\u00a0[5]: Copied! <pre># nfigs = 100\n# ncols = 10\n# nrows = 1 + nfigs//ncols\n\n# plt.figure(figsize=(4*ncols, 4*nrows))\n# for i in range(nfigs):\n#     plt.subplot(nrows, ncols, i+1)\n#     plt.imshow(basis[i], cmap='seismic')\n#     plt.xticks([])\n#     plt.yticks([])\n# plt.tight_layout()\n# plt.show()\n</pre> # nfigs = 100 # ncols = 10 # nrows = 1 + nfigs//ncols  # plt.figure(figsize=(4*ncols, 4*nrows)) # for i in range(nfigs): #     plt.subplot(nrows, ncols, i+1) #     plt.imshow(basis[i], cmap='seismic') #     plt.xticks([]) #     plt.yticks([]) # plt.tight_layout() # plt.show() <p>First we want to construct a dLux layer that we can use to design a binary mask, for this we will use <code>ApplyBasisCLIMB</code> which soft-thresholds the edges (see Wong et al, 2021, sec 3.2.2). In brief, what this does is make an OPD map as a weighted sum of modes; where this is positive, we set to \u03c0 phase, where it is negative, we set it to zero, and on the edges, we soft-edge it to propagate gradients.</p> In\u00a0[6]: Copied! <pre># Define our mask layer, here we use ApplyBasisCLIMB\nwavels = 1e-9 * np.linspace(595, 695, 3)\ncoeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)])\nCLIMB = dl.ApplyBasisCLIMB(basis, np.mean(wavels), coeffs)\n</pre> # Define our mask layer, here we use ApplyBasisCLIMB wavels = 1e-9 * np.linspace(595, 695, 3) coeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)]) CLIMB = dl.ApplyBasisCLIMB(basis, np.mean(wavels), coeffs) <p>Now we create our optical system, we can use the pre-built TOLIMAN models, with an oversampled detector.</p> In\u00a0[7]: Copied! <pre>from dLux.utils import radians_to_arcseconds as r2a, get_pixel_scale, toliman\n\n# Array sizes\nwavefront_npixels = basis.shape[-1]//3\ndetector_npixels = 128\nsampling_rate = 5 # pixels per fringe ie 5x nyquist\ndetector_pixel_size = get_pixel_scale(sampling_rate, wavels.max(), 0.125)\n\n# Make optical system\noptics = toliman(wavefront_npixels, detector_npixels, \n                 detector_pixel_size=r2a(detector_pixel_size),\n                 extra_layers=[CLIMB], angular=True)\n</pre> from dLux.utils import radians_to_arcseconds as r2a, get_pixel_scale, toliman  # Array sizes wavefront_npixels = basis.shape[-1]//3 detector_npixels = 128 sampling_rate = 5 # pixels per fringe ie 5x nyquist detector_pixel_size = get_pixel_scale(sampling_rate, wavels.max(), 0.125)  # Make optical system optics = toliman(wavefront_npixels, detector_npixels,                   detector_pixel_size=r2a(detector_pixel_size),                  extra_layers=[CLIMB], angular=True) <p>Now we also add a small amount of jitter, to help engineer the psf shape, and define a simple point source. We then combine all of these together into an instrument</p> In\u00a0[8]: Copied! <pre># Add some detector jitter\ndetector = dl.Detector([dl.ApplyJitter(2.)])\n\n# Define a source\nsource = dl.PointSource(wavelengths=wavels)\n\n# Create our instrument\ntel = dl.Instrument(optics, source, detector)\n</pre> # Add some detector jitter detector = dl.Detector([dl.ApplyJitter(2.)])  # Define a source source = dl.PointSource(wavelengths=wavels)  # Create our instrument tel = dl.Instrument(optics, source, detector) <p>We also define a minimum and maximum radius that we want to try and push all of the light into using the mask. Now lets examine all of this together.</p> In\u00a0[9]: Copied! <pre>rmin = 1*sampling_rate # 1 lam/D\nrmax = 8*sampling_rate # 8 lam/D\n</pre> rmin = 1*sampling_rate # 1 lam/D rmax = 8*sampling_rate # 8 lam/D In\u00a0[10]: Copied! <pre>aperture = tel.CircularAperture.aperture\nmask = tel.ApplyBasisCLIMB.get_binary_phase()\ninner = plt.Circle((64, 64), rmin, fill=False, color='w')\nouter = plt.Circle((64, 64), rmax, fill=False, color='w')\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture*mask, cmap='hot')\nplt.title('Input OPD')\n\nax = plt.subplot(1, 2, 2)\nax.imshow(tel.model())\nax.set_title('Input PSF')\nax.add_patch(inner)\nax.add_patch(outer)\nplt.show()\n</pre> aperture = tel.CircularAperture.aperture mask = tel.ApplyBasisCLIMB.get_binary_phase() inner = plt.Circle((64, 64), rmin, fill=False, color='w') outer = plt.Circle((64, 64), rmax, fill=False, color='w')  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture*mask, cmap='hot') plt.title('Input OPD')  ax = plt.subplot(1, 2, 2) ax.imshow(tel.model()) ax.set_title('Input PSF') ax.add_patch(inner) ax.add_patch(outer) plt.show() <p>Now lets define our loss function. We can pass the path to our mask coefficients to the <code>zdx.filter_value_and_grad</code> function in order to generate gradients for only those terms!</p> In\u00a0[11]: Copied! <pre>param = 'ApplyBasisCLIMB.coefficients'\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef loss_func(tel, rmin=20, rmax=150, power=0.5):\n    # Get PSF, Gradients and Mask\n    psf = tel.model()\n    Rmask = dl.utils.get_radial_mask(psf.shape[0], rmin, rmax)\n\n    # Calcualte loss\n    loss1 = - np.power(Rmask*dl.utils.get_GE(psf),  power).sum()/1\n    loss2 = - np.power(Rmask*dl.utils.get_RGE(psf), power).sum()\n    return loss1 + loss2\n</pre> param = 'ApplyBasisCLIMB.coefficients'  @zdx.filter_jit @zdx.filter_value_and_grad(param) def loss_func(tel, rmin=20, rmax=150, power=0.5):     # Get PSF, Gradients and Mask     psf = tel.model()     Rmask = dl.utils.get_radial_mask(psf.shape[0], rmin, rmax)      # Calcualte loss     loss1 = - np.power(Rmask*dl.utils.get_GE(psf),  power).sum()/1     loss2 = - np.power(Rmask*dl.utils.get_RGE(psf), power).sum()     return loss1 + loss2 <p>Evaluate once to <code>jit</code> compile:</p> In\u00a0[12]: Copied! <pre>%%time\nloss, grads = loss_func(tel, rmin=rmin, rmax=rmax) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = loss_func(tel, rmin=rmin, rmax=rmax) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -29.38055992126465\nCPU times: user 3.53 s, sys: 102 ms, total: 3.63 s\nWall time: 2.73 s\n</pre> <p>Gradient descent time!</p> In\u00a0[13]: Copied! <pre>model = tel\noptim, opt_state = zdx.get_optimiser(model, param, optax.adam(5e1))\n\nlosses, models_out = [], []\nwith tqdm(range(100),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_func(model, rmin=rmin, rmax=rmax)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> model = tel optim, opt_state = zdx.get_optimiser(model, param, optax.adam(5e1))  losses, models_out = [], [] with tqdm(range(100),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_func(model, rmin=rmin, rmax=rmax)         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)          t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Visualize the results:</p> In\u00a0[14]: Copied! <pre>coeffs_out = np.array([model.get(param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\naxes['C'].imshow(aperture*mask,cmap='hot')\naxes['C'].set_title('Input OPD')\n\n# Model without jitter\npsf_in = tel.set('detector.layers', {}).model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nfinal = models_out[-1]\naxes['E'].imshow(aperture*final.ApplyBasisCLIMB.get_binary_phase(),cmap='hot')\naxes['E'].set_title('Final OPD')\n\n# Model without jitter\npsf_out = final.set('detector.layers', {}).model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n</pre> coeffs_out = np.array([model.get(param) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  axes['C'].imshow(aperture*mask,cmap='hot') axes['C'].set_title('Input OPD')  # Model without jitter psf_in = tel.set('detector.layers', {}).model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  final = models_out[-1] axes['E'].imshow(aperture*final.ApplyBasisCLIMB.get_binary_phase(),cmap='hot') axes['E'].set_title('Final OPD')  # Model without jitter psf_out = final.set('detector.layers', {}).model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF') Out[14]: <pre>Text(0.5, 1.0, 'Final PSF')</pre> In\u00a0[15]: Copied! <pre>psf_out = final.set('detector.layers', {}).model()\nnew = final.set('detector.layers', {}).model()\n\nps = final.AngularMFT.pixel_scale_out\nnpix = final.AngularMFT.npixels_out\n\nnew = final.set(['AngularMFT.pixel_scale_out', 'AngularMFT.npixels_out'], [ps/10, 10*npix]).model()\n</pre> psf_out = final.set('detector.layers', {}).model() new = final.set('detector.layers', {}).model()  ps = final.AngularMFT.pixel_scale_out npix = final.AngularMFT.npixels_out  new = final.set(['AngularMFT.pixel_scale_out', 'AngularMFT.npixels_out'], [ps/10, 10*npix]).model() In\u00a0[16]: Copied! <pre>plt.figure(figsize=(20, 4))\nplt.subplot(1, 4, 1)\nplt.imshow(psf_out)\nplt.colorbar()\n\nplt.subplot(1, 4, 2)\nplt.imshow(dl.utils.get_GE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 3)\nplt.imshow(dl.utils.get_RGE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 4)\nplt.imshow(dl.utils.get_RWGE(psf_out))\nplt.colorbar()\nplt.show()\n</pre> plt.figure(figsize=(20, 4)) plt.subplot(1, 4, 1) plt.imshow(psf_out) plt.colorbar()  plt.subplot(1, 4, 2) plt.imshow(dl.utils.get_GE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 3) plt.imshow(dl.utils.get_RGE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 4) plt.imshow(dl.utils.get_RWGE(psf_out)) plt.colorbar() plt.show() In\u00a0[17]: Copied! <pre># # Save mask for use in flatfield_calibration notebook\n# mask_out = models_out[-1].ApplyBasisCLIMB.get_binary_phase()\n# np.save(\"files/test_mask\", mask_out)\n</pre> # # Save mask for use in flatfield_calibration notebook # mask_out = models_out[-1].ApplyBasisCLIMB.get_binary_phase() # np.save(\"files/test_mask\", mask_out) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"docs/notebooks/designing_a_mask/#phase-mask-design","title":"Phase Mask Design\u00b6","text":"<p>In this notebook, we will illustrate the problem of inverse design of a phase mask: we will choose the example from Wong et al, 2021, designing a diffractive pupil phase mask for the Toliman telescope.</p> <p>In order to get high precision centroids, we need to maximize the gradient energy of the pupil; in order to satisfy fabrication constraints, we need a binary mask with phases only in {0, \u03c0}.</p>"},{"location":"docs/notebooks/designing_a_mask/#optimizing-the-pupil","title":"Optimizing the Pupil\u00b6","text":""},{"location":"docs/notebooks/fisher_information/","title":"Fisher Information","text":"<p>Right, let's import some things.</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nfrom jax.config import config\n\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Bayesan functions\nfrom dLux.utils import bayes\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nfrom chainconsumer import ChainConsumer\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax from jax.config import config  import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Bayesan functions from dLux.utils import bayes  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm from chainconsumer import ChainConsumer  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"text.usetex\"] = 'true' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>First we construct our parameterised Binary Source</p> In\u00a0[2]: Copied! <pre>separation = dl.utils.arcseconds_to_radians(10)\nwavels = 1e-9 * np.linspace(595, 695, 3)\nsource = dl.BinarySource(separation=separation, position_angle=np.pi/2, \n                         flux=1e6, contrast=1, wavelengths=wavels)\n</pre> separation = dl.utils.arcseconds_to_radians(10) wavels = 1e-9 * np.linspace(595, 695, 3) source = dl.BinarySource(separation=separation, position_angle=np.pi/2,                           flux=1e6, contrast=1, wavelengths=wavels) <p>Here we want to optimise a binary mask using the CLIMB algorithm using the saved basis vectors from the tutorial on designing a mask.</p> <p>We can use the pre-built Toliman model, while adding our CLIMB mask.</p> In\u00a0[3]: Copied! <pre># Binary CLIMB mask basis\nclimb_basis = np.load(\"files/basis.npy\")\ncoefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)])\nmask_layer = dl.ApplyBasisCLIMB(climb_basis, wavels.mean(), coefficients)\n\noptics = dl.utils.toliman(wavefront_npixels   = 256,\n                          detector_npixels    = 256,\n                          detector_pixel_size = 0.2,\n                          nzernike            = 7,\n                          extra_layers        = [mask_layer])\n\n# Construct instrument\nmodel = dl.Instrument(optics, source)\n</pre> # Binary CLIMB mask basis climb_basis = np.load(\"files/basis.npy\") coefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)]) mask_layer = dl.ApplyBasisCLIMB(climb_basis, wavels.mean(), coefficients)  optics = dl.utils.toliman(wavefront_npixels   = 256,                           detector_npixels    = 256,                           detector_pixel_size = 0.2,                           nzernike            = 7,                           extra_layers        = [mask_layer])  # Construct instrument model = dl.Instrument(optics, source) <p>Visualize the PSF:</p> In\u00a0[4]: Copied! <pre>aperture = model.CircularAperture.aperture\nmask = model.ApplyBasisCLIMB.get_binary_phase()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture * mask, cmap='hot')\nplt.title('Input OPD')\n\nplt.subplot(1, 2, 2)\npsf = model.model()\nplt.imshow(psf)\nplt.colorbar()\nplt.title('Input PSF')\nplt.show()\n</pre> aperture = model.CircularAperture.aperture mask = model.ApplyBasisCLIMB.get_binary_phase()  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture * mask, cmap='hot') plt.title('Input OPD')  plt.subplot(1, 2, 2) psf = model.model() plt.imshow(psf) plt.colorbar() plt.title('Input PSF') plt.show() <p>Now here we want to optimise the coefficients of the binary mask, with respect to the entropy of the covaraince matrix. To do this we need to define which parameters we want to calculate the covariance with respect to. To do this we create a function that perturbs each of the parameters we want to opitmise with respect to, optionally scalling them by the appropriate units, and return this model. Becuase dLux is end-to-end differentiable, we take gradients of our model with respect to this function!</p> In\u00a0[5]: Copied! <pre>def perturb(X, model):\n\"\"\"\n    Perturbs the values of the model\n    \"\"\"\n    a2r = dl.utils.arcseconds_to_radians(1)\n    \n    # Separation (arcseconds)\n    model = model.add('BinarySource.separation', X[0] * a2r)\n    \n    # contrast \n    model = model.add('BinarySource.contrast', X[1])\n    \n    # Position Angle (milli-arcseconds)\n    model = model.add('BinarySource.position_angle', X[2] * a2r * 1e-3)\n    \n    # Mean wavelength (nm)\n    model = model.add('BinarySource.spectrum.wavelengths', X[3] * 1e-9)\n    \n    # Plate Scale (nm)\n    model = model.add('AngularMFT.pixel_scale_out', X[4] * 1e-9)\n\n    # Zernikes (nm)\n    model = model.add('CircularAperture.coefficients', X[5:] * 1e-9)\n\n    # Return\n    return model\n\nX = np.zeros(12)\n</pre> def perturb(X, model):     \"\"\"     Perturbs the values of the model     \"\"\"     a2r = dl.utils.arcseconds_to_radians(1)          # Separation (arcseconds)     model = model.add('BinarySource.separation', X[0] * a2r)          # contrast      model = model.add('BinarySource.contrast', X[1])          # Position Angle (milli-arcseconds)     model = model.add('BinarySource.position_angle', X[2] * a2r * 1e-3)          # Mean wavelength (nm)     model = model.add('BinarySource.spectrum.wavelengths', X[3] * 1e-9)          # Plate Scale (nm)     model = model.add('AngularMFT.pixel_scale_out', X[4] * 1e-9)      # Zernikes (nm)     model = model.add('CircularAperture.coefficients', X[5:] * 1e-9)      # Return     return model  X = np.zeros(12) <p>Define a loss function and specify that we are only optimizing over the CLIMB basis coefficients:</p> <p>Note here in the loss function we are calculating the entropy of the covariance matrix with respect to some arbitrary log-likelihood function</p> In\u00a0[6]: Copied! <pre>param = 'ApplyBasisCLIMB.coefficients'\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(param)\ndef fim_loss_func(model, X, loglike_fn, update_fn, model_fn):\n    psf = model.model()\n    loss = bayes.calculate_entropy(loglike_fn, X, psf, model, update_fn, model_fn)\n    return loss\n</pre> param = 'ApplyBasisCLIMB.coefficients'  @zdx.filter_jit @zdx.filter_value_and_grad(param) def fim_loss_func(model, X, loglike_fn, update_fn, model_fn):     psf = model.model()     loss = bayes.calculate_entropy(loglike_fn, X, psf, model, update_fn, model_fn)     return loss <p>Call the loss function once to compile:</p> In\u00a0[7]: Copied! <pre>%%time\nloss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model') print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -21.312088012695312\nCPU times: user 16.6 s, sys: 486 ms, total: 17.1 s\nWall time: 9.36 s\n</pre> <p>Now run gradient descent!</p> In\u00a0[8]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, param, optax.adam(1e2))\n\nlosses, models_out = [], [model]\nwith tqdm(range(50),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> optim, opt_state = zdx.get_optimiser(model, param, optax.adam(1e2))  losses, models_out = [], [model] with tqdm(range(50),desc='Gradient Descent') as t:     for i in t:          loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)         t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> In\u00a0[9]: Copied! <pre>coeffs_out = np.array([model.get(param) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\nmask = models_out[0].ApplyBasisCLIMB.get_binary_phase()\naxes['C'].imshow(aperture * mask, cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = models_out[0].model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nmask = models_out[-1].ApplyBasisCLIMB.get_binary_phase()\naxes['E'].imshow(aperture * mask, cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = models_out[-1].model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n\nplt.show()\n</pre> coeffs_out = np.array([model.get(param) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])   axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  mask = models_out[0].ApplyBasisCLIMB.get_binary_phase() axes['C'].imshow(aperture * mask, cmap='hot') axes['C'].set_title('Input OPD')  psf_in = models_out[0].model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  mask = models_out[-1].ApplyBasisCLIMB.get_binary_phase() axes['E'].imshow(aperture * mask, cmap='hot') axes['E'].set_title('Final OPD')  psf_out = models_out[-1].model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF')  plt.show() <p>Let's calculate the covariance matrix elements:</p> In\u00a0[10]: Copied! <pre>%%time\ncovs = [bayes.calculate_covariance(bayes.poisson_log_likelihood, X, model.model(), model, perturb, 'model') for model in [models_out[0], models_out[-1]]]\n</pre> %%time covs = [bayes.calculate_covariance(bayes.poisson_log_likelihood, X, model.model(), model, perturb, 'model') for model in [models_out[0], models_out[-1]]] <pre>CPU times: user 11.1 s, sys: 715 ms, total: 11.8 s\nWall time: 5.11 s\n</pre> <p>And using ChainConsumer we can easily visualize this covariance:</p> In\u00a0[11]: Copied! <pre>param_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",\n               \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",\n               \"TfoilX\", \"TfoilY\"]\n\nc = ChainConsumer()\nc.add_covariance(X, covs[0], parameters=param_names, name='Initial')\nc.add_covariance(X, covs[1], parameters=param_names, name='Final')\nc.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\n# fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised\nfig = c.plotter.plot()\n</pre> param_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",                \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",                \"TfoilX\", \"TfoilY\"]  c = ChainConsumer() c.add_covariance(X, covs[0], parameters=param_names, name='Initial') c.add_covariance(X, covs[1], parameters=param_names, name='Final') c.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  # fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised fig = c.plotter.plot() <pre>/Users/louis/mambaforge/envs/dLux/lib/python3.11/site-packages/chainconsumer/chainconsumer.py:346: RuntimeWarning: covariance is not symmetric positive-semidefinite.\n  chain = np.random.multivariate_normal(mean, covariance, size=1000000)\n</pre> <p>It looks like the optimization worked - marginal posterior bounds for all the optical parameters are much tighter after the optimization than they were before.</p> <p>We see that in this narrowband simulation, most parameters aren't tightly correlated, but separation, plate scale and wavelength are almost indistinguishable - this makes sense, as they affect the PSF in the same way! Only independent constraints on \u03bb can save us here. If you want to do precise astrometry, you have to nail down your plate scale and your spectrum: we see that the marginal posterior for separation is the same, but dominated entirely by this degeneracy with plate scale and \u03bb, which is much tighter for the optimized pupil.</p> <p>This is why in the Toliman telescope design we superimpose a grating over our pupil (design paper, Fig 6) - so we can measure a stellar spectrum and separate this from the astrometry.</p> <p>If we were doing this properly for a telescope design, we would want to take this into account - our real goal is precisely measuring separation, and everything else is something we can just marginalize over. If we incorporate our prior constraints on plate scale and wavelength I am sure we will do even better.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"docs/notebooks/fisher_information/#fisher-information","title":"Fisher Information\u00b6","text":"<p>Autodiff doesn't just make it faster to solve optimization and inference problems - it also allows you to use powerful ideas in statistics that require second derivatives that are intractable analytically or with finite differences.</p> <p>The Fisher Information Matrix, or the inverse of the Hessian of the likelihood, can be used for</p> <ul> <li>the Laplace approximation to a posterior for variational inference, giving you the Gaussian covariance of the posterior near the maximum likelihood point;</li> <li>Fisher forecasting, where you calculate this for an instrument or experiment at expected parameters, to predict how well it will constrain them; and</li> <li>optimal design, as the Cram\u00e9r-Rao lower bound on the precision of an experiment is the inverse of the Fisher information matrix - so you want to make this as tight as possible!</li> </ul> <p>Because <code>jax</code> lets us compute the Hessian of our loss function, we can use the Fisher matrix for variational inference without MCMC, and also more powerfully as an objective function to optimize a telescope design: why bother engineering a PSF for a particular goal, when you could model the system end to end and optimize the precision of the Fisher forecast of the parameter of interest?</p> <ul> <li>This is the topic of a Desdoigts et al paper in prep. It wasn't quite that easy to build and we're pretty happy about it.</li> </ul> <p>This notebook follows on from Phase Mask Design and will reuse some of the same code without repeating explanations.</p>"},{"location":"docs/notebooks/flatfield_calibration/","title":"Pixel Level Calibration","text":"<p>First, import everything as usual:</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nfrom dLux.utils import arcseconds_to_radians as a2r\nfrom dLux.utils import radians_to_arcseconds as r2a\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl from dLux.utils import arcseconds_to_radians as a2r from dLux.utils import radians_to_arcseconds as r2a  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>Then we generate an array of 5 dithered images, in a coarsely-sampled broad bandwidth, of 15 stars. The reason we want multiple stars, and especially dithered images, is because we want to retrieve the flat field - multiplicative errors on each pixel that, if we only have the one image, are formally degenerate with the PSF. It turns out that if we can hit each pixel with light from the same PSF multiple times, we can retrieve the whole thing unambiguously.</p> <p>We will use the presaved default Toliman pupil - a diffractive pupil that nicely spreads out the PSF in a highly structured pattern, designed (with <code>dLux</code>) to be ideal for astrometry and field calibration.</p> <p>We will then add some Zernike mode aberrations on top of this, and have some 5% level flat field calibration errors, and additive background noise.</p> In\u00a0[2]: Copied! <pre># Basic Optical Parameters\ndiameter = 0.5\nwf_npix = 256 \n\n# Detector Parameters\ndet_npix = 256 \ndet_pixsize = a2r(10/det_npix)\n\n# Load mask\nraw_mask = np.load(\"files/test_mask.npy\") * (6e-7/(2*np.pi))\nmask = dl.utils.scale_array(raw_mask, wf_npix, 0)\n\n# Zernike Basis\nzern_basis = np.arange(3, 10)\ncoeffs = 2e-8 * jr.normal(jr.PRNGKey(0), [len(zern_basis)])\n\n# Define Optical Configuration\noptical_layers = [\n    dl.CreateWavefront    (wf_npix, diameter),\n    dl.ApertureFactory    (wf_npix, zernikes=zern_basis, coefficients=coeffs),\n    dl.AddOPD             (mask),\n    dl.NormaliseWavefront (),\n    dl.AngularMFT         (det_npix, det_pixsize)]\n\n# Create Optics object\noptics = dl.Optics(optical_layers)\n</pre> # Basic Optical Parameters diameter = 0.5 wf_npix = 256   # Detector Parameters det_npix = 256  det_pixsize = a2r(10/det_npix)  # Load mask raw_mask = np.load(\"files/test_mask.npy\") * (6e-7/(2*np.pi)) mask = dl.utils.scale_array(raw_mask, wf_npix, 0)  # Zernike Basis zern_basis = np.arange(3, 10) coeffs = 2e-8 * jr.normal(jr.PRNGKey(0), [len(zern_basis)])  # Define Optical Configuration optical_layers = [     dl.CreateWavefront    (wf_npix, diameter),     dl.ApertureFactory    (wf_npix, zernikes=zern_basis, coefficients=coeffs),     dl.AddOPD             (mask),     dl.NormaliseWavefront (),     dl.AngularMFT         (det_npix, det_pixsize)]  # Create Optics object optics = dl.Optics(optical_layers) In\u00a0[3]: Copied! <pre># Pixel response\npix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])\n\n# Create Detector object\ndetector = dl.Detector([dl.ApplyPixelResponse(pix_response)])\n</pre> # Pixel response pix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])  # Create Detector object detector = dl.Detector([dl.ApplyPixelResponse(pix_response)]) In\u00a0[4]: Copied! <pre># Multiple sources to observe\nNstars = 15\ntrue_positions = a2r(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-4, maxval=4))\ntrue_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(0), (Nstars,))\nwavels = 1e-9 * np.linspace(545, 645, 3)\n\n# Create Source object\nsource = dl.MultiPointSource(true_positions, true_fluxes, wavelengths=wavels)\n</pre> # Multiple sources to observe Nstars = 15 true_positions = a2r(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-4, maxval=4)) true_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(0), (Nstars,)) wavels = 1e-9 * np.linspace(545, 645, 3)  # Create Source object source = dl.MultiPointSource(true_positions, true_fluxes, wavelengths=wavels) <p>Now we need to introduce the dithers. To do this we define an 'observation function' that we use to update the relevant parameters and model the sources. Instruments have a pre-built <code>dither_and_model(dithers)</code> function that does this for us!</p> <p>With the observation function, we then put this inside of a dictionary under the key 'fn' along with the dithers under 'args'. We can then use the <code>.obserse()</code> method to call the function stored under 'fn' with the input arguments 'args'. This is how we allow for arbitrary observation stratergy to be modelled simply!</p> In\u00a0[5]: Copied! <pre># Observation stratergy, define dithers\ndithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]])\nobservation = dl.Dither(dithers)\n</pre> # Observation stratergy, define dithers dithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]]) observation = dl.Dither(dithers) <p>Now we combine all of this into an instrument and observe!</p> In\u00a0[6]: Copied! <pre># Combine into instrument\ntel = dl.Instrument(optics, source, detector, observation)\n\n# Observe!\npsfs = tel.observe()\n</pre> # Combine into instrument tel = dl.Instrument(optics, source, detector, observation)  # Observe! psfs = tel.observe() In\u00a0[7]: Copied! <pre># Apply some noise to the PSF Background noise\nBG_noise = np.abs(5*jr.normal(jr.PRNGKey(0), psfs.shape))\ndata = jr.poisson(jr.PRNGKey(0), psfs) + BG_noise\n\nplt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(data[i])\n    plt.colorbar()\nplt.show()\n</pre> # Apply some noise to the PSF Background noise BG_noise = np.abs(5*jr.normal(jr.PRNGKey(0), psfs.shape)) data = jr.poisson(jr.PRNGKey(0), psfs) + BG_noise  plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(data[i])     plt.colorbar() plt.show() <p>Now there are 4 sets of parameters we are going to learn:</p> <ul> <li>Positions</li> <li>Fluxes</li> <li>Zernike aberrations</li> <li>Pixel responses</li> </ul> <p>We start by defining the paths to those parameters. We will define them individually so we can refer to them easily later</p> In\u00a0[8]: Copied! <pre>positions = 'MultiPointSource.position'\nfluxes    = 'MultiPointSource.flux'\nzernikes  = 'CircularAperture.coefficients'\nflatfield = 'ApplyPixelResponse.pixel_response'\n\nparameters = [positions, fluxes, zernikes, flatfield]\n</pre> positions = 'MultiPointSource.position' fluxes    = 'MultiPointSource.flux' zernikes  = 'CircularAperture.coefficients' flatfield = 'ApplyPixelResponse.pixel_response'  parameters = [positions, fluxes, zernikes, flatfield] <p>Each of these parameters needs a different initilisation</p> <ul> <li>Positions need to be shifted by some random value</li> <li>Fluxes need to be multiplied by some random value</li> <li>Zernike coefficients need to be set to zero</li> <li>Pixel response values need to be set to one</li> </ul> <p>Perturb the values to intialise the model</p> In\u00a0[9]: Copied! <pre># Add small random values to the positions\nmodel = tel.add(positions, 2.5*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))\n\n# Multiply the fluxes by small random values\nmodel = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))\n\n# Set the zernike coefficients to zero\nmodel = model.set(zernikes, np.zeros(len(zern_basis)))\n\n# Set the flat fiel to uniform\nmodel = model.set(flatfield, np.ones((det_npix, det_npix)))\n\n# Generate psfs\npsfs = model.observe()\n</pre> # Add small random values to the positions model = tel.add(positions, 2.5*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))  # Multiply the fluxes by small random values model = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))  # Set the zernike coefficients to zero model = model.set(zernikes, np.zeros(len(zern_basis)))  # Set the flat fiel to uniform model = model.set(flatfield, np.ones((det_npix, det_npix)))  # Generate psfs psfs = model.observe() <p>Model and observe the residuals are pretty bad:</p> In\u00a0[10]: Copied! <pre>plt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(psfs[i] - data[i])\n    plt.colorbar()\nplt.show()\n</pre> plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(psfs[i] - data[i])     plt.colorbar() plt.show() <p>Now we want to generate an optax optimiser object that we can use to train each parameter individually. Becuase of the various scales and effect of the loss fucntion that each parameter has, we need to be able to set individual learning rates, and optimisation schedules for every parameter. Luckily we have built some functions to help specifically with that! Lets see how to use it!</p> In\u00a0[11]: Copied! <pre># So first we simply set the simple parameters to use an adam optimiser \n# algorithm, with individual learning rates\npos_optimiser   = optax.adam(2e-8)\nflux_optimiser  = optax.adam(1e6)\ncoeff_optimiser = optax.adam(2e-9)\n\n# Now the flat-field, becuase it is highly covariant with the mean flux level \n# we don't start learning its parameters until the 100th epoch.\nFF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8, \n                             boundaries_and_scales={100 : int(1e8)})\nFF_optimiser = optax.adam(FF_sched)\n\n# Combine the optimisers into a list\noptimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]\n\n# Generate out optax optimiser, and also get our args\noptim, opt_state = zdx.get_optimiser(model, parameters, optimisers)\n</pre> # So first we simply set the simple parameters to use an adam optimiser  # algorithm, with individual learning rates pos_optimiser   = optax.adam(2e-8) flux_optimiser  = optax.adam(1e6) coeff_optimiser = optax.adam(2e-9)  # Now the flat-field, becuase it is highly covariant with the mean flux level  # we don't start learning its parameters until the 100th epoch. FF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8,                               boundaries_and_scales={100 : int(1e8)}) FF_optimiser = optax.adam(FF_sched)  # Combine the optimisers into a list optimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]  # Generate out optax optimiser, and also get our args optim, opt_state = zdx.get_optimiser(model, parameters, optimisers) <p>Poisson log-likelihood:</p> In\u00a0[12]: Copied! <pre>@zdx.filter_jit\n@zdx.filter_value_and_grad(parameters)\ndef loss_fn(model, data):\n    out = model.observe()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</pre> @zdx.filter_jit @zdx.filter_value_and_grad(parameters) def loss_fn(model, data):     out = model.observe()     return -np.sum(jax.scipy.stats.poisson.logpmf(data, out)) <p>Call once to jit compile:</p> In\u00a0[13]: Copied! <pre>%%time\nloss, grads = loss_fn(model, data) # Compile\nprint(\"Initial Loss: {}\".format(int(loss)))\n</pre> %%time loss, grads = loss_fn(model, data) # Compile print(\"Initial Loss: {}\".format(int(loss))) <pre>Initial Loss: 1270765568\nCPU times: user 3.74 s, sys: 129 ms, total: 3.87 s\nWall time: 954 ms\n</pre> <p>Run gradient descent:</p> In\u00a0[14]: Copied! <pre>losses, models_out = [], []\nwith tqdm(range(200),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_fn(model, data)    \n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        losses.append(loss)\n        models_out.append(model)\n        t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar\n</pre> losses, models_out = [], [] with tqdm(range(200),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_fn(model, data)             updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         losses.append(loss)         models_out.append(model)         t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar <pre>Gradient Descent:   0%|          | 0/200 [00:00&lt;?, ?it/s]</pre> <p>Format the output into arrays:</p> In\u00a0[15]: Copied! <pre>nepochs = len(models_out)\npsfs_out = models_out[-1].observe()\n\npositions_found  = np.array([model.get(positions) for model in models_out])\nfluxes_found     = np.array([model.get(fluxes)    for model in models_out])\nzernikes_found   = np.array([model.get(zernikes)  for model in models_out])\nflatfields_found = np.array([model.get(flatfield) for model in models_out])\n</pre> nepochs = len(models_out) psfs_out = models_out[-1].observe()  positions_found  = np.array([model.get(positions) for model in models_out]) fluxes_found     = np.array([model.get(fluxes)    for model in models_out]) zernikes_found   = np.array([model.get(zernikes)  for model in models_out]) flatfields_found = np.array([model.get(flatfield) for model in models_out]) <p>Pull out the quantities to be plotted - eg final model and residuals:</p> In\u00a0[16]: Copied! <pre>coeff_residuals = coeffs - zernikes_found\nflux_residuals = true_fluxes - fluxes_found\n\nscaler = 1e3\npositions_residuals = true_positions - positions_found\nr_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1])\nr_residuals = r2a(r_residuals_rads)\n</pre> coeff_residuals = coeffs - zernikes_found flux_residuals = true_fluxes - fluxes_found  scaler = 1e3 positions_residuals = true_positions - positions_found r_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1]) r_residuals = r2a(r_residuals_rads) In\u00a0[17]: Copied! <pre>j = len(models_out)\nplt.figure(figsize=(16, 13))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Log10 Loss\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Log10 ADU\")\nplt.plot(np.log10(np.array(losses)[:j]))\n\nplt.subplot(3, 2, 2)\nplt.title(\"Stellar Positions\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Positional Error (arcseconds)\")\nplt.plot(r_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 3)\nplt.title(\"Stellar Fluxes\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Flux Error (Photons)\")\nplt.plot(flux_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Zernike Coeff Residuals\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Residual Amplitude\")\nplt.plot(coeff_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> j = len(models_out) plt.figure(figsize=(16, 13))  plt.subplot(3, 2, 1) plt.title(\"Log10 Loss\") plt.xlabel(\"Epochs\") plt.ylabel(\"Log10 ADU\") plt.plot(np.log10(np.array(losses)[:j]))  plt.subplot(3, 2, 2) plt.title(\"Stellar Positions\") plt.xlabel(\"Epochs\") plt.ylabel(\"Positional Error (arcseconds)\") plt.plot(r_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 3) plt.title(\"Stellar Fluxes\") plt.xlabel(\"Epochs\") plt.ylabel(\"Flux Error (Photons)\") plt.plot(flux_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 4) plt.title(\"Zernike Coeff Residuals\") plt.xlabel(\"Epochs\") plt.ylabel(\"Residual Amplitude\") plt.plot(coeff_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.tight_layout() plt.show() <p>How did the phase retrieval go? Really well, as it happens!</p> In\u00a0[18]: Copied! <pre># OPDs\ntrue_opd = tel.CircularAperture.get_opd()\nopds_found = np.array([model.CircularAperture.get_opd() for model in models_out])\nfound_opd = opds_found[-1]\nopd_residuls = true_opd - opds_found\nopd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5\n\nvmin = np.min(np.array([true_opd, found_opd]))\nvmax = np.max(np.array([true_opd, found_opd]))\n\n# Coefficients\ntrue_coeff = tel.get(zernikes)\nfound_coeff = models_out[-1].get(zernikes)\nindex = np.arange(len(true_coeff))+4\n\nplt.figure(figsize=(20, 10))\nplt.suptitle(\"Optical Aberrations\")\n\nplt.subplot(2, 2, 1)\nplt.title(\"RMS OPD residual\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"RMS OPD (nm)\")\nplt.plot(opd_rmse_nm)\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Zernike Coefficient Amplitude\")\nplt.xlabel(\"Index\")\nplt.ylabel(\"Amplitude\")\nplt.scatter(index, true_coeff, label=\"True Value\")\nplt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x')\nplt.bar(index, true_coeff - found_coeff, label='Residual')\nplt.axhline(0, c='k', alpha=0.5)\nplt.legend()\n\nplt.subplot(2, 3, 4)\nplt.title(\"True OPD\")\nplt.imshow(true_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found OPD\")\nplt.imshow(found_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"OPD Residual\")\nplt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax)\nplt.colorbar()\nplt.show()\n</pre> # OPDs true_opd = tel.CircularAperture.get_opd() opds_found = np.array([model.CircularAperture.get_opd() for model in models_out]) found_opd = opds_found[-1] opd_residuls = true_opd - opds_found opd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5  vmin = np.min(np.array([true_opd, found_opd])) vmax = np.max(np.array([true_opd, found_opd]))  # Coefficients true_coeff = tel.get(zernikes) found_coeff = models_out[-1].get(zernikes) index = np.arange(len(true_coeff))+4  plt.figure(figsize=(20, 10)) plt.suptitle(\"Optical Aberrations\")  plt.subplot(2, 2, 1) plt.title(\"RMS OPD residual\") plt.xlabel(\"Epochs\") plt.ylabel(\"RMS OPD (nm)\") plt.plot(opd_rmse_nm) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(2, 2, 2) plt.title(\"Zernike Coefficient Amplitude\") plt.xlabel(\"Index\") plt.ylabel(\"Amplitude\") plt.scatter(index, true_coeff, label=\"True Value\") plt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x') plt.bar(index, true_coeff - found_coeff, label='Residual') plt.axhline(0, c='k', alpha=0.5) plt.legend()  plt.subplot(2, 3, 4) plt.title(\"True OPD\") plt.imshow(true_opd) plt.colorbar()  plt.subplot(2, 3, 5) plt.title(\"Found OPD\") plt.imshow(found_opd) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"OPD Residual\") plt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax) plt.colorbar() plt.show() <p>Most impressively, we are getting the tens of thousands of parameters of the flat field pretty well too!</p> In\u00a0[19]: Copied! <pre># calculate the mask where there was enough flux to infer the flat field\nthresh = 2500\nfmask = data.mean(0) &gt;= thresh\n\nout_mask = np.where(data.mean(0) &lt; thresh)\nin_mask = np.where(data.mean(0) &gt;= thresh)\n\ndata_tile = np.tile(data.mean(0), [len(models_out), 1, 1])\nin_mask_tiled = np.where(data_tile &gt;= thresh)\n\n# calculate residuals\npr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]\n\n# for correlation plot\ntrue_pr_masked = pix_response.at[out_mask].set(1)\nfound_pr_masked = flatfields_found[-1].at[out_mask].set(1)\n\n# FF Scatter Plot\ndata_sum = data.sum(0) # [flux_mask]\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\n# Errors\npfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])])\nptrue = pix_response[in_mask]\npr_res = ptrue - pfound\nmasked_error = np.abs(pr_res).mean(-1)\n\nplt.figure(figsize=(20, 10))\nplt.subplot(2, 3, (1,2))\nplt.title(\"Pixel Response\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Mean Sensitivity Error\")\nplt.plot(masked_error)\nplt.axhline(0, c='k', alpha=0.5)\n\n# FF Scatter Plot\ndata_sum = data.sum(0)\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\nplt.subplot(2, 3, 3)\nplt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75)\nplt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5)\nplt.colorbar()\nplt.title(\"Sensitivity Residual\")\nplt.ylabel(\"Recovered Sensitivity\")\nplt.xlabel(\"True Sensitivity\")\n\nplt.subplot(2, 3, 4)\nplt.title(\"True Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked)\nplt.colorbar()\n\nvmin = np.min(pix_response)\nvmax = np.max(pix_response)\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(found_pr_masked, vmin=vmin, vmax=vmax)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"Pixel Response Residual\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2)\nplt.colorbar()\n\nplt.show()\n</pre> # calculate the mask where there was enough flux to infer the flat field thresh = 2500 fmask = data.mean(0) &gt;= thresh  out_mask = np.where(data.mean(0) &lt; thresh) in_mask = np.where(data.mean(0) &gt;= thresh)  data_tile = np.tile(data.mean(0), [len(models_out), 1, 1]) in_mask_tiled = np.where(data_tile &gt;= thresh)  # calculate residuals pr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]  # for correlation plot true_pr_masked = pix_response.at[out_mask].set(1) found_pr_masked = flatfields_found[-1].at[out_mask].set(1)  # FF Scatter Plot data_sum = data.sum(0) # [flux_mask] colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  # Errors pfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])]) ptrue = pix_response[in_mask] pr_res = ptrue - pfound masked_error = np.abs(pr_res).mean(-1)  plt.figure(figsize=(20, 10)) plt.subplot(2, 3, (1,2)) plt.title(\"Pixel Response\") plt.xlabel(\"Epochs\") plt.ylabel(\"Mean Sensitivity Error\") plt.plot(masked_error) plt.axhline(0, c='k', alpha=0.5)  # FF Scatter Plot data_sum = data.sum(0) colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  plt.subplot(2, 3, 3) plt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75) plt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5) plt.colorbar() plt.title(\"Sensitivity Residual\") plt.ylabel(\"Recovered Sensitivity\") plt.xlabel(\"True Sensitivity\")  plt.subplot(2, 3, 4) plt.title(\"True Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked) plt.colorbar()  vmin = np.min(pix_response) vmax = np.max(pix_response)  plt.subplot(2, 3, 5) plt.title(\"Found Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(found_pr_masked, vmin=vmin, vmax=vmax) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"Pixel Response Residual\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2) plt.colorbar()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"docs/notebooks/flatfield_calibration/#pixel-level-calibration","title":"Pixel Level Calibration\u00b6","text":"<p>There are a lot of existing frameworks for phase retrieval - but it is not so straightforward to simultaneously retrieve</p> <ul> <li>aberrations (the optical distortions, maybe tens of parameters)</li> <li>astrometry (the positions of stars, tens of parameters)</li> <li>interpixel sensitivity (aka the 'flat field', on a large pixel grid!)</li> </ul> <p>The dimensionality of the pixel grid can be so high it is hard to retrieve without autodiff. With <code>dLux</code>, it is easy*!</p> <p>* This is the topic of a Desdoigts et al paper in prep. It wasn't quite that easy to build and we're pretty happy about it.</p>"},{"location":"docs/notebooks/phase_retrieval_demo/","title":"Phase Retrieval in dLux","text":"<p>First, we import the necessary packages, including <code>Jax</code>:</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom matplotlib import colormaps\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt from matplotlib import colormaps from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <p>Now, we want to construct a basic optical system with a 1m aperture.</p> <p>We also generate a Zernike basis in order to model some optical aberrations, omitting the piston/tip/tilt elements, and initialising them as normally-distributed coefficients over that basis.</p> <p>As noted by Martinache et al 2013, you can only detect the sign of even-order aberrations if your pupil is not inversion-symmetric; so following that paper, we introduce a small bar asymmetry.</p> In\u00a0[2]: Copied! <pre># Basic Optical Parameters\ndiameter = 1.\nwf_npix = 256 \n\n# Detector Parameters\ndet_npix = 256 \ndet_pixsize = dl.utils.arcseconds_to_radians(1e-2)\n\n# Generate an asymmetry\nc, s = wf_npix//2, 13\nasymmetry = np.ones((wf_npix,wf_npix)).at[c-s:c+s, :c].set(0)\nasymmetric_mask = dl.TransmissiveOptic(asymmetry)\n\n# Define the aberrations\nseed = 0\nzernikes = np.arange(4, 11)\ncoeffs = 2e-8*jr.normal(jr.PRNGKey(seed), (len(zernikes),))\n</pre> # Basic Optical Parameters diameter = 1. wf_npix = 256   # Detector Parameters det_npix = 256  det_pixsize = dl.utils.arcseconds_to_radians(1e-2)  # Generate an asymmetry c, s = wf_npix//2, 13 asymmetry = np.ones((wf_npix,wf_npix)).at[c-s:c+s, :c].set(0) asymmetric_mask = dl.TransmissiveOptic(asymmetry)  # Define the aberrations seed = 0 zernikes = np.arange(4, 11) coeffs = 2e-8*jr.normal(jr.PRNGKey(seed), (len(zernikes),)) <p>Here is the core syntax of <code>dLux</code>: a list of optical layers. Unlike some other systems, we are very explicit about the whole optical system:</p> <ul> <li>First initialize a wavefront using the <code>CreateWavefront</code> class.</li> <li>For a simple circular aperutre extending the width of the wavefront we use the <code>ApertureFactory</code> class, specifying the the properties we want (ratio of primary to secondary mirror, number of struts etc), so it can pre-calculate the aperture and return the correct aperture class.</li> <li>We then want to apply the zernike aberrations using <code>AberrationFactory</code> to generate this class for us.</li> <li>To introduce our assymetry we add a <code>TransmissiveOptic</code> layer, feeding in the asymmetric array on ones and zeros we calcualted.</li> <li>We then normalise the flux to unitary power after the wavefront has passed through these two layers.</li> <li>Then we propagate our wavefront to a focal plane using the <code>AngularMFT</code> class, which defines pixel scale units in angular SI units, ie radians, specifying the number of pixels in the output detector.</li> </ul> In\u00a0[3]: Copied! <pre># Define Optical Configuration\noptical_layers = [\n    dl.CreateWavefront(wf_npix, diameter),\n    dl.ApertureFactory(wf_npix, nstruts=3, secondary_ratio=0.1, strut_ratio=0.01, name='Aperture'),\n    dl.AberrationFactory(wf_npix, zernikes=zernikes, coefficients=coeffs, name='Aberrations'),\n    dl.TransmissiveOptic(asymmetry),\n    dl.NormaliseWavefront(),\n    dl.AngularMFT(det_npix, det_pixsize)]\n\noptics = dl.Optics(optical_layers)\n</pre> # Define Optical Configuration optical_layers = [     dl.CreateWavefront(wf_npix, diameter),     dl.ApertureFactory(wf_npix, nstruts=3, secondary_ratio=0.1, strut_ratio=0.01, name='Aperture'),     dl.AberrationFactory(wf_npix, zernikes=zernikes, coefficients=coeffs, name='Aberrations'),     dl.TransmissiveOptic(asymmetry),     dl.NormaliseWavefront(),     dl.AngularMFT(det_npix, det_pixsize)]  optics = dl.Optics(optical_layers) <p>Now we also need to create a source that we will be examining with this optical configuration. Here we use a simple point source, which is initialised on-axis, with a flux of one. We only need to define the wavelengths of this source, so lets have a look at the resulting object.</p> In\u00a0[4]: Copied! <pre># Create a point source\nwavels = np.linspace(450e-9, 550e-9, 5)\nsource = dl.PointSource(wavelengths=wavels)\n</pre> # Create a point source wavels = np.linspace(450e-9, 550e-9, 5) source = dl.PointSource(wavelengths=wavels) <p>Now we want to combine these two objects together into the convenient dLux.Instrument class, in order to model the optical system response to the point source.</p> <p>Note all dLux objects that contain 'layers' - such as the optical layers we define above - can be accessed like an attribute of the class. In this case we want to examine the input optical aberrations, so we will access the 'ApplyBasisOPD' layer using this method.</p> In\u00a0[5]: Copied! <pre># Construct the instrument with the source\ntelescope = dl.Instrument(optics, source)\n\n# Get aperture &amp; aberrations\naper_in = telescope.Aperture.get_aperture()\naberr_in = telescope.Aberrations.get_opd()\n\n# Get mask, setting nan values for visualisation\nmask = 1.0*(aper_in*asymmetry &gt; 1e-5)\nmask = mask.at[mask==False].set(np.nan)\ncmap = colormaps['inferno']\ncmap.set_bad('k',1.)\n\n# Model the PSF using the .model() method\npsf = telescope.model()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aberrations\")\nplt.imshow(mask*aberr_in*1e9, cmap=cmap)\nplt.colorbar(label='nm')\n\nplt.subplot(1, 2, 2)\nplt.title(\"PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.show()\n</pre> # Construct the instrument with the source telescope = dl.Instrument(optics, source)  # Get aperture &amp; aberrations aper_in = telescope.Aperture.get_aperture() aberr_in = telescope.Aberrations.get_opd()  # Get mask, setting nan values for visualisation mask = 1.0*(aper_in*asymmetry &gt; 1e-5) mask = mask.at[mask==False].set(np.nan) cmap = colormaps['inferno'] cmap.set_bad('k',1.)  # Model the PSF using the .model() method psf = telescope.model()  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aberrations\") plt.imshow(mask*aberr_in*1e9, cmap=cmap) plt.colorbar(label='nm')  plt.subplot(1, 2, 2) plt.title(\"PSF\") plt.imshow(psf**0.5) plt.colorbar() plt.show() <p>Excellent! Now we want to try and recover these aberrations. To do this we want to create a new optical system with a different set of zernike aberrations. We can do this using the <code>.set()</code> method and defining the path the optical aberration coefficients and assigning a newly-randomlised coefficient values. With this new optical system we will try and recover the original aberration coefficients using gradient descent methods.</p> In\u00a0[6]: Copied! <pre># Define path to the zernikes\nzernikes = 'Aberrations.coefficients'\n\n# Generate new random set of zernikes\ncoeffs_init = 2e-8*jr.normal(jr.PRNGKey(seed + 1), [len(coeffs)])\n\n# Generate a new model with updated zernike coefficients\nmodel = telescope.set(zernikes, coeffs_init)\n</pre> # Define path to the zernikes zernikes = 'Aberrations.coefficients'  # Generate new random set of zernikes coeffs_init = 2e-8*jr.normal(jr.PRNGKey(seed + 1), [len(coeffs)])  # Generate a new model with updated zernike coefficients model = telescope.set(zernikes, coeffs_init) <p>Now we need to define our loss function, and specify that we want to optimise the zernike coefficients. To do this we can pass in the string path to our zernikes that we just defined into the <code>zdx.filter_value_and_grad()</code> function. Note we also use the <code>zdx.filter_jit()</code> function in order to compile this function into XLA in order to run much faster!</p> In\u00a0[7]: Copied! <pre>@zdx.filter_jit\n@zdx.filter_value_and_grad(zernikes)\ndef loss_func(model, data):\n    out = model.model()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</pre> @zdx.filter_jit @zdx.filter_value_and_grad(zernikes) def loss_func(model, data):     out = model.model()     return -np.sum(jax.scipy.stats.poisson.logpmf(data, out)) <p>Now we compile the function and time its evaluation - even on CPU it is fast!</p> In\u00a0[8]: Copied! <pre>%%time\nloss, initial_grads = loss_func(model, psf) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, initial_grads = loss_func(model, psf) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: 8.39254379272461\nCPU times: user 570 ms, sys: 18.1 ms, total: 588 ms\nWall time: 266 ms\n</pre> In\u00a0[9]: Copied! <pre>%%timeit\nloss = loss_func(model, psf)[0].block_until_ready()\n</pre> %%timeit loss = loss_func(model, psf)[0].block_until_ready() <pre>21.4 ms \u00b1 347 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre> <p>Now begin the optimization loop using <code>optax</code> with a low learning rate.</p> In\u00a0[10]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, [zernikes], [optax.adam(2e-9)])\n\nlosses, models_out = [], []\nwith tqdm(range(100), desc='Gradient Descent') as t:\n    for i in t: \n        # calculate the loss and gradient\n        loss, grads = loss_func(model, psf) \n        \n        # apply the update\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        \n        # save results\n        models_out.append(model) \n        losses.append(loss)\n        \n        t.set_description('Loss %.5f' % (loss)) # update the progress bar\nfinal_psf = model.model()\n</pre> optim, opt_state = zdx.get_optimiser(model, [zernikes], [optax.adam(2e-9)])  losses, models_out = [], [] with tqdm(range(100), desc='Gradient Descent') as t:     for i in t:          # calculate the loss and gradient         loss, grads = loss_func(model, psf)                   # apply the update         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)                  # save results         models_out.append(model)          losses.append(loss)                  t.set_description('Loss %.5f' % (loss)) # update the progress bar final_psf = model.model() <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Now we visualize this: we have great performance, recovering the input Zernike coefficients accurately and a beautiful PSF recovery.</p> In\u00a0[11]: Copied! <pre>coeffs_out = np.array([model_out.get(zernikes) for model_out in models_out])\n\nmosaic = \"\"\"\n    AABD\n    GGEF\n    \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['B','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Training History\")\naxes['A'].set_xlabel('Training Epoch')\naxes['A'].set_ylabel('Poisson Log-Likelihood')\n\naxes['B'].imshow(psf**0.5)\naxes['B'].set_title('True PSF')\n\naxes['G'].plot(coeffs*1e9,model.get(zernikes)*1e9,'.',markersize=12,color='C0',label='Recovered')\naxes['G'].plot(coeffs*1e9,coeffs_init*1e9,'.',markersize=12,color='C1',label='Initial')\n\naxes['G'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               '-',color='C2',label='1:1')\naxes['G'].legend()\naxes['G'].set_title('Correlation Plot ')\naxes['G'].set_xlabel('True Zernike Coefficients (nm)')\naxes['G'].set_ylabel('Model Zernike Coefficients (nm)')\n\naxes['D'].imshow(final_psf**0.5)\naxes['D'].set_title('Recovered PSF')\n\naxes['E'].imshow(mask*aberr_in, cmap=cmap)\naxes['E'].set_title('Input Aberrations')\n\naxes['F'].imshow(mask*model.Aberrations.get_opd(), cmap=cmap)\naxes['F'].set_title('Recovered Aberrations')\nplt.show()\n</pre> coeffs_out = np.array([model_out.get(zernikes) for model_out in models_out])  mosaic = \"\"\"     AABD     GGEF     \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['B','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Training History\") axes['A'].set_xlabel('Training Epoch') axes['A'].set_ylabel('Poisson Log-Likelihood')  axes['B'].imshow(psf**0.5) axes['B'].set_title('True PSF')  axes['G'].plot(coeffs*1e9,model.get(zernikes)*1e9,'.',markersize=12,color='C0',label='Recovered') axes['G'].plot(coeffs*1e9,coeffs_init*1e9,'.',markersize=12,color='C1',label='Initial')  axes['G'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,                np.array([np.min(coeffs),np.max(coeffs)])*1e9,                '-',color='C2',label='1:1') axes['G'].legend() axes['G'].set_title('Correlation Plot ') axes['G'].set_xlabel('True Zernike Coefficients (nm)') axes['G'].set_ylabel('Model Zernike Coefficients (nm)')  axes['D'].imshow(final_psf**0.5) axes['D'].set_title('Recovered PSF')  axes['E'].imshow(mask*aberr_in, cmap=cmap) axes['E'].set_title('Input Aberrations')  axes['F'].imshow(mask*model.Aberrations.get_opd(), cmap=cmap) axes['F'].set_title('Recovered Aberrations') plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"docs/notebooks/phase_retrieval_demo/#phase-retrieval-in-dlux","title":"Phase Retrieval in dLux\u00b6","text":"<p>In this notebook, we will go through a simple example of phase retrieval in dLux, just recovering Zernike coefficients for an aberrated circular aperture by gradient descent.</p>"},{"location":"tests/conftest/","title":"Conftest","text":"In\u00a0[\u00a0]: Copied! <pre>import pytest\nimport jax.numpy as np\nimport dLux\n</pre> import pytest import jax.numpy as np import dLux In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\nWavefront = dLux.wavefronts.Wavefront\nOpticalLayer = dLux.optics.OpticalLayer\nSpectrum = dLux.spectrums.Spectrum\nSource = dLux.sources.Source\nAperture = dLux.apertures.ApertureLayer\nAbstractObservation = dLux.observations.AbstractObservation\n</pre> Array = np.ndarray Wavefront = dLux.wavefronts.Wavefront OpticalLayer = dLux.optics.OpticalLayer Spectrum = dLux.spectrums.Spectrum Source = dLux.sources.Source Aperture = dLux.apertures.ApertureLayer AbstractObservation = dLux.observations.AbstractObservation In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_wavefront() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_wavefront: callable\n        A function that has all keyword arguments and can be \n        used to create a wavefront for testing.\n    \"\"\"\n    def _create_wavefront(\n            wavelength: Array = np.array(550e-09),\n            pixel_scale: Array = np.array(1.),\n            plane_type: int = dLux.PlaneType.Pupil,\n            amplitude: Array = np.ones((1, 16, 16)),\n            phase: Array = np.zeros((1, 16, 16))) -&gt; Wavefront:\n        return dLux.wavefronts.Wavefront(\n            wavelength, pixel_scale, amplitude, phase, plane_type)\n    return _create_wavefront\n</pre> @pytest.fixture def create_wavefront() -&gt; callable:     \"\"\"     Returns:     --------     create_wavefront: callable         A function that has all keyword arguments and can be          used to create a wavefront for testing.     \"\"\"     def _create_wavefront(             wavelength: Array = np.array(550e-09),             pixel_scale: Array = np.array(1.),             plane_type: int = dLux.PlaneType.Pupil,             amplitude: Array = np.ones((1, 16, 16)),             phase: Array = np.zeros((1, 16, 16))) -&gt; Wavefront:         return dLux.wavefronts.Wavefront(             wavelength, pixel_scale, amplitude, phase, plane_type)     return _create_wavefront In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_create_wavefront() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_create_wavefront: callable \n        A function that has all keyword arguments and can be \n        used to create a `CreateWavefront` layer for testing.\n    \"\"\"\n    def _create_create_wavefront(\n            npixels = 16,\n            diameter = np.array(1.),\n            wavefront_type = \"Cartesian\") -&gt; OpticalLayer:\n        return dLux.optics.CreateWavefront(npixels, diameter, wavefront_type)\n    return _create_create_wavefront\n</pre> @pytest.fixture def create_create_wavefront() -&gt; callable:     \"\"\"     Returns:     --------     create_create_wavefront: callable          A function that has all keyword arguments and can be          used to create a `CreateWavefront` layer for testing.     \"\"\"     def _create_create_wavefront(             npixels = 16,             diameter = np.array(1.),             wavefront_type = \"Cartesian\") -&gt; OpticalLayer:         return dLux.optics.CreateWavefront(npixels, diameter, wavefront_type)     return _create_create_wavefront In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_tilt_wavefront() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_tilt_wavefront: callable \n        A function that has all keyword arguments and can be \n        used to create a `TiltWavefront` layer for testing.\n    \"\"\"\n    def _create_tilt_wavefront(\n            tilt_angles: Array = np.ones(2)) -&gt; OpticalLayer:\n        return dLux.optics.TiltWavefront(tilt_angles)\n    return _create_tilt_wavefront\n</pre> @pytest.fixture def create_tilt_wavefront() -&gt; callable:     \"\"\"     Returns:     --------     create_tilt_wavefront: callable          A function that has all keyword arguments and can be          used to create a `TiltWavefront` layer for testing.     \"\"\"     def _create_tilt_wavefront(             tilt_angles: Array = np.ones(2)) -&gt; OpticalLayer:         return dLux.optics.TiltWavefront(tilt_angles)     return _create_tilt_wavefront In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_normalise_wavefront() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_normalise_wavefront: callable \n        A function that has all keyword arguments and can be \n        used to create a `NormaliseWavefront` layer for testing.\n    \"\"\"\n    def _create_normalise_wavefront():\n        return dLux.optics.NormaliseWavefront()\n    return _create_normalise_wavefront\n</pre> @pytest.fixture def create_normalise_wavefront() -&gt; callable:     \"\"\"     Returns:     --------     create_normalise_wavefront: callable          A function that has all keyword arguments and can be          used to create a `NormaliseWavefront` layer for testing.     \"\"\"     def _create_normalise_wavefront():         return dLux.optics.NormaliseWavefront()     return _create_normalise_wavefront In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_apply_basis_opd():\n\"\"\"\n    Returns:\n    --------\n    create_apply_basis_opd: callable \n        A function that has all keyword arguments and can be \n        used to create a `ApplyBasisOPD` layer for testing.\n    \"\"\"\n    def _create_apply_basis_opd(\n            basis = np.ones((3, 16, 16)),\n            coefficients = np.ones(3)) -&gt; OpticalLayer:\n        return dLux.optics.ApplyBasisOPD(basis, coefficients)\n    return _create_apply_basis_opd\n</pre> @pytest.fixture def create_apply_basis_opd():     \"\"\"     Returns:     --------     create_apply_basis_opd: callable          A function that has all keyword arguments and can be          used to create a `ApplyBasisOPD` layer for testing.     \"\"\"     def _create_apply_basis_opd(             basis = np.ones((3, 16, 16)),             coefficients = np.ones(3)) -&gt; OpticalLayer:         return dLux.optics.ApplyBasisOPD(basis, coefficients)     return _create_apply_basis_opd In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_add_phase():\n\"\"\"\n    Returns:\n    --------\n    create_add_phase: callable \n        A function that has all keyword arguments and can be \n        used to create a `AddPhase` layer for testing.\n    \"\"\"\n    def _create_add_phase(phase: Array = np.ones((16, 16))) -&gt; OpticalLayer:\n        return dLux.optics.AddPhase(phase)\n    return _create_add_phase\n</pre> @pytest.fixture def create_add_phase():     \"\"\"     Returns:     --------     create_add_phase: callable          A function that has all keyword arguments and can be          used to create a `AddPhase` layer for testing.     \"\"\"     def _create_add_phase(phase: Array = np.ones((16, 16))) -&gt; OpticalLayer:         return dLux.optics.AddPhase(phase)     return _create_add_phase     In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_add_opd():\n\"\"\"\n    Returns:\n    --------\n    create_add_opd: callable\n        a function that has all keyword arguments and can be\n        used to create a `AddOPD` layer for testing.\n    \"\"\"\n    def _create_add_opd(opd: Array = np.ones((16, 16))) -&gt; OpticalLayer:\n        return dLux.optics.AddOPD(opd)\n    return _create_add_opd\n</pre> @pytest.fixture def create_add_opd():     \"\"\"     Returns:     --------     create_add_opd: callable         a function that has all keyword arguments and can be         used to create a `AddOPD` layer for testing.     \"\"\"     def _create_add_opd(opd: Array = np.ones((16, 16))) -&gt; OpticalLayer:         return dLux.optics.AddOPD(opd)     return _create_add_opd In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_transmissive_optic():\n\"\"\"\n    Returns:\n    --------\n    create_transmissive_optic: callable\n        a function that has all keyword arguments and can be\n        used to create a `TransmissiveOptic` layer for testing.\n    \"\"\"\n    def _create_trans_optic(trans: Array = np.ones((16, 16))) -&gt; OpticalLayer:\n        return dLux.optics.TransmissiveOptic(trans)\n    return _create_trans_optic\n</pre> @pytest.fixture def create_transmissive_optic():     \"\"\"     Returns:     --------     create_transmissive_optic: callable         a function that has all keyword arguments and can be         used to create a `TransmissiveOptic` layer for testing.     \"\"\"     def _create_trans_optic(trans: Array = np.ones((16, 16))) -&gt; OpticalLayer:         return dLux.optics.TransmissiveOptic(trans)     return _create_trans_optic  In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_basis_climb():\n\"\"\"\n    Returns:\n    --------\n    create_basis_climb: callable\n        a function that has all keyword arguments and can be\n        used to create a `BasisCLIMB` layer for testing.\n    \"\"\"\n    def _create_basis_climb(\n            basis: Array = np.ones((3, 768, 768)),\n            coefficients: Array = np.ones(3),\n            ideal_wavelength: Array = np.array(5e-7)) -&gt; OpticalLayer:\n        return dLux.optics.ApplyBasisCLIMB(\n            basis, ideal_wavelength, coefficients)\n    return _create_basis_climb\n</pre> @pytest.fixture def create_basis_climb():     \"\"\"     Returns:     --------     create_basis_climb: callable         a function that has all keyword arguments and can be         used to create a `BasisCLIMB` layer for testing.     \"\"\"     def _create_basis_climb(             basis: Array = np.ones((3, 768, 768)),             coefficients: Array = np.ones(3),             ideal_wavelength: Array = np.array(5e-7)) -&gt; OpticalLayer:         return dLux.optics.ApplyBasisCLIMB(             basis, ideal_wavelength, coefficients)     return _create_basis_climb In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rotate() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_rotate: callable\n        a function that has all keyword arguments and can be\n        used to create a `Rotate` layer for testing.\n    \"\"\"\n    def _create_rotate(\n            angle: Array = np.array(np.pi),\n            real_imaginary: bool = False,\n            fourier: bool = False,\n            order: int = 1,\n            padding: int = 2) -&gt; OpticalLayer:\n        return dLux.optics.Rotate(angle, real_imaginary, fourier, order, padding)\n    return _create_rotate\n</pre> @pytest.fixture def create_rotate() -&gt; callable:     \"\"\"     Returns:     --------     create_rotate: callable         a function that has all keyword arguments and can be         used to create a `Rotate` layer for testing.     \"\"\"     def _create_rotate(             angle: Array = np.array(np.pi),             real_imaginary: bool = False,             fourier: bool = False,             order: int = 1,             padding: int = 2) -&gt; OpticalLayer:         return dLux.optics.Rotate(angle, real_imaginary, fourier, order, padding)     return _create_rotate In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_propagator() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_propagator: callable\n        a function that has all keyword arguments and can be\n        used to create a `Propagator` layer for testing.\n    \"\"\"\n    def _create_propagator(\n            inverse : bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        inverse = inverse if inverse is None else False\n        return dLux.propagators.Propagator(inverse=inverse)\n    return _create_propagator\n</pre> @pytest.fixture def create_propagator() -&gt; callable:     \"\"\"     Returns:     --------     _create_propagator: callable         a function that has all keyword arguments and can be         used to create a `Propagator` layer for testing.     \"\"\"     def _create_propagator(             inverse : bool = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         inverse = inverse if inverse is None else False         return dLux.propagators.Propagator(inverse=inverse)     return _create_propagator In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_fixed_sampling_propagator() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_fixed_sampling_propagator_utility: callable\n        a function that has all keyword arguments and can be\n        used to create a `FixedSamplingPropagator` layer for testing.\n    \"\"\"\n    def _create_fixed_sampling_propagator_utility() -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.FixedSamplingPropagator()\n    return _create_fixed_sampling_propagator_utility\n</pre> @pytest.fixture def create_fixed_sampling_propagator() -&gt; callable:     \"\"\"     Returns:     --------     _create_fixed_sampling_propagator_utility: callable         a function that has all keyword arguments and can be         used to create a `FixedSamplingPropagator` layer for testing.     \"\"\"     def _create_fixed_sampling_propagator_utility() -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.FixedSamplingPropagator()     return _create_fixed_sampling_propagator_utility In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_variable_sampling_propagator() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    create_variable_sampling_propagator: callable\n        a function that has all keyword arguments and can be\n        used to create a `VariableSamplingPropagator` layer for testing.\n    \"\"\"\n    def _create_variable_sampling_propagator_utility(\n                                                     npixels_out     : int   = 16,\n                                                     pixel_scale_out : Array = np.array(1.),\n                                                     shift           : Array = np.zeros(2),\n                                                     pixel_shift     : bool  = False,\n                                                     inverse         : bool  = None\n                                                     ) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.VariableSamplingPropagator(pixel_scale_out,\n                            npixels_out, shift, pixel_shift)\n    return _create_variable_sampling_propagator_utility\n</pre> @pytest.fixture def create_variable_sampling_propagator() -&gt; callable:     \"\"\"     Returns:     --------     create_variable_sampling_propagator: callable         a function that has all keyword arguments and can be         used to create a `VariableSamplingPropagator` layer for testing.     \"\"\"     def _create_variable_sampling_propagator_utility(                                                      npixels_out     : int   = 16,                                                      pixel_scale_out : Array = np.array(1.),                                                      shift           : Array = np.zeros(2),                                                      pixel_shift     : bool  = False,                                                      inverse         : bool  = None                                                      ) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.VariableSamplingPropagator(pixel_scale_out,                             npixels_out, shift, pixel_shift)     return _create_variable_sampling_propagator_utility In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_cartesian_propagator() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_cartesian_propagator: callable\n        a function that has all keyword arguments and can be\n        used to create a `CartesianPropagator` layer for testing.\n    \"\"\"\n\n    def _create_cartesian_propagator(\n                                     focal_length : Array = np.array(1.),\n                                     inverse      : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.CartesianPropagator(focal_length, \\\n                                                    inverse=inverse)\n    return _create_cartesian_propagator\n</pre> @pytest.fixture def create_cartesian_propagator() -&gt; callable:     \"\"\"     Returns:     --------     _create_cartesian_propagator: callable         a function that has all keyword arguments and can be         used to create a `CartesianPropagator` layer for testing.     \"\"\"      def _create_cartesian_propagator(                                      focal_length : Array = np.array(1.),                                      inverse      : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.CartesianPropagator(focal_length, \\                                                     inverse=inverse)     return _create_cartesian_propagator In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_angular_propagator() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_angular_propagator: callable\n        a function that has all keyword arguments and can be\n        used to create a `AngularPropagator` layer for testing.\n    \"\"\"\n\n    def _create_angular_propagator(inverse : bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.AngularPropagator(inverse=inverse)\n    return _create_angular_propagator\n</pre> @pytest.fixture def create_angular_propagator() -&gt; callable:     \"\"\"     Returns:     --------     _create_angular_propagator: callable         a function that has all keyword arguments and can be         used to create a `AngularPropagator` layer for testing.     \"\"\"      def _create_angular_propagator(inverse : bool = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.AngularPropagator(inverse=inverse)     return _create_angular_propagator In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_far_field_fresnel() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_far_field_fresnel: callable\n        a function that has all keyword arguments and can be\n        used to create a `FarFieldFresnel` layer for testing.\n    \"\"\"\n\n    def _create_far_field_fresnel(\n                  propagation_shift : Array = np.array(1e-3),\n                  inverse           : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.FarFieldFresnel(propagation_shift, \\\n                                                inverse=inverse)\n    return _create_far_field_fresnel\n</pre> @pytest.fixture def create_far_field_fresnel() -&gt; callable:     \"\"\"     Returns:     --------     _create_far_field_fresnel: callable         a function that has all keyword arguments and can be         used to create a `FarFieldFresnel` layer for testing.     \"\"\"      def _create_far_field_fresnel(                   propagation_shift : Array = np.array(1e-3),                   inverse           : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.FarFieldFresnel(propagation_shift, \\                                                 inverse=inverse)     return _create_far_field_fresnel In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_cartesian_mft() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_cartesian_mft: callable\n        a function that has all keyword arguments and can be\n        used to create a `CartesianMFT` layer for testing.\n    \"\"\"\n\n    def _create_cartesian_mft(\n                            npixels_out     : int   = 16,\n                            pixel_scale_out : Array = np.array(1.),\n                            focal_length    : Array = np.array(1.),\n                            shift           : Array = np.zeros(2),\n                            pixel_shift     : bool  = False,\n                            inverse         : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        pixel_scale_out = pixel_scale_out if pixel_scale_out is None \\\n                                                        else pixel_scale_out\n        focal_length = focal_length if focal_length is None \\\n                                                        else focal_length\n        npixels_out = npixels_out if npixels_out is None else npixels_out\n        shift       = shift       if shift       is None else shift\n        pixel_shift = pixel_shift if pixel_shift is None else pixel_shift\n        inverse     = inverse     if inverse     is None else inverse\n        return dLux.propagators.CartesianMFT(npixels_out, pixel_scale_out,\n                                     focal_length, inverse, shift, pixel_shift)\n    return _create_cartesian_mft\n</pre> @pytest.fixture def create_cartesian_mft() -&gt; callable:     \"\"\"     Returns:     --------     _create_cartesian_mft: callable         a function that has all keyword arguments and can be         used to create a `CartesianMFT` layer for testing.     \"\"\"      def _create_cartesian_mft(                             npixels_out     : int   = 16,                             pixel_scale_out : Array = np.array(1.),                             focal_length    : Array = np.array(1.),                             shift           : Array = np.zeros(2),                             pixel_shift     : bool  = False,                             inverse         : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         pixel_scale_out = pixel_scale_out if pixel_scale_out is None \\                                                         else pixel_scale_out         focal_length = focal_length if focal_length is None \\                                                         else focal_length         npixels_out = npixels_out if npixels_out is None else npixels_out         shift       = shift       if shift       is None else shift         pixel_shift = pixel_shift if pixel_shift is None else pixel_shift         inverse     = inverse     if inverse     is None else inverse         return dLux.propagators.CartesianMFT(npixels_out, pixel_scale_out,                                      focal_length, inverse, shift, pixel_shift)     return _create_cartesian_mft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_angular_mft() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_angular_mft: callable\n        a function that has all keyword arguments and can be\n        used to create a `AngularMFT` layer for testing.\n    \"\"\"\n    def _create_angular_mft(\n                  npixels_out     : int   = 16,\n                  pixel_scale_out : float = np.array(1.),\n                  inverse         : bool  = False,\n                  shift           : Array = np.zeros(2),\n                  pixel_shift     : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.AngularMFT(npixels_out, pixel_scale_out,\n                                           inverse, shift, pixel_shift)\n    return _create_angular_mft\n</pre> @pytest.fixture def create_angular_mft() -&gt; callable:     \"\"\"     Returns:     --------     _create_angular_mft: callable         a function that has all keyword arguments and can be         used to create a `AngularMFT` layer for testing.     \"\"\"     def _create_angular_mft(                   npixels_out     : int   = 16,                   pixel_scale_out : float = np.array(1.),                   inverse         : bool  = False,                   shift           : Array = np.zeros(2),                   pixel_shift     : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.AngularMFT(npixels_out, pixel_scale_out,                                            inverse, shift, pixel_shift)     return _create_angular_mft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_cartesian_fft():\n\"\"\"\n    Returns:\n    --------\n    _create_angular_mft: callable\n        a function that has all keyword arguments and can be\n        used to create a `CartesianFFT` layer for testing.\n    \"\"\"\n\n    def _create_cartesian_fft(\n                  focal_length : Array = np.array(1.),\n                  inverse      : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        focal_length = focal_length if focal_length is None \\\n                                                        else focal_length\n        inverse = inverse if inverse is None else inverse\n        return dLux.propagators.CartesianFFT(focal_length, inverse)\n    return _create_cartesian_fft\n</pre> @pytest.fixture def create_cartesian_fft():     \"\"\"     Returns:     --------     _create_angular_mft: callable         a function that has all keyword arguments and can be         used to create a `CartesianFFT` layer for testing.     \"\"\"      def _create_cartesian_fft(                   focal_length : Array = np.array(1.),                   inverse      : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         focal_length = focal_length if focal_length is None \\                                                         else focal_length         inverse = inverse if inverse is None else inverse         return dLux.propagators.CartesianFFT(focal_length, inverse)     return _create_cartesian_fft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_angular_fft() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_angular_fft: callable\n        a function that has all keyword arguments and can be\n        used to create a `AngularFFT` layer for testing.\n    \"\"\"\n\n    def _create_angular_fft(inverse : bool = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.AngularFFT(inverse)\n    return _create_angular_fft\n</pre> @pytest.fixture def create_angular_fft() -&gt; callable:     \"\"\"     Returns:     --------     _create_angular_fft: callable         a function that has all keyword arguments and can be         used to create a `AngularFFT` layer for testing.     \"\"\"      def _create_angular_fft(inverse : bool = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.AngularFFT(inverse)     return _create_angular_fft In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_cartesian_fresnel() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_cartesian_fresnel: callable\n        a function that has all keyword arguments and can be\n        used to create a `CartesianFresnel` layer for testing.\n    \"\"\"\n    def _create_cartesian_fresnel(\n                  npixels_out       : int   = 16,\n                  pixel_scale_out   : float = np.array(1.),\n                  focal_length      : Array = np.array(1.),\n                  propagation_shift : Array = np.array(1e-3),\n                  inverse           : bool  = False,\n                  shift             : Array = np.zeros(2),\n                  pixel_shift       : bool  = False) -&gt; OpticalLayer:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.propagators.CartesianFresnel(npixels_out, pixel_scale_out,\n                 focal_length, propagation_shift, inverse, shift, pixel_shift)\n    return _create_cartesian_fresnel\n</pre> @pytest.fixture def create_cartesian_fresnel() -&gt; callable:     \"\"\"     Returns:     --------     _create_cartesian_fresnel: callable         a function that has all keyword arguments and can be         used to create a `CartesianFresnel` layer for testing.     \"\"\"     def _create_cartesian_fresnel(                   npixels_out       : int   = 16,                   pixel_scale_out   : float = np.array(1.),                   focal_length      : Array = np.array(1.),                   propagation_shift : Array = np.array(1e-3),                   inverse           : bool  = False,                   shift             : Array = np.zeros(2),                   pixel_shift       : bool  = False) -&gt; OpticalLayer:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.propagators.CartesianFresnel(npixels_out, pixel_scale_out,                  focal_length, propagation_shift, inverse, shift, pixel_shift)     return _create_cartesian_fresnel In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `Source` layer for testing.\n    \"\"\"\n\n    def _create_source(\n                  position : Array    = np.array([0., 0.]),\n                  flux     : Array    = np.array(1.),\n                  spectrum : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  name     : str      = \"Source\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.Source(position, flux, spectrum, name=name)\n    return _create_source\n</pre> @pytest.fixture def create_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_source: callable         a function that has all keyword arguments and can be         used to create a `Source` layer for testing.     \"\"\"      def _create_source(                   position : Array    = np.array([0., 0.]),                   flux     : Array    = np.array(1.),                   spectrum : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   name     : str      = \"Source\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.Source(position, flux, spectrum, name=name)     return _create_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_relative_flux_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_relative_flux_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `RelativeFluxSource` layer for testing.\n    \"\"\"\n    \n    def _create_relative_flux_source(\n                  position : Array    = np.array([0., 0.]),\n                  flux     : Array    = np.array(1.),\n                  spectrum : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  contrast   : Array    = np.array(2.),\n                  name       : str      = \"RelativeSource\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.RelativeFluxSource(contrast, position=position,\n                                               flux=flux, spectrum=spectrum,\n                                               name=name)\n    return _create_relative_flux_source\n</pre> @pytest.fixture def create_relative_flux_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_relative_flux_source: callable         a function that has all keyword arguments and can be         used to create a `RelativeFluxSource` layer for testing.     \"\"\"          def _create_relative_flux_source(                   position : Array    = np.array([0., 0.]),                   flux     : Array    = np.array(1.),                   spectrum : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   contrast   : Array    = np.array(2.),                   name       : str      = \"RelativeSource\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.RelativeFluxSource(contrast, position=position,                                                flux=flux, spectrum=spectrum,                                                name=name)     return _create_relative_flux_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_relative_position_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_relative_position_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `RelativePositionSource` layer for testing.\n    \"\"\"\n\n    def _create_relative_position_source(\n                  position       : Array    = np.array([0., 0.]),\n                  flux           : Array    = np.array(1.),\n                  spectrum       : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  separation     : Array    = np.array(1.),\n                  position_angle : Array    = np.array(0.),\n                  name           : str      = \"RelativePositionSource\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.RelativePositionSource(separation, position_angle,\n                                                   position=position, flux=flux,\n                                                   spectrum=spectrum, name=name)\n    return _create_relative_position_source\n</pre> @pytest.fixture def create_relative_position_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_relative_position_source: callable         a function that has all keyword arguments and can be         used to create a `RelativePositionSource` layer for testing.     \"\"\"      def _create_relative_position_source(                   position       : Array    = np.array([0., 0.]),                   flux           : Array    = np.array(1.),                   spectrum       : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   separation     : Array    = np.array(1.),                   position_angle : Array    = np.array(0.),                   name           : str      = \"RelativePositionSource\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.RelativePositionSource(separation, position_angle,                                                    position=position, flux=flux,                                                    spectrum=spectrum, name=name)     return _create_relative_position_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_point_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_point_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `PointSource` layer for testing.\n    \"\"\"\n\n\n    def _create_point_source(\n                  position    : Array    = np.array([0., 0.]),\n                  flux        : Array    = np.array(1.),\n                  spectrum    : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  name        : str      = \"PointSource\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.PointSource(position, flux, spectrum, name=name)\n    return _create_point_source\n</pre> @pytest.fixture def create_point_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_point_source: callable         a function that has all keyword arguments and can be         used to create a `PointSource` layer for testing.     \"\"\"       def _create_point_source(                   position    : Array    = np.array([0., 0.]),                   flux        : Array    = np.array(1.),                   spectrum    : OpticalLayer = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   name        : str      = \"PointSource\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.PointSource(position, flux, spectrum, name=name)     return _create_point_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_multi_point_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_point_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `MultiPointSource` layer for testing.\n    \"\"\"\n\n\n    def _create_multi_point_source(\n                  position : Array    = np.zeros((3, 2)),\n                  flux     : Array    = np.ones(3),\n                  spectrum : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  name     : str      = \"Source\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.MultiPointSource(position, flux, spectrum, name=name)\n    return _create_multi_point_source\n</pre> @pytest.fixture def create_multi_point_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_point_source: callable         a function that has all keyword arguments and can be         used to create a `MultiPointSource` layer for testing.     \"\"\"       def _create_multi_point_source(                   position : Array    = np.zeros((3, 2)),                   flux     : Array    = np.ones(3),                   spectrum : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   name     : str      = \"Source\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.MultiPointSource(position, flux, spectrum, name=name)     return _create_multi_point_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_array_distribution():\n\"\"\"\n    Returns:\n    --------\n    _create_array_distribution: callable\n        a function that has all keyword arguments and can be\n        used to create a `ArrayDistribution` layer for testing.\n    \"\"\"\n\n\n    def _create_array_distribution(\n                  position     : Array    = np.array([0., 0.]),\n                  flux         : Array    = np.array(1.),\n                  spectrum     : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),\n                  name         : str      = \"Source\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.ArrayDistribution(position, flux, distribution,\n                                              spectrum, name=name)\n    return _create_array_distribution\n</pre> @pytest.fixture def create_array_distribution():     \"\"\"     Returns:     --------     _create_array_distribution: callable         a function that has all keyword arguments and can be         used to create a `ArrayDistribution` layer for testing.     \"\"\"       def _create_array_distribution(                   position     : Array    = np.array([0., 0.]),                   flux         : Array    = np.array(1.),                   spectrum     : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),                   name         : str      = \"Source\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.ArrayDistribution(position, flux, distribution,                                               spectrum, name=name)     return _create_array_distribution In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_binary_source():\n\"\"\"\n    Returns:\n    --------\n    _create_binary_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `BinarySource` layer for testing.\n    \"\"\"\n\n\n    def _create_binary_source(\n                  position       : Array    = np.array([0., 0.]),\n                  flux           : Array    = np.array(1.),\n                  spectrum       : Spectrum = None,\n                  separation     : Array    = np.array(1.),\n                  position_angle : Array    = np.array(0.),\n                  contrast       : Array    = np.array(2.),\n                  name           : str      = \"BinarySource\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        if spectrum is None:\n            wavelengths = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1))\n            weights     = np.tile(np.arange(10), (2, 1))\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths, weights)\n            \n        return dLux.sources.BinarySource(position, flux, separation, \\\n                                  position_angle, contrast, spectrum, name=name)\n    return _create_binary_source\n</pre> @pytest.fixture def create_binary_source():     \"\"\"     Returns:     --------     _create_binary_source: callable         a function that has all keyword arguments and can be         used to create a `BinarySource` layer for testing.     \"\"\"       def _create_binary_source(                   position       : Array    = np.array([0., 0.]),                   flux           : Array    = np.array(1.),                   spectrum       : Spectrum = None,                   separation     : Array    = np.array(1.),                   position_angle : Array    = np.array(0.),                   contrast       : Array    = np.array(2.),                   name           : str      = \"BinarySource\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         if spectrum is None:             wavelengths = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1))             weights     = np.tile(np.arange(10), (2, 1))             spectrum = dLux.spectrums.CombinedSpectrum(wavelengths, weights)                      return dLux.sources.BinarySource(position, flux, separation, \\                                   position_angle, contrast, spectrum, name=name)     return _create_binary_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_point_extended_source() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_point_extended_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `PointExtendedSource` layer for testing.\n    \"\"\"\n\n    def _create_point_extended_source(\n                  position     : Array    = np.array([0., 0.]),\n                  flux         : Array    = np.array(1.),\n                  spectrum     : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\\n                                                                 600e-9, 10)),\n                  contrast     : Array    = np.array(2.),\n                  distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),\n                  name         : str      = \"Source\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.sources.PointExtendedSource(position, flux, distribution,\n                                                contrast, spectrum, name=name)\n    return _create_point_extended_source\n</pre> @pytest.fixture def create_point_extended_source() -&gt; callable:     \"\"\"     Returns:     --------     _create_point_extended_source: callable         a function that has all keyword arguments and can be         used to create a `PointExtendedSource` layer for testing.     \"\"\"      def _create_point_extended_source(                   position     : Array    = np.array([0., 0.]),                   flux         : Array    = np.array(1.),                   spectrum     : Spectrum = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, \\                                                                  600e-9, 10)),                   contrast     : Array    = np.array(2.),                   distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),                   name         : str      = \"Source\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.sources.PointExtendedSource(position, flux, distribution,                                                 contrast, spectrum, name=name)     return _create_point_extended_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_point_and_extended_source():\n\"\"\"\n    Returns:\n    --------\n    _create_point_and_extended_source: callable\n        a function that has all keyword arguments and can be\n        used to create a `PointAndExtendedSource` layer for testing.\n    \"\"\"\n\n\n    def _create_point_and_extended_source(\n                  position     : Array    = np.array([0., 0.]),\n                  flux         : Array    = np.array(1.),\n                  spectrum     : Spectrum = None,\n                  contrast     : Array    = np.array(2.),\n                  distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),\n                  name         : str      = \"Point and extended source\") -&gt; Source:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        if spectrum is None:\n            wavelengths = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1))\n            weights = np.tile(np.arange(10), (2, 1))\n            spectrum = dLux.spectrums.CombinedSpectrum(wavelengths, weights)\n            \n        return dLux.sources.PointAndExtendedSource(position, flux, distribution,\n                                                contrast, spectrum, name=name)\n    return _create_point_and_extended_source\n</pre> @pytest.fixture def create_point_and_extended_source():     \"\"\"     Returns:     --------     _create_point_and_extended_source: callable         a function that has all keyword arguments and can be         used to create a `PointAndExtendedSource` layer for testing.     \"\"\"       def _create_point_and_extended_source(                   position     : Array    = np.array([0., 0.]),                   flux         : Array    = np.array(1.),                   spectrum     : Spectrum = None,                   contrast     : Array    = np.array(2.),                   distribution : Array    = np.ones((5, 5))/np.ones((5, 5)).sum(),                   name         : str      = \"Point and extended source\") -&gt; Source:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         if spectrum is None:             wavelengths = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1))             weights = np.tile(np.arange(10), (2, 1))             spectrum = dLux.spectrums.CombinedSpectrum(wavelengths, weights)                      return dLux.sources.PointAndExtendedSource(position, flux, distribution,                                                 contrast, spectrum, name=name)     return _create_point_and_extended_source In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_array_spectrum() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_array_spectrum: callable\n        a function that has all keyword arguments and can be\n        used to create a `ArraySpectrum` layer for testing.\n    \"\"\"\n\n    def _create_array_spectrum(\n                  wavelengths : Array = np.linspace(500e-9, 600e-9, 10),\n                  weights     : Array = np.arange(10)) -&gt; Spectrum:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.spectrums.ArraySpectrum(wavelengths, weights)\n    return _create_array_spectrum\n</pre> @pytest.fixture def create_array_spectrum() -&gt; callable:     \"\"\"     Returns:     --------     _create_array_spectrum: callable         a function that has all keyword arguments and can be         used to create a `ArraySpectrum` layer for testing.     \"\"\"      def _create_array_spectrum(                   wavelengths : Array = np.linspace(500e-9, 600e-9, 10),                   weights     : Array = np.arange(10)) -&gt; Spectrum:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.spectrums.ArraySpectrum(wavelengths, weights)     return _create_array_spectrum In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_polynomial_spectrum() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_polynomial_spectrum: callable\n        a function that has all keyword arguments and can be\n        used to create a `ArraySpectrum` layer for testing.\n    \"\"\"\n\n    def _create_polynomial_spectrum(\n                  wavelengths  : Array = np.linspace(500e-9, 600e-9, 10),\n                  coefficients : Array = np.arange(3)) -&gt; Spectrum:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.spectrums.PolynomialSpectrum(wavelengths, coefficients)\n    return _create_polynomial_spectrum\n</pre> @pytest.fixture def create_polynomial_spectrum() -&gt; callable:     \"\"\"     Returns:     --------     _create_polynomial_spectrum: callable         a function that has all keyword arguments and can be         used to create a `ArraySpectrum` layer for testing.     \"\"\"      def _create_polynomial_spectrum(                   wavelengths  : Array = np.linspace(500e-9, 600e-9, 10),                   coefficients : Array = np.arange(3)) -&gt; Spectrum:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.spectrums.PolynomialSpectrum(wavelengths, coefficients)     return _create_polynomial_spectrum In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_combined_spectrum() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_combined_spectrum: callable\n        a function that has all keyword arguments and can be\n        used to create a `ArraySpectrum` layer for testing.\n    \"\"\"\n\n    def _create_combined_spectrum(\n                  wavelengths : Array = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1)),\n                  weights     : Array = np.tile(np.arange(10), (2, 1))) -&gt; Spectrum:\n\"\"\"\n        Safe constructor for the dLuxModule, associated with this utility.\n        \"\"\"\n        return dLux.spectrums.CombinedSpectrum(wavelengths, weights)\n    return _create_combined_spectrum\n</pre> @pytest.fixture def create_combined_spectrum() -&gt; callable:     \"\"\"     Returns:     --------     _create_combined_spectrum: callable         a function that has all keyword arguments and can be         used to create a `ArraySpectrum` layer for testing.     \"\"\"      def _create_combined_spectrum(                   wavelengths : Array = np.tile(np.linspace(500e-9, 600e-9, 10), (2, 1)),                   weights     : Array = np.tile(np.arange(10), (2, 1))) -&gt; Spectrum:         \"\"\"         Safe constructor for the dLuxModule, associated with this utility.         \"\"\"         return dLux.spectrums.CombinedSpectrum(wavelengths, weights)     return _create_combined_spectrum In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_optics() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_optics: callable\n        A function that has all keyword arguments and can be\n        used to create a `Optics` layer for testing.\n    \"\"\"\n    def _create_optics(\n            layers = [\n                dLux.optics.CreateWavefront(16, 1),\n                dLux.apertures.ApertureFactory(16),\n                dLux.optics.NormaliseWavefront(),\n                dLux.propagators.CartesianMFT(16, 1., 1e-6)\n            ]) -&gt; OpticalLayer:\n        return dLux.core.Optics(layers)\n    return _create_optics\n</pre> @pytest.fixture def create_optics() -&gt; callable:     \"\"\"     Returns:     --------     _create_optics: callable         A function that has all keyword arguments and can be         used to create a `Optics` layer for testing.     \"\"\"     def _create_optics(             layers = [                 dLux.optics.CreateWavefront(16, 1),                 dLux.apertures.ApertureFactory(16),                 dLux.optics.NormaliseWavefront(),                 dLux.propagators.CartesianMFT(16, 1., 1e-6)             ]) -&gt; OpticalLayer:         return dLux.core.Optics(layers)     return _create_optics In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_detector() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_detector: callable\n        A function that has all keyword arguments and can be\n        used to create a `Detector` layer for testing.\n    \"\"\"\n    def _create_detector(\n            layers = [dLux.detectors.AddConstant(1.)]) -&gt; OpticalLayer:\n        return dLux.core.Detector(layers)\n    return _create_detector\n</pre> @pytest.fixture def create_detector() -&gt; callable:     \"\"\"     Returns:     --------     _create_detector: callable         A function that has all keyword arguments and can be         used to create a `Detector` layer for testing.     \"\"\"     def _create_detector(             layers = [dLux.detectors.AddConstant(1.)]) -&gt; OpticalLayer:         return dLux.core.Detector(layers)     return _create_detector In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_filter() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_filter: callable\n        A function that has all keyword arguments and can be\n        used to create a `Filter` layer for testing.\n    \"\"\"\n    def _create_filter( \n            wavelengths = np.linspace(1e-6, 10e-6, 10),\n            throughput = np.linspace(0, 1, 10),\n            filter_name = None) -&gt; OpticalLayer:\n        return dLux.core.Filter(wavelengths, throughput, filter_name=filter_name)\n    return _create_filter\n</pre> @pytest.fixture def create_filter() -&gt; callable:     \"\"\"     Returns:     --------     _create_filter: callable         A function that has all keyword arguments and can be         used to create a `Filter` layer for testing.     \"\"\"     def _create_filter(              wavelengths = np.linspace(1e-6, 10e-6, 10),             throughput = np.linspace(0, 1, 10),             filter_name = None) -&gt; OpticalLayer:         return dLux.core.Filter(wavelengths, throughput, filter_name=filter_name)     return _create_filter In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_instrument(\n        create_optics: callable, \n        create_point_source: callable, \n        create_detector: callable,\n        create_filter: callable) -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_instrument: callable\n        A function that has all keyword arguments and can be\n        used to create a `Instrument` layer for testing.\n    \"\"\"\n    def _create_instrument(\n            optics          : OpticalLayer  = create_optics(),\n            sources         : OpticalLayer  = create_point_source(),\n            detector        : OpticalLayer  = create_detector(),\n            ) -&gt; OpticalLayer:\n\n        # if input_both:\n        return dLux.core.Instrument(\n            optics=optics,\n            detector=detector,\n            sources=sources)\n    return _create_instrument\n</pre> @pytest.fixture def create_instrument(         create_optics: callable,          create_point_source: callable,          create_detector: callable,         create_filter: callable) -&gt; callable:     \"\"\"     Returns:     --------     _create_instrument: callable         A function that has all keyword arguments and can be         used to create a `Instrument` layer for testing.     \"\"\"     def _create_instrument(             optics          : OpticalLayer  = create_optics(),             sources         : OpticalLayer  = create_point_source(),             detector        : OpticalLayer  = create_detector(),             ) -&gt; OpticalLayer:          # if input_both:         return dLux.core.Instrument(             optics=optics,             detector=detector,             sources=sources)     return _create_instrument In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_square_aperture() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_filter: callable\n        A function that has all keyword arguments and can be\n        used to create a `Filter` layer for testing.\n    \"\"\"\n\n    def _create_square_aperture(  \n            width       : Array = 1., \n            centre      : Array = [0., 0.],\n            shear      : Array = [0., 0.],\n            compression : Array = [1., 1.],\n            rotation    : Array = 0.,\n            occulting   : bool = False, \n            softening   : Array = 0.) -&gt; Aperture:\n\"\"\"\n        Construct's an instance of `SquareAperture` making \n        it easy to toggle a single parameter. \n        Parameters:\n        -----------\n        centre: float, meters\n            The centre of the coordinate system in the paraxial coordinates.\n        shear: Array\n            Linear stretching of the x and y axis representing a \n            shear of the coordinate system.\n        compression: Array \n            The x and y compression of the coordinate system. This \n            is a constant. \n        rotation: float, radians\n            The rotation of the aperture away from the positive \n            x-axis. \n        softening: bool \n            True if the aperture is soft edged otherwise False. A\n            soft edged aperture has a small layer of non-binary \n            pixels. This is to prevent undefined gradients. \n        occulting: bool \n            True if the aperture is occulting else False. An \n            occulting aperture is zero inside and one outside. \n        theta: float, radians\n            The rotation of the aperture away from the positive \n            x-axis. \n        width: float, meters\n            The side length of the square. \n        \"\"\"\n        return dLux.SquareAperture(width,\n            centre,\n            shear,\n            compression,\n            rotation,\n            occulting,\n            softening)\n\n    return _create_square_aperture\n</pre> @pytest.fixture def create_square_aperture() -&gt; callable:     \"\"\"     Returns:     --------     _create_filter: callable         A function that has all keyword arguments and can be         used to create a `Filter` layer for testing.     \"\"\"      def _create_square_aperture(               width       : Array = 1.,              centre      : Array = [0., 0.],             shear      : Array = [0., 0.],             compression : Array = [1., 1.],             rotation    : Array = 0.,             occulting   : bool = False,              softening   : Array = 0.) -&gt; Aperture:         \"\"\"         Construct's an instance of `SquareAperture` making          it easy to toggle a single parameter.          Parameters:         -----------         centre: float, meters             The centre of the coordinate system in the paraxial coordinates.         shear: Array             Linear stretching of the x and y axis representing a              shear of the coordinate system.         compression: Array              The x and y compression of the coordinate system. This              is a constant.          rotation: float, radians             The rotation of the aperture away from the positive              x-axis.          softening: bool              True if the aperture is soft edged otherwise False. A             soft edged aperture has a small layer of non-binary              pixels. This is to prevent undefined gradients.          occulting: bool              True if the aperture is occulting else False. An              occulting aperture is zero inside and one outside.          theta: float, radians             The rotation of the aperture away from the positive              x-axis.          width: float, meters             The side length of the square.          \"\"\"         return dLux.SquareAperture(width,             centre,             shear,             compression,             rotation,             occulting,             softening)      return _create_square_aperture In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rectangular_aperture()-&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_rectangular_aperture: callable\n        A function that has all keyword arguments and can be\n        used to create a `RectangularAperture` layer for testing.\n    \"\"\"\n\n    def _create_rectangular_aperture(\n                                    length      : Array = 0.5, \n                                    width       : Array = 1., \n                                    centre      : Array = [0., 0.],\n                                    shear      : Array = [0., 0.],\n                                    compression : Array = [1., 1.],\n                                    rotation    : Array = 0.,\n                                    occulting   : bool = False, \n                                    softening   : Array = 0.) -&gt; Aperture:\n\"\"\"\n        Construct's an instance of `SquareAperture` making \n        it easy to toggle a single parameter. \n        Parameters:\n        -----------\n        occulting: bool = None\n            True if light passes through the aperture. \n            False if light is blocked by the aperture. \n        softening: bool = None\n            True is the aperture has soft pixels on the \n            edges else false. \n        x_offset: float = None, meters\n            The distance along the x axis that the aperture \n            is moved from the centre of the coordinate system. \n        y_offset: float = None, meters\n            The distance along the y axis that the aperture \n            is moved from the centre of the coordinate system.\n        width: float = None, meters\n            The width of the aperture.\n        length: float = None, meters \n            The length of the aperture.\n        theta: float = None, radians\n            The rotation of the aperture.\n        \"\"\"\n        return dLux.apertures.RectangularAperture(\n                                                length      , \n                                                width       , \n                                                centre      ,\n                                                shear      ,\n                                                compression ,\n                                                rotation    ,\n                                                occulting   , \n                                                softening)\n    return _create_rectangular_aperture\n</pre> @pytest.fixture def create_rectangular_aperture()-&gt; callable:     \"\"\"     Returns:     --------     _create_rectangular_aperture: callable         A function that has all keyword arguments and can be         used to create a `RectangularAperture` layer for testing.     \"\"\"      def _create_rectangular_aperture(                                     length      : Array = 0.5,                                      width       : Array = 1.,                                      centre      : Array = [0., 0.],                                     shear      : Array = [0., 0.],                                     compression : Array = [1., 1.],                                     rotation    : Array = 0.,                                     occulting   : bool = False,                                      softening   : Array = 0.) -&gt; Aperture:         \"\"\"         Construct's an instance of `SquareAperture` making          it easy to toggle a single parameter.          Parameters:         -----------         occulting: bool = None             True if light passes through the aperture.              False if light is blocked by the aperture.          softening: bool = None             True is the aperture has soft pixels on the              edges else false.          x_offset: float = None, meters             The distance along the x axis that the aperture              is moved from the centre of the coordinate system.          y_offset: float = None, meters             The distance along the y axis that the aperture              is moved from the centre of the coordinate system.         width: float = None, meters             The width of the aperture.         length: float = None, meters              The length of the aperture.         theta: float = None, radians             The rotation of the aperture.         \"\"\"         return dLux.apertures.RectangularAperture(                                                 length      ,                                                  width       ,                                                  centre      ,                                                 shear      ,                                                 compression ,                                                 rotation    ,                                                 occulting   ,                                                  softening)     return _create_rectangular_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_circular_aperture() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_circular_aperture: callable\n        A function that has all keyword arguments and can be\n        used to create a `CircularAperture` layer for testing.\n    \"\"\"\n\n\n    def _create_circular_aperture( \n            radius      : Array = 1., \n            centre      : Array = [0., 0.],\n            shear      : Array = [0., 0.],\n            compression : Array = [1., 1.],\n            occulting   : bool = False, \n            softening   : Array = 0.) -&gt; Aperture:\n        return dLux.apertures.CircularAperture(\n            radius,\n            centre,\n            shear,\n            compression,\n            occulting,\n            softening)\n\n    return _create_circular_aperture\n</pre> @pytest.fixture def create_circular_aperture() -&gt; callable:     \"\"\"     Returns:     --------     _create_circular_aperture: callable         A function that has all keyword arguments and can be         used to create a `CircularAperture` layer for testing.     \"\"\"       def _create_circular_aperture(              radius      : Array = 1.,              centre      : Array = [0., 0.],             shear      : Array = [0., 0.],             compression : Array = [1., 1.],             occulting   : bool = False,              softening   : Array = 0.) -&gt; Aperture:         return dLux.apertures.CircularAperture(             radius,             centre,             shear,             compression,             occulting,             softening)      return _create_circular_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_hexagonal_aperture() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_hexagonal_aperture: callable\n        A function that has all keyword arguments and can be\n        used to create a `HexagonalAperture` layer for testing.\n    \"\"\"\n\n\n    def _create_hexagonal_aperture( \n            radius      : Array = 1., \n            centre      : Array = [0., 0.],\n            shear      : Array = [0., 0.],\n            compression : Array = [1., 1.],\n            rotation    : Array = 0.,\n            occulting   : bool = False, \n            softening   : Array = 0.) -&gt; Aperture:\n        return dLux.apertures.HexagonalAperture(\n            radius,\n            centre,\n            shear,\n            compression,\n            rotation,\n            occulting,\n            softening)\n\n    return _create_hexagonal_aperture\n</pre> @pytest.fixture def create_hexagonal_aperture() -&gt; callable:     \"\"\"     Returns:     --------     _create_hexagonal_aperture: callable         A function that has all keyword arguments and can be         used to create a `HexagonalAperture` layer for testing.     \"\"\"       def _create_hexagonal_aperture(              radius      : Array = 1.,              centre      : Array = [0., 0.],             shear      : Array = [0., 0.],             compression : Array = [1., 1.],             rotation    : Array = 0.,             occulting   : bool = False,              softening   : Array = 0.) -&gt; Aperture:         return dLux.apertures.HexagonalAperture(             radius,             centre,             shear,             compression,             rotation,             occulting,             softening)      return _create_hexagonal_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_annular_aperture() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_annular_aperture: callable\n        A function that has all keyword arguments and can be\n        used to create a `AnnularAperture` layer for testing.\n    \"\"\"\n\n\n    def _create_annular_aperture( \n            rmax        : Array = 1.2, \n            rmin        : Array = 0.5, \n            centre      : Array = [0., 0.],\n            shear      : Array = [0., 0.],\n            compression : Array = [1., 1.],\n            occulting   : bool = False, \n            softening   : Array = 0.) -&gt; Aperture:\n        return dLux.apertures.AnnularAperture(\n            rmax,\n            rmin,\n            centre,\n            shear,\n            compression,\n            occulting,\n            softening)\n\n    return _create_annular_aperture\n</pre> @pytest.fixture def create_annular_aperture() -&gt; callable:     \"\"\"     Returns:     --------     _create_annular_aperture: callable         A function that has all keyword arguments and can be         used to create a `AnnularAperture` layer for testing.     \"\"\"       def _create_annular_aperture(              rmax        : Array = 1.2,              rmin        : Array = 0.5,              centre      : Array = [0., 0.],             shear      : Array = [0., 0.],             compression : Array = [1., 1.],             occulting   : bool = False,              softening   : Array = 0.) -&gt; Aperture:         return dLux.apertures.AnnularAperture(             rmax,             rmin,             centre,             shear,             compression,             occulting,             softening)      return _create_annular_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_pixel_response() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_pixel_response: callable\n        A function that has all keyword arguments and can be\n        used to create a `ApplyPixelResponse` layer for testing.\n    \"\"\"\n    def _create_pixel_response(\n            pixel_response: Array = np.ones((16, 16))) -&gt; OpticalLayer:\n        return dLux.detectors.ApplyPixelResponse(pixel_response)\n    return _create_pixel_response\n</pre> @pytest.fixture def create_pixel_response() -&gt; callable:     \"\"\"     Returns:     --------     _create_pixel_response: callable         A function that has all keyword arguments and can be         used to create a `ApplyPixelResponse` layer for testing.     \"\"\"     def _create_pixel_response(             pixel_response: Array = np.ones((16, 16))) -&gt; OpticalLayer:         return dLux.detectors.ApplyPixelResponse(pixel_response)     return _create_pixel_response In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_jitter() -&gt; None:\n\"\"\"\n    Returns:\n    --------\n    _create_jitter: callable\n        A function that has all keyword arguments and can be\n        used to create a `ApplyJitter` layer for testing.\n    \"\"\"\n    def _create_jitter(\n            sigma: Array = np.array(1.),\n            kernel_size: int = 10) -&gt; OpticalLayer:\n        return dLux.detectors.ApplyJitter(sigma, kernel_size)\n    return _create_jitter\n</pre> @pytest.fixture def create_jitter() -&gt; None:     \"\"\"     Returns:     --------     _create_jitter: callable         A function that has all keyword arguments and can be         used to create a `ApplyJitter` layer for testing.     \"\"\"     def _create_jitter(             sigma: Array = np.array(1.),             kernel_size: int = 10) -&gt; OpticalLayer:         return dLux.detectors.ApplyJitter(sigma, kernel_size)     return _create_jitter In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_saturation() -&gt; None:\n\"\"\"\n    Returns:\n    --------\n    _create_saturation: callable\n        A function that has all keyword arguments and can be\n        used to create a `ApplySaturation` layer for testing.\n    \"\"\"\n    def _create_saturation(saturation: Array = np.array(1.)) -&gt; OpticalLayer:\n        return dLux.detectors.ApplySaturation(saturation)\n    return _create_saturation\n</pre> @pytest.fixture def create_saturation() -&gt; None:     \"\"\"     Returns:     --------     _create_saturation: callable         A function that has all keyword arguments and can be         used to create a `ApplySaturation` layer for testing.     \"\"\"     def _create_saturation(saturation: Array = np.array(1.)) -&gt; OpticalLayer:         return dLux.detectors.ApplySaturation(saturation)     return _create_saturation In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_constant() -&gt; None:\n\"\"\"\n    Returns:\n    --------\n    _create_constant: callable\n        A function that has all keyword arguments and can be\n        used to create a `ApplyConstant` layer for testing.\n    \"\"\"\n    def _create_constant(value: Array = np.array(1.)) -&gt; OpticalLayer:\n        return dLux.detectors.AddConstant(value)\n    return _create_constant\n</pre> @pytest.fixture def create_constant() -&gt; None:     \"\"\"     Returns:     --------     _create_constant: callable         A function that has all keyword arguments and can be         used to create a `ApplyConstant` layer for testing.     \"\"\"     def _create_constant(value: Array = np.array(1.)) -&gt; OpticalLayer:         return dLux.detectors.AddConstant(value)     return _create_constant In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_integer_downsample() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_integer_downsample: callable\n        A function that has all keyword arguments and can be\n        used to create a `IntegerDownsample` layer for testing.\n    \"\"\"\n    def _create_integer_downsample(kernel_size: int = 4) -&gt; OpticalLayer:\n        return dLux.detectors.IntegerDownsample(kernel_size)\n    return _create_integer_downsample\n</pre> @pytest.fixture def create_integer_downsample() -&gt; callable:     \"\"\"     Returns:     --------     _create_integer_downsample: callable         A function that has all keyword arguments and can be         used to create a `IntegerDownsample` layer for testing.     \"\"\"     def _create_integer_downsample(kernel_size: int = 4) -&gt; OpticalLayer:         return dLux.detectors.IntegerDownsample(kernel_size)     return _create_integer_downsample     In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_rotate_detector() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_rotate_detector: callable\n        A function that has all keyword arguments and can be\n        used to create a `Rotate` layer for testing.\n    \"\"\"\n    def _create_rotate_detector(\n            angle: Array = np.array(np.pi),\n            fourier: bool = False,\n            padding: int = 2) -&gt; OpticalLayer:\n        return dLux.detectors.Rotate(angle, fourier, padding)\n    return _create_rotate_detector\n</pre> @pytest.fixture def create_rotate_detector() -&gt; callable:     \"\"\"     Returns:     --------     _create_rotate_detector: callable         A function that has all keyword arguments and can be         used to create a `Rotate` layer for testing.     \"\"\"     def _create_rotate_detector(             angle: Array = np.array(np.pi),             fourier: bool = False,             padding: int = 2) -&gt; OpticalLayer:         return dLux.detectors.Rotate(angle, fourier, padding)     return _create_rotate_detector In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_uniform_spider() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_uniform_spider: callable\n        A function that has all keyword arguments and can be\n        used to create a `UniformSpider` layer for testing.\n    \"\"\"\n    def _create_uniform_spider(\n            number_of_struts: int = 4,\n            width_of_struts: float = .05,\n            centre      : Array = [0., 0.], \n            shear      : Array = [0., 0.],\n            compression : Array = [1., 1.],\n            rotation    : Array = 0., \n            softening   : bool = False) -&gt; OpticalLayer:\n        return dLux.apertures.UniformSpider(\n            number_of_struts, \n            width_of_struts,\n            centre=centre,\n            shear=shear,\n            compression=compression,\n            rotation=rotation,\n            softening=softening)\n    return _create_uniform_spider\n</pre> @pytest.fixture def create_uniform_spider() -&gt; callable:     \"\"\"     Returns:     --------     _create_uniform_spider: callable         A function that has all keyword arguments and can be         used to create a `UniformSpider` layer for testing.     \"\"\"     def _create_uniform_spider(             number_of_struts: int = 4,             width_of_struts: float = .05,             centre      : Array = [0., 0.],              shear      : Array = [0., 0.],             compression : Array = [1., 1.],             rotation    : Array = 0.,              softening   : bool = False) -&gt; OpticalLayer:         return dLux.apertures.UniformSpider(             number_of_struts,              width_of_struts,             centre=centre,             shear=shear,             compression=compression,             rotation=rotation,             softening=softening)     return _create_uniform_spider In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_aberrated_aperture(create_circular_aperture: callable) -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_aberrated_aperture: callable\n        A function that has all keyword arguments and can be\n        used to create a `AberratedAperture` layer for testing.\n    \"\"\"\n    shape: int = 6\n\n    def _create_aberrated_aperture(\n            noll_inds: list = np.arange(1, shape+1, dtype=int),\n            coefficients: Array = np.ones(shape, dtype=float),\n            aperture: object = create_circular_aperture()) -&gt; OpticalLayer:\n        return dLux.apertures.AberratedAperture(\n            noll_inds=noll_inds,\n            coefficients=coefficients,\n            aperture=aperture)\n    \n    return _create_aberrated_aperture\n</pre> @pytest.fixture def create_aberrated_aperture(create_circular_aperture: callable) -&gt; callable:     \"\"\"     Returns:     --------     _create_aberrated_aperture: callable         A function that has all keyword arguments and can be         used to create a `AberratedAperture` layer for testing.     \"\"\"     shape: int = 6      def _create_aberrated_aperture(             noll_inds: list = np.arange(1, shape+1, dtype=int),             coefficients: Array = np.ones(shape, dtype=float),             aperture: object = create_circular_aperture()) -&gt; OpticalLayer:         return dLux.apertures.AberratedAperture(             noll_inds=noll_inds,             coefficients=coefficients,             aperture=aperture)          return _create_aberrated_aperture In\u00a0[\u00a0]: Copied! <pre>@pytest.fixture\ndef create_dither() -&gt; callable:\n\"\"\"\n    Returns:\n    --------\n    _create_dither: callable\n        A function that has all keyword arguments and can be\n        used to create a `Dither` class for testing.\n    \"\"\"\n    def _create_dither(\n            dithers: Array = np.ones((5, 2))) -&gt; AbstractObservation:\n        return dLux.observations.Dither(dithers)\n    \n    return _create_dither\n</pre> @pytest.fixture def create_dither() -&gt; callable:     \"\"\"     Returns:     --------     _create_dither: callable         A function that has all keyword arguments and can be         used to create a `Dither` class for testing.     \"\"\"     def _create_dither(             dithers: Array = np.ones((5, 2))) -&gt; AbstractObservation:         return dLux.observations.Dither(dithers)          return _create_dither"},{"location":"tests/conftest/#apertures","title":"Apertures\u00b6","text":""},{"location":"tests/test_apertures/","title":"Test apertures","text":"In\u00a0[\u00a0]: Copied! <pre>import dLux \nimport jax\nimport jax.numpy as np\nimport typing\n</pre> import dLux  import jax import jax.numpy as np import typing In\u00a0[\u00a0]: Copied! <pre>jax.config.update(\"jax_debug_nans\", True)\n</pre> jax.config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Aperture = typing.TypeVar(\"Aperture\")\nArray = typing.TypeVar(\"Array\")\nSpider = typing.TypeVar(\"Spider\")\n</pre> Aperture = typing.TypeVar(\"Aperture\") Array = typing.TypeVar(\"Array\") Spider = typing.TypeVar(\"Spider\") In\u00a0[\u00a0]: Copied! <pre>class TestAperturesCommonInterfaces():\n\"\"\"\n    For each type of aperture that has common properties, test it\n    \"\"\"\n    def _assert_valid_hard_aperture(aperture, msg=''):\n        assert ((aperture == 1.) | (aperture == 0.)).all(), msg\n        \n    def _assert_valid_soft_aperture(aperture, msg=''):\n        assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all(), msg\n        assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all(), msg\n        # there should also exist something in bounds (assuming edges are within coordinates)\n        assert np.logical_and(aperture &gt; 0., aperture &lt; 1.).any(), msg\n        \n    # input is all the fixtures that need testing\n    def test_all_apertures(self, create_square_aperture : callable,\n                           create_rectangular_aperture : callable,\n                           create_circular_aperture : callable,\n                           create_hexagonal_aperture : callable,\n                           create_annular_aperture : callable):\n        \n        constructors = [create_square_aperture,\n                        create_rectangular_aperture,\n                        create_circular_aperture,\n                        create_hexagonal_aperture,\n                        create_annular_aperture]\n        \n        # TODO might need to add error message for when this fails but it checks things very easily\n        for ctor in constructors:\n            self._test_single_aperture_class(ctor)\n    \n    def _test_single_aperture_class(self, aperture_fixture):\n        coordinates = dLux.utils.get_pixel_positions((16, 16), (2./16, 2./16))\n        \n        x_offset = 1.\n        y_offset = 1.\n        centres = [np.array([0., 0.]),\n                   np.array([x_offset, 0.]),\n                   np.array([0., y_offset]),\n                   np.array([x_offset, y_offset])]\n        \n        rotations = [0, np.pi/3., -np.pi/3.5, np.pi/2.]\n        not_rotatable_apertures = (dLux.apertures.CircularAperture,\n                                   dLux.apertures.AnnularAperture)\n        \n        base_kwargs = {\"centre\" : None,\n                       \"softening\" : None,\n                       \"occulting\" : None\n                       }\n\n        for centre in centres:\n            for rotation in rotations:\n                for softening in [0., 1.]:\n                    for occulting in [True, False]:\n                        actual_kwargs = base_kwargs\n                        actual_kwargs[\"centre\"] = centre\n                        actual_kwargs[\"softening\"] = softening\n                        actual_kwargs[\"occulting\"] = occulting\n                        \n                        if not isinstance(aperture_fixture(), not_rotatable_apertures):\n                            actual_kwargs[\"rotation\"] = rotation\n                            \n                        \n                        aperture = aperture_fixture(**actual_kwargs)._aperture(coordinates)\n                        \n                        msg = f'{actual_kwargs}, on ctor {aperture_fixture}'\n                        \n                        if softening:\n                            TestAperturesCommonInterfaces._assert_valid_soft_aperture(aperture, msg)\n                        else:\n                            TestAperturesCommonInterfaces._assert_valid_hard_aperture(aperture, msg)\n</pre> class TestAperturesCommonInterfaces():     \"\"\"     For each type of aperture that has common properties, test it     \"\"\"     def _assert_valid_hard_aperture(aperture, msg=''):         assert ((aperture == 1.) | (aperture == 0.)).all(), msg              def _assert_valid_soft_aperture(aperture, msg=''):         assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all(), msg         assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all(), msg         # there should also exist something in bounds (assuming edges are within coordinates)         assert np.logical_and(aperture &gt; 0., aperture &lt; 1.).any(), msg              # input is all the fixtures that need testing     def test_all_apertures(self, create_square_aperture : callable,                            create_rectangular_aperture : callable,                            create_circular_aperture : callable,                            create_hexagonal_aperture : callable,                            create_annular_aperture : callable):                  constructors = [create_square_aperture,                         create_rectangular_aperture,                         create_circular_aperture,                         create_hexagonal_aperture,                         create_annular_aperture]                  # TODO might need to add error message for when this fails but it checks things very easily         for ctor in constructors:             self._test_single_aperture_class(ctor)          def _test_single_aperture_class(self, aperture_fixture):         coordinates = dLux.utils.get_pixel_positions((16, 16), (2./16, 2./16))                  x_offset = 1.         y_offset = 1.         centres = [np.array([0., 0.]),                    np.array([x_offset, 0.]),                    np.array([0., y_offset]),                    np.array([x_offset, y_offset])]                  rotations = [0, np.pi/3., -np.pi/3.5, np.pi/2.]         not_rotatable_apertures = (dLux.apertures.CircularAperture,                                    dLux.apertures.AnnularAperture)                  base_kwargs = {\"centre\" : None,                        \"softening\" : None,                        \"occulting\" : None                        }          for centre in centres:             for rotation in rotations:                 for softening in [0., 1.]:                     for occulting in [True, False]:                         actual_kwargs = base_kwargs                         actual_kwargs[\"centre\"] = centre                         actual_kwargs[\"softening\"] = softening                         actual_kwargs[\"occulting\"] = occulting                                                  if not isinstance(aperture_fixture(), not_rotatable_apertures):                             actual_kwargs[\"rotation\"] = rotation                                                                               aperture = aperture_fixture(**actual_kwargs)._aperture(coordinates)                                                  msg = f'{actual_kwargs}, on ctor {aperture_fixture}'                                                  if softening:                             TestAperturesCommonInterfaces._assert_valid_soft_aperture(aperture, msg)                         else:                             TestAperturesCommonInterfaces._assert_valid_hard_aperture(aperture, msg) In\u00a0[\u00a0]: Copied! <pre>class TestUniformSpider(object):\n\"\"\"\n    Contains the unit tests for the `UniformSpider` class.\n    \"\"\"\n\n\n    def test_constructor(self, create_uniform_spider: callable) -&gt; None:\n\"\"\"\n        Tests that the state is correctly initialised. \n        \"\"\"\n        # Test functioning\n        spider = create_uniform_spider()\n\n    \n    def test_range_hard(self, create_uniform_spider: callable) -&gt; None:\n\"\"\"\n        Checks that the apertures fall into the correct range.\n        \"\"\"\n        npix = 16\n        width = 2.\n        pixel_scale = width / npix\n        coordinates = dLux.utils.get_pixel_positions((npix,npix), \n                                                    (pixel_scale, pixel_scale))\n\n        # Case Translated \n        spider = create_uniform_spider(centre=[1., 1.], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert ((aperture == 1.) | (aperture == 0.)).all()\n\n        # Case Rotated \n        spider = create_uniform_spider(rotation=np.pi/4., softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert ((aperture == 1.) | (aperture == 0.)).all()\n\n        # Case Strained \n        spider = create_uniform_spider(shear=[.05, .05], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert ((aperture == 1.) | (aperture == 0.)).all()\n\n        # Case Compression\n        spider = create_uniform_spider(compression=[1.05, .95], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert ((aperture == 1.) | (aperture == 0.)).all()\n\n\n    def test_range_soft(self, create_uniform_spider: callable) -&gt; None:\n\"\"\"\n        Checks that the aperture falls into the correct range.\n        \"\"\"\n        npix = 16\n        width = 2.\n        pixel_scale = width / npix\n        coordinates = dLux.utils.get_pixel_positions((npix,npix), \n                                                    (pixel_scale, pixel_scale))\n\n        # Case Translated \n        spider = create_uniform_spider(centre=[1., 1.], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()\n        assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()\n\n        # Case Rotated \n        spider = create_uniform_spider(rotation=np.pi/4., softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()\n        assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()\n\n        # Case Strained \n        spider = create_uniform_spider(shear=[.05, .05], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()\n        assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()\n\n        # Case Compression\n        spider = create_uniform_spider(compression=[1.05, .95], softening=0.)\n        aperture = spider._aperture(coordinates)\n        assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()\n        assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()\n</pre> class TestUniformSpider(object):     \"\"\"     Contains the unit tests for the `UniformSpider` class.     \"\"\"       def test_constructor(self, create_uniform_spider: callable) -&gt; None:         \"\"\"         Tests that the state is correctly initialised.          \"\"\"         # Test functioning         spider = create_uniform_spider()           def test_range_hard(self, create_uniform_spider: callable) -&gt; None:         \"\"\"         Checks that the apertures fall into the correct range.         \"\"\"         npix = 16         width = 2.         pixel_scale = width / npix         coordinates = dLux.utils.get_pixel_positions((npix,npix),                                                      (pixel_scale, pixel_scale))          # Case Translated          spider = create_uniform_spider(centre=[1., 1.], softening=0.)         aperture = spider._aperture(coordinates)         assert ((aperture == 1.) | (aperture == 0.)).all()          # Case Rotated          spider = create_uniform_spider(rotation=np.pi/4., softening=0.)         aperture = spider._aperture(coordinates)         assert ((aperture == 1.) | (aperture == 0.)).all()          # Case Strained          spider = create_uniform_spider(shear=[.05, .05], softening=0.)         aperture = spider._aperture(coordinates)         assert ((aperture == 1.) | (aperture == 0.)).all()          # Case Compression         spider = create_uniform_spider(compression=[1.05, .95], softening=0.)         aperture = spider._aperture(coordinates)         assert ((aperture == 1.) | (aperture == 0.)).all()       def test_range_soft(self, create_uniform_spider: callable) -&gt; None:         \"\"\"         Checks that the aperture falls into the correct range.         \"\"\"         npix = 16         width = 2.         pixel_scale = width / npix         coordinates = dLux.utils.get_pixel_positions((npix,npix),                                                      (pixel_scale, pixel_scale))          # Case Translated          spider = create_uniform_spider(centre=[1., 1.], softening=0.)         aperture = spider._aperture(coordinates)         assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()         assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()          # Case Rotated          spider = create_uniform_spider(rotation=np.pi/4., softening=0.)         aperture = spider._aperture(coordinates)         assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()         assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()          # Case Strained          spider = create_uniform_spider(shear=[.05, .05], softening=0.)         aperture = spider._aperture(coordinates)         assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()         assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all()          # Case Compression         spider = create_uniform_spider(compression=[1.05, .95], softening=0.)         aperture = spider._aperture(coordinates)         assert (aperture &lt;= 1. + np.finfo(np.float32).resolution).all()         assert (aperture &gt;= 0. - np.finfo(np.float32).resolution).all() In\u00a0[\u00a0]: Copied! <pre>class TestAberratedAperture(object):\n\"\"\"\n    Checks that the aberrated aperture is functional. It does not\n    test whether the aberrated aperture is correct.\n    \"\"\"\n\n\n    def test_constructor(self, create_aberrated_aperture: callable) -&gt; None:\n\"\"\"\n        Tests that it is possible to instantiate an AberratedAperture.\n        Does not test if the AberratedAperture is correct.\n        \"\"\"\n        # TODO: Make sure that the class asserts that the coeffs and \n        # the noll indexes have the same length.\n        create_aberrated_aperture()\n\n\n    def test_on_aperture(self: object, \n            create_aberrated_aperture: callable,\n            create_circular_aperture: callable) -&gt; None:\n\"\"\"\n        Tests that the basis functions are evaluated atop the aperture.\n        Applies mutliple different permutations.\n        \"\"\"\n        jax.config.update(\"jax_debug_nans\", True)\n        \n        npix = 16\n        width = 2.\n        pixel_scale = width / npix\n        coordinates = dLux.utils.get_pixel_positions((npix,npix), \n                                                    (pixel_scale, pixel_scale))\n\n        ap = create_circular_aperture()\n\n        aber_ap = create_aberrated_aperture(aperture=ap)._basis(coordinates)\n        ap = ap._aperture(coordinates)\n\n        abers = np.where(ap == 0., aber_ap, 0.)\n        assert (abers == 0.).all()\n</pre> class TestAberratedAperture(object):     \"\"\"     Checks that the aberrated aperture is functional. It does not     test whether the aberrated aperture is correct.     \"\"\"       def test_constructor(self, create_aberrated_aperture: callable) -&gt; None:         \"\"\"         Tests that it is possible to instantiate an AberratedAperture.         Does not test if the AberratedAperture is correct.         \"\"\"         # TODO: Make sure that the class asserts that the coeffs and          # the noll indexes have the same length.         create_aberrated_aperture()       def test_on_aperture(self: object,              create_aberrated_aperture: callable,             create_circular_aperture: callable) -&gt; None:         \"\"\"         Tests that the basis functions are evaluated atop the aperture.         Applies mutliple different permutations.         \"\"\"         jax.config.update(\"jax_debug_nans\", True)                  npix = 16         width = 2.         pixel_scale = width / npix         coordinates = dLux.utils.get_pixel_positions((npix,npix),                                                      (pixel_scale, pixel_scale))          ap = create_circular_aperture()          aber_ap = create_aberrated_aperture(aperture=ap)._basis(coordinates)         ap = ap._aperture(coordinates)          abers = np.where(ap == 0., aber_ap, 0.)         assert (abers == 0.).all()"},{"location":"tests/test_core/","title":"Test core","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>def test_model(\n        create_optics: callable,\n        create_detector: callable,\n        create_point_source: callable) -&gt; None:\n\"\"\"\n    Test the model function\n    \"\"\"\n    optics = create_optics()\n    detector = create_detector()\n    source = create_point_source()\n    sources = [source, source]\n\n    # Test non-optics input\n    with pytest.raises(AssertionError):\n        dLux.core.model([], [])\n\n    # Test non detector input\n    with pytest.raises(AssertionError):\n        dLux.core.model(optics, sources, detector=[])\n\n    # Test no source inputs\n    with pytest.raises(TypeError):\n        dLux.core.model(optics)\n\n    # Test sources with non-source input\n    with pytest.raises(AssertionError):\n        dLux.core.model(optics, sources=[source, 1.])\n\n    # Test different combinations of inputs, detector\n    out = dLux.core.model(optics, sources=sources, detector=detector)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test normalise function for scene\n    out = dLux.core.model(optics, sources=sources)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test normalise function for sources\n    out = dLux.core.model(optics, sources=sources, normalise=False)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test return_tree with different structures, list\n    out = dLux.core.model(optics, sources=sources, return_tree=True)\n    out = np.array(out)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test return_tree with different structures, dict\n    out = dLux.core.model(optics, sources={\"source\": source}, return_tree=True)\n    out = np.array(list(out.values()))\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test return_tree with different structures, source\n    out = dLux.core.model(optics, sources=sources, return_tree=True)\n    out = np.array(out)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n\n    # Test return_tree with detector input\n    out = dLux.core.model(optics, sources=sources, detector=detector, return_tree=True)\n    out = np.array(out)\n    assert not np.isnan(out).all()\n    assert not np.isinf(out).all()\n</pre> def test_model(         create_optics: callable,         create_detector: callable,         create_point_source: callable) -&gt; None:     \"\"\"     Test the model function     \"\"\"     optics = create_optics()     detector = create_detector()     source = create_point_source()     sources = [source, source]      # Test non-optics input     with pytest.raises(AssertionError):         dLux.core.model([], [])      # Test non detector input     with pytest.raises(AssertionError):         dLux.core.model(optics, sources, detector=[])      # Test no source inputs     with pytest.raises(TypeError):         dLux.core.model(optics)      # Test sources with non-source input     with pytest.raises(AssertionError):         dLux.core.model(optics, sources=[source, 1.])      # Test different combinations of inputs, detector     out = dLux.core.model(optics, sources=sources, detector=detector)     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test normalise function for scene     out = dLux.core.model(optics, sources=sources)     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test normalise function for sources     out = dLux.core.model(optics, sources=sources, normalise=False)     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test return_tree with different structures, list     out = dLux.core.model(optics, sources=sources, return_tree=True)     out = np.array(out)     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test return_tree with different structures, dict     out = dLux.core.model(optics, sources={\"source\": source}, return_tree=True)     out = np.array(list(out.values()))     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test return_tree with different structures, source     out = dLux.core.model(optics, sources=sources, return_tree=True)     out = np.array(out)     assert not np.isnan(out).all()     assert not np.isinf(out).all()      # Test return_tree with detector input     out = dLux.core.model(optics, sources=sources, detector=detector, return_tree=True)     out = np.array(out)     assert not np.isnan(out).all()     assert not np.isinf(out).all() In\u00a0[\u00a0]: Copied! <pre>class TestOptics(object):\n\"\"\"\n    Tests the Optics class.\n    \"\"\"\n\n\n    def test_constructor(self, create_optics: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test non-list inputs\n        with pytest.raises(AssertionError):\n            create_optics(layers={})\n\n        # Test list input with non Optics Layer input\n        with pytest.raises(AssertionError):\n            create_optics(layers=[10.])\n\n\n    def test_propagate_mono(self, create_optics: callable) -&gt; None:\n\"\"\"\n        Tests the propagate_mono method.\n        \"\"\"\n        osys = create_optics() \n\n        # Test inputs\n        with pytest.raises(AssertionError):\n            osys.propagate_mono([1e-6])\n\n        with pytest.raises(AssertionError):\n            osys.propagate_mono(1e-6, [0.])\n\n        with pytest.raises(AssertionError):\n            osys.propagate_mono(1e-6, weight=[0.])\n\n        # Test propagation\n        psf = osys.propagate_mono(4e-6)\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n\n\n    def test_propagate(self, create_optics: callable) -&gt; None:\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        osys = create_optics()\n\n        # Test inputs\n        with pytest.raises(AssertionError):\n            osys.propagate(1e-6)\n\n        with pytest.raises(AssertionError):\n            osys.propagate([[1e-6]])\n\n        with pytest.raises(AssertionError):\n            osys.propagate([1e-6], [0.])\n\n        with pytest.raises(AssertionError):\n            osys.propagate([1e-6, 2e-6], weights=[0.])\n\n        # Test propagation\n        psf = osys.propagate([4e-6, 5e-6])\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n\n\n    def test_debug_prop(self, create_optics: callable) -&gt; None:\n\"\"\"\n        Tests the debug_prop method.\n        \"\"\"\n        osys = create_optics()\n\n        # Test inputs\n        with pytest.raises(AssertionError):\n            osys.debug_prop([1e-6])\n\n        with pytest.raises(AssertionError):\n            osys.debug_prop(1e-6, [0.])\n\n        with pytest.raises(AssertionError):\n            osys.debug_prop(1e-6, weight=[0.])\n\n        # Test propagation\n        psf, _, _ = osys.debug_prop(4e-6)\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n\n\n    def test_model(self, \n            create_optics: callable, \n            create_point_source: callable) -&gt; None:\n\"\"\"\n        Tests the model method\n        \"\"\"\n        osys = create_optics()\n        psf = osys.model(sources=create_point_source())\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n</pre> class TestOptics(object):     \"\"\"     Tests the Optics class.     \"\"\"       def test_constructor(self, create_optics: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test non-list inputs         with pytest.raises(AssertionError):             create_optics(layers={})          # Test list input with non Optics Layer input         with pytest.raises(AssertionError):             create_optics(layers=[10.])       def test_propagate_mono(self, create_optics: callable) -&gt; None:         \"\"\"         Tests the propagate_mono method.         \"\"\"         osys = create_optics()           # Test inputs         with pytest.raises(AssertionError):             osys.propagate_mono([1e-6])          with pytest.raises(AssertionError):             osys.propagate_mono(1e-6, [0.])          with pytest.raises(AssertionError):             osys.propagate_mono(1e-6, weight=[0.])          # Test propagation         psf = osys.propagate_mono(4e-6)         assert not np.isnan(psf).all()         assert not np.isinf(psf).all()       def test_propagate(self, create_optics: callable) -&gt; None:         \"\"\"         Tests the propagate method.         \"\"\"         osys = create_optics()          # Test inputs         with pytest.raises(AssertionError):             osys.propagate(1e-6)          with pytest.raises(AssertionError):             osys.propagate([[1e-6]])          with pytest.raises(AssertionError):             osys.propagate([1e-6], [0.])          with pytest.raises(AssertionError):             osys.propagate([1e-6, 2e-6], weights=[0.])          # Test propagation         psf = osys.propagate([4e-6, 5e-6])         assert not np.isnan(psf).all()         assert not np.isinf(psf).all()       def test_debug_prop(self, create_optics: callable) -&gt; None:         \"\"\"         Tests the debug_prop method.         \"\"\"         osys = create_optics()          # Test inputs         with pytest.raises(AssertionError):             osys.debug_prop([1e-6])          with pytest.raises(AssertionError):             osys.debug_prop(1e-6, [0.])          with pytest.raises(AssertionError):             osys.debug_prop(1e-6, weight=[0.])          # Test propagation         psf, _, _ = osys.debug_prop(4e-6)         assert not np.isnan(psf).all()         assert not np.isinf(psf).all()       def test_model(self,              create_optics: callable,              create_point_source: callable) -&gt; None:         \"\"\"         Tests the model method         \"\"\"         osys = create_optics()         psf = osys.model(sources=create_point_source())         assert not np.isnan(psf).all()         assert not np.isinf(psf).all() In\u00a0[\u00a0]: Copied! <pre>class TestDetector(object):\n\"\"\"\n    Tests the Detector class.\n    \"\"\"\n\n\n    def test_constructor(self, create_detector: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test non-list inputs\n        with pytest.raises(AssertionError):\n            create_detector(layers={})\n\n        # Test list input with non Optics Layer input\n        with pytest.raises(AssertionError):\n            create_detector(layers=[10.])\n\n\n    def test_apply_detector(self, create_detector: callable) -&gt; None:\n\"\"\"\n        Tests the apply_detector method.\n        \"\"\"\n        detector = create_detector()\n\n        # Test inputs\n        with pytest.raises(AssertionError):\n            detector.apply_detector([1e-6])\n\n        # Test 1d input\n        with pytest.raises(AssertionError):\n            detector.apply_detector(np.array([1.]))\n\n        # Test 3d input\n        with pytest.raises(AssertionError):\n            detector.apply_detector(np.array([[[1.]]]))\n\n        # Test propagation\n        image = detector.apply_detector(np.ones((5, 5)))\n        assert not np.isnan(image).all()\n        assert not np.isinf(image).all()\n\n\n    def test_debug_apply_detector(self, create_detector: callable) -&gt; None:\n\"\"\"\n        Tests the debug_apply_detector method.\n        \"\"\"\n        detector = create_detector()\n\n        # Test inputs\n        with pytest.raises(AssertionError):\n            detector.debug_apply_detector([1e-6])\n\n        # Test 1d input\n        with pytest.raises(AssertionError):\n            detector.debug_apply_detector(np.array([1.]))\n\n        # Test 3d input\n        with pytest.raises(AssertionError):\n            detector.debug_apply_detector(np.array([[[1.]]]))\n\n        # Test propagation\n        image, _, _ = detector.debug_apply_detector(np.ones((5, 5)))\n        assert not np.isnan(image).all()\n        assert not np.isinf(image).all()\n\n\n    def test_model(self,\n            create_detector: callable,\n            create_point_source: callable,\n            create_optics: callable) -&gt; None:\n\"\"\"\n        Tests the model method\n        \"\"\"\n        detector = create_detector()\n        source = create_point_source()\n        psf = create_optics().model(sources=source)\n        psf = detector.model(psf)\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n</pre> class TestDetector(object):     \"\"\"     Tests the Detector class.     \"\"\"       def test_constructor(self, create_detector: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test non-list inputs         with pytest.raises(AssertionError):             create_detector(layers={})          # Test list input with non Optics Layer input         with pytest.raises(AssertionError):             create_detector(layers=[10.])       def test_apply_detector(self, create_detector: callable) -&gt; None:         \"\"\"         Tests the apply_detector method.         \"\"\"         detector = create_detector()          # Test inputs         with pytest.raises(AssertionError):             detector.apply_detector([1e-6])          # Test 1d input         with pytest.raises(AssertionError):             detector.apply_detector(np.array([1.]))          # Test 3d input         with pytest.raises(AssertionError):             detector.apply_detector(np.array([[[1.]]]))          # Test propagation         image = detector.apply_detector(np.ones((5, 5)))         assert not np.isnan(image).all()         assert not np.isinf(image).all()       def test_debug_apply_detector(self, create_detector: callable) -&gt; None:         \"\"\"         Tests the debug_apply_detector method.         \"\"\"         detector = create_detector()          # Test inputs         with pytest.raises(AssertionError):             detector.debug_apply_detector([1e-6])          # Test 1d input         with pytest.raises(AssertionError):             detector.debug_apply_detector(np.array([1.]))          # Test 3d input         with pytest.raises(AssertionError):             detector.debug_apply_detector(np.array([[[1.]]]))          # Test propagation         image, _, _ = detector.debug_apply_detector(np.ones((5, 5)))         assert not np.isnan(image).all()         assert not np.isinf(image).all()       def test_model(self,             create_detector: callable,             create_point_source: callable,             create_optics: callable) -&gt; None:         \"\"\"         Tests the model method         \"\"\"         detector = create_detector()         source = create_point_source()         psf = create_optics().model(sources=source)         psf = detector.model(psf)         assert not np.isnan(psf).all()         assert not np.isinf(psf).all() In\u00a0[\u00a0]: Copied! <pre>class TestInstrument(object):\n\"\"\"\n    Tests the Optics class.\n    \"\"\"\n\n\n    def test_constructor(self, create_instrument: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test non optics input\n        with pytest.raises(ValueError):\n            create_instrument(optics=[])\n\n        # Test non detector input\n        with pytest.raises(ValueError):\n            create_instrument(detector=[])\n\n        # Test non source input\n        with pytest.raises(ValueError):\n            create_instrument(sources=[1.])\n\n\n    def test_normalise(self, create_instrument: callable) -&gt; None:\n\"\"\"\n        Tests the normalise method.\n        \"\"\"\n        # Test all sources in the scene are normalised\n        instrument = create_instrument()\n        normalised_instrument = instrument.normalise()\n        for source in normalised_instrument.sources.values():\n            assert np.allclose(source.get_weights().sum(), 1.)\n            if hasattr(source, 'get_distribution'):\n                assert np.allclose(source.get_distribution(), 1.)\n\n\n    def test_model(self, \n            create_instrument: callable, \n            create_point_source: callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        instrument = create_instrument()\n        sources = [create_point_source()]\n        source = create_point_source()\n\n        # Test modelling\n        psf = instrument.model()\n        assert not np.isnan(psf).all()\n        assert not np.isinf(psf).all()\n</pre> class TestInstrument(object):     \"\"\"     Tests the Optics class.     \"\"\"       def test_constructor(self, create_instrument: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test non optics input         with pytest.raises(ValueError):             create_instrument(optics=[])          # Test non detector input         with pytest.raises(ValueError):             create_instrument(detector=[])          # Test non source input         with pytest.raises(ValueError):             create_instrument(sources=[1.])       def test_normalise(self, create_instrument: callable) -&gt; None:         \"\"\"         Tests the normalise method.         \"\"\"         # Test all sources in the scene are normalised         instrument = create_instrument()         normalised_instrument = instrument.normalise()         for source in normalised_instrument.sources.values():             assert np.allclose(source.get_weights().sum(), 1.)             if hasattr(source, 'get_distribution'):                 assert np.allclose(source.get_distribution(), 1.)       def test_model(self,              create_instrument: callable,              create_point_source: callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         instrument = create_instrument()         sources = [create_point_source()]         source = create_point_source()          # Test modelling         psf = instrument.model()         assert not np.isnan(psf).all()         assert not np.isinf(psf).all() In\u00a0[\u00a0]: Copied! <pre>class TestFilter(object):\n\"\"\"\n    Tests the Filter class.\n    \"\"\"\n\n\n    def test_constructor(self, create_filter: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test adding filter name\n        with pytest.raises(NotImplementedError):\n            create_filter(filter_name='Test')\n\n        # Test 2d wavelengths input\n        with pytest.raises(AssertionError):\n            create_filter(2,2)\n\n        # Test 2d throughput input\n        with pytest.raises(AssertionError):\n            create_filter(2,2)\n\n        # Test different shape wavelengths and throughput\n        with pytest.raises(AssertionError):\n            create_filter(4)\n\n        # Test negative wavelengths\n        with pytest.raises(AssertionError):\n            create_filter([-1, 1])\n\n        # Test negative throughputs\n        with pytest.raises(AssertionError):\n            create_filter([-1, 1])\n\n        # Test throughputs greater than 1\n        with pytest.raises(AssertionError):\n            create_filter([0, 1.5])\n\n        # Test reverse order wavelengths\n        with pytest.raises(AssertionError):\n            create_filter([1, 0.5])\n\n\n    def test_get_throughput(self, create_filter: callable) -&gt; None:\n\"\"\"\n        Test the get_throughput method.\n        \"\"\"\n        filt = create_filter()\n\n        # Test scalar input\n        throughput = filt.get_throughput(np.array([1e-6, 2e-6]))\n        assert not np.isnan(throughput).all()\n        assert not np.isinf(throughput).all()\n        assert (throughput &gt;= 0).all()\n        assert (throughput &lt;= 1).all()\n\n        # test array input\n        throughput = filt.get_throughput(np.array([1e-6, 2e-6]))\n        assert not np.isnan(throughput).all()\n        assert not np.isinf(throughput).all()\n        assert (throughput &gt;= 0).all()\n        assert (throughput &lt;= 1).all()\n\n        # Test 1d array inputs\n        throughput = filt.get_throughput(1e-6*np.linspace(1, 5, 5))\n        assert not np.isnan(throughput).all()\n        assert not np.isinf(throughput).all()\n        assert (throughput &gt;= 0).all()\n        assert (throughput &lt;= 1).all()\n</pre> class TestFilter(object):     \"\"\"     Tests the Filter class.     \"\"\"       def test_constructor(self, create_filter: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test adding filter name         with pytest.raises(NotImplementedError):             create_filter(filter_name='Test')          # Test 2d wavelengths input         with pytest.raises(AssertionError):             create_filter(2,2)          # Test 2d throughput input         with pytest.raises(AssertionError):             create_filter(2,2)          # Test different shape wavelengths and throughput         with pytest.raises(AssertionError):             create_filter(4)          # Test negative wavelengths         with pytest.raises(AssertionError):             create_filter([-1, 1])          # Test negative throughputs         with pytest.raises(AssertionError):             create_filter([-1, 1])          # Test throughputs greater than 1         with pytest.raises(AssertionError):             create_filter([0, 1.5])          # Test reverse order wavelengths         with pytest.raises(AssertionError):             create_filter([1, 0.5])       def test_get_throughput(self, create_filter: callable) -&gt; None:         \"\"\"         Test the get_throughput method.         \"\"\"         filt = create_filter()          # Test scalar input         throughput = filt.get_throughput(np.array([1e-6, 2e-6]))         assert not np.isnan(throughput).all()         assert not np.isinf(throughput).all()         assert (throughput &gt;= 0).all()         assert (throughput &lt;= 1).all()          # test array input         throughput = filt.get_throughput(np.array([1e-6, 2e-6]))         assert not np.isnan(throughput).all()         assert not np.isinf(throughput).all()         assert (throughput &gt;= 0).all()         assert (throughput &lt;= 1).all()          # Test 1d array inputs         throughput = filt.get_throughput(1e-6*np.linspace(1, 5, 5))         assert not np.isnan(throughput).all()         assert not np.isinf(throughput).all()         assert (throughput &gt;= 0).all()         assert (throughput &lt;= 1).all()"},{"location":"tests/test_detectors/","title":"Test detectors","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class TestApplyPixelResponse(object):\n\"\"\"\n    Tests the ApplyPixelResponse class.\n    \"\"\"\n\n\n    def test_constructor(self, create_pixel_response: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_pixel_response(pixel_response=np.ones(1))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_pixel_response(pixel_response=np.array(1.))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_pixel_response(pixel_response=np.ones((1, 1, 1)))\n\n        # Test functioning\n        create_pixel_response()\n\n\n    def test_call(self, create_pixel_response: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        image = np.ones((16, 16))\n        create_pixel_response()(image)\n</pre> class TestApplyPixelResponse(object):     \"\"\"     Tests the ApplyPixelResponse class.     \"\"\"       def test_constructor(self, create_pixel_response: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_pixel_response(pixel_response=np.ones(1))          # Test wrong dims         with pytest.raises(AssertionError):             create_pixel_response(pixel_response=np.array(1.))          # Test wrong dims         with pytest.raises(AssertionError):             create_pixel_response(pixel_response=np.ones((1, 1, 1)))          # Test functioning         create_pixel_response()       def test_call(self, create_pixel_response: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         image = np.ones((16, 16))         create_pixel_response()(image) In\u00a0[\u00a0]: Copied! <pre>class TestApplyJitter(object):\n\"\"\"\n    Tests the ApplyJitter class.\n    \"\"\"\n\n\n    def test_constructor(self, create_jitter: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_jitter(sigma=np.ones(1))\n\n        # Test functioning\n        create_jitter()\n\n\n    def test_call(self, create_jitter: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        image = np.ones((16, 16))\n        create_jitter()(image)\n</pre> class TestApplyJitter(object):     \"\"\"     Tests the ApplyJitter class.     \"\"\"       def test_constructor(self, create_jitter: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_jitter(sigma=np.ones(1))          # Test functioning         create_jitter()       def test_call(self, create_jitter: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         image = np.ones((16, 16))         create_jitter()(image) In\u00a0[\u00a0]: Copied! <pre>class TestApplySaturation(object):\n\"\"\"\n    Tests the ApplySaturation class.\n    \"\"\"\n\n\n    def test_constructor(self, create_saturation: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_saturation(saturation=np.ones(1))\n\n        # Test functioning\n        create_saturation()\n\n\n    def test_call(self, create_saturation: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        image = np.ones((16, 16))\n        create_saturation()(image)\n</pre> class TestApplySaturation(object):     \"\"\"     Tests the ApplySaturation class.     \"\"\"       def test_constructor(self, create_saturation: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_saturation(saturation=np.ones(1))          # Test functioning         create_saturation()       def test_call(self, create_saturation: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         image = np.ones((16, 16))         create_saturation()(image) In\u00a0[\u00a0]: Copied! <pre>class TestAddConstant(object):\n\"\"\"\n    Tests the AddConstant class.\n    \"\"\"\n\n\n    def test_constructor(self, create_constant: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_constant(value=np.ones(1))\n\n        # Test functioning\n        create_constant()\n\n\n    def test_call(self, create_constant: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        image = np.ones((16, 16))\n        create_constant()(image)\n</pre> class TestAddConstant(object):     \"\"\"     Tests the AddConstant class.     \"\"\"       def test_constructor(self, create_constant: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_constant(value=np.ones(1))          # Test functioning         create_constant()       def test_call(self, create_constant: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         image = np.ones((16, 16))         create_constant()(image) In\u00a0[\u00a0]: Copied! <pre>class TestIntegerDownsample(object):\n\"\"\"\n    Tests the IntegerDownsample class.\n    \"\"\"\n\n\n    def test_constructor(self, create_integer_downsample: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test functioning\n        create_integer_downsample()\n\n\n    def test_call(self, create_integer_downsample: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        image = np.ones((16, 16))\n        create_integer_downsample()(image)\n</pre> class TestIntegerDownsample(object):     \"\"\"     Tests the IntegerDownsample class.     \"\"\"       def test_constructor(self, create_integer_downsample: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test functioning         create_integer_downsample()       def test_call(self, create_integer_downsample: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         image = np.ones((16, 16))         create_integer_downsample()(image) In\u00a0[\u00a0]: Copied! <pre>class TestRotate(object):\n\"\"\"\n    Tests the Rotate class.\n    \"\"\"\n\n\n    def test_constructor(self, create_rotate_detector: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_rotate_detector(angle=np.ones(1))\n\n        # Test functioning\n        create_rotate_detector()\n\n\n    def test_call(self, create_rotate_detector: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        # Test regular rotation\n        image = np.ones((16, 16))\n        create_rotate_detector()(image)\n\n        # Test fourier\n        with pytest.raises(NotImplementedError):\n            create_rotate_detector(fourier=True)(image)\n</pre> class TestRotate(object):     \"\"\"     Tests the Rotate class.     \"\"\"       def test_constructor(self, create_rotate_detector: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_rotate_detector(angle=np.ones(1))          # Test functioning         create_rotate_detector()       def test_call(self, create_rotate_detector: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         # Test regular rotation         image = np.ones((16, 16))         create_rotate_detector()(image)          # Test fourier         with pytest.raises(NotImplementedError):             create_rotate_detector(fourier=True)(image)"},{"location":"tests/test_installation/","title":"Test installation","text":"In\u00a0[\u00a0]: Copied! <pre>import pytest\nimport sys\nimport os\n</pre> import pytest import sys import os In\u00a0[\u00a0]: Copied! <pre>platform: str = sys.platform\nnot_lin_err: str = \"\"\"\n    The installation test is designed to run on\n    a linux machine. In particular, this test\n    is designed to be run by github actions.\n    If you are using windows dispare.\n\"\"\"\n</pre> platform: str = sys.platform not_lin_err: str = \"\"\"     The installation test is designed to run on     a linux machine. In particular, this test     is designed to be run by github actions.     If you are using windows dispare. \"\"\" In\u00a0[\u00a0]: Copied! <pre>if platform not in [\"linux\", \"linux2\"]:\n    print(f\"Error: {not_lin_err}\")\n</pre> if platform not in [\"linux\", \"linux2\"]:     print(f\"Error: {not_lin_err}\") In\u00a0[\u00a0]: Copied! <pre>def test_install_dLux():\n    install_ok: int = os.system(\"pip install --quiet .\")\n\n    assert install_ok == 0\n\n    os.system(\"rm -r dLux.egg-info\")\n    os.system(\"rm -r build\")\n</pre> def test_install_dLux():     install_ok: int = os.system(\"pip install --quiet .\")      assert install_ok == 0      os.system(\"rm -r dLux.egg-info\")     os.system(\"rm -r build\") In\u00a0[\u00a0]: Copied! <pre>def test_import_dLux():\n    import dLux\n    assert True\n</pre> def test_import_dLux():     import dLux     assert True In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tests/test_observations/","title":"Test observations","text":"In\u00a0[\u00a0]: Copied! <pre>import dLux \nimport jax\nimport jax.numpy as np\nimport typing\nfrom dLux.exceptions import DimensionError\nimport pytest\n</pre> import dLux  import jax import jax.numpy as np import typing from dLux.exceptions import DimensionError import pytest In\u00a0[\u00a0]: Copied! <pre>jax.config.update(\"jax_debug_nans\", True)\n</pre> jax.config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Dither = dLux.observations.Dither\nArray = typing.TypeVar(\"Array\")\n</pre> Dither = dLux.observations.Dither Array = typing.TypeVar(\"Array\") In\u00a0[\u00a0]: Copied! <pre>class TestDither(object):\n\"\"\"\n    Contains the unit tests for the `UniformSpider` class.\n    \"\"\"\n\n    def test_constructor(self, create_dither: callable) -&gt; None:\n\n        with pytest.raises(DimensionError):\n            dither = create_dither(np.array([1., 1., 1.]))\n        \n        dither = create_dither()\n</pre> class TestDither(object):     \"\"\"     Contains the unit tests for the `UniformSpider` class.     \"\"\"      def test_constructor(self, create_dither: callable) -&gt; None:          with pytest.raises(DimensionError):             dither = create_dither(np.array([1., 1., 1.]))                  dither = create_dither()"},{"location":"tests/test_optics/","title":"Test optics","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class TestCreateWavefront(object):\n\"\"\"\n    Tests the CreateWavefront class.\n    \"\"\"\n\n\n    def test_constructor(self, create_create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_create_wavefront(diameter=np.array([]))\n\n        # Test wrong string input\n        with pytest.raises(AssertionError):\n            create_create_wavefront(wavefront_type='cartesian')\n\n        # Test functioning\n        create_create_wavefront()\n\n\n    def test_call(self, create_create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        params = {'wavelength': np.array(1e-6), 'offset': np.zeros(2)}\n        create_create_wavefront()(None, params)\n</pre> class TestCreateWavefront(object):     \"\"\"     Tests the CreateWavefront class.     \"\"\"       def test_constructor(self, create_create_wavefront: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_create_wavefront(diameter=np.array([]))          # Test wrong string input         with pytest.raises(AssertionError):             create_create_wavefront(wavefront_type='cartesian')          # Test functioning         create_create_wavefront()       def test_call(self, create_create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         params = {'wavelength': np.array(1e-6), 'offset': np.zeros(2)}         create_create_wavefront()(None, params) In\u00a0[\u00a0]: Copied! <pre>class TestTiltWavefront(object):\n\"\"\"\n    Tests the TiltWavefront class.\n    \"\"\"\n\n\n    def test_constructor(self, create_tilt_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_tilt_wavefront(tilt_angles=np.ones(1))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_tilt_wavefront(tilt_angles=np.array([]))\n\n        # Test functioning\n        create_tilt_wavefront()\n\n\n    def test_call(self, \n            create_tilt_wavefront: callable,\n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        create_tilt_wavefront()(wf)\n</pre> class TestTiltWavefront(object):     \"\"\"     Tests the TiltWavefront class.     \"\"\"       def test_constructor(self, create_tilt_wavefront: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_tilt_wavefront(tilt_angles=np.ones(1))          # Test wrong dims         with pytest.raises(AssertionError):             create_tilt_wavefront(tilt_angles=np.array([]))          # Test functioning         create_tilt_wavefront()       def test_call(self,              create_tilt_wavefront: callable,             create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          create_tilt_wavefront()(wf) In\u00a0[\u00a0]: Copied! <pre>class TestNormaliseWavefront(object):\n\"\"\"\n    Tests the NormaliseWavefront class.\n    \"\"\"\n\n\n    def test_constructor(self, create_normalise_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test functioning\n        create_normalise_wavefront()\n\n\n    def test_call(self, \n            create_normalise_wavefront: callable,\n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        wf = create_normalise_wavefront()(wf)\n        assert wf.psf.sum() == 1.\n</pre> class TestNormaliseWavefront(object):     \"\"\"     Tests the NormaliseWavefront class.     \"\"\"       def test_constructor(self, create_normalise_wavefront: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test functioning         create_normalise_wavefront()       def test_call(self,              create_normalise_wavefront: callable,             create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          wf = create_normalise_wavefront()(wf)         assert wf.psf.sum() == 1. In\u00a0[\u00a0]: Copied! <pre>class TestApplyBasisOPD(object):\n\"\"\"\n    Tests the ApplyBasisOPD class.\n    \"\"\"\n\n\n    def test_constructor(self, create_apply_basis_opd: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_apply_basis_opd(basis=np.ones((16, 16)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_apply_basis_opd(basis=np.ones((1, 1, 16, 16)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_apply_basis_opd(coefficients=np.array([]))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_apply_basis_opd(coefficients=np.zeros((1, 1)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_apply_basis_opd(basis=np.ones((2, 15, 15)),\n                                   coefficients=np.zeros((3)))\n\n        # Test functioning\n        create_apply_basis_opd()\n\n\n    def test_call(self, \n            create_apply_basis_opd: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        create_apply_basis_opd()(wf)\n</pre> class TestApplyBasisOPD(object):     \"\"\"     Tests the ApplyBasisOPD class.     \"\"\"       def test_constructor(self, create_apply_basis_opd: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_apply_basis_opd(basis=np.ones((16, 16)))          # Test wrong dims         with pytest.raises(AssertionError):             create_apply_basis_opd(basis=np.ones((1, 1, 16, 16)))          # Test wrong dims         with pytest.raises(AssertionError):             create_apply_basis_opd(coefficients=np.array([]))          # Test wrong dims         with pytest.raises(AssertionError):             create_apply_basis_opd(coefficients=np.zeros((1, 1)))          # Test wrong dims         with pytest.raises(AssertionError):             create_apply_basis_opd(basis=np.ones((2, 15, 15)),                                    coefficients=np.zeros((3)))          # Test functioning         create_apply_basis_opd()       def test_call(self,              create_apply_basis_opd: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          create_apply_basis_opd()(wf) In\u00a0[\u00a0]: Copied! <pre>class TestAddPhase(object):\n\"\"\"\n    Tests the AddPhase class.\n    \"\"\"\n\n\n    def test_constructor(self, create_add_phase: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_add_phase(phase=np.ones(1))\n\n        # Test functioning\n        create_add_phase()\n\n\n    def test_call(self, \n            create_add_phase: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        npix = wf.npixels\n\n        # Test 0d\n        create_add_phase(phase=np.array(1.))(wf)\n\n        # Test 2d\n        create_add_phase(phase=np.ones((npix, npix)))(wf)\n\n        # Test 3d\n        create_add_phase(phase=np.ones((1, npix, npix)))(wf)\n</pre> class TestAddPhase(object):     \"\"\"     Tests the AddPhase class.     \"\"\"       def test_constructor(self, create_add_phase: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_add_phase(phase=np.ones(1))          # Test functioning         create_add_phase()       def test_call(self,              create_add_phase: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          npix = wf.npixels          # Test 0d         create_add_phase(phase=np.array(1.))(wf)          # Test 2d         create_add_phase(phase=np.ones((npix, npix)))(wf)          # Test 3d         create_add_phase(phase=np.ones((1, npix, npix)))(wf) In\u00a0[\u00a0]: Copied! <pre>class TestAddOPD(object):\n\"\"\"\n    Tests the AddOPD class.\n    \"\"\"\n\n\n    def test_constructor(self, create_add_opd: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_add_opd(opd=np.ones(1))\n\n        # Test functioning\n        create_add_opd()\n\n\n    def test_call(self, \n            create_add_opd: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        npix = wf.npixels\n\n        # Test 0d\n        create_add_opd(opd=np.array(1.))(wf)\n\n        # Test 2d\n        create_add_opd(opd=np.ones((npix, npix)))(wf)\n\n        # Test 3d\n        create_add_opd(opd=np.ones((1, npix, npix)))(wf)\n</pre> class TestAddOPD(object):     \"\"\"     Tests the AddOPD class.     \"\"\"       def test_constructor(self, create_add_opd: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_add_opd(opd=np.ones(1))          # Test functioning         create_add_opd()       def test_call(self,              create_add_opd: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          npix = wf.npixels          # Test 0d         create_add_opd(opd=np.array(1.))(wf)          # Test 2d         create_add_opd(opd=np.ones((npix, npix)))(wf)          # Test 3d         create_add_opd(opd=np.ones((1, npix, npix)))(wf) In\u00a0[\u00a0]: Copied! <pre>class TestTransmissiveOptic(object):\n\"\"\"\n    Tests the TransmissiveOptic class.\n    \"\"\"\n\n\n    def test_constructor(self, create_transmissive_optic: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_transmissive_optic(trans=np.ones(1))\n\n        # Test functioning\n        create_transmissive_optic()\n\n\n    def test_call(self, \n            create_transmissive_optic: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront() \n        npix = wf.npixels\n\n        # Test 0d\n        create_transmissive_optic(trans=np.array(1.))(wf)\n\n        # Test 2d\n        create_transmissive_optic(trans=np.ones((npix, npix)))(wf)\n\n        # Test 3d\n        create_transmissive_optic(trans=np.ones((1, npix, npix)))(wf)\n</pre> class TestTransmissiveOptic(object):     \"\"\"     Tests the TransmissiveOptic class.     \"\"\"       def test_constructor(self, create_transmissive_optic: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_transmissive_optic(trans=np.ones(1))          # Test functioning         create_transmissive_optic()       def test_call(self,              create_transmissive_optic: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront()          npix = wf.npixels          # Test 0d         create_transmissive_optic(trans=np.array(1.))(wf)          # Test 2d         create_transmissive_optic(trans=np.ones((npix, npix)))(wf)          # Test 3d         create_transmissive_optic(trans=np.ones((1, npix, npix)))(wf) In\u00a0[\u00a0]: Copied! <pre>class TestApplyBasisCLIMB(object):\n\"\"\"\n    Tests the ApplyBasisCLIMB class.\n    \"\"\"\n\n\n    def test_constructor(self, create_basis_climb: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(basis=np.ones((16, 16)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(basis=np.ones((1, 1, 16, 16)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(ideal_wavelength=np.ones(1))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(coefficients=np.array([]))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(coefficients=np.zeros((1, 1)))\n\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_basis_climb(basis=np.ones((2, 15, 15)),\n                                   coefficients=np.zeros((3)))\n\n        # Test functioning\n        create_basis_climb()\n\n\n    def test_call(self, \n            create_basis_climb: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        wf = create_wavefront(amplitude = np.ones((1, 256, 256)),\n                            phase = np.zeros((1, 256, 256))) \n        npix = wf.npixels\n        basis = np.ones((3, 3*npix, 3*npix))\n        create_basis_climb(basis=basis)(wf)\n</pre> class TestApplyBasisCLIMB(object):     \"\"\"     Tests the ApplyBasisCLIMB class.     \"\"\"       def test_constructor(self, create_basis_climb: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(basis=np.ones((16, 16)))          # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(basis=np.ones((1, 1, 16, 16)))          # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(ideal_wavelength=np.ones(1))          # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(coefficients=np.array([]))          # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(coefficients=np.zeros((1, 1)))          # Test wrong dims         with pytest.raises(AssertionError):             create_basis_climb(basis=np.ones((2, 15, 15)),                                    coefficients=np.zeros((3)))          # Test functioning         create_basis_climb()       def test_call(self,              create_basis_climb: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         wf = create_wavefront(amplitude = np.ones((1, 256, 256)),                             phase = np.zeros((1, 256, 256)))          npix = wf.npixels         basis = np.ones((3, 3*npix, 3*npix))         create_basis_climb(basis=basis)(wf) In\u00a0[\u00a0]: Copied! <pre>class TestRotate(object):\n\"\"\"\n    Tests the Rotate class.\n    \"\"\"\n\n\n    def test_constructor(self, create_rotate: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test wrong dims\n        with pytest.raises(AssertionError):\n            create_rotate(angle=np.ones(1))\n\n        # Test functioning\n        create_rotate()\n\n\n    def test_call(self, \n            create_rotate: callable, \n            create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the __call__ method.\n        \"\"\"\n        # Test regular rotation\n        wf = create_wavefront()\n        create_rotate()(wf)\n\n        # Test real imaginary rotation\n        wf = create_wavefront()\n        create_rotate(real_imaginary=True)(wf)\n\n        # Test fourier\n        with pytest.raises(NotImplementedError):\n            wf = create_wavefront()\n            create_rotate(fourier=True)(wf)\n</pre> class TestRotate(object):     \"\"\"     Tests the Rotate class.     \"\"\"       def test_constructor(self, create_rotate: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test wrong dims         with pytest.raises(AssertionError):             create_rotate(angle=np.ones(1))          # Test functioning         create_rotate()       def test_call(self,              create_rotate: callable,              create_wavefront: callable) -&gt; None:         \"\"\"         Tests the __call__ method.         \"\"\"         # Test regular rotation         wf = create_wavefront()         create_rotate()(wf)          # Test real imaginary rotation         wf = create_wavefront()         create_rotate(real_imaginary=True)(wf)          # Test fourier         with pytest.raises(NotImplementedError):             wf = create_wavefront()             create_rotate(fourier=True)(wf)"},{"location":"tests/test_propagators/","title":"Test propagators","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestCartesianMFT():\n\"\"\"\n    Test the CartesianMFT class.\n    \"\"\"\n\n\n    def test_constructor(self, create_cartesian_mft : callable):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_cartesian_mft()\n\n\n    def test_propagate(self, create_cartesian_mft : callable):\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        wl, npix, f_pscale, fl = 1e-6, 32, 1e-6, 5.\n        p_pscale = 1/npix\n        amplitude = np.ones((1, npix, npix))\n        phase = np.zeros((1, npix, npix))\n        plane_type = dLux.PlaneType.Pupil\n\n        # Construct\n        wf = dLux.CartesianWavefront(wl, p_pscale, amplitude, phase, plane_type)\n        prop = create_cartesian_mft(npix, f_pscale, fl)\n        inv_prop = create_cartesian_mft(npix, p_pscale, fl, inverse=True)\n\n        # Prop\n        focal = prop(wf)\n        pupil = inv_prop(focal)\n\n        # Test\n        assert not np.isnan(focal.psf).any()\n        assert not np.isnan(pupil.psf).any()\n\n        # Shift tests\n        shift_pix = np.ones(2)\n        shift = f_pscale * np.ones(2)\n\n        # Construct\n        prop_shift = create_cartesian_mft(npix, f_pscale, fl, shift=shift)\n        prop_shift_pix = create_cartesian_mft(npix, f_pscale, fl, \n                                            shift=shift_pix, pixel_shift=True)\n\n        # Prop\n        focal_shift = prop_shift(wf)\n        focal_shift_pix = prop_shift_pix(wf)\n        focal_roll = np.roll(focal.psf, (1, 1), (0, 1))[1:, 1:]\n\n        # Test\n        assert np.allclose(focal_roll, focal_shift.psf[1:, 1:])\n        assert np.allclose(focal_roll, focal_shift_pix.psf[1:, 1:])\n</pre> class TestCartesianMFT():     \"\"\"     Test the CartesianMFT class.     \"\"\"       def test_constructor(self, create_cartesian_mft : callable):         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_cartesian_mft()       def test_propagate(self, create_cartesian_mft : callable):         \"\"\"         Tests the propagate method.         \"\"\"         wl, npix, f_pscale, fl = 1e-6, 32, 1e-6, 5.         p_pscale = 1/npix         amplitude = np.ones((1, npix, npix))         phase = np.zeros((1, npix, npix))         plane_type = dLux.PlaneType.Pupil          # Construct         wf = dLux.CartesianWavefront(wl, p_pscale, amplitude, phase, plane_type)         prop = create_cartesian_mft(npix, f_pscale, fl)         inv_prop = create_cartesian_mft(npix, p_pscale, fl, inverse=True)          # Prop         focal = prop(wf)         pupil = inv_prop(focal)          # Test         assert not np.isnan(focal.psf).any()         assert not np.isnan(pupil.psf).any()          # Shift tests         shift_pix = np.ones(2)         shift = f_pscale * np.ones(2)          # Construct         prop_shift = create_cartesian_mft(npix, f_pscale, fl, shift=shift)         prop_shift_pix = create_cartesian_mft(npix, f_pscale, fl,                                              shift=shift_pix, pixel_shift=True)          # Prop         focal_shift = prop_shift(wf)         focal_shift_pix = prop_shift_pix(wf)         focal_roll = np.roll(focal.psf, (1, 1), (0, 1))[1:, 1:]          # Test         assert np.allclose(focal_roll, focal_shift.psf[1:, 1:])         assert np.allclose(focal_roll, focal_shift_pix.psf[1:, 1:]) In\u00a0[\u00a0]: Copied! <pre>class TestAngularMFT():\n\"\"\"\n    Test the AngularMFT class.\n    \"\"\"\n\n    def test_constructor(self, create_angular_mft : callable):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_angular_mft()\n\n\n    def test_propagate(self, create_angular_mft : callable):\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        wl, npix, f_pscale = 1e-6, 32, 2e-7\n        p_pscale = 1/npix\n        amplitude = np.ones((1, npix, npix))\n        phase = np.zeros((1, npix, npix))\n        plane_type = dLux.PlaneType.Pupil\n\n        # Construct\n        wf = dLux.AngularWavefront(wl, p_pscale, amplitude, phase, plane_type)\n        prop = create_angular_mft(npix, f_pscale)\n        inv_prop = create_angular_mft(npix, p_pscale, inverse=True)\n\n        # Prop\n        focal = prop(wf)\n        pupil = inv_prop(focal)\n\n        # Test\n        assert not np.isnan(focal.psf).any()\n        assert not np.isnan(pupil.psf).any()\n\n        # Shift tests\n        shift_pix = np.ones(2)\n        shift = f_pscale * np.ones(2)\n\n        # Construct\n        prop_shift = create_angular_mft(npix, f_pscale, shift=shift)\n        prop_shift_pix = create_angular_mft(npix, f_pscale, \n                                            shift=shift_pix, pixel_shift=True)\n\n        # Prop\n        focal_shift = prop_shift(wf)\n        focal_shift_pix = prop_shift_pix(wf)\n        focal_roll = np.roll(focal.psf, (1, 1), (0, 1))[1:, 1:]\n\n        # Test\n        assert np.allclose(focal_roll, focal_shift.psf[1:, 1:])\n        assert np.allclose(focal_roll, focal_shift_pix.psf[1:, 1:])\n</pre> class TestAngularMFT():     \"\"\"     Test the AngularMFT class.     \"\"\"      def test_constructor(self, create_angular_mft : callable):         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_angular_mft()       def test_propagate(self, create_angular_mft : callable):         \"\"\"         Tests the propagate method.         \"\"\"         wl, npix, f_pscale = 1e-6, 32, 2e-7         p_pscale = 1/npix         amplitude = np.ones((1, npix, npix))         phase = np.zeros((1, npix, npix))         plane_type = dLux.PlaneType.Pupil          # Construct         wf = dLux.AngularWavefront(wl, p_pscale, amplitude, phase, plane_type)         prop = create_angular_mft(npix, f_pscale)         inv_prop = create_angular_mft(npix, p_pscale, inverse=True)          # Prop         focal = prop(wf)         pupil = inv_prop(focal)          # Test         assert not np.isnan(focal.psf).any()         assert not np.isnan(pupil.psf).any()          # Shift tests         shift_pix = np.ones(2)         shift = f_pscale * np.ones(2)          # Construct         prop_shift = create_angular_mft(npix, f_pscale, shift=shift)         prop_shift_pix = create_angular_mft(npix, f_pscale,                                              shift=shift_pix, pixel_shift=True)          # Prop         focal_shift = prop_shift(wf)         focal_shift_pix = prop_shift_pix(wf)         focal_roll = np.roll(focal.psf, (1, 1), (0, 1))[1:, 1:]          # Test         assert np.allclose(focal_roll, focal_shift.psf[1:, 1:])         assert np.allclose(focal_roll, focal_shift_pix.psf[1:, 1:]) In\u00a0[\u00a0]: Copied! <pre>class TestCartesianFFT():\n\"\"\"\n    Test the CartesianFFT class.\n    \"\"\"\n\n\n    def test_constructor(self, create_cartesian_fft : callable):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_cartesian_fft()\n\n\n    def test_propagate(self, create_cartesian_fft : callable):\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        wl, npix, fl = 1e-6, 32, 5.\n        p_pscale = 1/npix\n        amplitude = np.ones((1, npix, npix))\n        phase = np.zeros((1, npix, npix))\n        plane_type = dLux.PlaneType.Pupil\n\n        # Construct\n        wf = dLux.CartesianWavefront(wl, p_pscale, amplitude, phase, plane_type)\n        prop = create_cartesian_fft(fl)\n        inv_prop = create_cartesian_fft(fl, inverse=True)\n\n        # Prop\n        focal = prop(wf.pad_to(npix * 5))\n        pupil = inv_prop(focal).crop_to(npix)\n\n        # Test\n        assert not np.isnan(focal.psf).any()\n        assert not np.isnan(pupil.psf).any()\n</pre> class TestCartesianFFT():     \"\"\"     Test the CartesianFFT class.     \"\"\"       def test_constructor(self, create_cartesian_fft : callable):         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_cartesian_fft()       def test_propagate(self, create_cartesian_fft : callable):         \"\"\"         Tests the propagate method.         \"\"\"         wl, npix, fl = 1e-6, 32, 5.         p_pscale = 1/npix         amplitude = np.ones((1, npix, npix))         phase = np.zeros((1, npix, npix))         plane_type = dLux.PlaneType.Pupil          # Construct         wf = dLux.CartesianWavefront(wl, p_pscale, amplitude, phase, plane_type)         prop = create_cartesian_fft(fl)         inv_prop = create_cartesian_fft(fl, inverse=True)          # Prop         focal = prop(wf.pad_to(npix * 5))         pupil = inv_prop(focal).crop_to(npix)          # Test         assert not np.isnan(focal.psf).any()         assert not np.isnan(pupil.psf).any() In\u00a0[\u00a0]: Copied! <pre>class TestAngularFFT():\n\"\"\"\n    Test the AngularFFT class.\n    \"\"\"\n\n\n    def test_constructor(self, create_angular_fft : callable):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_angular_fft()\n\n\n    def test_propagate(self, create_angular_fft : callable):\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        wl, npix = 1e-6, 32\n        p_pscale = 1/npix\n        amplitude = np.ones((1, npix, npix))\n        phase = np.zeros((1, npix, npix))\n        plane_type = dLux.PlaneType.Pupil\n\n        # Construct\n        wf = dLux.AngularWavefront(wl, p_pscale, amplitude, phase, plane_type)\n        prop = create_angular_fft()\n        inv_prop = create_angular_fft(inverse=True)\n\n        # Prop\n        focal = prop(wf.pad_to(npix * 5))\n        pupil = inv_prop(focal).crop_to(npix)\n\n        # Test\n        assert not np.isnan(focal.psf).any()\n        assert not np.isnan(pupil.psf).any()\n</pre> class TestAngularFFT():     \"\"\"     Test the AngularFFT class.     \"\"\"       def test_constructor(self, create_angular_fft : callable):         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_angular_fft()       def test_propagate(self, create_angular_fft : callable):         \"\"\"         Tests the propagate method.         \"\"\"         wl, npix = 1e-6, 32         p_pscale = 1/npix         amplitude = np.ones((1, npix, npix))         phase = np.zeros((1, npix, npix))         plane_type = dLux.PlaneType.Pupil          # Construct         wf = dLux.AngularWavefront(wl, p_pscale, amplitude, phase, plane_type)         prop = create_angular_fft()         inv_prop = create_angular_fft(inverse=True)          # Prop         focal = prop(wf.pad_to(npix * 5))         pupil = inv_prop(focal).crop_to(npix)          # Test         assert not np.isnan(focal.psf).any()         assert not np.isnan(pupil.psf).any() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class TestCartesianFresnel():\n\"\"\"\n    Test the CartesianFresnel class.\n    \"\"\"\n\n\n    def test_constructor(self, create_cartesian_fresnel : callable):\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_cartesian_fresnel()\n\n\n    def test_propagate(self, create_cartesian_fresnel : callable):\n\"\"\"\n        Tests the propagate method.\n        \"\"\"\n        wl, npix, f_pscale, fl = 1e-6, 32, 2e-7, 5.\n        p_pscale = 1/npix\n        amplitude = np.ones((1, npix, npix))\n        phase = np.zeros((1, npix, npix))\n        plane_type = dLux.PlaneType.Pupil\n\n        # Construct\n        wf = dLux.FarFieldFresnelWavefront(wl, p_pscale, amplitude, phase, \n                                         plane_type)\n        fresnel_prop = create_cartesian_fresnel(npix, f_pscale, fl, 5e-5)\n        focal_prop = dLux.CartesianFresnel(npix, f_pscale, fl, 0.)\n        inv_prop = create_cartesian_fresnel(npix, p_pscale, fl, 1e0, inverse=True)\n\n        # Prop\n        fresnel = fresnel_prop(wf)\n        focal = focal_prop(wf)\n        pupil = inv_prop(focal)\n\n        # Test\n        assert not np.isnan(fresnel.psf).any()\n        assert not np.isnan(focal.psf).any()\n        assert not np.isnan(pupil.psf).any()\n</pre> class TestCartesianFresnel():     \"\"\"     Test the CartesianFresnel class.     \"\"\"       def test_constructor(self, create_cartesian_fresnel : callable):         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_cartesian_fresnel()       def test_propagate(self, create_cartesian_fresnel : callable):         \"\"\"         Tests the propagate method.         \"\"\"         wl, npix, f_pscale, fl = 1e-6, 32, 2e-7, 5.         p_pscale = 1/npix         amplitude = np.ones((1, npix, npix))         phase = np.zeros((1, npix, npix))         plane_type = dLux.PlaneType.Pupil          # Construct         wf = dLux.FarFieldFresnelWavefront(wl, p_pscale, amplitude, phase,                                           plane_type)         fresnel_prop = create_cartesian_fresnel(npix, f_pscale, fl, 5e-5)         focal_prop = dLux.CartesianFresnel(npix, f_pscale, fl, 0.)         inv_prop = create_cartesian_fresnel(npix, p_pscale, fl, 1e0, inverse=True)          # Prop         fresnel = fresnel_prop(wf)         focal = focal_prop(wf)         pupil = inv_prop(focal)          # Test         assert not np.isnan(fresnel.psf).any()         assert not np.isnan(focal.psf).any()         assert not np.isnan(pupil.psf).any()"},{"location":"tests/test_sources/","title":"Test sources","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class TestSource():\n\"\"\"\n    Tests the Source class.\n    \"\"\"\n\n\n    def test_constructor(self, create_source : callable) -&gt; None:\n\"\"\"\n        Test the constructor class.\n        \"\"\"\n        # Position\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_source(position=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_source(position=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_source(position=[])\n\n        # Flux\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_source(flux=\"\")\n\n        # Test 1d dimension input\n        with pytest.raises(AssertionError):\n            create_source(flux=[1.])\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_source(flux=[])\n\n        # Spectrum\n        # Test non-spectrum input\n        with pytest.raises(AssertionError):\n            create_source(spectrum=[])\n\n        # Name\n        # Test non-string input\n        with pytest.raises(AssertionError):\n            create_source(name=[])\n\n\n    # Getters\n    def test_get_position(self, create_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_position method.\n        \"\"\"\n        source = create_source()\n        assert (source.get_position() == source.position).all()\n\n\n    def test_get_flux(self, create_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_flux method.\n        \"\"\"\n        source = create_source()\n        assert (source.get_flux() == source.flux).all()\n\n\n    def test_get_wavelengths(self, create_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_wavelengths method.\n        \"\"\"\n        source = create_source()\n        assert (source.get_wavelengths() == source.spectrum.wavelengths).all()\n\n\n    def test_get_weights(self, create_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_weights method.\n        \"\"\"\n        source = create_source()\n        assert (source.get_weights() == source.spectrum.weights).all()\n</pre> class TestSource():     \"\"\"     Tests the Source class.     \"\"\"       def test_constructor(self, create_source : callable) -&gt; None:         \"\"\"         Test the constructor class.         \"\"\"         # Position         # Test string inputs         with pytest.raises(ValueError):             create_source(position=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_source(position=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_source(position=[])          # Flux         # Test string inputs         with pytest.raises(ValueError):             create_source(flux=\"\")          # Test 1d dimension input         with pytest.raises(AssertionError):             create_source(flux=[1.])          # Test zero length input         with pytest.raises(AssertionError):             create_source(flux=[])          # Spectrum         # Test non-spectrum input         with pytest.raises(AssertionError):             create_source(spectrum=[])          # Name         # Test non-string input         with pytest.raises(AssertionError):             create_source(name=[])       # Getters     def test_get_position(self, create_source : callable) -&gt; None:         \"\"\"         Tests the get_position method.         \"\"\"         source = create_source()         assert (source.get_position() == source.position).all()       def test_get_flux(self, create_source : callable) -&gt; None:         \"\"\"         Tests the get_flux method.         \"\"\"         source = create_source()         assert (source.get_flux() == source.flux).all()       def test_get_wavelengths(self, create_source : callable) -&gt; None:         \"\"\"         Tests the get_wavelengths method.         \"\"\"         source = create_source()         assert (source.get_wavelengths() == source.spectrum.wavelengths).all()       def test_get_weights(self, create_source : callable) -&gt; None:         \"\"\"         Tests the get_weights method.         \"\"\"         source = create_source()         assert (source.get_weights() == source.spectrum.weights).all() In\u00a0[\u00a0]: Copied! <pre>class TestResolvedSource():\n\"\"\"\n    Tests the ResolvedSourve class.\n    \"\"\"\n    pass\n</pre> class TestResolvedSource():     \"\"\"     Tests the ResolvedSourve class.     \"\"\"     pass In\u00a0[\u00a0]: Copied! <pre>class TestRelativeFluxSource():\n\"\"\"\n    Tests the RelativeFluxSource class.\n    \"\"\"\n\n\n    def test_constructor(self, create_relative_flux_source : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_relative_flux_source(contrast=\"\")\n\n        # Test one dimension input\n        with pytest.raises(AssertionError):\n            create_relative_flux_source(contrast=[5.])\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_relative_flux_source(contrast=[])\n\n\n    def test_get_flux(self, create_relative_flux_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_flux method.\n        \"\"\"\n        source = create_relative_flux_source()\n        flux_out = source.get_flux()\n        assert flux_out.shape == (2,)\n        assert np.allclose(flux_out[0]/flux_out[1], source.contrast)\n</pre> class TestRelativeFluxSource():     \"\"\"     Tests the RelativeFluxSource class.     \"\"\"       def test_constructor(self, create_relative_flux_source : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test string inputs         with pytest.raises(ValueError):             create_relative_flux_source(contrast=\"\")          # Test one dimension input         with pytest.raises(AssertionError):             create_relative_flux_source(contrast=[5.])          # Test zero length input         with pytest.raises(AssertionError):             create_relative_flux_source(contrast=[])       def test_get_flux(self, create_relative_flux_source : callable) -&gt; None:         \"\"\"         Tests the get_flux method.         \"\"\"         source = create_relative_flux_source()         flux_out = source.get_flux()         assert flux_out.shape == (2,)         assert np.allclose(flux_out[0]/flux_out[1], source.contrast) In\u00a0[\u00a0]: Copied! <pre>class TestRelativePositionSource():\n\"\"\"\n    Tests the RelativePositionSource class.\n    \"\"\"\n\n\n    def test_constructor(self, create_relative_position_source : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Separation\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_relative_position_source(separation=\"\")\n\n        # Test one dimension input\n        with pytest.raises(AssertionError):\n            create_relative_position_source(separation=[5.])\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_relative_position_source(separation=[])\n\n        # position_angle\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_relative_position_source(position_angle=\"\")\n\n        # Test one dimension input\n        with pytest.raises(AssertionError):\n            create_relative_position_source(position_angle=[5.])\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_relative_position_source(position_angle=[])\n\n\n    def test_get_position(self, create_relative_position_source : callable) -&gt; None:\n\"\"\"\n        Tests the get_position method.\n        \"\"\"\n        source = create_relative_position_source()\n        position_out = source.get_position()\n        sep_vec = position_out[0] - position_out[1]\n        separation = np.hypot(sep_vec[0], sep_vec[1])\n        position_angle = np.arctan2(sep_vec[0], sep_vec[1])\n        assert position_out.shape == (2,2)\n        assert np.allclose(source.separation, separation).all()\n        assert np.allclose(source.position_angle, position_angle).all()\n</pre> class TestRelativePositionSource():     \"\"\"     Tests the RelativePositionSource class.     \"\"\"       def test_constructor(self, create_relative_position_source : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Separation         # Test string inputs         with pytest.raises(ValueError):             create_relative_position_source(separation=\"\")          # Test one dimension input         with pytest.raises(AssertionError):             create_relative_position_source(separation=[5.])          # Test zero length input         with pytest.raises(AssertionError):             create_relative_position_source(separation=[])          # position_angle         # Test string inputs         with pytest.raises(ValueError):             create_relative_position_source(position_angle=\"\")          # Test one dimension input         with pytest.raises(AssertionError):             create_relative_position_source(position_angle=[5.])          # Test zero length input         with pytest.raises(AssertionError):             create_relative_position_source(position_angle=[])       def test_get_position(self, create_relative_position_source : callable) -&gt; None:         \"\"\"         Tests the get_position method.         \"\"\"         source = create_relative_position_source()         position_out = source.get_position()         sep_vec = position_out[0] - position_out[1]         separation = np.hypot(sep_vec[0], sep_vec[1])         position_angle = np.arctan2(sep_vec[0], sep_vec[1])         assert position_out.shape == (2,2)         assert np.allclose(source.separation, separation).all()         assert np.allclose(source.position_angle, position_angle).all() In\u00a0[\u00a0]: Copied! <pre>class TestPointSource():\n\"\"\"\n    Tests the PointSource class.\n    \"\"\"\n\n\n    def test_model(self, create_point_source : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        # TODO: this has no asserts?\n        source = create_point_source()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestPointSource():     \"\"\"     Tests the PointSource class.     \"\"\"       def test_model(self, create_point_source : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         # TODO: this has no asserts?         source = create_point_source()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in) In\u00a0[\u00a0]: Copied! <pre>class TestMultiPointSource():\n\"\"\"\n    Tests the MultiPointSource class.\n    \"\"\"\n\n\n    def test_constructor(self, create_multi_point_source : callable) -&gt; None:\n\"\"\"\n        Test the constructor class.\n        \"\"\"\n        # Position\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_multi_point_source(position=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(position=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(position=[])\n\n        # Test 1 dim input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(position=np.ones(2))\n\n        # Flux\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_multi_point_source(flux=\"\")\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(flux=[])\n\n        # Test 2 dim input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(flux=np.ones((2, 2)))\n\n        # Spectrum\n        # Test non-spectrum input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(spectrum=[])\n\n        # Name\n        # Test non-string input\n        with pytest.raises(AssertionError):\n            create_multi_point_source(name=[])\n\n\n    def test_model(self, create_multi_point_source : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        source = create_multi_point_source()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestMultiPointSource():     \"\"\"     Tests the MultiPointSource class.     \"\"\"       def test_constructor(self, create_multi_point_source : callable) -&gt; None:         \"\"\"         Test the constructor class.         \"\"\"         # Position         # Test string inputs         with pytest.raises(ValueError):             create_multi_point_source(position=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_multi_point_source(position=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_multi_point_source(position=[])          # Test 1 dim input         with pytest.raises(AssertionError):             create_multi_point_source(position=np.ones(2))          # Flux         # Test string inputs         with pytest.raises(ValueError):             create_multi_point_source(flux=\"\")          # Test zero length input         with pytest.raises(AssertionError):             create_multi_point_source(flux=[])          # Test 2 dim input         with pytest.raises(AssertionError):             create_multi_point_source(flux=np.ones((2, 2)))          # Spectrum         # Test non-spectrum input         with pytest.raises(AssertionError):             create_multi_point_source(spectrum=[])          # Name         # Test non-string input         with pytest.raises(AssertionError):             create_multi_point_source(name=[])       def test_model(self, create_multi_point_source : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         source = create_multi_point_source()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in) In\u00a0[\u00a0]: Copied! <pre>class TestArrayDistribution():\n\"\"\"\n    Tests the ArrayDistribution class.\n    \"\"\"\n\n\n    def test_constructor(self, create_array_distribution : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_array_distribution(distribution=\"\")\n\n        # Test one dimension input\n        with pytest.raises(AssertionError):\n            create_array_distribution(distribution=[5.])\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_array_distribution(distribution=[])\n\n\n    def test_get_distribution(self, create_array_distribution : callable) -&gt; None:\n\"\"\"\n        Tests the get_distribution method.\n        \"\"\"\n        source = create_array_distribution()\n        assert (source.get_distribution() == source.distribution).all()\n\n\n    def test_normalise(self, create_array_distribution : callable) -&gt; None:\n\"\"\"\n        Tests the normalise method.\n        \"\"\"\n        source = create_array_distribution()\n        new_distribution = np.ones((4, 4))\n        new_source = source.set('distribution', new_distribution).normalise()\n        assert np.allclose(new_source.distribution.sum(), 1.)\n\n\n    def test_model(self, create_array_distribution : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        source = create_array_distribution()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestArrayDistribution():     \"\"\"     Tests the ArrayDistribution class.     \"\"\"       def test_constructor(self, create_array_distribution : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test string inputs         with pytest.raises(ValueError):             create_array_distribution(distribution=\"\")          # Test one dimension input         with pytest.raises(AssertionError):             create_array_distribution(distribution=[5.])          # Test zero length input         with pytest.raises(AssertionError):             create_array_distribution(distribution=[])       def test_get_distribution(self, create_array_distribution : callable) -&gt; None:         \"\"\"         Tests the get_distribution method.         \"\"\"         source = create_array_distribution()         assert (source.get_distribution() == source.distribution).all()       def test_normalise(self, create_array_distribution : callable) -&gt; None:         \"\"\"         Tests the normalise method.         \"\"\"         source = create_array_distribution()         new_distribution = np.ones((4, 4))         new_source = source.set('distribution', new_distribution).normalise()         assert np.allclose(new_source.distribution.sum(), 1.)       def test_model(self, create_array_distribution : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         source = create_array_distribution()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in) In\u00a0[\u00a0]: Copied! <pre>class TestBinarySource():\n\"\"\"\n    Tests the BinarySource class.\n    \"\"\"\n\n\n    def test_model(self, create_binary_source : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        # TODO add tests\n        source = create_binary_source()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestBinarySource():     \"\"\"     Tests the BinarySource class.     \"\"\"       def test_model(self, create_binary_source : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         # TODO add tests         source = create_binary_source()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in) In\u00a0[\u00a0]: Copied! <pre>class TestPointExtendedSource():\n\"\"\"\n    Tests the PointExtendedSource class.\n    \"\"\"\n\n    def test_model(self, create_point_extended_source : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        source = create_point_extended_source()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestPointExtendedSource():     \"\"\"     Tests the PointExtendedSource class.     \"\"\"      def test_model(self, create_point_extended_source : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         source = create_point_extended_source()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class TestPointAndExtendedSource():\n\"\"\"\n    Tests the PointAndExtendedSource class.\n    \"\"\"\n\n\n    def test_constructor(self, create_point_and_extended_source : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test non Combined Spectrum input\n        with pytest.raises(AssertionError):\n            spec = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, 600e-9, 10))\n            create_point_and_extended_source(spectrum=spec)\n\n\n    def test_model(self, create_point_and_extended_source : callable) -&gt; None:\n\"\"\"\n        Tests the model method.\n        \"\"\"\n        source = create_point_and_extended_source()\n        optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])\n        detector = dLux.core.Detector([dLux.AddConstant(0.)])\n        # filter_in = dLux.Filter()\n        source.model(optics)\n        source.model(optics, detector)\n        # source.model(optics, detector, filter_in)\n        # source.model(optics, filter_in=filter_in)\n</pre> class TestPointAndExtendedSource():     \"\"\"     Tests the PointAndExtendedSource class.     \"\"\"       def test_constructor(self, create_point_and_extended_source : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test non Combined Spectrum input         with pytest.raises(AssertionError):             spec = dLux.spectrums.ArraySpectrum(np.linspace(500e-9, 600e-9, 10))             create_point_and_extended_source(spectrum=spec)       def test_model(self, create_point_and_extended_source : callable) -&gt; None:         \"\"\"         Tests the model method.         \"\"\"         source = create_point_and_extended_source()         optics = dLux.core.Optics([dLux.CreateWavefront(16, 1)])         detector = dLux.core.Detector([dLux.AddConstant(0.)])         # filter_in = dLux.Filter()         source.model(optics)         source.model(optics, detector)         # source.model(optics, detector, filter_in)         # source.model(optics, filter_in=filter_in)"},{"location":"tests/test_spectrums/","title":"Test spectrums","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\nimport jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> from __future__ import annotations import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>class TestArraySpectrum():\n\"\"\"\n    Tests the ArraySpectrum class.\n    \"\"\"\n\n    def test_constructor(self, create_array_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_array_spectrum(weights=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_array_spectrum(weights=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_array_spectrum(weights=[])\n\n\n    def test_get_weights(self, create_array_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the get_weights method.\n        \"\"\"\n        spectrum = create_array_spectrum()\n        assert (spectrum.get_weights() == spectrum.weights).all()\n\n\n    def test_normalise(self, create_array_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the normalise method.\n        \"\"\"\n        new_weights = np.arange(10)\n        new_spectrum = create_array_spectrum().set('weights',\n                                                    new_weights).normalise()\n        assert np.allclose(new_spectrum.weights.sum(), 1.)\n</pre> class TestArraySpectrum():     \"\"\"     Tests the ArraySpectrum class.     \"\"\"      def test_constructor(self, create_array_spectrum : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test string inputs         with pytest.raises(ValueError):             create_array_spectrum(weights=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_array_spectrum(weights=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_array_spectrum(weights=[])       def test_get_weights(self, create_array_spectrum : callable) -&gt; None:         \"\"\"         Tests the get_weights method.         \"\"\"         spectrum = create_array_spectrum()         assert (spectrum.get_weights() == spectrum.weights).all()       def test_normalise(self, create_array_spectrum : callable) -&gt; None:         \"\"\"         Tests the normalise method.         \"\"\"         new_weights = np.arange(10)         new_spectrum = create_array_spectrum().set('weights',                                                     new_weights).normalise()         assert np.allclose(new_spectrum.weights.sum(), 1.) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>class TestPolynomialSpectrum():\n\"\"\"\n    Tests the PolynomialSpectrum class.\n\n    Note this does not test the .normalise() method becuase it does not\n    normalise the coefficients, instead the .get_weights() returns a normalised\n    weights.\n    \"\"\"\n\n\n    def test_constructor(self, create_polynomial_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_polynomial_spectrum(coefficients=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_polynomial_spectrum(coefficients=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_polynomial_spectrum(coefficients=[])\n\n        # Test nan inputs\n        with pytest.raises(AssertionError):\n            create_polynomial_spectrum(coefficients=[np.nan])\n\n        # Test infinite inputs\n        with pytest.raises(AssertionError):\n            create_polynomial_spectrum(coefficients=[np.inf])\n\n        create_polynomial_spectrum()\n\n    def test_get_weights(self, create_polynomial_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the normalisation of the get_weights method.\n        \"\"\"\n        assert np.allclose(create_polynomial_spectrum().get_weights().sum(), 1.)\n</pre> class TestPolynomialSpectrum():     \"\"\"     Tests the PolynomialSpectrum class.      Note this does not test the .normalise() method becuase it does not     normalise the coefficients, instead the .get_weights() returns a normalised     weights.     \"\"\"       def test_constructor(self, create_polynomial_spectrum : callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test string inputs         with pytest.raises(ValueError):             create_polynomial_spectrum(coefficients=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_polynomial_spectrum(coefficients=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_polynomial_spectrum(coefficients=[])          # Test nan inputs         with pytest.raises(AssertionError):             create_polynomial_spectrum(coefficients=[np.nan])          # Test infinite inputs         with pytest.raises(AssertionError):             create_polynomial_spectrum(coefficients=[np.inf])          create_polynomial_spectrum()      def test_get_weights(self, create_polynomial_spectrum : callable) -&gt; None:         \"\"\"         Tests the normalisation of the get_weights method.         \"\"\"         assert np.allclose(create_polynomial_spectrum().get_weights().sum(), 1.) In\u00a0[\u00a0]: Copied! <pre>class TestCombinedSpectrum():\n\"\"\"\n    Tests the CombinedSpectrum class\n    \"\"\"\n\n\n    def test_constructor(self, create_combined_spectrum : callable) -&gt; None:\n\"\"\"\n        Test the constructor.\n        \"\"\"\n        # Wavelengths Testing\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_combined_spectrum(wavelengths=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_combined_spectrum(wavelengths=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_combined_spectrum(wavelengths=[])\n\n        # Weights Testing\n        # Test string inputs\n        with pytest.raises(ValueError):\n            create_combined_spectrum(weights=\"\")\n\n        # Test zero dimension input\n        with pytest.raises(AssertionError):\n            create_combined_spectrum(weights=5.)\n\n        # Test zero length input\n        with pytest.raises(AssertionError):\n            create_combined_spectrum(weights=[])\n\n\n    def test_normalise(self, create_combined_spectrum : callable) -&gt; None:\n\"\"\"\n        Tests the normalise method.\n        \"\"\"\n        new_weights = np.tile(np.arange(10), (2, 1))\n        new_spectrum = create_combined_spectrum().set('weights',\n                                                    new_weights).normalise()\n        assert np.allclose(new_spectrum.weights.sum(1), 1.)\n</pre> class TestCombinedSpectrum():     \"\"\"     Tests the CombinedSpectrum class     \"\"\"       def test_constructor(self, create_combined_spectrum : callable) -&gt; None:         \"\"\"         Test the constructor.         \"\"\"         # Wavelengths Testing         # Test string inputs         with pytest.raises(ValueError):             create_combined_spectrum(wavelengths=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_combined_spectrum(wavelengths=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_combined_spectrum(wavelengths=[])          # Weights Testing         # Test string inputs         with pytest.raises(ValueError):             create_combined_spectrum(weights=\"\")          # Test zero dimension input         with pytest.raises(AssertionError):             create_combined_spectrum(weights=5.)          # Test zero length input         with pytest.raises(AssertionError):             create_combined_spectrum(weights=[])       def test_normalise(self, create_combined_spectrum : callable) -&gt; None:         \"\"\"         Tests the normalise method.         \"\"\"         new_weights = np.tile(np.arange(10), (2, 1))         new_spectrum = create_combined_spectrum().set('weights',                                                     new_weights).normalise()         assert np.allclose(new_spectrum.weights.sum(1), 1.)"},{"location":"tests/test_wavefronts/","title":"Test wavefronts","text":"In\u00a0[\u00a0]: Copied! <pre>import jax.numpy as np\nimport pytest\nimport dLux\nfrom jax import config\nconfig.update(\"jax_debug_nans\", True)\n</pre> import jax.numpy as np import pytest import dLux from jax import config config.update(\"jax_debug_nans\", True) In\u00a0[\u00a0]: Copied! <pre>Array = np.ndarray\n</pre> Array = np.ndarray In\u00a0[\u00a0]: Copied! <pre>class TestWavefront(object):\n\"\"\"\n    Test the Wavefront class.\n    \"\"\"\n\n\n    def test_constructor(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the constructor.\n        \"\"\"\n        # Test constructor\n        create_wavefront()\n\n        # Test empty array\n        with pytest.raises(AssertionError):\n            create_wavefront(wavelength=[])\n\n        # Test 1d array\n        with pytest.raises(AssertionError):\n            create_wavefront(wavelength=[1e3, 1e4])\n\n        # Test empty array\n        with pytest.raises(AssertionError):\n            create_wavefront(pixel_scale=[])\n\n        # Test 1d array\n        with pytest.raises(AssertionError):\n            create_wavefront(pixel_scale=[1e3, 1e4])\n\n        # Test non 3d amplitude array\n        with pytest.raises(AssertionError):\n            create_wavefront(amplitude=np.ones((3, 3)))\n\n        # Test non 3d amplitude array\n        with pytest.raises(AssertionError):\n            create_wavefront(amplitude=np.ones((3, 3, 3, 3)))\n\n        # Test non 3d phase array\n        with pytest.raises(AssertionError):\n            create_wavefront(phase=np.ones((3, 3)))\n\n        # Test non 3d phase array\n        with pytest.raises(AssertionError):\n            create_wavefront(phase=np.ones((3, 3, 3, 3)))\n\n        # Test different amplitude/phase array shapes\n        with pytest.raises(AssertionError):\n            create_wavefront(amplitude=np.ones((4, 4, 4)),\n                                   phase=np.ones((3, 3, 3)))\n\n        # Test non-planetype plane_type\n        with pytest.raises(AssertionError):\n            create_wavefront(plane_type=[1])\n\n\n    def test_npixels(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the npixels property.\n        \"\"\"\n        wf = create_wavefront()\n        assert wf.npixels == wf.amplitude.shape[-1]\n\n\n    def test_nfields(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the nfields property.\n        \"\"\"\n        wf = create_wavefront()\n        assert wf.nfields == wf.amplitude.shape[0]\n\n\n    def test_diameter(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the diameter property.\n        \"\"\"\n        wf = create_wavefront()\n        assert wf.diameter == wf.npixels * wf.pixel_scale\n\n\n    def test_real(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the real property.\n        \"\"\"\n        wf = create_wavefront()\n        assert (wf.real == wf.amplitude * np.cos(wf.phase)).all()\n\n\n    def test_imaginary(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the imaginary property.\n        \"\"\"\n        wf = create_wavefront()\n        assert (wf.imaginary == wf.amplitude * np.sin(wf.phase)).all()\n\n\n    def test_phasor(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the phasor property.\n        \"\"\"\n        wf = create_wavefront()\n        assert (wf.phasor == wf.amplitude * np.exp(1j*wf.phase)).all()\n\n\n    def test_psf(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the psf property.\n        \"\"\"\n        wf = create_wavefront()\n        assert (wf.psf == wf.amplitude**2).all()\n\n\n    def test_pixel_coordinates(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the pixel_coordinates property.\n        \"\"\"\n        wf = create_wavefront()\n        assert (wf.pixel_coordinates == \\\n        dLux.utils.coordinates.get_pixel_positions((wf.npixels, wf.npixels,),\n                                        (wf.pixel_scale, wf.pixel_scale))).all()\n\n\n    def test_set_amplitude(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the set_amplitude method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.set_amplitude(\"some string\")\n\n        # Test list inputs\n        with pytest.raises(AssertionError):\n            wf.set_amplitude([])\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_amplitude(np.ones((16, 16)))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_amplitude(np.ones((1, 1, 16, 16)))\n\n        # Test correct behaviour\n        new_ampl = 0.5*np.ones((1, 16, 16))\n        assert (wf.set_amplitude(new_ampl).amplitude == new_ampl).all()\n\n\n    def test_set_phase(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the set_phase method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.set_phase(\"some string\")\n\n        # Test list inputs\n        with pytest.raises(AssertionError):\n            wf.set_phase([])\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_phase(np.ones((16, 16)))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_phase(np.ones((1, 1, 16, 16)))\n\n        # Test correct behaviour\n        new_phase = 0.5*np.ones((1, 16, 16))\n        assert (wf.set_phase(new_phase).phase == new_phase).all()\n\n\n    def test_set_pixel_scale(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the set_pixel_scale method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.set_pixel_scale(\"some string\")\n\n        # Test list inputs\n        with pytest.raises(AssertionError):\n            wf.set_pixel_scale([])\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_pixel_scale(np.array([]))\n\n        # Test correct behaviour\n        new_pixscale = np.array(1.5)\n        assert wf.set_pixel_scale(new_pixscale).pixel_scale == new_pixscale\n\n\n    def test_set_plane_type(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the set_plane_type method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.set_plane_type(\"some string\")\n\n        # Test correct behaviour\n        new_plane_type = dLux.PlaneType.Focal\n        assert wf.set_plane_type(new_plane_type).plane_type == new_plane_type\n\n\n    def test_set_phasor(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the set_phasor method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.set_phasor(\"some string\", \"some_string\")\n\n        # Test list inputs\n        with pytest.raises(AssertionError):\n            wf.set_phasor([], [])\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_phasor(np.ones((16, 16)), np.ones((16, 16)))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_phasor(np.ones((1, 1, 16, 16)), np.ones((1, 1, 16, 16)))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.set_phasor(np.ones((1, 16, 16)), np.ones((1, 15, 15)))\n\n        # Test correct behaviour\n        new_ampl = 0.5*np.ones((1, 16, 16))\n        new_phase = 0.5*np.ones((1, 16, 16))\n        assert (wf.set_phasor(new_ampl, new_phase).amplitude == new_ampl).all()\n        assert (wf.set_phasor(new_ampl, new_phase).phase == new_phase).all()\n\n\n    def test_tilt_wavefront(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the tilt_wavefront method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.tilt_wavefront(\"some string\")\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.tilt_wavefront(np.ones(1))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.tilt_wavefront(np.array(1.))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.tilt_wavefront(np.ones(3))\n\n        # Test basic behaviour\n        wf.tilt_wavefront(np.ones(2))\n\n\n    def test_multiply_amplitude(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the multiply_amplitude method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.multiply_amplitude(\"some string\")\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.multiply_amplitude(np.ones(1))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.multiply_amplitude(np.ones((1, 1, 1, 1)))\n\n        # Test basic behaviour\n        npix = wf.npixels\n        wf.multiply_amplitude(np.array(1.))\n        wf.multiply_amplitude(np.ones((npix, npix)))\n        wf.multiply_amplitude(np.ones((1, npix, npix)))\n\n\n    def test_add_phase(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the add_phase method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.add_phase(\"some string\")\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.add_phase(np.ones(1))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.add_phase(np.ones((1, 1, 1, 1)))\n\n        # Test basic behaviour\n        npix = wf.npixels\n        wf.add_phase(np.array(1.))\n        wf.add_phase(np.ones((npix, npix)))\n        wf.add_phase(np.ones((1, npix, npix)))\n\n\n    def test_add_opd(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the add_opd method.\n        \"\"\"\n        wf = create_wavefront()\n\n        # Test string inputs\n        with pytest.raises(AssertionError):\n            wf.add_opd(\"some string\")\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.add_opd(np.ones(1))\n\n        # Test wrong shapes\n        with pytest.raises(AssertionError):\n            wf.add_opd(np.ones((1, 1, 1, 1)))\n\n        # Test basic behaviour\n        npix = wf.npixels\n        wf.add_opd(np.array(1.))\n        wf.add_opd(np.ones((npix, npix)))\n        wf.add_opd(np.ones((1, npix, npix)))\n\n\n    def test_normalise(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the normalise method.\n        \"\"\"\n        wf = create_wavefront()\n\n        new_wf = wf.normalise()\n        assert np.sum(new_wf.amplitude**2) == 1.\n\n\n    def test_wavefront_to_psf(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the wavefront_to_psf method.\n        \"\"\"\n        wf = create_wavefront()\n        wf.wavefront_to_psf()\n\n\n    def test_invert_x_and_y(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the invert_x_and_y method.\n        \"\"\"\n        wf = create_wavefront()\n\n        flipped_ampl = np.flip(wf.amplitude, axis=(-1, -2))\n        flipped_phase = np.flip(wf.phase, axis=(-1, -2))\n        new_wf = wf.invert_x_and_y()\n        assert (new_wf.amplitude == flipped_ampl).all()\n        assert (new_wf.phase == flipped_phase).all()\n\n\n    def test_invert_x(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the invert_x method.\n        \"\"\"\n        wf = create_wavefront()\n\n        flipped_ampl = np.flip(wf.amplitude, axis=-1)\n        flipped_phase = np.flip(wf.phase, axis=-1)\n        new_wf = wf.invert_x()\n        assert (new_wf.amplitude == flipped_ampl).all()\n        assert (new_wf.phase == flipped_phase).all()\n\n\n    def test_invert_y(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the invert_y method.\n        \"\"\"\n        wf = create_wavefront()\n\n        flipped_ampl = np.flip(wf.amplitude, axis=-2)\n        flipped_phase = np.flip(wf.phase, axis=-2)\n        new_wf = wf.invert_y()\n        assert (new_wf.amplitude == flipped_ampl).all()\n        assert (new_wf.phase == flipped_phase).all()\n\n\n    def test_interpolate(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the interpolate method.\n        \"\"\"\n        wf = create_wavefront()\n        wf = dLux.CircularAperture(1.)(wf)\n\n        npix = wf.npixels\n        pixscale = wf.pixel_scale\n        k = 2\n        new_wf = wf.interpolate(npix//k, pixscale*k)\n        new_wf2 = wf.interpolate(npix//k, pixscale*k, real_imaginary=True)\n        small_ampl = dLux.IntegerDownsample(k)(wf.amplitude[0])/k**2\n\n        assert np.allclose(new_wf.amplitude[0], small_ampl)\n        assert np.allclose(new_wf2.amplitude[0], small_ampl)\n\n\n    def test_rotate(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the rotate method.\n        \"\"\"\n        wf = create_wavefront()\n        wf = dLux.CircularAperture(1.)(wf)\n        flipped_amplitude = np.flip(wf.amplitude, axis=(-1, -2))\n        flipped_phase = np.flip(wf.phase, axis=(-1, -2))\n\n        new_wf = wf.rotate(np.pi, order=1)\n        assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)\n        assert np.allclose(new_wf.phase, flipped_phase)\n\n        new_wf = wf.rotate(np.pi, real_imaginary=True, order=1)\n\n        assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)\n        # Add small remainer to fix 0-pi instability\n        assert np.allclose((new_wf.phase+1e-6)%np.pi, flipped_phase, atol=1e-5)\n\n        with pytest.raises(NotImplementedError):\n            wf.rotate(np.pi, fourier=True)\n\n\n    def test_pad_to(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the pad_to method.\n        \"\"\"\n        even_wf = create_wavefront()\n        odd_wf = create_wavefront(amplitude=np.ones((1, 15, 15)),\n                                        phase=np.ones((1, 15, 15)))\n\n        # Smaller value\n        with pytest.raises(AssertionError):\n            even_wf.pad_to(14)\n\n        # even -&gt; odd\n        with pytest.raises(AssertionError):\n            even_wf.pad_to(17)\n\n        # odd -&gt; even\n        with pytest.raises(AssertionError):\n            odd_wf.pad_to(16)\n\n        assert even_wf.pad_to(20).npixels == 20\n\n\n    def test_crop_to(self, create_wavefront: callable) -&gt; None:\n\"\"\"\n        Tests the crop_to method.\n        \"\"\"\n        even_wf = create_wavefront()\n        odd_wf = create_wavefront(amplitude=np.ones((1, 15, 15)),\n                                        phase=np.ones((1, 15, 15)))\n\n        # Smaller value\n        with pytest.raises(AssertionError):\n            even_wf.crop_to(18)\n\n        # even -&gt; odd\n        with pytest.raises(AssertionError):\n            even_wf.crop_to(15)\n\n        # odd -&gt; even\n        with pytest.raises(AssertionError):\n            odd_wf.crop_to(14)\n\n        assert even_wf.crop_to(12).npixels == 12\n</pre> class TestWavefront(object):     \"\"\"     Test the Wavefront class.     \"\"\"       def test_constructor(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the constructor.         \"\"\"         # Test constructor         create_wavefront()          # Test empty array         with pytest.raises(AssertionError):             create_wavefront(wavelength=[])          # Test 1d array         with pytest.raises(AssertionError):             create_wavefront(wavelength=[1e3, 1e4])          # Test empty array         with pytest.raises(AssertionError):             create_wavefront(pixel_scale=[])          # Test 1d array         with pytest.raises(AssertionError):             create_wavefront(pixel_scale=[1e3, 1e4])          # Test non 3d amplitude array         with pytest.raises(AssertionError):             create_wavefront(amplitude=np.ones((3, 3)))          # Test non 3d amplitude array         with pytest.raises(AssertionError):             create_wavefront(amplitude=np.ones((3, 3, 3, 3)))          # Test non 3d phase array         with pytest.raises(AssertionError):             create_wavefront(phase=np.ones((3, 3)))          # Test non 3d phase array         with pytest.raises(AssertionError):             create_wavefront(phase=np.ones((3, 3, 3, 3)))          # Test different amplitude/phase array shapes         with pytest.raises(AssertionError):             create_wavefront(amplitude=np.ones((4, 4, 4)),                                    phase=np.ones((3, 3, 3)))          # Test non-planetype plane_type         with pytest.raises(AssertionError):             create_wavefront(plane_type=[1])       def test_npixels(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the npixels property.         \"\"\"         wf = create_wavefront()         assert wf.npixels == wf.amplitude.shape[-1]       def test_nfields(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the nfields property.         \"\"\"         wf = create_wavefront()         assert wf.nfields == wf.amplitude.shape[0]       def test_diameter(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the diameter property.         \"\"\"         wf = create_wavefront()         assert wf.diameter == wf.npixels * wf.pixel_scale       def test_real(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the real property.         \"\"\"         wf = create_wavefront()         assert (wf.real == wf.amplitude * np.cos(wf.phase)).all()       def test_imaginary(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the imaginary property.         \"\"\"         wf = create_wavefront()         assert (wf.imaginary == wf.amplitude * np.sin(wf.phase)).all()       def test_phasor(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the phasor property.         \"\"\"         wf = create_wavefront()         assert (wf.phasor == wf.amplitude * np.exp(1j*wf.phase)).all()       def test_psf(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the psf property.         \"\"\"         wf = create_wavefront()         assert (wf.psf == wf.amplitude**2).all()       def test_pixel_coordinates(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the pixel_coordinates property.         \"\"\"         wf = create_wavefront()         assert (wf.pixel_coordinates == \\         dLux.utils.coordinates.get_pixel_positions((wf.npixels, wf.npixels,),                                         (wf.pixel_scale, wf.pixel_scale))).all()       def test_set_amplitude(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the set_amplitude method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.set_amplitude(\"some string\")          # Test list inputs         with pytest.raises(AssertionError):             wf.set_amplitude([])          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_amplitude(np.ones((16, 16)))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_amplitude(np.ones((1, 1, 16, 16)))          # Test correct behaviour         new_ampl = 0.5*np.ones((1, 16, 16))         assert (wf.set_amplitude(new_ampl).amplitude == new_ampl).all()       def test_set_phase(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the set_phase method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.set_phase(\"some string\")          # Test list inputs         with pytest.raises(AssertionError):             wf.set_phase([])          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_phase(np.ones((16, 16)))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_phase(np.ones((1, 1, 16, 16)))          # Test correct behaviour         new_phase = 0.5*np.ones((1, 16, 16))         assert (wf.set_phase(new_phase).phase == new_phase).all()       def test_set_pixel_scale(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the set_pixel_scale method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.set_pixel_scale(\"some string\")          # Test list inputs         with pytest.raises(AssertionError):             wf.set_pixel_scale([])          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_pixel_scale(np.array([]))          # Test correct behaviour         new_pixscale = np.array(1.5)         assert wf.set_pixel_scale(new_pixscale).pixel_scale == new_pixscale       def test_set_plane_type(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the set_plane_type method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.set_plane_type(\"some string\")          # Test correct behaviour         new_plane_type = dLux.PlaneType.Focal         assert wf.set_plane_type(new_plane_type).plane_type == new_plane_type       def test_set_phasor(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the set_phasor method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.set_phasor(\"some string\", \"some_string\")          # Test list inputs         with pytest.raises(AssertionError):             wf.set_phasor([], [])          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_phasor(np.ones((16, 16)), np.ones((16, 16)))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_phasor(np.ones((1, 1, 16, 16)), np.ones((1, 1, 16, 16)))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.set_phasor(np.ones((1, 16, 16)), np.ones((1, 15, 15)))          # Test correct behaviour         new_ampl = 0.5*np.ones((1, 16, 16))         new_phase = 0.5*np.ones((1, 16, 16))         assert (wf.set_phasor(new_ampl, new_phase).amplitude == new_ampl).all()         assert (wf.set_phasor(new_ampl, new_phase).phase == new_phase).all()       def test_tilt_wavefront(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the tilt_wavefront method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.tilt_wavefront(\"some string\")          # Test wrong shapes         with pytest.raises(AssertionError):             wf.tilt_wavefront(np.ones(1))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.tilt_wavefront(np.array(1.))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.tilt_wavefront(np.ones(3))          # Test basic behaviour         wf.tilt_wavefront(np.ones(2))       def test_multiply_amplitude(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the multiply_amplitude method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.multiply_amplitude(\"some string\")          # Test wrong shapes         with pytest.raises(AssertionError):             wf.multiply_amplitude(np.ones(1))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.multiply_amplitude(np.ones((1, 1, 1, 1)))          # Test basic behaviour         npix = wf.npixels         wf.multiply_amplitude(np.array(1.))         wf.multiply_amplitude(np.ones((npix, npix)))         wf.multiply_amplitude(np.ones((1, npix, npix)))       def test_add_phase(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the add_phase method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.add_phase(\"some string\")          # Test wrong shapes         with pytest.raises(AssertionError):             wf.add_phase(np.ones(1))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.add_phase(np.ones((1, 1, 1, 1)))          # Test basic behaviour         npix = wf.npixels         wf.add_phase(np.array(1.))         wf.add_phase(np.ones((npix, npix)))         wf.add_phase(np.ones((1, npix, npix)))       def test_add_opd(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the add_opd method.         \"\"\"         wf = create_wavefront()          # Test string inputs         with pytest.raises(AssertionError):             wf.add_opd(\"some string\")          # Test wrong shapes         with pytest.raises(AssertionError):             wf.add_opd(np.ones(1))          # Test wrong shapes         with pytest.raises(AssertionError):             wf.add_opd(np.ones((1, 1, 1, 1)))          # Test basic behaviour         npix = wf.npixels         wf.add_opd(np.array(1.))         wf.add_opd(np.ones((npix, npix)))         wf.add_opd(np.ones((1, npix, npix)))       def test_normalise(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the normalise method.         \"\"\"         wf = create_wavefront()          new_wf = wf.normalise()         assert np.sum(new_wf.amplitude**2) == 1.       def test_wavefront_to_psf(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the wavefront_to_psf method.         \"\"\"         wf = create_wavefront()         wf.wavefront_to_psf()       def test_invert_x_and_y(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the invert_x_and_y method.         \"\"\"         wf = create_wavefront()          flipped_ampl = np.flip(wf.amplitude, axis=(-1, -2))         flipped_phase = np.flip(wf.phase, axis=(-1, -2))         new_wf = wf.invert_x_and_y()         assert (new_wf.amplitude == flipped_ampl).all()         assert (new_wf.phase == flipped_phase).all()       def test_invert_x(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the invert_x method.         \"\"\"         wf = create_wavefront()          flipped_ampl = np.flip(wf.amplitude, axis=-1)         flipped_phase = np.flip(wf.phase, axis=-1)         new_wf = wf.invert_x()         assert (new_wf.amplitude == flipped_ampl).all()         assert (new_wf.phase == flipped_phase).all()       def test_invert_y(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the invert_y method.         \"\"\"         wf = create_wavefront()          flipped_ampl = np.flip(wf.amplitude, axis=-2)         flipped_phase = np.flip(wf.phase, axis=-2)         new_wf = wf.invert_y()         assert (new_wf.amplitude == flipped_ampl).all()         assert (new_wf.phase == flipped_phase).all()       def test_interpolate(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the interpolate method.         \"\"\"         wf = create_wavefront()         wf = dLux.CircularAperture(1.)(wf)          npix = wf.npixels         pixscale = wf.pixel_scale         k = 2         new_wf = wf.interpolate(npix//k, pixscale*k)         new_wf2 = wf.interpolate(npix//k, pixscale*k, real_imaginary=True)         small_ampl = dLux.IntegerDownsample(k)(wf.amplitude[0])/k**2          assert np.allclose(new_wf.amplitude[0], small_ampl)         assert np.allclose(new_wf2.amplitude[0], small_ampl)       def test_rotate(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the rotate method.         \"\"\"         wf = create_wavefront()         wf = dLux.CircularAperture(1.)(wf)         flipped_amplitude = np.flip(wf.amplitude, axis=(-1, -2))         flipped_phase = np.flip(wf.phase, axis=(-1, -2))          new_wf = wf.rotate(np.pi, order=1)         assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)         assert np.allclose(new_wf.phase, flipped_phase)          new_wf = wf.rotate(np.pi, real_imaginary=True, order=1)          assert np.allclose(new_wf.amplitude, flipped_amplitude, atol=1e-5)         # Add small remainer to fix 0-pi instability         assert np.allclose((new_wf.phase+1e-6)%np.pi, flipped_phase, atol=1e-5)          with pytest.raises(NotImplementedError):             wf.rotate(np.pi, fourier=True)       def test_pad_to(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the pad_to method.         \"\"\"         even_wf = create_wavefront()         odd_wf = create_wavefront(amplitude=np.ones((1, 15, 15)),                                         phase=np.ones((1, 15, 15)))          # Smaller value         with pytest.raises(AssertionError):             even_wf.pad_to(14)          # even -&gt; odd         with pytest.raises(AssertionError):             even_wf.pad_to(17)          # odd -&gt; even         with pytest.raises(AssertionError):             odd_wf.pad_to(16)          assert even_wf.pad_to(20).npixels == 20       def test_crop_to(self, create_wavefront: callable) -&gt; None:         \"\"\"         Tests the crop_to method.         \"\"\"         even_wf = create_wavefront()         odd_wf = create_wavefront(amplitude=np.ones((1, 15, 15)),                                         phase=np.ones((1, 15, 15)))          # Smaller value         with pytest.raises(AssertionError):             even_wf.crop_to(18)          # even -&gt; odd         with pytest.raises(AssertionError):             even_wf.crop_to(15)          # odd -&gt; even         with pytest.raises(AssertionError):             odd_wf.crop_to(14)          assert even_wf.crop_to(12).npixels == 12"}]}