{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#lux","title":"\u2202Lux","text":""},{"location":"#differentiable-light-optical-systems-as-a-neural-network","title":"Differentiable Light - Optical systems as a neural network","text":"<p>Contributors: Louis Desdoigts, Benjamin Pope, Jordan Dennis, Adam Taras, Peter Tuthill</p>"},{"location":"#what-is-lux","title":"What is \u2202Lux?","text":"<p>\u2202Lux is a differentiable physical optics modelling framework built using Jax for automatic differentiation and GPU acceleration. With a simple object-oriented interface built in Equinox, it is easy to specify astronomical optical systems involving many planes, phase and amplitude screens in each, and propagate between them in the Fraunhofer or Fresnel regimes. This enables fast phase retrieval, image deconvolution, and hardware design in high dimensions. Because \u2202Lux models are fully differentiable, you can optimize them by gradient descent over millions of parameters; or use Hamiltonian Monte Carlo to accelerate MCMC sampling. Our code is fully open-source under an MIT license, and we encourage you to use it and build on it to solve problems in astronomy and beyond.</p>"},{"location":"#use-documentation","title":"Use &amp; Documentation","text":"<p>Documentation can be found here. To get started look, go to the Tutorials section and have a look!</p>"},{"location":"#publications","title":"Publications","text":"<p>We have a multitude of publications in the pipeline using dLux, some built from our tutorials. To start we would recommend looking at this invited talk on \u2202Lux which gives a good overview and has an attatched recording of it being presented! We also have this poster!</p>"},{"location":"#collaboration-development","title":"Collaboration &amp; Development","text":"<p>We are always looking to collaborate and further develop this software! We have focused on flexibility and ease of development, so if you have a project you want to use \u2202Lux for, but it currently does not have the required capabilities, don't hesitate to email me and we can discuss how to implement and merge it! Similarly you can take a look at the <code>CONTRIBUTING.md</code> file.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>\u2202Lux is hosted on PyPI, so simply pip install!</p> <pre><code>pip install dLux\n</code></pre> <p>You can also build from source. To do so, clone the git repo, enter the directory, and run</p> <pre><code>pip install .\n</code></pre> <p>We encourage the creation of a virtual enironment to run dLux to prevent software conflicts as we keep the software up to date with the lastest version of the core packages.</p>"},{"location":"installation/#windowsgoogle-colab-quickstart","title":"Windows/Google Colab Quickstart","text":"<p><code>jaxlib</code> is currently not supported by the jax team on windows, however there are two work-arounds! </p> <p>Firstly here is some community built software to install jax on windows! We do not use this ourselves so have limited knowledge, but some users seems to have got everyting working fine! </p> <p>Secondly users can also run our software on Google Colab. If you want to instal from source in colab, run this at the start of your notebook!</p> <pre><code>!git clone https://github.com/LouisDesdoigts/dLux.git # Download latest version\n!cd dLux; pip install . -q # Navigate to \u2202Lux and install from source\n</code></pre> <p>From here everything should work! You can also run the code on GPU to take full advantage of Jax, simply by switch to a GPU runtime environment, no extra steps necessary!</p>"},{"location":"aberrations/aberration_factory/","title":"Aberration Factory","text":"<p>This class is not actually ever instatiated, but is rather a class used to  give a simple constructor interface that is used to construct the most commonly used aberrations. It is able to construct hard-edged circular or  regular poygonal aberrations. </p> <p>Lets look at an example of how to construct a simple circular aberration  class. Let calcualte this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>from dLux import AberrationFactory\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nzernikes = np.arange(4, 11)\ncoefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n# Construct aberrations\naberrations = AberrationFactory(512, zernikes=zernikes, \n                                coefficients=coefficients)\n</code></pre> <p>The resulting aperture class has two parameters, <code>.basis</code> and  <code>.coefficients</code>. We can then examine the opd like so:</p> <pre><code>import matplotlib.pyplot as plt\nplt.figure(figsize=(5, 4))\nplt.imshow(aberrations.get_opd())\nplt.colorbar()\nplt.show()\n</code></pre> <p>We can also easily change this to a hexagonal aperture:</p> <pre><code># Construct aberrations\naberrations = AberrationFactory(512, nsides=6, zernikes=zernikes, \n                                coefficients=coefficients)\n\n# Examine\nplt.figure(figsize=(5, 4))\nplt.imshow(aberrations.get_opd())\nplt.colorbar()\nplt.show()\n</code></pre>"},{"location":"aberrations/aberration_factory/#dLux.aberrations.AberrationFactory.__init__","title":"<code>__init__()</code>","text":"<p>Constructs a basic single static aberration class.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> required <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> required <code>aperutre_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> required <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> required <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> required <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> required <p>Returns:</p> Name Type Description <code>aperture</code> <code>ApplyBasisOPD</code> <p>Returns an appropriately constructed ApplyBasisOPD.</p>"},{"location":"aberrations/aberration_factory/#dLux.aberrations.AberrationFactory.__new__","title":"<code>__new__(npixels, nsides=0, rotation=0.0, aperutre_ratio=1.0, zernikes=None, coefficients=None, name=None)</code>","text":"<p>Constructs a basic single static aberration class.</p> <p>TODO: Add link to the zenike noll indicies</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> <code>0</code> <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> <code>0.0</code> <code>aperutre_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> <code>1.0</code> <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> <code>None</code> <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>aperture</code> <code>ApplyBasisOPD</code> <p>Returns an appropriately constructed ApplyBasisOPD.</p>"},{"location":"aberrations/zernike/","title":"Zernike","text":"<p>         Bases: <code>Base</code></p> <p>A class to generate Zernike polynomials dynamically.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> <code>n</code> <code>int</code> <p>The radial order of the Zernike polynomial.</p> <code>m</code> <code>int</code> <p>The azimuthal order of the Zernike polynomial.</p> <code>name</code> <code>str</code> <p>The name of the Zernike polynomial.</p> <code>_k</code> <code>Array</code> <p>The array of powers using the radial calculation. This is a  pre-calculated parameter and should not be changed.</p> <code>_c</code> <code>Array</code> <p>The array of normalisaton coefficients used in the radial calculation. This is a pre-calculated parameter and should not be changed.</p>"},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.j","title":"<code>j = int(j)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.m","title":"<code>m: int</code>  <code>class-attribute</code>","text":""},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.n","title":"<code>n: int</code>  <code>class-attribute</code>","text":""},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.name","title":"<code>name = zernike_names[int(self.j)] if self.j &gt;= 1 and self.j &lt;= 36 else f'Zernike {int(self.j)}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.__init__","title":"<code>__init__(j)</code>","text":"<p>Construct for the Zernike class.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <code>int</code> <p>The Zernike (noll) index.</p> required"},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.calculate","title":"<code>calculate(coordinates, nsides=0)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. If 0, the Zernike polynomial is calculated on a circular aperture.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p>"},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.calculate_polike","title":"<code>calculate_polike(coordinates, nsides)</code>","text":"<p>Calculates the Zernike polynomial on an nsided aperture.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <p>Returns:</p> Name Type Description <code>polike</code> <code>Array</code> <p>The Zernike polynomial on an nsided aperture.</p>"},{"location":"aberrations/zernike/#dLux.aberrations.Zernike.calculate_zernike","title":"<code>calculate_zernike(coordinates)</code>","text":"<p>Calculates the Zernike polynomial.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The cartesian coordinates to calcualte the Zernike polynomial upon.</p> required <p>Returns:</p> Name Type Description <code>zernike</code> <code>Array</code> <p>The Zernike polynomial.</p>"},{"location":"aberrations/zernike_basis/","title":"Zenike Basis","text":"<p>         Bases: <code>Base</code></p> <p>A class to calculate a set of Zernike polynomials on a dynamic set of coordiantes.</p> <p>The 'jth' zernike polynomial is defined here. The basic translation between the noll index and the pair of numbers is shown below:</p> <p>1 -&gt; (0, 0)</p> <p>2, 3 -&gt; (1, -1), (1, 1)</p> <p>4, 5, 6 -&gt; (2, -2), (2, 0), (2, 2)</p> <p>7, 8, 9, 10 -&gt; (3, -3), (3, -1), (3, 1), (3, 3)</p> <p>Attributes:</p> Name Type Description <code>zernikes</code> <code>list[Zernike]</code> <p>The list of Zernike polynomial classes to calculate.</p>"},{"location":"aberrations/zernike_basis/#dLux.aberrations.ZernikeBasis.zernikes","title":"<code>zernikes = [Zernike(j) for j in js]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"aberrations/zernike_basis/#dLux.aberrations.ZernikeBasis.__init__","title":"<code>__init__(js)</code>","text":"<p>Constructor for the DynamicZernike class.</p> <p>Parameters:</p> Name Type Description Default <code>js</code> <code>list[int]</code> <p>The list of Zernike (noll) indices to calculate.</p> required"},{"location":"aberrations/zernike_basis/#dLux.aberrations.ZernikeBasis.calculate_basis","title":"<code>calculate_basis(coordinates, nsides=0)</code>","text":"<p>Calculates the full Zernike polynomial basis.</p> <p>Note: The zernike polynomial is defined on the coordinates up to a radial value of 1.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Arraya</code> <p>The cartesian coordinates to calcualte the Zernike basis upon.</p> required <p>Returns:</p> Name Type Description <code>zernike_basis</code> <code>Array</code> <p>The Zernike polynomial basis.</p>"},{"location":"apertures/overview/","title":"An Overview of the Apertures.","text":""},{"location":"apertures/overview/#introduction","title":"Introduction","text":"<p><code>dLux</code> implements a number of aperture components for telescopes. Because <code>dLux</code> is powered by autodiff, the shape of the aperture can be learned.  Theoretically, you could learn the value of every pixel in the aperture.  Learning by pixel would be computationally expensive and the model could  chase noise making the results meaningless. Instead the apertures that we  have implemented are minimally paramtrised. Minimal is perhaps a  misnomer as we have allowed for flexible manipulation of the apertures. </p> <p>In general the apertures can be, sheared, compressed, rotated and  translated arround the plane. However, the effect on the point spread  function (psf) due to changes in the aperture is one of the smallest  sources of error in most cases. A notable counter example is the hubble  space telescope, upon which the two apertures are missaligned considerably. Anomalies aside, before trying to learn a deformation in your aperture  ask make sure your model is accounting for more common, larger sources  of error. </p> <p>When working with gradients we found that it was best to avoid discontinuous  functions. However, an aperture is discontinuous across the boundary.  To avoid the undefined gradients that this can lead to we developed a  system of soft-edging the apertures. In particular we avoided using a  nearest-neighbour interpolator (or linear interpolator) by choosing a  sigmoid like function across the boundary. Naturally this leads to a  degree of approximation, but in general works.</p>"},{"location":"apertures/overview/#static-apertures","title":"Static Apertures","text":"<p>The inbuild flexibility of the <code>dLux.apertures</code> module is not all good. The evaluation of the apertures remains much cheaper than the calculations that carry the wavefront from one plane to another, but in situations  where speed matters they are a burden. Moreover, we anticipate that most models will not need to learn the parameters of the aperture. To  avoid extra calculations we created a related class <code>StaticAperture</code> that works to pre-compute the aperture making optimisation faster. As well as  providing <code>StaticAperture</code> we also created <code>StaticAberratedAperture</code> to  pre-compute basis functions. </p>"},{"location":"apertures/overview/#aberrated-apertures","title":"Aberrated Apertures","text":"<p>Phase retrieval is synonomous with modern physical optics. <code>dLux</code> provides  a streamlined, physical interface for phase retrieval in the  <code>dLux.apertures</code> using the <code>AberratedAperture</code> class. This class wraps  a standard <code>dLux.apertures.Aperture</code> in a set of basis vectors of your  chosing. In general, these basis vectors are derived from the Zernike polynomials, via orthonormalisation. However, orthonormalisation is  expensive and a large amount of work has gone into optimising it. </p> <p>For regular polygons, the orthonormalisation has analytic solutions.  We have implemented this along with a mechanism to pre-evaluate the  coefficients of the basis vectors. This means that the evaluation is  very fast allowing the shape of the aperture to be learned along  with the basis and the coefficients. The basis will be updated to  follow the shape of the aperture. This works by transforming the  paraxial coordinates of wavefront into those of the apertures. </p> <p>An important result is that the basis vectors might lose their  orthonormality. This is OK. Since a typical model does not use an  infinite number of basis vectors it does not make sense to split hairs  of the set is not completely orhtonormal. All that matters is if the  correct order of error is spanned. This will depend upon your scenario. The orthonormalisation step is debatebly important. Depending on the  number of terms and their order, it can essentially reduce to just  cutting an aperture-shaped hole in the corresponding Zernike.</p> <p>We have implemented special cases for <code>CircularAperture</code> and  <code>HexagonalAperture</code> because these are common cases. Outside of regular polygons, circles and hexagons, the orthonormalisation needs to be  performed at each pass. This presents a major barrier to learning  the shape of an <code>AberratedAperture</code> because it significantly increases the computation complexity. An active avenue of improvent is in the  handling of arbitrary apertures.</p>"},{"location":"apertures/overview/#usage-and-examples","title":"Usage and Examples","text":"<p>Here is a complete list of the apertures that we have implemented.  - Simple, shaped apertures:    - <code>AnnularAperture</code>    - <code>CircularAperture</code>    - <code>HexagonalAperture</code>    - <code>SquareAperture</code>    - <code>RectangularAperture</code>    - <code>RegularPolygonalAperture</code>    - <code>IrregularPolygonalAperture</code>  - Composite apertures:    - <code>CompoundAperture</code>    - <code>MultiAperture</code>  - <code>AberratedAperture</code>  - Static apertures:    - <code>StaticAperture</code>    - <code>StaticAberratedAperture</code>  - <code>UniformSpider</code> In general they function as you might intuitively expect. The  notable exception to this rule is the composite apertures, of  which there are two. The <code>CompoundAperture</code> is for overlapping  apertures that you wish to treat as a single aperture. For example, the components of a spider that is fused to an obstruction and  pupil will not move very much with respect to one another.  Indeed for all intents and purposes we can treat this as static. However, it might move with respect to a secondary pupil  acting as the camera lens. This particular circumstance was the  case on the Hubble Space Telescope.</p> <p>Now let's write some code. We can create a basic circular aperture at the centre of the paraxial coordinate system and with radius  of \\(1m\\) using,</p> <pre><code>circ = CircularAperture(1.) # Default w. radius: 1m\ncirc = CircularAperture(1., centre=[.5, .5])\ncirc = CircularAperture(1., shear=[.05, .05])\ncirc = CircularAperture(1., compression=[1.05, .95])\ncirc = CircularAperture(1., softening=True)\ncirc = CircularAperture(1., occulting=True)\n</code></pre> <p>Running this script produces the output shown in Fig. 1. </p> <p>The same can be done for all of the other apertures which in  general have only a few non-default parameters, such as length  and width for the <code>RectangularAperture</code>. The notable exception  to this rule is <code>IrregularPolygonalAperture</code> which takes a  list of vertices as a non-default parameter. This class can be  used to generate many of the other pre-loaded parameters but the  cost of generality is performance. Moreover, it is very unlikely that learning the position of the vertices is ever going to be  necessary, but it is possible. Fig. 2. shows plots of all the apertures.  </p> <p>The <code>AberratedApertures</code>, which contain basis implementation in  <code>dLux</code> takes in three parameters. The noll indices of the basis  vectors, the aperture and the coefficients of those basis  vectors. The basis vectors shown in Fig. 3. were generated using  the following code,</p> <pre><code>shape = 10\naber_circ = AberratedAperture(\n    noll_inds = np.arange(1, shape, dtype=float),\n    coeffs = np.ones(shape),\n    aperture = CircularAperture(1.)\n)\n</code></pre> <p>The benefit of this representation is that we can simultaneously  learn abitrary aberrations represented using Zernike polynomials  and the shape/position of the aperture. Although this is unlikely  to be something that is often required it is an interesting piece  of functionality.  </p>"},{"location":"apertures/api/aberrated_aperture/","title":"Aberrated Aperture","text":"<p>         Bases: <code>AbstractAberratedAperture</code></p> <p>A class for generating apertures with aberrations. This class generates the basis vectors of the aberrations at run time, allowing for the aperture and aberrations to be recovered simultaneously.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> <code>basis_funcs</code> <code>list[callable]</code> <p>A list of basis functions that represent the basis. The exact  polynomials that are represented will depend on the aperture shape. </p> <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.aperture","title":"<code>aperture = aperture</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.basis","title":"<code>basis = dLux.aberrations.ZernikeBasis(noll_inds)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the aperture and the abberations to the wavefront.  </p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is passing through the aperture.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront after passing through the aperture.</p>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.__init__","title":"<code>__init__(aperture, noll_inds, coefficients=None, name='AberratedAperture', **kwargs)</code>","text":"<p>Constructor for the AberratedAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>The aperture on which the aberration basis is defined.</p> required <code>noll_inds</code> <code>Array</code> <p>The noll indices are a scheme for indexing the Zernike polynomials. Normally these polynomials have two  indices but the noll indices prevent an order to  these pairs. All basis can be indexed using the noll indices based on <code>n</code> and <code>m</code>.</p> required <code>coefficients</code> <code>Array</code> <p>The amplitude of each basis vector of the aberrations. If nothing  is provided, then the coefficients are set to zero.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AberratedAperture'</code>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.get_aperture","title":"<code>get_aperture(npixels, diameter)</code>","text":"<p>Compute the array representing the aperture on a set of coordinates  with the specified number of pixels and diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The array representing the transmission of the aperture.</p>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.get_basis","title":"<code>get_basis(npixels, diameter)</code>","text":"<p>Compute the basis vectors of the aperture aberrations on the provided  coordinates with the specified number of pixels and diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the basis vectors of the aperture aberrations.</p>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.get_opd","title":"<code>get_opd(npixels, diameter)</code>","text":"<p>Compute the total optical path difference of the aperture aberrations  on the provided coordinates with the specified number of pixels and  diameter.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p>"},{"location":"apertures/api/aberrated_aperture/#dLux.apertures.AberratedAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/annular_aperture/","title":"Annular Aperture","text":"<p>         Bases: <code>DynamicAperture</code></p> <p>An annular aperture defined by its inner and outer radii.</p> <p>Attributes:</p> Name Type Description <code>rmax</code> <code>Array, meters</code> <p>Outer radius of aperture.</p> <code>rmin</code> <code>Array, meters</code> <p>Inner radius of aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/annular_aperture/#dLux.apertures.AnnularAperture.rmax","title":"<code>rmax = np.asarray(rmax).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/annular_aperture/#dLux.apertures.AnnularAperture.rmin","title":"<code>rmin = np.asarray(rmin).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/annular_aperture/#dLux.apertures.AnnularAperture.__init__","title":"<code>__init__(rmax, rmin, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), occulting=False, softening=np.array(1.0), name='AnnularAperture')</code>","text":"<p>Constructor for the AnnularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>rmax</code> <code>Array, meters</code> <p>The outer radius of the aperture.</p> required <code>rmin</code> <code>Array, meters</code> <p>The inner radius of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AnnularAperture'</code>"},{"location":"apertures/api/annular_aperture/#dLux.apertures.AnnularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/aperture_factory/","title":"Aperture Factory","text":"<p>This class is not actually ever instatiated, but is rather a class used to  give a simple constructor interface that is used to construct the most commonly used apertures. It is able to construct hard-edged circular or  regular poygonalal apertures. Secondary mirrors obscurations with the same aperture shape can be constructed, along with uniformly spaced struts.  Aberrations can also be applied to the aperture. The ratio of the primary aperture opening to the array size is determined by the <code>aperture_ratio</code> parameter, with secondary mirror obscurations and struts being scaled relative to the aperture diameter. </p> <p>Lets look at an example of how to construct a simple circular aperture with a secondary mirror obscurtion held by 4 struts and some low-order  aberrations. For this example lets take a 2m diameter aperutre, with a 20cm  secondary mirror held by 3 struts with a width of 2cm. In this example the secondary mirror is 10% of the primary aperture diameter and the struts are 1% of the primary aperture diameter, giving us values of 0.1 and 0.01 for the <code>secondary_ratio</code> and <code>strut_ratio</code> parameters. Let calcualte this for a 512x512 array with the aperture spanning the full array.</p> <pre><code>from dLux import SimpleAperture\nimport jax.numpy as np\nimport jax.random as jr\n\n# Construct Zernikes\nzernikes = np.arange(4, 11)\ncoefficients = jr.normal(jr.PRNGKey(0), (zernikes.shape[0],))\n\n# Construct aperture\naperture = SimpleAperture(512, secondary_ratio=0.1, nstruts=4, \n                          strut_ratio=0.01, zernikes=zernikes, \n                          coefficients=coefficients)\n</code></pre> <p>The resulting aperture class has three parameters, <code>.aperture</code>, <code>.basis</code> and <code>.coefficients</code>. We can examine the aperture and opd like so:</p> <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.aperture)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(aperture.opd)\nplt.colorbar()\nplt.show()\n</code></pre> <p>We can also easily change this to a hexagonal aperture with 3 struts:</p> <pre><code># Make aperture\naperture = SimpleAperture(512, nsides=6, secondary_ratio=0.1, nstruts=3, \n                          strut_ratio=0.01, zernikes=zernikes, \n                          coefficients=coefficients)\n\n# Examine\nplt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture.aperture)\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.imshow(aperture.opd)\nplt.colorbar()\nplt.show()\n</code></pre>"},{"location":"apertures/api/aperture_factory/#dLux.apertures.ApertureFactory.__init__","title":"<code>__init__()</code>","text":"<p>Constructs a basic single static aperture, either with or without  aberrations.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> required <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> required <code>aperutre_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> required <code>secondary_ratio</code> <code>float</code> <p>The ratio of the secondary mirror obsuration diameter to the  aperture diameter. A value of 0. results in no secondary mirror  obsuration.</p> required <code>nstruts</code> <code>int</code> <p>The number of uniformly spaced struts holding the secondary mirror.</p> required <code>strut_ratio</code> <code>float</code> <p>The ratio of the width of the strut to the aperture diameter.</p> required <code>strut_rotation</code> <code>float</code> <p>The rotation of the struts in radians.</p> required <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> required <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> required <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> required <p>Returns:</p> Name Type Description <code>aperture</code> <code>Union[StaticAperture, StaticAberratedAperture]</code> <p>Returns an appropriately constructed StaticAperture or  StaticAberratedAperture, depending on if zernikes are provided.</p>"},{"location":"apertures/api/aperture_factory/#dLux.apertures.ApertureFactory.__new__","title":"<code>__new__(npixels, nsides=0, rotation=0.0, aperutre_ratio=1.0, secondary_ratio=0.0, secondary_nsides=0, nstruts=0, strut_ratio=0.0, strut_rotation=0.0, zernikes=None, coefficients=None, name=None)</code>","text":"<p>Constructs a basic single static aperture, either with or without  aberrations.</p> <p>TODO: Add link to the zenike noll indicies</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>Number of pixels used to represent the aperture.</p> required <code>nsides</code> <code>int</code> <p>Number of sides of the aperture. A zero input results in a circular aperture. All other other values of three and above are supported.</p> <code>0</code> <code>rotation</code> <code>float, radians</code> <p>The global rotation of the aperture in radians.</p> <code>0.0</code> <code>aperutre_ratio</code> <code>float</code> <p>The ratio of the aperture size to the array size. A value of 1.  results in an aperture that fully spans the array, a value of 0.5  retuls in an aperure that is half the size of the array, which is  equivilent to a padding factor of 2.</p> <code>1.0</code> <code>secondary_ratio</code> <code>float</code> <p>The ratio of the secondary mirror obsuration diameter to the  aperture diameter. A value of 0. results in no secondary mirror  obsuration.</p> <code>0.0</code> <code>secondary_nsides</code> <code>int</code> <p>The number of sides of the secondary mirror obsuration. A zero input results in a circular aperture. All other other values of three and  above are supported.</p> <code>0</code> <code>nstruts</code> <code>int</code> <p>The number of uniformly spaced struts holding the secondary mirror.</p> <code>0</code> <code>strut_ratio</code> <code>float</code> <p>The ratio of the width of the strut to the aperture diameter.</p> <code>0.0</code> <code>strut_rotation</code> <code>float</code> <p>The rotation of the struts in radians.</p> <code>0.0</code> <code>zernikes</code> <code>Array</code> <p>The zernike noll indices to be used for the aberrations. Please  refer to (this)[Add this link] docstring to see which indicides  correspond to which aberrations. Typical values are range(4, 11).</p> <code>None</code> <code>coefficients</code> <code>Array</code> <p>The zernike cofficients to be applied to the aberrations. Defaults  to an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the aperture used to index the layers dictionary. If  not supplied, the aperture will be named based on the number of sides. However this is only supported up to 8 sides, and a name must be supplied for apertures with more than 8 sides.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>aperture</code> <code>Union[StaticAperture, StaticAberratedAperture]</code> <p>Returns an appropriately constructed StaticAperture or  StaticAberratedAperture, depending on if zernikes are provided.</p>"},{"location":"apertures/api/circular_aperture/","title":"Circular Aperture","text":"<p>         Bases: <code>DynamicAperture</code></p> <p>A circular aperture parameterised by its radius.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>Array, meters</code> <p>The radius of the aperture. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/circular_aperture/#dLux.apertures.CircularAperture.radius","title":"<code>radius = np.asarray(radius).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/circular_aperture/#dLux.apertures.CircularAperture.__init__","title":"<code>__init__(radius, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), occulting=False, softening=np.array(1.0), name='CircularAperture')</code>","text":"<p>Constructor for the CircularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>Array</code> <p>The radius of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CircularAperture'</code>"},{"location":"apertures/api/circular_aperture/#dLux.apertures.CircularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/compound_aperture/","title":"Compound Aperture","text":"<p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture with spiders holding a secondary mirror.</p> <p>This class is distinct from the MultiAperture class in that the  sub-apertures are combined by mulitplying their respective tranmissions  together, ie the sub-apertures are overlapping.</p> <p>This class should not contain a MulitAperture, but MultiApertures can  contain CompoundApertures.</p> <p>A single aberrated aperture can be placed into the set of apertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/compound_aperture/#dLux.apertures.CompoundAperture.__init__","title":"<code>__init__(apertures, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), name='CompoundAperture')</code>","text":"<p>Constructor for the CompoundAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CompoundAperture'</code>"},{"location":"apertures/api/compound_aperture/#dLux.apertures.CompoundAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/hexagonal_aperture/","title":"Hexagonal Aperture","text":"<p>         Bases: <code>RegularPolygonalAperture</code></p> <p>A hexagonal aperture parameterised by the maximum radius to the vertices  from its center.</p> <p>Attributes:</p> Name Type Description <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/hexagonal_aperture/#dLux.apertures.HexagonalAperture.rmax","title":"<code>rmax: Array</code>  <code>class-attribute</code>","text":""},{"location":"apertures/api/hexagonal_aperture/#dLux.apertures.HexagonalAperture.__init__","title":"<code>__init__(rmax, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='HexagonalAperture')</code>","text":"<p>Constructor for the HexagonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'HexagonalAperture'</code>"},{"location":"apertures/api/hexagonal_aperture/#dLux.apertures.HexagonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/irregular_polygonal_aperture/","title":"Irregular Polygonal Aperture","text":"<p>         Bases: <code>PolygonalAperture</code></p> <p>An arbitrary aperture parameterised by a set of vertices.</p> <p>TODO: Check if the verticies need to be defined in a specific way, based on the methods this looks like the case (ie, ordered).</p> <p>Attributes:</p> Name Type Description <code>vertices</code> <code>Array, meters</code> <p>The location of the vertices of the aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/irregular_polygonal_aperture/#dLux.apertures.IrregularPolygonalAperture.vertices","title":"<code>vertices = np.array(vertices).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/irregular_polygonal_aperture/#dLux.apertures.IrregularPolygonalAperture.__init__","title":"<code>__init__(vertices, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='IrregularPolygonalAperture')</code>","text":"<p>Constructor for the IrregularPolygonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>Array</code> <p>The location of the vertices of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'IrregularPolygonalAperture'</code>"},{"location":"apertures/api/irregular_polygonal_aperture/#dLux.apertures.IrregularPolygonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/multi_aperture/","title":"Multi Aperture","text":"<p>         Bases: <code>CompositeAperture</code></p> <p>A  class used to combine multiple apertures into a single coherent aperture. An example would be an aperture mask.</p> <p>This class is distinct from the CompoundAperture class in that the  sub-apertures are combined by adding their respective tranmissions  together, ie the sub-apertures are not overlapping.</p> <p>This class can contain multiple CompoundApertures.</p> <p>Attributes:</p> Name Type Description <code>apertures</code> <code>dict(str, Aperture)</code> <p>The sub-apertures that make up the full aperture.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/multi_aperture/#dLux.apertures.MultiAperture.__init__","title":"<code>__init__(apertures, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), name='MultiAperture')</code>","text":"<p>Constructor for the MultiAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>apertures</code> <code>list</code> <p>The sub-apertures that make up the full aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'MultiAperture'</code>"},{"location":"apertures/api/multi_aperture/#dLux.apertures.MultiAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/rectangular_aperture/","title":"Rectangular Aperture","text":"<p>         Bases: <code>DynamicAperture</code></p> <p>A rectangular aperture parameterised by it height and width.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>Array, meters</code> <p>The length of the aperture in the y-direction. </p> <code>width</code> <code>Array, meters</code> <p>The length of the aperture in the x-direction. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/rectangular_aperture/#dLux.apertures.RectangularAperture.height","title":"<code>height = np.asarray(height).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/rectangular_aperture/#dLux.apertures.RectangularAperture.width","title":"<code>width = np.asarray(width).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/rectangular_aperture/#dLux.apertures.RectangularAperture.__init__","title":"<code>__init__(height, width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='RectangularAperture')</code>","text":"<p>Constructor for the RectangularAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>Array</code> <p>The length of the aperture in the y-direction.</p> required <code>width</code> <code>Array</code> <p>The length of the aperture in the x-direction.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'RectangularAperture'</code>"},{"location":"apertures/api/rectangular_aperture/#dLux.apertures.RectangularAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/regular_polygonal_aperture/","title":"Regular Polygonal Aperture","text":"<p>         Bases: <code>PolygonalAperture</code></p> <p>A regular polygonal aperture defined by its number of sides and the maximum  radius to the vertices from its center.</p> <p>Attributes:</p> Name Type Description <code>nsides</code> <code>int</code> <p>The number of sides of the aperture. </p> <code>rmax</code> <code>Array, meters</code> <p>The maximum radius to the vertices from its center.</p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/regular_polygonal_aperture/#dLux.apertures.RegularPolygonalAperture.nsides","title":"<code>nsides = int(nsides)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/regular_polygonal_aperture/#dLux.apertures.RegularPolygonalAperture.rmax","title":"<code>rmax = np.array(rmax).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/regular_polygonal_aperture/#dLux.apertures.RegularPolygonalAperture.__init__","title":"<code>__init__(nsides, rmax, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='RegularPolygonalAperture')</code>","text":"<p>Constructor for the RegularPolygonalAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>nsides</code> <code>int</code> <p>The number of sides of the aperture.</p> required <code>rmax</code> <code>Array</code> <p>The maximum radius to the vertices from its center.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'RegularPolygonalAperture'</code>"},{"location":"apertures/api/regular_polygonal_aperture/#dLux.apertures.RegularPolygonalAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/square_aperture/","title":"Square Aperture","text":"<p>         Bases: <code>DynamicAperture</code></p> <p>A square aperture parameterised by its width.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>Array, meters</code> <p>The side length of the aperture. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a tranmissive aperture, and True results in an occulting aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/square_aperture/#dLux.apertures.SquareAperture.width","title":"<code>width = np.asarray(width).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/square_aperture/#dLux.apertures.SquareAperture.__init__","title":"<code>__init__(width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), occulting=False, softening=np.array(1.0), name='SquareAperture')</code>","text":"<p>Constructor for the SquareAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>Array</code> <p>The side length of the aperture.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>occulting</code> <code>bool</code> <p>Is the aperture occulting or tranmissive. False results in a  tranmissive aperture, and True results in an occulting aperture.</p> <code>False</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'SquareAperture'</code>"},{"location":"apertures/api/square_aperture/#dLux.apertures.SquareAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/static_aberrated_aperture/","title":"Static Aberrated Aperture","text":"<p>         Bases: <code>AbstractAberratedAperture</code>, <code>AbstractStaticAperture</code></p> <p>A class for static pre-calculated apertures with aberrations. This  pre-calcaultes both the aperture and the basis at init time and can not  have the aperture properties optimised.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The aperture represented as an array.</p> <code>basis</code> <code>Array</code> <p>The basis represented as an array.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.basis","title":"<code>basis = aperture._basis(coordinates)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.opd","title":"<code>opd: Array</code>  <code>property</code>","text":"<p>Return the total optical path difference of the aperture aberrations.</p> <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the aperture to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is passing through the aperture.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront after passing through the aperture</p>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.__init__","title":"<code>__init__(aperture, npixels=None, diameter=None, coordinates=None, name='StaticAberratedAperture')</code>","text":"<p>Constructor for the StaticAberratedAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>An instance of AberratedAperture.</p> required <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> <code>None</code> <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> <code>None</code> <code>coordinates</code> <code>Array, meters</code> <p>The coordinate system to calculate the aperture on.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'StaticAberratedAperture'</code>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.get_basis","title":"<code>get_basis(**kwargs)</code>","text":"<p>Compute the basis vectors of the aperture aberrations.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the basis vectors of the aperture aberrations.</p>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.get_opd","title":"<code>get_opd(**kwargs)</code>","text":"<p>Compute the total optical path difference of the aperture aberrations.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> required <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> required <p>Returns:</p> Name Type Description <code>basis</code> <code>Array</code> <p>The array of the total opd of the aperture aberrations.</p>"},{"location":"apertures/api/static_aberrated_aperture/#dLux.apertures.StaticAberratedAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/static_aperture/","title":"Static Aperture","text":"<p>         Bases: <code>AbstractStaticAperture</code></p> <p>A class for static pre-calculated apertures, without aberrations. Static apertures with aberrations can be instantiated using the  StaticAberratedAberrated class.</p> <p>Attributes:</p> Name Type Description <code>aperture</code> <code>Array</code> <p>The aperture represented as an array.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/static_aperture/#dLux.apertures.StaticAperture.__init__","title":"<code>__init__(aperture, npixels=None, diameter=None, coordinates=None, name='StaticAperture')</code>","text":"<p>Constructor for the StaticAperture class.</p> <p>Parameters:</p> Name Type Description Default <code>aperture</code> <code>ApertureLayer</code> <p>An instance of DynamicAperture.</p> required <code>npixels</code> <code>int</code> <p>The number of pixels accross one edge of the aperture.</p> <code>None</code> <code>diameter</code> <code>float, meters</code> <p>The diameter of the aperture in meters.</p> <code>None</code> <code>coordinates</code> <code>Array, meters</code> <p>The coordinate system to calculate the aperture on.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'StaticAperture'</code>"},{"location":"apertures/api/static_aperture/#dLux.apertures.StaticAperture.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/api/uniform_spider/","title":"Uniform Spider","text":"<p>         Bases: <code>Spider</code></p> <p>A set of spider struts with equally-spaced, equal-width struts.</p> <p>Attributes:</p> Name Type Description <code>nstruts</code> <code>int</code> <p>The number of spider struts.</p> <code>strut_width</code> <code>Array, meters</code> <p>The width of each strut. </p> <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture. </p> <code>rotation</code> <code>Array, radians</code> <p>The clockwise rotation of the aperture.</p> <code>softening</code> <code>Array, pixels</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"apertures/api/uniform_spider/#dLux.apertures.UniformSpider.nstruts","title":"<code>nstruts = int(nstruts)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/uniform_spider/#dLux.apertures.UniformSpider.strut_width","title":"<code>strut_width = np.asarray(strut_width).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"apertures/api/uniform_spider/#dLux.apertures.UniformSpider.__init__","title":"<code>__init__(nstruts, strut_width, centre=np.array([0.0, 0.0]), shear=np.array([0.0, 0.0]), compression=np.array([1.0, 1.0]), rotation=np.array(0.0), softening=np.array(1.0), name='UniformSpider')</code>","text":"<p>Constructor for the UniformSpider class.</p> <p>Parameters:</p> Name Type Description Default <code>nstruts</code> <code>int</code> <p>The number of struts to equally space around the circle. This is not  a differentiable parameter.</p> required <code>strut_width</code> <code>Array</code> <p>The width of each strut.</p> required <code>centre</code> <code>Array</code> <p>The (x, y) coordinates of the centre of the aperture.</p> <code>np.array([0.0, 0.0])</code> <code>shear</code> <code>Array</code> <p>The (x, y) linear shear of the aperutre.</p> <code>np.array([0.0, 0.0])</code> <code>compression</code> <code>Array</code> <p>The (x, y) compression of the aperture.</p> <code>np.array([1.0, 1.0])</code> <code>rotation</code> <code>Array</code> <p>The clockwise rotation of the aperture.</p> <code>np.array(0.0)</code> <code>softening</code> <code>Array</code> <p>The approximate pixel width of the soft boundary applied to the  aperture. Hard edges can be achieved by setting the softening to 0.</p> <code>np.array(1.0)</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'UniformSpider'</code>"},{"location":"apertures/api/uniform_spider/#dLux.apertures.UniformSpider.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"apertures/assets/aberrated_apertures/","title":"Aberrated apertures","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport dLux\nimport jax.numpy as np\n</pre> import matplotlib as mpl import matplotlib.pyplot as plt import dLux import jax.numpy as np In\u00a0[\u00a0]: Copied! <pre>mpl.rcParams[\"image.cmap\"] = \"seismic\"\nmpl.rcParams[\"text.usetex\"] = True\n</pre> mpl.rcParams[\"image.cmap\"] = \"seismic\" mpl.rcParams[\"text.usetex\"] = True In\u00a0[\u00a0]: Copied! <pre>width: float = 2.\npixels: int = 128\ncoords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels)\n</pre> width: float = 2. pixels: int = 128 coords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels) In\u00a0[\u00a0]: Copied! <pre>nvecs: int = 6\nnolls: int = np.arange(1, nvecs, dtype=int)\ncoeff: float = np.ones(nvecs, dtype=float)\n</pre> nvecs: int = 6 nolls: int = np.arange(1, nvecs, dtype=int) coeff: float = np.ones(nvecs, dtype=float) In\u00a0[\u00a0]: Copied! <pre>aps = [\n    dLux.AberratedAperture(nolls, coeff, dLux.CircularAperture(1.)),\n    dLux.AberratedAperture(nolls, coeff, dLux.HexagonalAperture(1.)),\n]\n</pre> aps = [     dLux.AberratedAperture(nolls, coeff, dLux.CircularAperture(1.)),     dLux.AberratedAperture(nolls, coeff, dLux.HexagonalAperture(1.)), ] In\u00a0[\u00a0]: Copied! <pre>naps: int = len(aps)\nfig: object = plt.figure()\nfigs: object = fig.subfigures(naps, 1)\n</pre> naps: int = len(aps) fig: object = plt.figure() figs: object = fig.subfigures(naps, 1) In\u00a0[\u00a0]: Copied! <pre>for i in range(naps):\n    axes: object = figs[i].subplots(1, nvecs)\n    basis: float = aps[i]._basis(coords)\n\n    for j in range(nvecs):\n        axes[j].imshow(basis[j], vmin=basis.min(), vmax=basis.max())\n        axes[j].set_xticks([])\n        axes[j].set_yticks([])\n        axes[j].axis(\"off\")\n</pre> for i in range(naps):     axes: object = figs[i].subplots(1, nvecs)     basis: float = aps[i]._basis(coords)      for j in range(nvecs):         axes[j].imshow(basis[j], vmin=basis.min(), vmax=basis.max())         axes[j].set_xticks([])         axes[j].set_yticks([])         axes[j].axis(\"off\") In\u00a0[\u00a0]: Copied! <pre>fig.savefig(\"docs/apertures/assets/aberrated_apertures.png\")\nplt.show()\n</pre> fig.savefig(\"docs/apertures/assets/aberrated_apertures.png\") plt.show()"},{"location":"apertures/assets/apertures/","title":"Apertures","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport dLux\n</pre> import matplotlib as mpl import matplotlib.pyplot as plt import dLux In\u00a0[\u00a0]: Copied! <pre>mpl.rcParams[\"image.cmap\"] = \"Greys\"\nmpl.rcParams[\"text.usetex\"] = True\n</pre> mpl.rcParams[\"image.cmap\"] = \"Greys\" mpl.rcParams[\"text.usetex\"] = True In\u00a0[\u00a0]: Copied! <pre>width: float = 2.\npixels: int = 128\ncoords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels)\n</pre> width: float = 2. pixels: int = 128 coords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels) In\u00a0[\u00a0]: Copied! <pre>aps = [\n    dLux.CircularAperture(1.),\n    dLux.SquareAperture(1.),\n    dLux.RectangularAperture(1., .5),\n    dLux.HexagonalAperture(1.),\n    dLux.AnnularAperture(1., .5),\n    dLux.RegularPolygonalAperture(9, 1.),\n]\n</pre> aps = [     dLux.CircularAperture(1.),     dLux.SquareAperture(1.),     dLux.RectangularAperture(1., .5),     dLux.HexagonalAperture(1.),     dLux.AnnularAperture(1., .5),     dLux.RegularPolygonalAperture(9, 1.), ] In\u00a0[\u00a0]: Copied! <pre>shape: int = len(aps)\nfig: object = plt.figure(figsize=(shape, 1))\naxes: object = fig.subplots(1, shape)\n</pre> shape: int = len(aps) fig: object = plt.figure(figsize=(shape, 1)) axes: object = fig.subplots(1, shape) In\u00a0[\u00a0]: Copied! <pre>for i in range(shape):\n    axes[i].imshow(aps[i]._aperture(coords))\n    axes[i].set_xticks([])\n    axes[i].set_yticks([])\n</pre> for i in range(shape):     axes[i].imshow(aps[i]._aperture(coords))     axes[i].set_xticks([])     axes[i].set_yticks([]) In\u00a0[\u00a0]: Copied! <pre>fig.savefig(\"docs/apertures/assets/apertures.png\")\nplt.show()\n</pre> fig.savefig(\"docs/apertures/assets/apertures.png\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"apertures/assets/circles/","title":"Circles","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib as mpl \nimport matplotlib.pyplot as plt \nimport dLux\n</pre> import matplotlib as mpl  import matplotlib.pyplot as plt  import dLux In\u00a0[\u00a0]: Copied! <pre>mpl.rcParams[\"image.cmap\"] = \"Greys\"\n</pre> mpl.rcParams[\"image.cmap\"] = \"Greys\" In\u00a0[\u00a0]: Copied! <pre>width: float = 2.\npixels: int = 32\ncoords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels)\n</pre> width: float = 2. pixels: int = 32 coords: float = dLux.utils.get_pixel_coordinates(pixels, width / pixels) In\u00a0[\u00a0]: Copied! <pre>aps = [\n    dLux.CircularAperture(1.),\n    dLux.CircularAperture(1., centre=[.5, .5]),\n    dLux.CircularAperture(1., strain=[.05, .05]),\n    dLux.CircularAperture(1., compression=[1.05, .95]),\n    dLux.CircularAperture(1., softening=True),\n    dLux.CircularAperture(1., occulting=True)\n]\n</pre> aps = [     dLux.CircularAperture(1.),     dLux.CircularAperture(1., centre=[.5, .5]),     dLux.CircularAperture(1., strain=[.05, .05]),     dLux.CircularAperture(1., compression=[1.05, .95]),     dLux.CircularAperture(1., softening=True),     dLux.CircularAperture(1., occulting=True) ] In\u00a0[\u00a0]: Copied! <pre>shape: int = len(aps)\nfig: object = plt.figure(figsize=(shape*4, 3))\naxes: object = fig.subplots(1, shape)\n</pre> shape: int = len(aps) fig: object = plt.figure(figsize=(shape*4, 3)) axes: object = fig.subplots(1, shape) In\u00a0[\u00a0]: Copied! <pre>for i in range(shape):\n    axes[i].imshow(aps[i]._aperture(coords))\n    axes[i].set_yticks([])\n    axes[i].set_xticks([])\n</pre> for i in range(shape):     axes[i].imshow(aps[i]._aperture(coords))     axes[i].set_yticks([])     axes[i].set_xticks([]) In\u00a0[\u00a0]: Copied! <pre>fig.savefig(\"docs/apertures/assets/circles.png\")\nplt.show()\n</pre> fig.savefig(\"docs/apertures/assets/circles.png\") plt.show()"},{"location":"core/detector/","title":"Detector","text":"<p>         Bases: <code>Base</code></p> <p>A high level class desgined to model the behaviour of some detectors response to some psf.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>dict</code> <p>A collections.OrderedDict of 'layers' that define the transformations and operations upon some input psf as it interacts with the detector.</p>"},{"location":"core/detector/#dLux.core.Detector.layers","title":"<code>layers = dLux.utils.list_to_dictionary(layers)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/detector/#dLux.core.Detector.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the layers dictionary of this class via the 'class.attribute' method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p>"},{"location":"core/detector/#dLux.core.Detector.__init__","title":"<code>__init__(layers)</code>","text":"<p>Constructor for the Detector class.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>An list of dLux detector layer classes that define the instrumental effects for some detector.</p> required"},{"location":"core/detector/#dLux.core.Detector.apply_detector","title":"<code>apply_detector(image)</code>","text":"<p>Applied the stored detector layers to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The input 'image' to the detector to be transformed.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The ouput 'image' after being transformed by the detector layers.</p>"},{"location":"core/detector/#dLux.core.Detector.debug_apply_detector","title":"<code>debug_apply_detector(image)</code>","text":"<p>Applied the stored detector layers to the input image, storing and returning the intermediate states of the image and layers.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The input 'image' to the detector to be transformed.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The ouput 'image' after being transformed by the detector layers.</p> <code>intermediate_images</code> <code>list</code> <p>The intermediate states of the image.</p> <code>intermediate_layers</code> <code>list</code> <p>The intermediate states of each layer after being applied to the image.</p>"},{"location":"core/detector/#dLux.core.Detector.model","title":"<code>model(optics, **kwargs)</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>filter</code> <code>Filter</code> <p>The filter through which the source is being observed. Defaults to the internally stored value.</p> required <code>scene</code> <code>Scene</code> <p>The scene to observe. Defaults to the internally stored value.</p> required <code>sources</code> <code>Union[dict, list, tuple) </code> <p>The sources to observe.</p> required <code>source</code> <code>dLux.sources.Source</code> <p>The source to observe.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> required <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> required <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/detector/#dLux.core.Detector.plot","title":"<code>plot(image)</code>","text":"<p>Prints the summary of all the layers and then plots a image as it propagates through the detector layer.</p> <p>Parameters:</p> Name Type Description Default <code>iamge</code> <code>Array</code> <p>The image to propagate through the detector.</p> required"},{"location":"core/detector/#dLux.core.Detector.summarise","title":"<code>summarise()</code>","text":"<p>Prints a summary of all the layers in the detector.</p>"},{"location":"core/filter/","title":"Filter","text":"<p>         Bases: <code>Base</code></p> <p>A class for modelling optical filters.</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array</code> <p>The wavelengths at which the filter is defined.</p> <code>throughput</code> <code>Array</code> <p>The throughput of the filter at the corresponding wavelength.</p> <code>filter_name</code> <code>str</code> <p>A string identifier that can be used to initialise specific filters.</p>"},{"location":"core/filter/#dLux.core.Filter.filter_name","title":"<code>filter_name: str</code>  <code>class-attribute</code>","text":""},{"location":"core/filter/#dLux.core.Filter.throughput","title":"<code>throughput: Array</code>  <code>class-attribute</code>","text":""},{"location":"core/filter/#dLux.core.Filter.wavelengths","title":"<code>wavelengths: Array</code>  <code>class-attribute</code>","text":""},{"location":"core/filter/#dLux.core.Filter.__init__","title":"<code>__init__(wavelengths=None, throughput=None, filter_name=None)</code>","text":"<p>Constructor for the Filter class. All inputs are optional and defaults to uniform unitary throughput. If filter_name is specified then wavelengths and weights must not be specified.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array</code> <p>The wavelengths at which the filter is defined.</p> <code>None</code> <code>throughput</code> <code>Array</code> <p>The throughput of the filter at the corresponding wavelength.</p> <code>None</code> <code>filter_name</code> <code>str</code> <p>A string identifier that can be used to initialise specific filters. Currently no pre-built filters are implemented.</p> <code>None</code>"},{"location":"core/filter/#dLux.core.Filter.get_throughput","title":"<code>get_throughput(sample_wavelenghts)</code>","text":"<p>Gets the average throughput of the bandpass defined the the differences between each sample wavelength, ie if sample wavelengths are:     [10, 20, 30, 40], the bandpasses for each sample wavelength will be     [5-15, 15-25, 25-30, 35-40]. The throughput is calculated as the average throughput over that bandpass.</p> <p>Parameters:</p> Name Type Description Default <code>sample_wavelengths</code> <code>Array, meters</code> <p>The wavelengths at which to sample the filter. Must contain at least two values.</p> required <p>Returns:</p> Name Type Description <code>throughputs</code> <code>Array</code> <p>The average throughput for each bandpass defined by sample_wavelengths.</p>"},{"location":"core/filter/#dLux.core.Filter.model","title":"<code>model(optics, **kwargs)</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector to use with the observation. Defaults to the internally stored value.</p> required <code>scene</code> <code>Scene</code> <p>The scene to observe. Defaults to the internally stored value.</p> required <code>sources</code> <code>Union[dict, list, tuple) </code> <p>The sources to observe.</p> required <code>source</code> <code>dLux.sources.Source</code> <p>The source to observe.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> required <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> required <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/instrument/","title":"Instrument","text":"<p>         Bases: <code>Base</code></p> <p>A high level class desgined to model the behaviour of a telescope. It stores a series different \u2202Lux objects, and primarily passes the relevant information between these objects in order to coherently model some telescope observation.</p> <p>Attributes:</p> Name Type Description <code>optics</code> <code>Optics</code> <p>A Optics object that defines some optical configuration.</p> <code>sources</code> <code>Scene</code> <p>A Scene that stores the various source objects that the instrument is observing.</p> <code>detector</code> <code>Detector</code> <p>A Detector object that is used to model the various instrumental effects on a psf.</p> <code>filter</code> <code>Filter</code> <p>A Filter object that is used to model the effective throughput of each wavelength though the optical system.</p> <code>observation</code> <code>Observation</code> <p>An class that inherits from Observation. This is to allow flexibility in the different kind of observations, ie applying dithers, switching filters, etc.</p>"},{"location":"core/instrument/#dLux.core.Instrument.detector","title":"<code>detector: Detector</code>  <code>class-attribute</code>","text":""},{"location":"core/instrument/#dLux.core.Instrument.filter","title":"<code>filter: Filter</code>  <code>class-attribute</code>","text":""},{"location":"core/instrument/#dLux.core.Instrument.observation","title":"<code>observation: Observation</code>  <code>class-attribute</code>","text":""},{"location":"core/instrument/#dLux.core.Instrument.optics","title":"<code>optics: Optics</code>  <code>class-attribute</code>","text":""},{"location":"core/instrument/#dLux.core.Instrument.scene","title":"<code>scene: Scene</code>  <code>class-attribute</code>","text":""},{"location":"core/instrument/#dLux.core.Instrument.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the sub-dictionaries of this class via the 'class.attribute' method. It is recommended that each dictionary key in the optical layers, detector layers, and scene sources are unique to prevent unexpected behaviour. In the case they there are idenitcal keys across the dictionaries This method prioritises searching for keys in the optical layers, then detector layers, and then the scene sources.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the sub-dictionaries.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the sub-dictionaries.</p>"},{"location":"core/instrument/#dLux.core.Instrument.__init__","title":"<code>__init__(optics=None, scene=None, detector=None, filter=None, optical_layers=None, sources=None, detector_layers=None, observation=None)</code>","text":"<p>Constructor for the Instrument class.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>A pre-configured Optics object. Can not be specified if optical layers in specified.</p> <code>None</code> <code>optical_layers</code> <code>list</code> <p>A list of dLux optical layer classes that define the optical transformations within some optical configuration. Can not be specified if optics is specified.</p> <code>None</code> <code>scene</code> <code>Scene</code> <p>A pre-configured Scene object. Can not be specified if sources is specified.</p> <code>None</code> <code>sources</code> <code>list</code> <p>A list of dLux source objects that the telescope is observing.</p> <code>None</code> <code>detector</code> <code>Detector</code> <p>A pre-configured Detector object. Can not be specified if detector_layers is specified.</p> <code>None</code> <code>detector_layers</code> <code>list</code> <p>An list of dLux detector layer classes that define the instrumental effects for some detector. Can not be specified if detector is specified.</p> <code>None</code> <code>filter</code> <code>Filter</code> <p>A Filter object that is used to model the effective throughput of each wavelength though the Instrument.</p> <code>None</code> <code>observation</code> <code>Observation</code> <p>An class that inherits from Observation. This is to allow flexibility in the different kind of observations, ie applying dithers, switching filters, etc.</p> <code>None</code>"},{"location":"core/instrument/#dLux.core.Instrument.model","title":"<code>model(**kwargs)</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects. Defaults to the internally stored value.</p> required <code>detector</code> <code>Detector</code> <p>The detector to use with the observation. Defaults to the internally stored value.</p> required <code>filter</code> <code>Filter</code> <p>The filter through which the source is being observed. Defaults to the internally stored value.</p> required <code>scene</code> <code>Scene</code> <p>The scene to observe. Defaults to the internally stored value.</p> required <code>sources</code> <code>Union[dict, list, tuple) </code> <p>The sources to observe.</p> required <code>source</code> <code>dLux.sources.Source</code> <p>The source to observe.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> required <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> required <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/instrument/#dLux.core.Instrument.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the internally stored scene by calling the scene.normalise() method.</p> <p>Returns:</p> Name Type Description <code>instrument</code> <code>Instrument</code> <p>A new version of the instrument with the interally stored scene normalised.</p>"},{"location":"core/instrument/#dLux.core.Instrument.observe","title":"<code>observe(**kwargs)</code>","text":"<p>TODO: Update docstring Calls the stored observation class.</p> <p>Returns:</p> Type Description <p>The output of the stored observation class.</p>"},{"location":"core/instrument/#dLux.core.Instrument.plot","title":"<code>plot(wavelength, offset=np.zeros(2))</code>","text":"<p>Prints the summary of all the planes and then plots a wavefront as it propagates through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>np.zeros(2)</code>"},{"location":"core/instrument/#dLux.core.Instrument.summarise","title":"<code>summarise()</code>","text":"<p>Prints a summary of all instrument</p>"},{"location":"core/model/","title":"model","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector to use with the observation.</p> <code>None</code> <code>filter</code> <code>Filter</code> <p>The filter through which the source is being observed.</p> <code>None</code> <code>scene</code> <code>Scene</code> <p>The scene to observe.</p> <code>None</code> <code>sources</code> <code>Union[dict, list) </code> <p>The sources to observe.</p> <code>None</code> <code>source</code> <code>dLux.sources.Source</code> <p>The source to observe.</p> <code>None</code> <code>normalise</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> <code>True</code> <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> <code>False</code> <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/optical_system/","title":"Optical System (depreceated)","text":"<p>         Bases: <code>Base</code></p> <p>Optical System class, Equinox Modle</p> <p>DOCSTRING NOT COMPLETE</p> <p>A Class to store and apply properties external to the optical system Ie: stellar positions and spectra</p> <p>positions: (Nstars, 2) array wavels: (Nwavels) array weights: (Nwavel)/(Nwavels, Nstars) array</p> <p>dLux currently does not check that inputs are correctly shaped/formatted!</p> <p>Notes:  - Take in layers in order to re-intialise the model every call?</p> <p>General images output shape: (Nimages, Nstars, Nwavels, Npix, Npix)</p> <ul> <li>Currently doesnt allow temporal variation in spectrum </li> <li>Currently doesnt allow temporal variation in flux</li> </ul> <p>ToDo: Add getter methods for accessing weights and fluxes attributes that use np.squeeze to remove empy axes</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>list, required</code> <ul> <li>A list of layers that defines the tranformaitons and operations of the system (typically optical)</li> </ul> <code>wavels</code> <code>ndarray</code> <ul> <li>An array of wavelengths in meters to simulate</li> <li>The shape must be 1d - stellar spectrums are controlled through the weights parameter</li> <li>No default value is set if not provided and this will throw an error if you try to call functions that depend on this parameter</li> <li>It is left as optional so that functions that allow wavelength input can be called on objects without having to pre-input wavelengths</li> </ul> <code>positions</code> <code>ndarray, optional</code> <ul> <li>An array of (x,y) stellar positions in units of radians, measured as deviation of the optical axis. </li> <li>Its input shape should be (Nstars, 2), defining an x, y position for each star. </li> <li>If not provided, the value defaults to (0, 0) - on axis</li> </ul> <code>fluxes</code> <code>ndarray, optional</code> <ul> <li>An array of stellar fluxes, its length must match the positions inputs size to work properly</li> <li>Theoretically this has arbitrary units, but we think of it as photons</li> <li>Defaults to 1 (ie, returning a unitary flux psf if not specified)</li> </ul> <code>weights</code> <code>ndarray, optional</code> <ul> <li>An array of stellar spectral weights (arb units)</li> <li>This can take multiple shapes</li> <li>Default is to weight all wavelengths equally (top-hat)</li> <li>If a 1d array is provided this is applied to all stars, shape (Nwavels)</li> <li>if a 2d array is provided each is applied to each individual star, shape (Nstars, Nwavels)</li> <li>Note the inputs values are always normalised and will not directly change total output flux (inderectly it can change it by weighting more flux to wavelengths with more aperture losses, for example)</li> </ul> <code>dithers</code> <code>ndarray, optional</code> <ul> <li>An arary of (x, y) positional dithers in units of radians</li> <li>Its input shape should be (Nims, 2), defining the (x,y) dither for each image</li> <li>if not provided, defualts to no-dither</li> </ul> <code>detector_layers</code> <code>list, optional</code> <ul> <li>A second list of layer objects designed to allow processing of psfs, rather than wavefronts</li> <li>It is applied to each image after psfs have been approraitely weighted and summed</li> </ul>"},{"location":"core/optical_system/#dLux.core.OpticalSystem.Nims","title":"<code>Nims = len(self.dithers)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.Nstars","title":"<code>Nstars = len(self.positions)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.Nwavels","title":"<code>Nwavels = len(self.wavels)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.detector_layers","title":"<code>detector_layers = [] if detector_layers is None else detector_layers</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.dithers","title":"<code>dithers = np.zeros([1, 2]) if dithers is None else dithers</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.fluxes","title":"<code>fluxes = np.ones(len(self.positions)) if fluxes is None else np.array(fluxes)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.layers","title":"<code>layers = layers</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.positions","title":"<code>positions = np.zeros([1, 2]) if positions is None else np.array(positions)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.wavels","title":"<code>wavels = np.array(wavels).astype(float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.weights","title":"<code>weights = np.ones(len(self.wavels)) if weights is None else np.array(weights)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.__init__","title":"<code>__init__(layers, wavels, positions=None, fluxes=None, weights=None, dithers=None, detector_layers=None)</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.apply_detector_layers","title":"<code>apply_detector_layers(image)</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.debug_prop","title":"<code>debug_prop(wavel, offset=np.zeros(2))</code>","text":"<p>I believe this is diffable but there is no reason to force it to be</p>"},{"location":"core/optical_system/#dLux.core.OpticalSystem.dither_positions","title":"<code>dither_positions()</code>","text":"<p>Dithers the input positions, returned with shape (Npsfs, 2)</p>"},{"location":"core/optical_system/#dLux.core.OpticalSystem.propagate","title":"<code>propagate()</code>","text":"<p>Maps the wavelength and position calcualtions across multiple dimesions</p> <p>To Do: Reformat the vmaps such that we only vmap over wavelengths and positions in order to simplify the dimensionality</p>"},{"location":"core/optical_system/#dLux.core.OpticalSystem.propagate_mono","title":"<code>propagate_mono(wavel, offset=np.zeros(2))</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.propagate_single","title":"<code>propagate_single(wavels, offset=np.zeros(2), weights=1.0, flux=1.0, apply_detector=False)</code>","text":"<p>Only propagates a single star, allowing wavelength input sums output to single array</p> <p>Wavels must be an array and the same shape as weights if provided</p>"},{"location":"core/optical_system/#dLux.core.OpticalSystem.reshape_psfs","title":"<code>reshape_psfs(psfs)</code>","text":""},{"location":"core/optical_system/#dLux.core.OpticalSystem.weight_psfs","title":"<code>weight_psfs(psfs)</code>","text":"<p>Normalise Weights, and format weights/fluxes Psfs output shape: (Nims, Nstars, Nwavels, npix, npix) We want weights shape: (1, 1, Nwavels, 1, 1) We want fluxes shape: (1, Nstars, 1, 1, 1)</p>"},{"location":"core/optics/","title":"Optics","text":"<p>         Bases: <code>Base</code></p> <p>A high level class desgined to model the behaviour of some optical systems response to wavefronts.</p> <p>Attributes:</p> Name Type Description <code>layers</code> <code>dict</code> <p>A collections.OrderedDict of 'layers' that define the transformations and operations upon some input wavefront through an optical system.</p>"},{"location":"core/optics/#dLux.core.Optics.layers","title":"<code>layers = dLux.utils.list_to_dictionary(layers)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/optics/#dLux.core.Optics.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the layers dictionary of this class via the 'class.attribute' method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the layers dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the layers dictionary.</p>"},{"location":"core/optics/#dLux.core.Optics.__init__","title":"<code>__init__(layers)</code>","text":"<p>Constructor for the Optics class.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>A list of \u2202Lux 'layers' that define the transformations and operations upon some input wavefront through an optical system.</p> required"},{"location":"core/optics/#dLux.core.Optics.debug_prop","title":"<code>debug_prop(wavelength, offset=np.zeros(2), weight=np.array(1.0))</code>","text":"<p>Propagates a monochromatic point source through the optical layers, while also returning the intermediate state of the parameter dictionary and layers after each layer application.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>weight</code> <code>Array</code> <p>The relative weighting of the wavelength. Simply scales the output psf.</p> <code>np.array(1.0)</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p> <code>intermediate_dicts</code> <code>list</code> <p>The intermediate states of the parameters dictionary.</p> <code>intermediate_layers</code> <code>list</code> <p>The intermediate states of each layer after being applied to the wavefront.</p>"},{"location":"core/optics/#dLux.core.Optics.get_planes","title":"<code>get_planes()</code>","text":"<p>Breaks the optical layers into planes, where each plane is a list of layers.</p> <p>Returns:</p> Name Type Description <code>planes</code> <code>list</code> <p>A list of lists, with the inner lists being optical layers, and the outer list being planes.</p>"},{"location":"core/optics/#dLux.core.Optics.model","title":"<code>model(**kwargs)</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>detector</code> <code>Detector</code> <p>The detector to use with the observation. Defaults to the internally stored value.</p> required <code>filter</code> <code>Filter</code> <p>The filter through which the source is being observed. Defaults to the internally stored value.</p> required <code>scene</code> <code>Scene</code> <p>The scene to observe. Defaults to the internally stored value.</p> required <code>sources</code> <code>Union[dict, list, tuple) </code> <p>The sources to observe.</p> required <code>source</code> <code>dLux.sources.Source</code> <p>The source to observe.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> required <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> required <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/optics/#dLux.core.Optics.plot","title":"<code>plot(wavelength, offset=np.zeros(2))</code>","text":"<p>Prints the summary of all the planes and then plots a wavefront as it propagates through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source.</p> <code>np.zeros(2)</code> <p>Returns:</p> Name Type Description <code>wf</code> <code>Wavefront</code> <p>The final wavefront after being propagated through the optical layers.</p>"},{"location":"core/optics/#dLux.core.Optics.propagate_mono","title":"<code>propagate_mono(wavelength, offset=np.zeros(2), weight=np.array(1.0))</code>","text":"<p>Propagates a monochromatic point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>weight</code> <code>Array</code> <p>The relative weighting of the wavelength. Simply scales the output psf.</p> <code>np.array(1.0)</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The monochromatic point spread function after being propagated though the optical layers.</p>"},{"location":"core/optics/#dLux.core.Optics.propagate_multi","title":"<code>propagate_multi(wavelengths, offset=np.zeros(2), weights=None)</code>","text":"<p>Propagates a broadband point source through the optical layers.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The wavelengths of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source. Default value is (0, 0), on axis.</p> <code>np.zeros(2)</code> <code>weights</code> <code>Array</code> <p>The relative weighting of the wavelengths. Simply scales the output psf.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The broadband point spread function after being propagated though the optical layers.</p>"},{"location":"core/optics/#dLux.core.Optics.summarise","title":"<code>summarise()</code>","text":"<p>Prints a summary of all the planes in the optical system.</p>"},{"location":"core/scene/","title":"Scene","text":"<p>         Bases: <code>Base</code></p> <p>A high level class representing some 'astrophysical scene', which is composed of dLux.sources.Sources.</p> <p>Attributes:</p> Name Type Description <code>sources</code> <code>dict</code> <p>A dictionary containing all the of sources that comprise the astrophysical scene.</p>"},{"location":"core/scene/#dLux.core.Scene.sources","title":"<code>sources = dLux.utils.list_to_dictionary(sources, ordered=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"core/scene/#dLux.core.Scene.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Magic method designed to allow accessing of the various items within the sources dictionary of this class via the 'class.attribute' method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the item to be searched for in the sources dictionary.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>object</code> <p>The item corresponding to the supplied key in the sources dictionary.</p>"},{"location":"core/scene/#dLux.core.Scene.__init__","title":"<code>__init__(sources)</code>","text":"<p>Constructor for the Scene class.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>list</code> <p>a list of individual source objects that is automatically converted into a dictionary</p> required"},{"location":"core/scene/#dLux.core.Scene.model","title":"<code>model(optics, **kwargs)</code>","text":"<p>A base level modelling function designed to robustly handle the different combinations of inputs. Models the sources through the instrument optics and detector. Users must provide optics and some form of source, either via a scene, sources or single source input, but not multiple.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects. Defaults to the internally stored value.</p> required <code>detector</code> <code>Detector</code> <p>The detector to use with the observation. Defaults to the internally stored value.</p> required <code>filter</code> <code>Filter</code> <p>The filter through which the source is being observed. Defaults to the internally stored value.</p> required <code>normalise_sources</code> <code>bool</code> <p>Whether to normalise the sources before modelling. Default is True.</p> required <code>flatten</code> <code>bool</code> <p>Whether the output image should be flattened. Default is False.</p> required <code>return_tree</code> <code>bool</code> <p>Whether to return a Pytree like object with matching tree structure as the input scene/sources/source. Default is False.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array, Pytree</code> <p>The image of the scene modelled through the optics with detector and filter effects applied if they are supplied. Returns either as a single array (if return_tree is false), or a pytree like object with matching tree strucutre as the input scene/sources/source.</p>"},{"location":"core/scene/#dLux.core.Scene.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the internally stores sources of the scene.</p> <p>Returns:</p> Name Type Description <code>scene</code> <code>Scene</code> <p>A new version of the scene with the interally stored sources normalised.</p>"},{"location":"core/scene/#dLux.core.Scene.plot","title":"<code>plot()</code>","text":"<p>Prints the summary of all the planes and then plots a wavefront as it propagates through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront to propagate through the optical layers.</p> required <code>offset</code> <code>Array, radians</code> <p>The (x, y) offset from the optical axis of the source.</p> required"},{"location":"core/scene/#dLux.core.Scene.summarise","title":"<code>summarise()</code>","text":"<p>Prints a summary of all the Scene.</p>"},{"location":"detectors/add_constant/","title":"Add Constant","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Add a constant to the output image. This is typically used to model the mean value of the detector noise.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>Array</code> <p>The value to add to the image.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"detectors/add_constant/#dLux.detectors.AddConstant.value","title":"<code>value = np.asarray(value, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/add_constant/#dLux.detectors.AddConstant.__call__","title":"<code>__call__(image)</code>","text":"<p>Adds the value to the input image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to add the value to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the value added.</p>"},{"location":"detectors/add_constant/#dLux.detectors.AddConstant.__init__","title":"<code>__init__(value, name='AddConstant')</code>","text":"<p>Constructor for the AddConstant class.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Array</code> <p>The value to add to the image.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddConstant'</code>"},{"location":"detectors/add_constant/#dLux.detectors.AddConstant.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"detectors/apply_jitter/","title":"Apply Jitter","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Convolves the image with a gaussian kernel parameterised by the standard deviation (sigma).</p> <p>Attributes:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the guassian kernel, in units of pixels.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.kernel_size","title":"<code>kernel_size = int(kernel_size)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.sigma","title":"<code>sigma = np.asarray(sigma, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.__call__","title":"<code>__call__(image)</code>","text":"<p>Convolves the input image with the generate gaussian kernel.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to convolve with the gussian kernel.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the gaussian kernel convolution applied.</p>"},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.__init__","title":"<code>__init__(sigma, kernel_size=10, name='ApplyJitter')</code>","text":"<p>Constructor for the ApplyJitter class.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>Array, pixels</code> <p>The standard deviation of the guassian kernel, in units of pixels.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the convolution kernel to use.</p> <code>10</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyJitter'</code>"},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.generate_kernel","title":"<code>generate_kernel()</code>","text":"<p>Generates the normalised guassian kernel.</p> <p>Returns:</p> Name Type Description <code>kernel</code> <code>Array</code> <p>The gaussian kernel.</p>"},{"location":"detectors/apply_jitter/#dLux.detectors.ApplyJitter.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"detectors/apply_pixel_response/","title":"Apply Pixel Response","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Applies a pixel response array to the the input image, via a multiplication.</p> <p>Attributes:</p> Name Type Description <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"detectors/apply_pixel_response/#dLux.detectors.ApplyPixelResponse.pixel_response","title":"<code>pixel_response = np.asarray(pixel_response, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/apply_pixel_response/#dLux.detectors.ApplyPixelResponse.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the pixel response to the input image, via a multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to apply the pixel_response to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the pixel_response applied.</p>"},{"location":"detectors/apply_pixel_response/#dLux.detectors.ApplyPixelResponse.__init__","title":"<code>__init__(pixel_response, name='ApplyPixelResponse')</code>","text":"<p>Constructor for the ApplyPixelResponse class.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_response</code> <code>Array</code> <p>The pixel_response to apply to the input image. Must be a 2 dimensional array equal to size of the image at time of application.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyPixelResponse'</code>"},{"location":"detectors/apply_pixel_response/#dLux.detectors.ApplyPixelResponse.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"detectors/apply_saturation/","title":"Apply Saturation","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Applies a simple saturation model to the input image, by clipping any values above saturation, to saturation.</p> <p>Attributes:</p> Name Type Description <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"detectors/apply_saturation/#dLux.detectors.ApplySaturation.saturation","title":"<code>saturation = np.asarray(saturation, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/apply_saturation/#dLux.detectors.ApplySaturation.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the satuation effect by reducing all values in the image above saturation, to the saturation value.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to apply the saturation to.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The image with the saturation applied.</p>"},{"location":"detectors/apply_saturation/#dLux.detectors.ApplySaturation.__init__","title":"<code>__init__(saturation, name='ApplySaturation')</code>","text":"<p>Constructor for the ApplySaturation class.</p> <p>Parameters:</p> Name Type Description Default <code>saturation</code> <code>Array</code> <p>The value at which the saturation is applied.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplySaturation'</code>"},{"location":"detectors/apply_saturation/#dLux.detectors.ApplySaturation.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"detectors/integer_downsample/","title":"Integer Downsample","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Downsamples an input image by an integer number of pixels via a sum. The number of pixels in the input image must by integer divisible by the kernel_size.</p> <p>Attributes:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"detectors/integer_downsample/#dLux.detectors.IntegerDownsample.kernel_size","title":"<code>kernel_size = int(kernel_size)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/integer_downsample/#dLux.detectors.IntegerDownsample.__call__","title":"<code>__call__(image)</code>","text":"<p>Downsamples the input image by the internally stored kernel_size.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to downsample.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The downsampled image.</p>"},{"location":"detectors/integer_downsample/#dLux.detectors.IntegerDownsample.__init__","title":"<code>__init__(kernel_size, name='IntegerDownsample')</code>","text":"<p>Constructor for the IntegerDownsample class.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the downsampling kernel.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'IntegerDownsample'</code>"},{"location":"detectors/integer_downsample/#dLux.detectors.IntegerDownsample.downsample","title":"<code>downsample(array, kernel_size)</code>","text":"<p>Downsamples the input array by kernel_size.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to downsample.</p> required <p>Returns:</p> Name Type Description <code>kernel_size</code> <code>int</code> <p>The size of the downsample kernel.</p>"},{"location":"detectors/integer_downsample/#dLux.detectors.IntegerDownsample.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"detectors/rotate/","title":"Rotate","text":"<p>         Bases: <code>DetectorLayer</code></p> <p>Applies a rotation to the image using interpolation methods.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required <code>fourier</code> <code>bool</code> <p>Should the rotation be done using fourier methods or interpolation.</p> <code>False</code> <code>padding</code> <code>int</code> <p>The amount of padding to use if the fourier method is used.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code>"},{"location":"detectors/rotate/#dLux.detectors.Rotate.angle","title":"<code>angle = np.asarray(angle, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/rotate/#dLux.detectors.Rotate.fourier","title":"<code>fourier = bool(fourier)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/rotate/#dLux.detectors.Rotate.padding","title":"<code>padding = padding if padding is None else int(padding)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"detectors/rotate/#dLux.detectors.Rotate.__call__","title":"<code>__call__(image)</code>","text":"<p>Applies the rotation to an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The image to rotate.</p> required <p>Returns:</p> Name Type Description <code>image</code> <code>Array</code> <p>The rotated image.</p>"},{"location":"detectors/rotate/#dLux.detectors.Rotate.__init__","title":"<code>__init__(angle, fourier=False, padding=None, name='Rotate')</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the image in the clockwise direction.</p> required <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code>"},{"location":"detectors/rotate/#dLux.detectors.Rotate.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"notebooks/Core_classes/","title":"\u2202Lux Overview!","text":"In\u00a0[\u00a0]: Copied!"},{"location":"notebooks/Core_classes/#lux-overview","title":"\u2202Lux Overview!\u00b6","text":"<p>This tutorial is designed to give users a gentle introduction to \u2202Lux, how it works and how to use it! Unfortunatly it is still under development, but please check out all of our other tutorials, which still show how to use \u2202Lux!</p>"},{"location":"notebooks/HMC/","title":"Numpyro and Hamiltonian Monte Carlo","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# PPL\nimport numpyro as npy\nimport numpyro.distributions as dist\n\n# Set CPU count for numpyro multi-chain multi-thread\nimport os\nos.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nimport chainconsumer as cc\n\n# Set global plotting parameters\n%matplotlib inline\nplt.figure()\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = 'serif'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # PPL import numpyro as npy import numpyro.distributions as dist  # Set CPU count for numpyro multi-chain multi-thread import os os.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=4'  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt import chainconsumer as cc  # Set global plotting parameters %matplotlib inline plt.figure() plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = 'serif' plt.rcParams[\"text.usetex\"] = 'true' plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>dLux: Jax is running in 32-bit, to enable 64-bit visit: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision\n</pre> <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> <p>First we want to create our spectral object for our binary star source, and then create the binary star object</p> In\u00a0[2]: Copied! <pre># Create Combined Spectrum for Binary\nwavels = np.linspace(400e-9, 500e-9, 3)\n\n# Create Binary Source\ntrue_position = np.zeros(2)\ntrue_separation = dl.utils.arcseconds_to_radians(8e-2)\ntrue_position_angle = np.pi/2\ntrue_flux = 1e3\ntrue_contrast = 2\nsource = dl.BinarySource(true_position, true_flux, true_separation, \n                         true_position_angle, true_contrast, \n                         wavelengths=wavels, name=\"Binary\")\n</pre> # Create Combined Spectrum for Binary wavels = np.linspace(400e-9, 500e-9, 3)  # Create Binary Source true_position = np.zeros(2) true_separation = dl.utils.arcseconds_to_radians(8e-2) true_position_angle = np.pi/2 true_flux = 1e3 true_contrast = 2 source = dl.BinarySource(true_position, true_flux, true_separation,                           true_position_angle, true_contrast,                           wavelengths=wavels, name=\"Binary\") <p>Next we define the optical system and detector, and combine then with the binary soure in order to create a telescope object that we will use to model all of these components simultaneously.</p> In\u00a0[3]: Copied! <pre># Construct Optical system\nwf_npix = 128\ndet_npix = 16\n\n# Zernike aberrations\n# zernike_basis = dl.utils.zernike_basis(10, npix=wf_npix)[3:] * 1e-9\nzernike_basis = np.arange(3, 10)\ntrue_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (zernike_basis.shape[0],))\n\n# Construct optical layers\ntrue_pixel_scale = dl.utils.arcseconds_to_radians(30e-3)\nlayers = [dl.CreateWavefront(wf_npix, 1),\n          dl.ApertureFactory(wf_npix, zernikes=zernike_basis, coefficients=true_coeffs),\n          dl.NormaliseWavefront(),\n          dl.AngularMFT(det_npix, true_pixel_scale)]\n\n# Construct Detector\ntrue_bg = 10.\ntrue_pixel_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), (det_npix, det_npix))\ndetector_layers = [dl.AddConstant(true_bg)]\n\n# Construct Telescope\ntelescope = dl.Instrument(dl.Optics(layers), \n                          dl.Scene([source]),\n                          detector=dl.Detector(detector_layers))\n</pre> # Construct Optical system wf_npix = 128 det_npix = 16  # Zernike aberrations # zernike_basis = dl.utils.zernike_basis(10, npix=wf_npix)[3:] * 1e-9 zernike_basis = np.arange(3, 10) true_coeffs = 1e-9 * jr.normal(jr.PRNGKey(0), (zernike_basis.shape[0],))  # Construct optical layers true_pixel_scale = dl.utils.arcseconds_to_radians(30e-3) layers = [dl.CreateWavefront(wf_npix, 1),           dl.ApertureFactory(wf_npix, zernikes=zernike_basis, coefficients=true_coeffs),           dl.NormaliseWavefront(),           dl.AngularMFT(det_npix, true_pixel_scale)]  # Construct Detector true_bg = 10. true_pixel_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), (det_npix, det_npix)) detector_layers = [dl.AddConstant(true_bg)]  # Construct Telescope telescope = dl.Instrument(dl.Optics(layers),                            dl.Scene([source]),                           detector=dl.Detector(detector_layers)) <p>Now lets create the fake data and examine it. Note that for Numpyro we will flatten our data to make it easier to interact with</p> In\u00a0[4]: Copied! <pre>## Gerenate psf\npsf = telescope.model()\npsf_photon = jr.poisson(jr.PRNGKey(0), psf)\nbg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape)\nimage = psf_photon + bg_noise\ndata = image.flatten()\n\nplt.figure(figsize=(15, 4))\nplt.subplot(1, 3, 1)\nplt.title(\"PSF\")\nplt.imshow(psf)\nplt.colorbar()\n\nplt.subplot(1, 3, 2)\nplt.title(\"PSF with photon noise\")\nplt.imshow(psf_photon)\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.title(\"Data\")\nplt.imshow(image)\nplt.colorbar()\nplt.show()\n</pre> ## Gerenate psf psf = telescope.model() psf_photon = jr.poisson(jr.PRNGKey(0), psf) bg_noise = 3*jr.normal(jr.PRNGKey(0), psf_photon.shape) image = psf_photon + bg_noise data = image.flatten()  plt.figure(figsize=(15, 4)) plt.subplot(1, 3, 1) plt.title(\"PSF\") plt.imshow(psf) plt.colorbar()  plt.subplot(1, 3, 2) plt.title(\"PSF with photon noise\") plt.imshow(psf_photon) plt.colorbar()  plt.subplot(1, 3, 3) plt.title(\"Data\") plt.imshow(image) plt.colorbar() plt.show() <p>Now we construct our Numpyro sampling function. In this function we need to define priors distribution variables for our parameters, and feed them (along with the corresponsing path to that parameter in the model) into the .update_and_model() function. This allows for Numpyro to simulatensly sample the posterior for all of the parameters by taking advantage of the differentiable nature of these models.</p> <p>With these parameters we define a 'plate' which defines our data, using a Possion likelihood since this is our dominant noise source.</p> In\u00a0[13]: Copied! <pre>def psf_model(data, model, path_dict=None):\n\"\"\"\n    Define the numpyro function\n    \"\"\"\n    # Define empty paths and values lists to append to\n    paths, values = [], []\n    \n    # Position\n    position_pix = npy.sample(\"position_pix\", dist.Uniform(-5, 5), sample_shape=(2,))\n    position     = npy.deterministic('position', position_pix*true_pixel_scale)\n    paths.append('Binary.position'), values.append(position)\n    \n    # Separation\n    separation_log = npy.sample(\"log_separation\", dist.Uniform(-12, -6))\n    separation     = npy.deterministic('separation', 10**(separation_log))\n    paths.append('Binary.separation'), values.append(separation)\n    \n    # Field Angle (Position Angle)\n    theta_x = npy.sample(\"theta_x\", dist.Normal(0, 1))\n    theta_y = npy.sample(\"theta_y\", dist.HalfNormal(1))\n    position_angle = npy.deterministic('position_angle', np.arctan2(theta_y, theta_x))\n    paths.append('Binary.position_angle'), values.append(position_angle)\n    \n    # Flux\n    flux_log = npy.sample(\"log_flux\", dist.Uniform(0, 5))\n    flux     = npy.deterministic('flux', 10**flux_log)\n    paths.append('Binary.flux'), values.append(flux)\n    \n    # Flux ratio\n    contrast_log = npy.sample(\"log_contrast\", dist.Uniform(-4, 2))\n    contrast     = npy.deterministic('contrast', 10**contrast_log)\n    paths.append('Binary.contrast'), values.append(contrast)\n\n    # Background\n    bg = npy.sample(\"bg\", dist.Uniform(5, 15))\n    paths.append('AddConstant.value'), values.append(bg)\n    \n    # Zernikes\n    coeffs_norm = npy.sample(\"coeffs_norm\", dist.Normal(0, 1), sample_shape=true_coeffs.shape)\n    coeffs = npy.deterministic('coeffs', 1e-9*coeffs_norm)\n    paths.append('CircularAperture.coefficients'), values.append(coeffs)\n\n    with npy.plate(\"data\", len(data)):\n        poisson_model = dist.Poisson(model.set_and_call(\n            paths, values, \"model\", flatten=True))\n        return npy.sample(\"psf\", poisson_model, obs=data)\n</pre> def psf_model(data, model, path_dict=None):     \"\"\"     Define the numpyro function     \"\"\"     # Define empty paths and values lists to append to     paths, values = [], []          # Position     position_pix = npy.sample(\"position_pix\", dist.Uniform(-5, 5), sample_shape=(2,))     position     = npy.deterministic('position', position_pix*true_pixel_scale)     paths.append('Binary.position'), values.append(position)          # Separation     separation_log = npy.sample(\"log_separation\", dist.Uniform(-12, -6))     separation     = npy.deterministic('separation', 10**(separation_log))     paths.append('Binary.separation'), values.append(separation)          # Field Angle (Position Angle)     theta_x = npy.sample(\"theta_x\", dist.Normal(0, 1))     theta_y = npy.sample(\"theta_y\", dist.HalfNormal(1))     position_angle = npy.deterministic('position_angle', np.arctan2(theta_y, theta_x))     paths.append('Binary.position_angle'), values.append(position_angle)          # Flux     flux_log = npy.sample(\"log_flux\", dist.Uniform(0, 5))     flux     = npy.deterministic('flux', 10**flux_log)     paths.append('Binary.flux'), values.append(flux)          # Flux ratio     contrast_log = npy.sample(\"log_contrast\", dist.Uniform(-4, 2))     contrast     = npy.deterministic('contrast', 10**contrast_log)     paths.append('Binary.contrast'), values.append(contrast)      # Background     bg = npy.sample(\"bg\", dist.Uniform(5, 15))     paths.append('AddConstant.value'), values.append(bg)          # Zernikes     coeffs_norm = npy.sample(\"coeffs_norm\", dist.Normal(0, 1), sample_shape=true_coeffs.shape)     coeffs = npy.deterministic('coeffs', 1e-9*coeffs_norm)     paths.append('CircularAperture.coefficients'), values.append(coeffs)      with npy.plate(\"data\", len(data)):         poisson_model = dist.Poisson(model.set_and_call(             paths, values, \"model\", flatten=True))         return npy.sample(\"psf\", poisson_model, obs=data) <p>Now we can use the numpyro.render_model() function to check to make sure everything is being fed in correctly</p> In\u00a0[14]: Copied! <pre># npy.render_model(psf_model, model_args=(data, telescope))\n</pre> # npy.render_model(psf_model, model_args=(data, telescope)) <p>Using the model above, we can now sample from the posterior distribution using the No U-Turn Sampler (NUTS).</p> In\u00a0[15]: Copied! <pre>sampler = npy.infer.MCMC(\n    npy.infer.NUTS(psf_model),    \n    num_warmup=2000,\n    num_samples=2000,\n    num_chains=jax.device_count(),\n    progress_bar=True,\n)\n%time sampler.run(jr.PRNGKey(0), data, telescope)\n</pre> sampler = npy.infer.MCMC(     npy.infer.NUTS(psf_model),         num_warmup=2000,     num_samples=2000,     num_chains=jax.device_count(),     progress_bar=True, ) %time sampler.run(jr.PRNGKey(0), data, telescope) <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>  0%|          | 0/4000 [00:00&lt;?, ?it/s]</pre> <pre>CPU times: user 10min 53s, sys: 43.4 s, total: 11min 36s\nWall time: 1min 55s\n</pre> <p>Now we examine the summary - Note here we want to make sure that all of the r_hat values are ~1</p> In\u00a0[16]: Copied! <pre>sampler.print_summary()\nvalues_out = sampler.get_samples()\n</pre> sampler.print_summary() values_out = sampler.get_samples() <pre>\n                      mean       std    median      5.0%     95.0%     n_eff     r_hat\n              bg     10.27      0.24     10.27      9.86     10.64   6743.19      1.00\n  coeffs_norm[0]     -0.00      0.99     -0.01     -1.59      1.64   6946.62      1.00\n  coeffs_norm[1]     -0.02      1.02     -0.02     -1.71      1.62   7362.42      1.00\n  coeffs_norm[2]      0.02      1.00      0.02     -1.65      1.62   7860.50      1.00\n  coeffs_norm[3]      0.01      0.99      0.03     -1.68      1.58   8307.07      1.00\n  coeffs_norm[4]      0.26      0.96      0.24     -1.31      1.83   7908.65      1.00\n  coeffs_norm[5]     -0.29      0.97     -0.29     -1.90      1.28   8527.31      1.00\n  coeffs_norm[6]      0.33      0.97      0.33     -1.32      1.87   7091.66      1.00\n    log_contrast      0.38      0.05      0.38      0.30      0.46   5848.75      1.00\n        log_flux      2.98      0.01      2.98      2.96      3.00   7451.86      1.00\n  log_separation     -6.39      0.02     -6.39     -6.42     -6.36   6620.59      1.00\n position_pix[0]     -0.11      0.09     -0.11     -0.25      0.04   5589.99      1.00\n position_pix[1]     -0.02      0.05     -0.02     -0.12      0.06   6676.25      1.00\n         theta_x     -0.01      0.06     -0.01     -0.11      0.08   5806.88      1.00\n         theta_y      1.27      0.65      1.18      0.24      2.19   4141.45      1.00\n\nNumber of divergences: 268\n</pre> <p>This is just a helper function to recast the names of the parameters, and to re-order them for plotting. It it not important.</p> In\u00a0[17]: Copied! <pre>def make_dict(dict_in, truth=False):\n\"\"\"\n    Just a convenience formatting function to latexise parameter names\n    for plotting\n    \"\"\"\n    znames = ['Focus', 'Astig45', 'Astig0', 'ComaY', 'ComaX', 'TfoilY', 'TfoilX']\n    name_dict = {'separation'    : 'r', \n                 'position_angle': r'$\\phi$',\n                 'field_angle'   : r'$\\phi$',\n                 'contrast'      : 'Contrast', \n                 'flux_ratio'    : 'Contrast', \n                 'flux'          :  r'$\\overline{flux}$',\n                 'bg'            : '$\\mu_{BG}$'}\n    \n    dict_out = {}\n    keys = list(dict_in.keys())\n    for i in range(len(keys)):\n        key = keys[i]\n        if 'log' in key or 'theta' in key or '_pix' in key:\n            continue\n        item = dict_in[key]\n        if key == 'position':\n            for j in range(item.shape[-1]):\n                dict_out[['Posx', 'Posy'][j]] = item[j] if truth else item[:, j]\n                    \n        elif key == 'coefficients' or key == 'coeffs' or key == 'coeffs_norm':\n            for j in range(item.shape[-1]):\n                dict_out[znames[j]] = item[j] if truth else item[:, j]\n        else:\n            dict_out[name_dict[key]] = item\n    \n    # Now re-order for nicer plotting\n    order = ['r', \n             r'$\\phi$', \n             'Posx', \n             'Posy', \n             r'$\\overline{flux}$', \n             'Contrast', \n             '$\\\\mu_{BG}$', \n             # 'Focus', \n             # 'Astig45', \n             # 'Astig0', \n             # 'ComaY', \n             # 'ComaX', \n             # 'TfoilY', \n             # 'TfoilX',\n            ]\n\n    new_dict = {}\n    for key in order:\n        new_dict[key] = dict_out[key]\n    return new_dict\n</pre> def make_dict(dict_in, truth=False):     \"\"\"     Just a convenience formatting function to latexise parameter names     for plotting     \"\"\"     znames = ['Focus', 'Astig45', 'Astig0', 'ComaY', 'ComaX', 'TfoilY', 'TfoilX']     name_dict = {'separation'    : 'r',                   'position_angle': r'$\\phi$',                  'field_angle'   : r'$\\phi$',                  'contrast'      : 'Contrast',                   'flux_ratio'    : 'Contrast',                   'flux'          :  r'$\\overline{flux}$',                  'bg'            : '$\\mu_{BG}$'}          dict_out = {}     keys = list(dict_in.keys())     for i in range(len(keys)):         key = keys[i]         if 'log' in key or 'theta' in key or '_pix' in key:             continue         item = dict_in[key]         if key == 'position':             for j in range(item.shape[-1]):                 dict_out[['Posx', 'Posy'][j]] = item[j] if truth else item[:, j]                              elif key == 'coefficients' or key == 'coeffs' or key == 'coeffs_norm':             for j in range(item.shape[-1]):                 dict_out[znames[j]] = item[j] if truth else item[:, j]         else:             dict_out[name_dict[key]] = item          # Now re-order for nicer plotting     order = ['r',               r'$\\phi$',               'Posx',               'Posy',               r'$\\overline{flux}$',               'Contrast',               '$\\\\mu_{BG}$',               # 'Focus',               # 'Astig45',               # 'Astig0',               # 'ComaY',               # 'ComaX',               # 'TfoilY',               # 'TfoilX',             ]      new_dict = {}     for key in order:         new_dict[key] = dict_out[key]     return new_dict <p>Now we can create our truth dictionary and format our chains in order to create nice corner plots using chain consumer</p> In\u00a0[18]: Copied! <pre># Format chains for plotting\ntruth_dict = {'bg':             true_bg,          \n              'coefficients':   true_coeffs, \n              'position_angle': true_position_angle, \n              'flux':           true_flux, \n              'contrast':       true_contrast,  \n              'position':       true_position, \n              'separation':     true_separation,  \n              }\n\ntruth_dict_in = make_dict(truth_dict, truth=True)\nchain_dict = make_dict(values_out)\n</pre> # Format chains for plotting truth_dict = {'bg':             true_bg,                         'coefficients':   true_coeffs,                'position_angle': true_position_angle,                'flux':           true_flux,                'contrast':       true_contrast,                 'position':       true_position,                'separation':     true_separation,                 }  truth_dict_in = make_dict(truth_dict, truth=True) chain_dict = make_dict(values_out) In\u00a0[19]: Copied! <pre>chain = cc.ChainConsumer()\nchain.add_chain(chain_dict)\nchain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\nfig = chain.plotter.plot(truth=truth_dict_in)\nfig.set_size_inches((15,15));\n</pre> chain = cc.ChainConsumer() chain.add_chain(chain_dict) chain.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  fig = chain.plotter.plot(truth=truth_dict_in) fig.set_size_inches((15,15)); <p>Excellent! As we can see all of the praameters are well constrained!</p>"},{"location":"notebooks/HMC/#numpyro-and-hamiltonian-monte-carlo","title":"Numpyro and Hamiltonian Monte Carlo\u00b6","text":"<p>In this tutorial we will see how we to integrate our \u2202Lux optical models with a Probablistic Programming Language (PPL) Numpyro. This allows us to run a subset of MCMC algorithms known as HMC, that take advantage of autodiff in order to infer the relationship between a large number of parameters.</p> <p>In this example we will simulate a binary star through a simple optical system, and simultanesouly infer the parameters of the stars and the state of the optical system at the same time.</p>"},{"location":"notebooks/HMC/#inference-with-numpyro","title":"Inference with Numpyro\u00b6","text":"<p>Awesome, now we are going to try and infer these parameters using an MCMC algortihm. There a few different parameters we want to learn:</p>"},{"location":"notebooks/HMC/#binary-parameters","title":"Binary parameters\u00b6","text":"<ul> <li>The (x,y) mean position (2 parameters)</li> <li>The separation (1 parameter)</li> <li>The position angle (1 parameter)</li> <li>The mean flux (1 parameter)</li> <li>The contrast ratio (1 parameter)</li> </ul>"},{"location":"notebooks/HMC/#optical-parameters","title":"Optical parameters\u00b6","text":"<ul> <li>The zernike aberration coefficients (7 parameters)</li> </ul>"},{"location":"notebooks/HMC/#detector-parameters","title":"Detector parameters\u00b6","text":"<ul> <li>The mean detector noise (1 parameter)</li> </ul> <p>This gives us a total of 14 parameters, which is quite high dimensional for regular MCMC algortihms.</p>"},{"location":"notebooks/designing_a_mask/","title":"Phase Mask Design","text":"In\u00a0[1]: Copied! <pre># Core jax\nimport jax.numpy as np\nimport jax.random as jr\nfrom jax import vmap\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax.numpy as np import jax.random as jr from jax import vmap  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>dLux: Jax is running in 32-bit, to enable 64-bit visit: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision\n</pre> <p>We will first generate an orthonormal basis for the pupil phases, and then threshold this to {0, 1} while preserving soft edges using the Continuous Latent Image Mask Binarization (CLIMB) algorithm from the Wong et al paper.</p> <p>Generate basis vectors however you like - in this case we are using logarithmic radial harmonics and sines and cosines in \u03b8., but you can do whatever you like here. This code is not important; just generate your favourite not-necessarily-orthonormal basis, and we will use PCA to orthonormalize it later on.</p> In\u00a0[2]: Copied! <pre># Define arrays sizes, samplings, symmetries\nwf_npix = 256\noversample = 3\nnslice = 3\n\n# Define basis hyper parameters\na = 10\nb = 8\nith = 10\n</pre> # Define arrays sizes, samplings, symmetries wf_npix = 256 oversample = 3 nslice = 3  # Define basis hyper parameters a = 10 b = 8 ith = 10 In\u00a0[3]: Copied! <pre># Define coordinate grids\nnpix = wf_npix * oversample\nc = (npix - 1) / 2.\nxs = (np.arange(npix) - c) / c\nXX, YY = np.meshgrid(xs, xs)\nRR = np.sqrt(XX ** 2 + YY ** 2)\nPHI = np.arctan2(YY, XX)\n\n# Generate basis vectors to map over\nAs = np.arange(-a, a+1)\nBs = nslice * np.arange(0, b+1)\nCs = np.array([-np.pi/2, np.pi/2])\nIs = np.arange(-ith, ith+1)\n\n# Define basis functions\nLRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C)\nsine_fn = lambda i, RR: np.sin(i * np.pi * RR)\ncose_fn = lambda i, RR: np.cos(i * np.pi * RR)\n\n# Map over basis functions\ngen_LRHF_basis = vmap(vmap(vmap( \\\n                            LRHF_fn, (None, 0, None, None, None)), \n                                     (0, None, None, None, None)), \n                                     (None, None, 0, None, None))\ngen_sine_basis = vmap(sine_fn, in_axes=(0, None))\ngen_cose_basis = vmap(cose_fn, in_axes=(0, None))\n\n# Generate basis\nLRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\\n            .reshape([len(As)*len(Bs)*len(Cs), npix, npix])\nsine_basis = gen_sine_basis(Is, RR)\ncose_basis = gen_cose_basis(Is, RR)\n\n# Format shapes and combine\nLRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix])\nsine_flat = sine_basis.reshape([len(sine_basis), npix*npix])\ncose_flat = cose_basis.reshape([len(cose_basis), npix*npix])\nfull_basis = np.concatenate([\n    LRHF_flat,\n    sine_flat,\n    cose_flat\n])\n</pre> # Define coordinate grids npix = wf_npix * oversample c = (npix - 1) / 2. xs = (np.arange(npix) - c) / c XX, YY = np.meshgrid(xs, xs) RR = np.sqrt(XX ** 2 + YY ** 2) PHI = np.arctan2(YY, XX)  # Generate basis vectors to map over As = np.arange(-a, a+1) Bs = nslice * np.arange(0, b+1) Cs = np.array([-np.pi/2, np.pi/2]) Is = np.arange(-ith, ith+1)  # Define basis functions LRHF_fn = lambda A, B, C, RR, PHI: np.cos(A*np.log(RR + 1e-12) + B*PHI + C) sine_fn = lambda i, RR: np.sin(i * np.pi * RR) cose_fn = lambda i, RR: np.cos(i * np.pi * RR)  # Map over basis functions gen_LRHF_basis = vmap(vmap(vmap( \\                             LRHF_fn, (None, 0, None, None, None)),                                       (0, None, None, None, None)),                                       (None, None, 0, None, None)) gen_sine_basis = vmap(sine_fn, in_axes=(0, None)) gen_cose_basis = vmap(cose_fn, in_axes=(0, None))  # Generate basis LRHF_basis = gen_LRHF_basis(As, Bs, Cs, RR, PHI) \\             .reshape([len(As)*len(Bs)*len(Cs), npix, npix]) sine_basis = gen_sine_basis(Is, RR) cose_basis = gen_cose_basis(Is, RR)  # Format shapes and combine LRHF_flat = LRHF_basis.reshape([len(As)*len(Bs)*len(Cs), npix*npix]) sine_flat = sine_basis.reshape([len(sine_basis), npix*npix]) cose_flat = cose_basis.reshape([len(cose_basis), npix*npix]) full_basis = np.concatenate([     LRHF_flat,     sine_flat,     cose_flat ]) <p>Orthonormalize with PCA - could also use Gram-Schmidt if you prefer.</p> In\u00a0[4]: Copied! <pre>%%time\nfrom sklearn.decomposition import PCA\npca = PCA().fit(full_basis)\n\ncomponents = pca.components_.reshape([len(full_basis), npix, npix])\ncomponents = np.copy(components[:99,:,:])\nbasis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])\n\n# # Load if already generated\n# basis = np.load('files/basis.npy')\n</pre> %%time from sklearn.decomposition import PCA pca = PCA().fit(full_basis)  components = pca.components_.reshape([len(full_basis), npix, npix]) components = np.copy(components[:99,:,:]) basis = np.concatenate([np.mean(pca.mean_)*np.array(np.ones((1,npix,npix))), components])  # # Load if already generated # basis = np.load('files/basis.npy') <p>Show the pretty basis vectors:</p> In\u00a0[5]: Copied! <pre>nfigs = 100\nncols = 10\nnrows = 1 + nfigs//ncols\n\nplt.figure(figsize=(4*ncols, 4*nrows))\nfor i in range(nfigs):\n    plt.subplot(nrows, ncols, i+1)\n    plt.imshow(basis[i], cmap='seismic')\n    plt.xticks([])\n    plt.yticks([])\nplt.tight_layout()\nplt.show()\n</pre> nfigs = 100 ncols = 10 nrows = 1 + nfigs//ncols  plt.figure(figsize=(4*ncols, 4*nrows)) for i in range(nfigs):     plt.subplot(nrows, ncols, i+1)     plt.imshow(basis[i], cmap='seismic')     plt.xticks([])     plt.yticks([]) plt.tight_layout() plt.show() In\u00a0[6]: Copied! <pre># save for use later\nnp.save('files/basis', basis)\n</pre> # save for use later np.save('files/basis', basis) <p>First we want to construct a dLux layer that we can use to design a binary mask, for this we will use <code>ApplyBasisCLIMB</code> which soft-thresholds the edges (see Wong et al, 2021, sec 3.2.2). In brief, what this does is make an OPD map as a weighted sum of modes; where this is positive, we set to \u03c0 phase, where it is negative, we set it to zero, and on the edges, we soft-edge it to propagate gradients.</p> In\u00a0[7]: Copied! <pre># Define our mask layer, here we use ApplyBasisCLIMB\nwavels = 1e-9 * np.linspace(595, 695, 3)\ncoeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)])\nCLIMB = dl.ApplyBasisCLIMB(basis, np.mean(wavels), coeffs)\n</pre> # Define our mask layer, here we use ApplyBasisCLIMB wavels = 1e-9 * np.linspace(595, 695, 3) coeffs = 100*jr.normal(jr.PRNGKey(0), [len(basis)]) CLIMB = dl.ApplyBasisCLIMB(basis, np.mean(wavels), coeffs) <p>Now we create our optical system, we can use the pre-built TOLIMAN models, with an oversampled detector.</p> In\u00a0[8]: Copied! <pre>from dLux.utils import radians_to_arcseconds as r2a, get_pixel_scale, toliman\n\n# Array sizes\nwavefront_npixels = basis.shape[-1]//3\ndetector_npixels = 128\nsampling_rate = 5 # pixels per fringe ie 5x nyquist\ndetector_pixel_size = get_pixel_scale(sampling_rate, wavels.max(), 0.125)\n\n# Make optical system\noptics = toliman(wavefront_npixels, detector_npixels, \n                 detector_pixel_size=r2a(detector_pixel_size),\n                 extra_layers=[CLIMB], angular=True)\n</pre> from dLux.utils import radians_to_arcseconds as r2a, get_pixel_scale, toliman  # Array sizes wavefront_npixels = basis.shape[-1]//3 detector_npixels = 128 sampling_rate = 5 # pixels per fringe ie 5x nyquist detector_pixel_size = get_pixel_scale(sampling_rate, wavels.max(), 0.125)  # Make optical system optics = toliman(wavefront_npixels, detector_npixels,                   detector_pixel_size=r2a(detector_pixel_size),                  extra_layers=[CLIMB], angular=True) <p>Now we also add a small amount of jitter, to help engineer the psf shape, and define a simple point source. We then combine all of these together into an instrument</p> In\u00a0[9]: Copied! <pre># Add some detector jitter\ndetector = dl.Detector([dl.ApplyJitter(2.)])\n\n# Define a source\nsource = dl.PointSource(wavelengths=wavels)\n\n# Create our instrument\ntel = dl.Instrument(optics=optics, detector=detector, sources=[source])\n</pre> # Add some detector jitter detector = dl.Detector([dl.ApplyJitter(2.)])  # Define a source source = dl.PointSource(wavelengths=wavels)  # Create our instrument tel = dl.Instrument(optics=optics, detector=detector, sources=[source]) <p>We also define a minimum and maximum radius that we want to try and push all of the light into using the mask. Now lets examine all of this together.</p> In\u00a0[10]: Copied! <pre>rmin = 1*sampling_rate # 1 lam/D\nrmax = 8*sampling_rate # 8 lam/D\n</pre> rmin = 1*sampling_rate # 1 lam/D rmax = 8*sampling_rate # 8 lam/D In\u00a0[11]: Copied! <pre>aperture = tel.CircularAperture.aperture\nmask = tel.ApplyBasisCLIMB.get_binary_phase()\ninner = plt.Circle((64, 64), rmin, fill=False, color='w')\nouter = plt.Circle((64, 64), rmax, fill=False, color='w')\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture*mask, cmap='hot')\nplt.title('Input OPD')\n\nax = plt.subplot(1, 2, 2)\nax.imshow(tel.model())\nax.set_title('Input PSF')\nax.add_patch(inner)\nax.add_patch(outer)\nplt.show()\n</pre> aperture = tel.CircularAperture.aperture mask = tel.ApplyBasisCLIMB.get_binary_phase() inner = plt.Circle((64, 64), rmin, fill=False, color='w') outer = plt.Circle((64, 64), rmax, fill=False, color='w')  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture*mask, cmap='hot') plt.title('Input OPD')  ax = plt.subplot(1, 2, 2) ax.imshow(tel.model()) ax.set_title('Input PSF') ax.add_patch(inner) ax.add_patch(outer) plt.show() <p>Now lets define our loss function. We can pass the path to our mask coefficients to the <code>zdx.filter_value_and_grad</code> function in order to generate gradients for only those terms!</p> In\u00a0[16]: Copied! <pre>args = ['ApplyBasisCLIMB.coefficients']\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(arg)\ndef loss_func(tel, rmin=20, rmax=150, power=0.5):\n    # Get PSF, Gradients and Mask\n    psf = tel.model()\n    Rmask = dl.utils.get_radial_mask(psf.shape[0], rmin, rmax)\n\n    # Calcualte loss\n    loss1 = - np.power(Rmask*dl.utils.get_GE(psf),  power).sum()/1\n    loss2 = - np.power(Rmask*dl.utils.get_RGE(psf), power).sum()\n    return loss1 + loss2\n</pre> args = ['ApplyBasisCLIMB.coefficients']  @zdx.filter_jit @zdx.filter_value_and_grad(arg) def loss_func(tel, rmin=20, rmax=150, power=0.5):     # Get PSF, Gradients and Mask     psf = tel.model()     Rmask = dl.utils.get_radial_mask(psf.shape[0], rmin, rmax)      # Calcualte loss     loss1 = - np.power(Rmask*dl.utils.get_GE(psf),  power).sum()/1     loss2 = - np.power(Rmask*dl.utils.get_RGE(psf), power).sum()     return loss1 + loss2 <p>Evaluate once to <code>jit</code> compile:</p> In\u00a0[17]: Copied! <pre>%%time\nloss, grads = loss_func(tel, rmin=rmin, rmax=rmax) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = loss_func(tel, rmin=rmin, rmax=rmax) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -29.38055992126465\nCPU times: user 3.51 s, sys: 84.1 ms, total: 3.6 s\nWall time: 2.87 s\n</pre> <p>Gradient descent time!</p> In\u00a0[18]: Copied! <pre>model = tel\noptim, opt_state = zdx.get_optimiser(model, args, optax.adam(5e1))\n\nlosses, models_out = [], []\nwith tqdm(range(100),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_func(model, rmin=rmin, rmax=rmax)\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> model = tel optim, opt_state = zdx.get_optimiser(model, args, optax.adam(5e1))  losses, models_out = [], [] with tqdm(range(100),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_func(model, rmin=rmin, rmax=rmax)         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)          t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Visualize the results:</p> In\u00a0[19]: Copied! <pre>coeffs_out = np.array([model.get(arg) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\naxes['C'].imshow(aperture*mask,cmap='hot')\naxes['C'].set_title('Input OPD')\n\n# Model without jitter\npsf_in = tel.set('detector.layers', {}).model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nfinal = models_out[-1]\naxes['E'].imshow(aperture*final.ApplyBasisCLIMB.get_binary_phase(),cmap='hot')\naxes['E'].set_title('Final OPD')\n\n# Model without jitter\npsf_out = final.set('detector.layers', {}).model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n</pre> coeffs_out = np.array([model.get(arg) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  axes['C'].imshow(aperture*mask,cmap='hot') axes['C'].set_title('Input OPD')  # Model without jitter psf_in = tel.set('detector.layers', {}).model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  final = models_out[-1] axes['E'].imshow(aperture*final.ApplyBasisCLIMB.get_binary_phase(),cmap='hot') axes['E'].set_title('Final OPD')  # Model without jitter psf_out = final.set('detector.layers', {}).model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF') Out[19]: <pre>Text(0.5, 1.0, 'Final PSF')</pre> In\u00a0[20]: Copied! <pre>psf_out = final.set('detector.layers', {}).model()\nnew = final.set('detector.layers', {}).model()\n\nps = final.AngularMFT.pixel_scale_out\nnpix = final.AngularMFT.npixels_out\n\nnew = final.set(['AngularMFT.pixel_scale_out', 'AngularMFT.npixels_out'], [ps/10, 10*npix]).model()\n</pre> psf_out = final.set('detector.layers', {}).model() new = final.set('detector.layers', {}).model()  ps = final.AngularMFT.pixel_scale_out npix = final.AngularMFT.npixels_out  new = final.set(['AngularMFT.pixel_scale_out', 'AngularMFT.npixels_out'], [ps/10, 10*npix]).model() In\u00a0[22]: Copied! <pre>plt.figure(figsize=(20, 4))\nplt.subplot(1, 4, 1)\nplt.imshow(psf_out)\nplt.colorbar()\n\nplt.subplot(1, 4, 2)\nplt.imshow(dl.utils.get_GE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 3)\nplt.imshow(dl.utils.get_RGE(psf_out))\nplt.colorbar()\n\nplt.subplot(1, 4, 4)\nplt.imshow(dl.utils.get_RWGE(psf_out))\nplt.colorbar()\nplt.show()\n</pre> plt.figure(figsize=(20, 4)) plt.subplot(1, 4, 1) plt.imshow(psf_out) plt.colorbar()  plt.subplot(1, 4, 2) plt.imshow(dl.utils.get_GE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 3) plt.imshow(dl.utils.get_RGE(psf_out)) plt.colorbar()  plt.subplot(1, 4, 4) plt.imshow(dl.utils.get_RWGE(psf_out)) plt.colorbar() plt.show() In\u00a0[17]: Copied! <pre># # Save mask for use in flatfield_calibration notebook\n# mask_out = models_out[-1].ApplyBasisCLIMB.get_binary_phase()\n# np.save(\"files/test_mask\", mask_out)\n</pre> # # Save mask for use in flatfield_calibration notebook # mask_out = models_out[-1].ApplyBasisCLIMB.get_binary_phase() # np.save(\"files/test_mask\", mask_out) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/designing_a_mask/#phase-mask-design","title":"Phase Mask Design\u00b6","text":"<p>In this notebook, we will illustrate the problem of inverse design of a phase mask: we will choose the example from Wong et al, 2021, designing a diffractive pupil phase mask for the Toliman telescope.</p> <p>In order to get high precision centroids, we need to maximize the gradient energy of the pupil; in order to satisfy fabrication constraints, we need a binary mask with phases only in {0, \u03c0}.</p>"},{"location":"notebooks/designing_a_mask/#optimizing-the-pupil","title":"Optimizing the Pupil\u00b6","text":""},{"location":"notebooks/fisher_information/","title":"Fisher Information","text":"<p>Right, let's import some things.</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nfrom jax.config import config\n\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Bayesan functions\nfrom dLux.utils import bayes\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\nfrom chainconsumer import ChainConsumer\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"text.usetex\"] = 'true'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax from jax.config import config  import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Bayesan functions from dLux.utils import bayes  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm from chainconsumer import ChainConsumer  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"text.usetex\"] = 'true' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>dLux: Jax is running in 32-bit, to enable 64-bit visit: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision\n</pre> <p>First we construct our parameterised Binary Source</p> In\u00a0[2]: Copied! <pre>separation = dl.utils.arcseconds_to_radians(10)\nwavels = 1e-9 * np.linspace(595, 695, 3)\nsource = dl.BinarySource(separation=separation, position_angle=np.pi/2, \n                         flux=1e6, contrast=1, wavelengths=wavels)\n</pre> separation = dl.utils.arcseconds_to_radians(10) wavels = 1e-9 * np.linspace(595, 695, 3) source = dl.BinarySource(separation=separation, position_angle=np.pi/2,                           flux=1e6, contrast=1, wavelengths=wavels) <p>Here we want to optimise a binary mask using the CLIMB algorithm using the saved basis vectors from the tutorial on designing a mask.</p> <p>We can use the pre-built Toliman model, while adding our CLIMB mask.</p> In\u00a0[3]: Copied! <pre># Binary CLIMB mask basis\nclimb_basis = np.load(\"files/basis.npy\")\ncoefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)])\nmask_layer = dl.ApplyBasisCLIMB(climb_basis, wavels.mean(), coefficients)\n\noptics = dl.utils.toliman(wavefront_npixels   = 256,\n                          detector_npixels    = 256,\n                          detector_pixel_size = 0.2,\n                          nzernike            = 7,\n                          extra_layers        = [mask_layer])\n\n# Construct instrument\nmodel = dl.Instrument(optics=optics, sources=[source])\n</pre> # Binary CLIMB mask basis climb_basis = np.load(\"files/basis.npy\") coefficients = 100*jr.normal(jr.PRNGKey(0), [len(climb_basis)]) mask_layer = dl.ApplyBasisCLIMB(climb_basis, wavels.mean(), coefficients)  optics = dl.utils.toliman(wavefront_npixels   = 256,                           detector_npixels    = 256,                           detector_pixel_size = 0.2,                           nzernike            = 7,                           extra_layers        = [mask_layer])  # Construct instrument model = dl.Instrument(optics=optics, sources=[source]) <p>Visualize the PSF:</p> In\u00a0[4]: Copied! <pre>aperture = model.CircularAperture.aperture\nmask = model.ApplyBasisCLIMB.get_binary_phase()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.imshow(aperture * mask, cmap='hot')\nplt.title('Input OPD')\n\nplt.subplot(1, 2, 2)\npsf = model.model()\nplt.imshow(psf)\nplt.colorbar()\nplt.title('Input PSF')\nplt.show()\n</pre> aperture = model.CircularAperture.aperture mask = model.ApplyBasisCLIMB.get_binary_phase()  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.imshow(aperture * mask, cmap='hot') plt.title('Input OPD')  plt.subplot(1, 2, 2) psf = model.model() plt.imshow(psf) plt.colorbar() plt.title('Input PSF') plt.show() <p>Now here we want to optimise the coefficients of the binary mask, with respect to the entropy of the covaraince matrix. To do this we need to define which parameters we want to calculate the covariance with respect to. To do this we create a function that perturbs each of the parameters we want to opitmise with respect to, optionally scalling them by the appropriate units, and return this model. Becuase dLux is end-to-end differentiable, we take gradients of our model with respect to this function!</p> In\u00a0[5]: Copied! <pre>def perturb(X, model):\n\"\"\"\n    Perturbs the values of the model\n    \"\"\"\n    a2r = dl.utils.arcseconds_to_radians(1)\n    \n    # Separation (arcseconds)\n    model = model.add('BinarySource.separation', X[0] * a2r)\n    \n    # contrast \n    model = model.add('BinarySource.contrast', X[1])\n    \n    # Position Angle (milli-arcseconds)\n    model = model.add('BinarySource.position_angle', X[2] * a2r * 1e-3)\n    \n    # Mean wavelength (nm)\n    model = model.add('BinarySource.spectrum.wavelengths', X[3] * 1e-9)\n    \n    # Plate Scale (nm)\n    model = model.add('AngularMFT.pixel_scale_out', X[4] * 1e-9)\n\n    # Zernikes (nm)\n    model = model.add('CircularAperture.coefficients', X[5:] * 1e-9)\n\n    # Return\n    return model\n\nX = np.zeros(12)\n</pre> def perturb(X, model):     \"\"\"     Perturbs the values of the model     \"\"\"     a2r = dl.utils.arcseconds_to_radians(1)          # Separation (arcseconds)     model = model.add('BinarySource.separation', X[0] * a2r)          # contrast      model = model.add('BinarySource.contrast', X[1])          # Position Angle (milli-arcseconds)     model = model.add('BinarySource.position_angle', X[2] * a2r * 1e-3)          # Mean wavelength (nm)     model = model.add('BinarySource.spectrum.wavelengths', X[3] * 1e-9)          # Plate Scale (nm)     model = model.add('AngularMFT.pixel_scale_out', X[4] * 1e-9)      # Zernikes (nm)     model = model.add('CircularAperture.coefficients', X[5:] * 1e-9)      # Return     return model  X = np.zeros(12) <p>Define a loss function and specify that we are only optimizing over the CLIMB basis coefficients:</p> <p>Note here in the loss function we are calculating the entropy of the covariance matrix with respect to some arbitrary log-likelihood function</p> In\u00a0[7]: Copied! <pre>args = ['ApplyBasisCLIMB.coefficients']\n\n@zdx.filter_jit\n@zdx.filter_value_and_grad(args)\ndef fim_loss_func(model, X, loglike_fn, update_fn, model_fn):\n    psf = model.model()\n    loss = bayes.calculate_entropy(loglike_fn, X, psf, model, update_fn, model_fn)\n    return loss\n</pre> args = ['ApplyBasisCLIMB.coefficients']  @zdx.filter_jit @zdx.filter_value_and_grad(args) def fim_loss_func(model, X, loglike_fn, update_fn, model_fn):     psf = model.model()     loss = bayes.calculate_entropy(loglike_fn, X, psf, model, update_fn, model_fn)     return loss <p>Call the loss function once to compile:</p> In\u00a0[8]: Copied! <pre>%%time\nloss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model') print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: -21.312088012695312\nCPU times: user 16.6 s, sys: 517 ms, total: 17.1 s\nWall time: 9.52 s\n</pre> <p>Now run gradient descent!</p> In\u00a0[11]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, args, optax.adam(1e2))\n\nlosses, models_out = [], [model]\nwith tqdm(range(50),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        models_out.append(model)\n        losses.append(loss)\n        t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar\n</pre> optim, opt_state = zdx.get_optimiser(model, args, optax.adam(1e2))  losses, models_out = [], [model] with tqdm(range(50),desc='Gradient Descent') as t:     for i in t:          loss, grads = fim_loss_func(model, X, bayes.poisson_log_likelihood, perturb, 'model')         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         models_out.append(model)         losses.append(loss)         t.set_description(\"Loss: {:.3f}\".format(loss)) # update the progress bar <pre>Gradient Descent:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> In\u00a0[12]: Copied! <pre>coeffs_out = np.array([model.get(arg) for model in models_out])\n\nmosaic = \"\"\"\n         AABB\n         CDEF\n         \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['C','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Loss\")\n\naxes['B'].set_title(\"Coeffs\")\naxes['B'].plot(coeffs_out[:], alpha=0.2)\n\nmask = models_out[0].ApplyBasisCLIMB.get_binary_phase()\naxes['C'].imshow(aperture * mask, cmap='hot')\naxes['C'].set_title('Input OPD')\n\npsf_in = models_out[0].model()\naxes['D'].imshow(psf_in)\naxes['D'].set_title('Input PSF')\n\nmask = models_out[-1].ApplyBasisCLIMB.get_binary_phase()\naxes['E'].imshow(aperture * mask, cmap='hot')\naxes['E'].set_title('Final OPD')\n\npsf_out = models_out[-1].model()\naxes['F'].imshow(psf_out)\naxes['F'].set_title('Final PSF')\n\nplt.show()\n</pre> coeffs_out = np.array([model.get(arg) for model in models_out])  mosaic = \"\"\"          AABB          CDEF          \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['C','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])   axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Loss\")  axes['B'].set_title(\"Coeffs\") axes['B'].plot(coeffs_out[:], alpha=0.2)  mask = models_out[0].ApplyBasisCLIMB.get_binary_phase() axes['C'].imshow(aperture * mask, cmap='hot') axes['C'].set_title('Input OPD')  psf_in = models_out[0].model() axes['D'].imshow(psf_in) axes['D'].set_title('Input PSF')  mask = models_out[-1].ApplyBasisCLIMB.get_binary_phase() axes['E'].imshow(aperture * mask, cmap='hot') axes['E'].set_title('Final OPD')  psf_out = models_out[-1].model() axes['F'].imshow(psf_out) axes['F'].set_title('Final PSF')  plt.show() <p>Let's calculate the covariance matrix elements:</p> In\u00a0[13]: Copied! <pre>%%time\ncovs = [bayes.calculate_covariance(bayes.poisson_log_likelihood, X, model.model(), model, perturb, 'model') for model in [models_out[0], models_out[-1]]]\n</pre> %%time covs = [bayes.calculate_covariance(bayes.poisson_log_likelihood, X, model.model(), model, perturb, 'model') for model in [models_out[0], models_out[-1]]] <pre>CPU times: user 11.3 s, sys: 725 ms, total: 12 s\nWall time: 5.24 s\n</pre> <p>And using ChainConsumer we can easily visualize this covariance:</p> In\u00a0[14]: Copied! <pre>param_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",\n               \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",\n               \"TfoilX\", \"TfoilY\"]\n\nc = ChainConsumer()\nc.add_covariance(X, covs[0], parameters=param_names, name='Initial')\nc.add_covariance(X, covs[1], parameters=param_names, name='Final')\nc.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)\n\n# fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised\nfig = c.plotter.plot()\n</pre> param_names = [\"r (asec)\", \"$\\phi (masec)$\", '$f_A/f_B$', \"$\\lambda (nm)$\",                \"Pscale (nm)\", \"Defoc\", \"AstigX\", \"AstigY\", \"ComaX\", \"ComaY\",                \"TfoilX\", \"TfoilY\"]  c = ChainConsumer() c.add_covariance(X, covs[0], parameters=param_names, name='Initial') c.add_covariance(X, covs[1], parameters=param_names, name='Final') c.configure(serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1., max_ticks=3)  # fig = c.plotter.plot_summary() # currently bugged for \\phi - issue raised fig = c.plotter.plot() <pre>/Users/louis/mambaforge/envs/dLux/lib/python3.11/site-packages/chainconsumer/chainconsumer.py:346: RuntimeWarning: covariance is not symmetric positive-semidefinite.\n  chain = np.random.multivariate_normal(mean, covariance, size=1000000)\n</pre> <p>It looks like the optimization worked - marginal posterior bounds for all the optical parameters are much tighter after the optimization than they were before.</p> <p>We see that in this narrowband simulation, most parameters aren't tightly correlated, but separation, plate scale and wavelength are almost indistinguishable - this makes sense, as they affect the PSF in the same way! Only independent constraints on \u03bb can save us here. If you want to do precise astrometry, you have to nail down your plate scale and your spectrum: we see that the marginal posterior for separation is the same, but dominated entirely by this degeneracy with plate scale and \u03bb, which is much tighter for the optimized pupil.</p> <p>This is why in the Toliman telescope design we superimpose a grating over our pupil (design paper, Fig 6) - so we can measure a stellar spectrum and separate this from the astrometry.</p> <p>If we were doing this properly for a telescope design, we would want to take this into account - our real goal is precisely measuring separation, and everything else is something we can just marginalize over. If we incorporate our prior constraints on plate scale and wavelength I am sure we will do even better.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/fisher_information/#fisher-information","title":"Fisher Information\u00b6","text":"<p>Autodiff doesn't just make it faster to solve optimization and inference problems - it also allows you to use powerful ideas in statistics that require second derivatives that are intractable analytically or with finite differences.</p> <p>The Fisher Information Matrix, or the inverse of the Hessian of the likelihood, can be used for</p> <ul> <li>the Laplace approximation to a posterior for variational inference, giving you the Gaussian covariance of the posterior near the maximum likelihood point;</li> <li>Fisher forecasting, where you calculate this for an instrument or experiment at expected parameters, to predict how well it will constrain them; and</li> <li>optimal design, as the Cram\u00e9r-Rao lower bound on the precision of an experiment is the inverse of the Fisher information matrix - so you want to make this as tight as possible!</li> </ul> <p>Because <code>jax</code> lets us compute the Hessian of our loss function, we can use the Fisher matrix for variational inference without MCMC, and also more powerfully as an objective function to optimize a telescope design: why bother engineering a PSF for a particular goal, when you could model the system end to end and optimize the precision of the Fisher forecast of the parameter of interest?</p> <ul> <li>This is the topic of a Desdoigts et al paper in prep. It wasn't quite that easy to build and we're pretty happy about it.</li> </ul> <p>This notebook follows on from Phase Mask Design and will reuse some of the same code without repeating explanations.</p>"},{"location":"notebooks/flatfield_calibration/","title":"Pixel Level Calibration","text":"<p>First, import everything as usual:</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\nfrom dLux.utils import arcseconds_to_radians as a2r\nfrom dLux.utils import radians_to_arcseconds as r2a\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl from dLux.utils import arcseconds_to_radians as a2r from dLux.utils import radians_to_arcseconds as r2a  # Plotting/visualisation import matplotlib.pyplot as plt from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>dLux: Jax is running in 32-bit, to enable 64-bit visit: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision\n</pre> <p>Then we generate an array of 5 dithered images, in a coarsely-sampled broad bandwidth, of 15 stars. The reason we want multiple stars, and especially dithered images, is because we want to retrieve the flat field - multiplicative errors on each pixel that, if we only have the one image, are formally degenerate with the PSF. It turns out that if we can hit each pixel with light from the same PSF multiple times, we can retrieve the whole thing unambiguously.</p> <p>We will use the presaved default Toliman pupil - a diffractive pupil that nicely spreads out the PSF in a highly structured pattern, designed (with <code>dLux</code>) to be ideal for astrometry and field calibration.</p> <p>We will then add some Zernike mode aberrations on top of this, and have some 5% level flat field calibration errors, and additive background noise.</p> In\u00a0[2]: Copied! <pre># Basic Optical Parameters\ndiameter = 0.5\nwf_npix = 256 \n\n# Detector Parameters\ndet_npix = 256 \ndet_pixsize = a2r(10/det_npix)\n\n# Load mask\nraw_mask = np.load(\"files/test_mask.npy\") * (6e-7/(2*np.pi))\nmask = dl.utils.scale_array(raw_mask, wf_npix, 0)\n\n# Zernike Basis\nzern_basis = np.arange(3, 10)\ncoeffs = 2e-8 * jr.normal(jr.PRNGKey(0), [len(zern_basis)])\n\n# Define Optical Configuration\noptical_layers = [\n    dl.CreateWavefront    (wf_npix, diameter),\n    dl.ApertureFactory    (wf_npix, zernikes=zern_basis, coefficients=coeffs),\n    dl.AddOPD             (mask),\n    dl.NormaliseWavefront (),\n    dl.AngularMFT         (det_npix, det_pixsize)]\n\n# Create Optics object\noptics = dl.Optics(optical_layers)\n</pre> # Basic Optical Parameters diameter = 0.5 wf_npix = 256   # Detector Parameters det_npix = 256  det_pixsize = a2r(10/det_npix)  # Load mask raw_mask = np.load(\"files/test_mask.npy\") * (6e-7/(2*np.pi)) mask = dl.utils.scale_array(raw_mask, wf_npix, 0)  # Zernike Basis zern_basis = np.arange(3, 10) coeffs = 2e-8 * jr.normal(jr.PRNGKey(0), [len(zern_basis)])  # Define Optical Configuration optical_layers = [     dl.CreateWavefront    (wf_npix, diameter),     dl.ApertureFactory    (wf_npix, zernikes=zern_basis, coefficients=coeffs),     dl.AddOPD             (mask),     dl.NormaliseWavefront (),     dl.AngularMFT         (det_npix, det_pixsize)]  # Create Optics object optics = dl.Optics(optical_layers) In\u00a0[3]: Copied! <pre># Pixel response\npix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])\n\n# Create Detector object\ndetector = dl.Detector([dl.ApplyPixelResponse(pix_response)])\n</pre> # Pixel response pix_response = 1 + 0.05*jr.normal(jr.PRNGKey(0), [det_npix, det_npix])  # Create Detector object detector = dl.Detector([dl.ApplyPixelResponse(pix_response)]) In\u00a0[4]: Copied! <pre># Multiple sources to observe\nNstars = 15\ntrue_positions = a2r(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-4, maxval=4))\ntrue_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(0), (Nstars,))\nwavels = 1e-9 * np.linspace(545, 645, 3)\n\n# Create Source object\nsource = dl.MultiPointSource(true_positions, true_fluxes, wavelengths=wavels)\n</pre> # Multiple sources to observe Nstars = 15 true_positions = a2r(jr.uniform(jr.PRNGKey(0), (Nstars, 2), minval=-4, maxval=4)) true_fluxes = 1e8 + 1e7*jr.normal(jr.PRNGKey(0), (Nstars,)) wavels = 1e-9 * np.linspace(545, 645, 3)  # Create Source object source = dl.MultiPointSource(true_positions, true_fluxes, wavelengths=wavels) <p>Now we need to introduce the dithers. To do this we define an 'observation function' that we use to update the relevant parameters and model the sources. Instruments have a pre-built <code>dither_and_model(dithers)</code> function that does this for us!</p> <p>With the observation function, we then put this inside of a dictionary under the key 'fn' along with the dithers under 'args'. We can then use the <code>.obserse()</code> method to call the function stored under 'fn' with the input arguments 'args'. This is how we allow for arbitrary observation stratergy to be modelled simply!</p> In\u00a0[5]: Copied! <pre># Observation stratergy, define dithers\ndithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]])\nobservation = dl.Dither(dithers)\n</pre> # Observation stratergy, define dithers dithers = det_pixsize * np.array([[0, 0], [+1, +1], [+1, -1], [-1, +1], [-1, -1]]) observation = dl.Dither(dithers) <p>Now we combine all of this into an instrument and observe!</p> In\u00a0[6]: Copied! <pre># Combine into instrument\ntel = dl.Instrument(optics=optics, sources=[source], detector=detector,\n                    observation=observation)\n\n# Observe!\npsfs = tel.observe()\n</pre> # Combine into instrument tel = dl.Instrument(optics=optics, sources=[source], detector=detector,                     observation=observation)  # Observe! psfs = tel.observe() In\u00a0[7]: Copied! <pre># Apply some noise to the PSF Background noise\nBG_noise = np.abs(5*jr.normal(jr.PRNGKey(0), psfs.shape))\ndata = jr.poisson(jr.PRNGKey(0), psfs) + BG_noise\n\nplt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(data[i])\n    plt.colorbar()\nplt.show()\n</pre> # Apply some noise to the PSF Background noise BG_noise = np.abs(5*jr.normal(jr.PRNGKey(0), psfs.shape)) data = jr.poisson(jr.PRNGKey(0), psfs) + BG_noise  plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(data[i])     plt.colorbar() plt.show() <p>Now there are 4 sets of parameters we are going to learn:</p> <ul> <li>Positions</li> <li>Fluxes</li> <li>Zernike aberrations</li> <li>Pixel responses</li> </ul> <p>We start by defining the paths to those parameters. We will define them individually so we can refer to them easily later</p> In\u00a0[8]: Copied! <pre>positions = 'MultiPointSource.position'\nfluxes = 'MultiPointSource.flux'\nzernikes = 'CircularAperture.coefficients'\nflatfield = 'ApplyPixelResponse.pixel_response'\n\nparameters = [positions, fluxes, zernikes, flatfield]\n</pre> positions = 'MultiPointSource.position' fluxes = 'MultiPointSource.flux' zernikes = 'CircularAperture.coefficients' flatfield = 'ApplyPixelResponse.pixel_response'  parameters = [positions, fluxes, zernikes, flatfield] <p>Each of these parameters needs a different initilisation</p> <ul> <li>Positions need to be shifted by some random value</li> <li>Fluxes need to be multiplied by some random value</li> <li>Zernike coefficients need to be set to zero</li> <li>Pixel response values need to be set to one</li> </ul> <p>Perturb the values to intialise the model</p> In\u00a0[9]: Copied! <pre># Add small random values to the positions\nmodel = tel.add(positions, 2.5*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))\n\n# Multiply the fluxes by small random values\nmodel = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))\n\n# Set the zernike coefficients to zero\nmodel = model.set(zernikes, np.zeros(len(zern_basis)))\n\n# Set the flat fiel to uniform\nmodel = model.set(flatfield, np.ones((det_npix, det_npix)))\n\n# Generate psfs\npsfs = model.observe()\n</pre> # Add small random values to the positions model = tel.add(positions, 2.5*det_pixsize*jr.normal(jr.PRNGKey(0),  (Nstars, 2)))  # Multiply the fluxes by small random values model = model.multiply(fluxes, 1 + 0.1*jr.normal(jr.PRNGKey(0), (Nstars,)))  # Set the zernike coefficients to zero model = model.set(zernikes, np.zeros(len(zern_basis)))  # Set the flat fiel to uniform model = model.set(flatfield, np.ones((det_npix, det_npix)))  # Generate psfs psfs = model.observe() <p>Model and observe the residuals are pretty bad:</p> In\u00a0[10]: Copied! <pre>plt.figure(figsize=(25, 4))\nfor i in range(len(psfs)):\n    plt.subplot(1, 5, i+1)\n    plt.imshow(psfs[i] - data[i])\n    plt.colorbar()\nplt.show()\n</pre> plt.figure(figsize=(25, 4)) for i in range(len(psfs)):     plt.subplot(1, 5, i+1)     plt.imshow(psfs[i] - data[i])     plt.colorbar() plt.show() <p>Now we want to generate an optax optimiser object that we can use to train each parameter individually. Becuase of the various scales and effect of the loss fucntion that each parameter has, we need to be able to set individual learning rates, and optimisation schedules for every parameter. Luckily we have built some functions to help specifically with that! Lets see how to use it!</p> In\u00a0[11]: Copied! <pre># So first we simply set the simple parameters to use an adam optimiser \n# algorithm, with individual learning rates\npos_optimiser   = optax.adam(2e-8)\nflux_optimiser  = optax.adam(1e6)\ncoeff_optimiser = optax.adam(2e-9)\n\n# Now the flat-field, becuase it is highly covariant with the mean flux level \n# we don't start learning its parameters until the 100th epoch.\nFF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8, \n                             boundaries_and_scales={100 : int(1e8)})\nFF_optimiser = optax.adam(FF_sched)\n\n# Combine the optimisers into a list\noptimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]\n\n# Generate out optax optimiser, and also get our args\noptim, opt_state = zdx.get_optimiser(model, parameters, optimisers)\n</pre> # So first we simply set the simple parameters to use an adam optimiser  # algorithm, with individual learning rates pos_optimiser   = optax.adam(2e-8) flux_optimiser  = optax.adam(1e6) coeff_optimiser = optax.adam(2e-9)  # Now the flat-field, becuase it is highly covariant with the mean flux level  # we don't start learning its parameters until the 100th epoch. FF_sched = optax.piecewise_constant_schedule(init_value=1e-2*1e-8,                               boundaries_and_scales={100 : int(1e8)}) FF_optimiser = optax.adam(FF_sched)  # Combine the optimisers into a list optimisers = [pos_optimiser, flux_optimiser, coeff_optimiser, FF_optimiser]  # Generate out optax optimiser, and also get our args optim, opt_state = zdx.get_optimiser(model, parameters, optimisers) <p>Poisson log-likelihood:</p> In\u00a0[12]: Copied! <pre>@zdx.filter_jit\n@zdx.filter_value_and_grad(parameters)\ndef loss_fn(model, data):\n    out = model.observe()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</pre> @zdx.filter_jit @zdx.filter_value_and_grad(parameters) def loss_fn(model, data):     out = model.observe()     return -np.sum(jax.scipy.stats.poisson.logpmf(data, out)) <p>Call once to jit compile:</p> In\u00a0[13]: Copied! <pre>%%time\nloss, grads = loss_fn(model, data) # Compile\nprint(\"Initial Loss: {}\".format(int(loss)))\n</pre> %%time loss, grads = loss_fn(model, data) # Compile print(\"Initial Loss: {}\".format(int(loss))) <pre>Initial Loss: 1270765568\nCPU times: user 3.76 s, sys: 140 ms, total: 3.9 s\nWall time: 978 ms\n</pre> <p>Run gradient descent:</p> In\u00a0[14]: Copied! <pre>losses, models_out = [], []\nwith tqdm(range(200),desc='Gradient Descent') as t:\n    for i in t: \n        loss, grads = loss_fn(model, data)    \n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        losses.append(loss)\n        models_out.append(model)\n        t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar\n</pre> losses, models_out = [], [] with tqdm(range(200),desc='Gradient Descent') as t:     for i in t:          loss, grads = loss_fn(model, data)             updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)         losses.append(loss)         models_out.append(model)         t.set_description(\"Log Loss: {:.3f}\".format(np.log10(loss))) # update the progress bar <pre>Gradient Descent:   0%|          | 0/200 [00:00&lt;?, ?it/s]</pre> <p>Format the output into arrays:</p> In\u00a0[15]: Copied! <pre>nepochs = len(models_out)\npsfs_out = models_out[-1].observe()\n\npositions_found  = np.array([model.get(positions) for model in models_out])\nfluxes_found     = np.array([model.get(fluxes)    for model in models_out])\nzernikes_found   = np.array([model.get(zernikes)  for model in models_out])\nflatfields_found = np.array([model.get(flatfield) for model in models_out])\n</pre> nepochs = len(models_out) psfs_out = models_out[-1].observe()  positions_found  = np.array([model.get(positions) for model in models_out]) fluxes_found     = np.array([model.get(fluxes)    for model in models_out]) zernikes_found   = np.array([model.get(zernikes)  for model in models_out]) flatfields_found = np.array([model.get(flatfield) for model in models_out]) <p>Pull out the quantities to be plotted - eg final model and residuals:</p> In\u00a0[16]: Copied! <pre>coeff_residuals = coeffs - zernikes_found\nflux_residuals = true_fluxes - fluxes_found\n\nscaler = 1e3\npositions_residuals = true_positions - positions_found\nr_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1])\nr_residuals = r2a(r_residuals_rads)\n</pre> coeff_residuals = coeffs - zernikes_found flux_residuals = true_fluxes - fluxes_found  scaler = 1e3 positions_residuals = true_positions - positions_found r_residuals_rads = np.hypot(positions_residuals[:, :, 0], positions_residuals[:, :, 1]) r_residuals = r2a(r_residuals_rads) In\u00a0[17]: Copied! <pre>j = len(models_out)\nplt.figure(figsize=(16, 13))\n\nplt.subplot(3, 2, 1)\nplt.title(\"Log10 Loss\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Log10 ADU\")\nplt.plot(np.log10(np.array(losses)[:j]))\n\nplt.subplot(3, 2, 2)\nplt.title(\"Stellar Positions\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Positional Error (arcseconds)\")\nplt.plot(r_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 3)\nplt.title(\"Stellar Fluxes\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Flux Error (Photons)\")\nplt.plot(flux_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(3, 2, 4)\nplt.title(\"Zernike Coeff Residuals\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Residual Amplitude\")\nplt.plot(coeff_residuals[:j])\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> j = len(models_out) plt.figure(figsize=(16, 13))  plt.subplot(3, 2, 1) plt.title(\"Log10 Loss\") plt.xlabel(\"Epochs\") plt.ylabel(\"Log10 ADU\") plt.plot(np.log10(np.array(losses)[:j]))  plt.subplot(3, 2, 2) plt.title(\"Stellar Positions\") plt.xlabel(\"Epochs\") plt.ylabel(\"Positional Error (arcseconds)\") plt.plot(r_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 3) plt.title(\"Stellar Fluxes\") plt.xlabel(\"Epochs\") plt.ylabel(\"Flux Error (Photons)\") plt.plot(flux_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(3, 2, 4) plt.title(\"Zernike Coeff Residuals\") plt.xlabel(\"Epochs\") plt.ylabel(\"Residual Amplitude\") plt.plot(coeff_residuals[:j]) plt.axhline(0, c='k', alpha=0.5)  plt.tight_layout() plt.show() <p>How did the phase retrieval go? Really well, as it happens!</p> In\u00a0[18]: Copied! <pre># OPDs\ntrue_opd = tel.CircularAperture.get_opd()\nopds_found = np.array([model.CircularAperture.get_opd() for model in models_out])\nfound_opd = opds_found[-1]\nopd_residuls = true_opd - opds_found\nopd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5\n\nvmin = np.min(np.array([true_opd, found_opd]))\nvmax = np.max(np.array([true_opd, found_opd]))\n\n# Coefficients\ntrue_coeff = tel.get(zernikes)\nfound_coeff = models_out[-1].get(zernikes)\nindex = np.arange(len(true_coeff))+4\n\nplt.figure(figsize=(20, 10))\nplt.suptitle(\"Optical Aberrations\")\n\nplt.subplot(2, 2, 1)\nplt.title(\"RMS OPD residual\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"RMS OPD (nm)\")\nplt.plot(opd_rmse_nm)\nplt.axhline(0, c='k', alpha=0.5)\n\nplt.subplot(2, 2, 2)\nplt.title(\"Zernike Coefficient Amplitude\")\nplt.xlabel(\"Index\")\nplt.ylabel(\"Amplitude\")\nplt.scatter(index, true_coeff, label=\"True Value\")\nplt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x')\nplt.bar(index, true_coeff - found_coeff, label='Residual')\nplt.axhline(0, c='k', alpha=0.5)\nplt.legend()\n\nplt.subplot(2, 3, 4)\nplt.title(\"True OPD\")\nplt.imshow(true_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found OPD\")\nplt.imshow(found_opd)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"OPD Residual\")\nplt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax)\nplt.colorbar()\nplt.show()\n</pre> # OPDs true_opd = tel.CircularAperture.get_opd() opds_found = np.array([model.CircularAperture.get_opd() for model in models_out]) found_opd = opds_found[-1] opd_residuls = true_opd - opds_found opd_rmse_nm = 1e9*np.mean(opd_residuls**2, axis=(-1,-2))**0.5  vmin = np.min(np.array([true_opd, found_opd])) vmax = np.max(np.array([true_opd, found_opd]))  # Coefficients true_coeff = tel.get(zernikes) found_coeff = models_out[-1].get(zernikes) index = np.arange(len(true_coeff))+4  plt.figure(figsize=(20, 10)) plt.suptitle(\"Optical Aberrations\")  plt.subplot(2, 2, 1) plt.title(\"RMS OPD residual\") plt.xlabel(\"Epochs\") plt.ylabel(\"RMS OPD (nm)\") plt.plot(opd_rmse_nm) plt.axhline(0, c='k', alpha=0.5)  plt.subplot(2, 2, 2) plt.title(\"Zernike Coefficient Amplitude\") plt.xlabel(\"Index\") plt.ylabel(\"Amplitude\") plt.scatter(index, true_coeff, label=\"True Value\") plt.scatter(index, found_coeff, label=\"Recovered Value\", marker='x') plt.bar(index, true_coeff - found_coeff, label='Residual') plt.axhline(0, c='k', alpha=0.5) plt.legend()  plt.subplot(2, 3, 4) plt.title(\"True OPD\") plt.imshow(true_opd) plt.colorbar()  plt.subplot(2, 3, 5) plt.title(\"Found OPD\") plt.imshow(found_opd) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"OPD Residual\") plt.imshow(true_opd - found_opd, vmin=vmin, vmax=vmax) plt.colorbar() plt.show() <p>Most impressively, we are getting the tens of thousands of parameters of the flat field pretty well too!</p> In\u00a0[19]: Copied! <pre># calculate the mask where there was enough flux to infer the flat field\nthresh = 2500\nfmask = data.mean(0) &gt;= thresh\n\nout_mask = np.where(data.mean(0) &lt; thresh)\nin_mask = np.where(data.mean(0) &gt;= thresh)\n\ndata_tile = np.tile(data.mean(0), [len(models_out), 1, 1])\nin_mask_tiled = np.where(data_tile &gt;= thresh)\n\n# calculate residuals\npr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]\n\n# for correlation plot\ntrue_pr_masked = pix_response.at[out_mask].set(1)\nfound_pr_masked = flatfields_found[-1].at[out_mask].set(1)\n\n# FF Scatter Plot\ndata_sum = data.sum(0) # [flux_mask]\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\n# Errors\npfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])])\nptrue = pix_response[in_mask]\npr_res = ptrue - pfound\nmasked_error = np.abs(pr_res).mean(-1)\n\nplt.figure(figsize=(20, 10))\nplt.subplot(2, 3, (1,2))\nplt.title(\"Pixel Response\")\nplt.xlabel(\"Epochs\")\nplt.ylabel(\"Mean Sensitivity Error\")\nplt.plot(masked_error)\nplt.axhline(0, c='k', alpha=0.5)\n\n# FF Scatter Plot\ndata_sum = data.sum(0)\ncolours = data_sum.flatten()\nind = np.argsort(colours)\ncolours = colours[ind]\n\npr_true_flat = true_pr_masked.flatten()\npr_found_flat = found_pr_masked.flatten()\n\npr_true_sort = pr_true_flat[ind]\npr_found_sort = pr_found_flat[ind]\n\nplt.subplot(2, 3, 3)\nplt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75)\nplt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5)\nplt.colorbar()\nplt.title(\"Sensitivity Residual\")\nplt.ylabel(\"Recovered Sensitivity\")\nplt.xlabel(\"True Sensitivity\")\n\nplt.subplot(2, 3, 4)\nplt.title(\"True Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked)\nplt.colorbar()\n\nvmin = np.min(pix_response)\nvmax = np.max(pix_response)\n\nplt.subplot(2, 3, 5)\nplt.title(\"Found Pixel Response\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(found_pr_masked, vmin=vmin, vmax=vmax)\nplt.colorbar()\n\nplt.subplot(2, 3, 6)\nplt.title(\"Pixel Response Residual\")\nplt.xlabel(\"Pixels\")\nplt.ylabel(\"Pixels\")\nplt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2)\nplt.colorbar()\n\nplt.show()\n</pre> # calculate the mask where there was enough flux to infer the flat field thresh = 2500 fmask = data.mean(0) &gt;= thresh  out_mask = np.where(data.mean(0) &lt; thresh) in_mask = np.where(data.mean(0) &gt;= thresh)  data_tile = np.tile(data.mean(0), [len(models_out), 1, 1]) in_mask_tiled = np.where(data_tile &gt;= thresh)  # calculate residuals pr_residuals = pix_response[in_mask] - flatfields_found[-1][in_mask]  # for correlation plot true_pr_masked = pix_response.at[out_mask].set(1) found_pr_masked = flatfields_found[-1].at[out_mask].set(1)  # FF Scatter Plot data_sum = data.sum(0) # [flux_mask] colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  # Errors pfound = flatfields_found[in_mask_tiled].reshape([len(models_out), len(in_mask[0])]) ptrue = pix_response[in_mask] pr_res = ptrue - pfound masked_error = np.abs(pr_res).mean(-1)  plt.figure(figsize=(20, 10)) plt.subplot(2, 3, (1,2)) plt.title(\"Pixel Response\") plt.xlabel(\"Epochs\") plt.ylabel(\"Mean Sensitivity Error\") plt.plot(masked_error) plt.axhline(0, c='k', alpha=0.5)  # FF Scatter Plot data_sum = data.sum(0) colours = data_sum.flatten() ind = np.argsort(colours) colours = colours[ind]  pr_true_flat = true_pr_masked.flatten() pr_found_flat = found_pr_masked.flatten()  pr_true_sort = pr_true_flat[ind] pr_found_sort = pr_found_flat[ind]  plt.subplot(2, 3, 3) plt.plot(np.linspace(0.8, 1.2), np.linspace(0.8, 1.2), c='k', alpha=0.75) plt.scatter(pr_true_sort, pr_found_sort, c=colours, alpha=0.5) plt.colorbar() plt.title(\"Sensitivity Residual\") plt.ylabel(\"Recovered Sensitivity\") plt.xlabel(\"True Sensitivity\")  plt.subplot(2, 3, 4) plt.title(\"True Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked) plt.colorbar()  vmin = np.min(pix_response) vmax = np.max(pix_response)  plt.subplot(2, 3, 5) plt.title(\"Found Pixel Response\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(found_pr_masked, vmin=vmin, vmax=vmax) plt.colorbar()  plt.subplot(2, 3, 6) plt.title(\"Pixel Response Residual\") plt.xlabel(\"Pixels\") plt.ylabel(\"Pixels\") plt.imshow(true_pr_masked - found_pr_masked, vmin=-0.2, vmax=0.2) plt.colorbar()  plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/flatfield_calibration/#pixel-level-calibration","title":"Pixel Level Calibration\u00b6","text":"<p>There are a lot of existing frameworks for phase retrieval - but it is not so straightforward to simultaneously retrieve</p> <ul> <li>aberrations (the optical distortions, maybe tens of parameters)</li> <li>astrometry (the positions of stars, tens of parameters)</li> <li>interpixel sensitivity (aka the 'flat field', on a large pixel grid!)</li> </ul> <p>The dimensionality of the pixel grid can be so high it is hard to retrieve without autodiff. With <code>dLux</code>, it is easy*!</p> <p>* This is the topic of a Desdoigts et al paper in prep. It wasn't quite that easy to build and we're pretty happy about it.</p>"},{"location":"notebooks/phase_retrieval_demo/","title":"Phase Retrieval in dLux","text":"<p>First, we import the necessary packages, including <code>Jax</code>:</p> In\u00a0[1]: Copied! <pre># Core jax\nimport jax\nimport jax.numpy as np\nimport jax.random as jr\n\n# Optimisation\nimport zodiax as zdx\nimport optax\n\n# Optics\nimport dLux as dl\n\n# Plotting/visualisation\nimport matplotlib.pyplot as plt\nfrom matplotlib import colormaps\nfrom tqdm.notebook import tqdm\n\n%matplotlib inline\nplt.rcParams['image.cmap'] = 'inferno'\nplt.rcParams[\"font.family\"] = \"serif\"\nplt.rcParams[\"image.origin\"] = 'lower'\nplt.rcParams['figure.dpi'] = 120\n</pre> # Core jax import jax import jax.numpy as np import jax.random as jr  # Optimisation import zodiax as zdx import optax  # Optics import dLux as dl  # Plotting/visualisation import matplotlib.pyplot as plt from matplotlib import colormaps from tqdm.notebook import tqdm  %matplotlib inline plt.rcParams['image.cmap'] = 'inferno' plt.rcParams[\"font.family\"] = \"serif\" plt.rcParams[\"image.origin\"] = 'lower' plt.rcParams['figure.dpi'] = 120 <pre>dLux: Jax is running in 32-bit, to enable 64-bit visit: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#double-64bit-precision\n</pre> <p>Now, we want to construct a basic optical system with a 1m aperture.</p> <p>We also generate a Zernike basis in order to model some optical aberrations, omitting the piston/tip/tilt elements, and initialising them as normally-distributed coefficients over that basis.</p> <p>As noted by Martinache et al 2013, you can only detect the sign of even-order aberrations if your pupil is not inversion-symmetric; so following that paper, we introduce a small bar asymmetry.</p> In\u00a0[2]: Copied! <pre># Basic Optical Parameters\ndiameter = 1.\nwf_npix = 256 \n\n# Detector Parameters\ndet_npix = 256 \ndet_pixsize = dl.utils.arcseconds_to_radians(1e-2)\n\n# Generate an asymmetry\nc, s = wf_npix//2, 13\nasymmetry = np.ones((wf_npix,wf_npix)).at[c-s:c+s, :c].set(0)\nasymmetric_mask = dl.TransmissiveOptic(asymmetry)\n\n# Define the aberrations\nseed = 0\nzernikes = np.arange(4, 11)\ncoeffs = 2e-8*jr.normal(jr.PRNGKey(seed), (len(zernikes),))\n</pre> # Basic Optical Parameters diameter = 1. wf_npix = 256   # Detector Parameters det_npix = 256  det_pixsize = dl.utils.arcseconds_to_radians(1e-2)  # Generate an asymmetry c, s = wf_npix//2, 13 asymmetry = np.ones((wf_npix,wf_npix)).at[c-s:c+s, :c].set(0) asymmetric_mask = dl.TransmissiveOptic(asymmetry)  # Define the aberrations seed = 0 zernikes = np.arange(4, 11) coeffs = 2e-8*jr.normal(jr.PRNGKey(seed), (len(zernikes),)) <p>Here is the core syntax of <code>dLux</code>: a list of optical layers. Unlike some other systems, we are very explicit about the whole optical system:</p> <ul> <li>First initialize a wavefront using the <code>CreateWavefront</code> class.</li> <li>For a simple circular aperutre extending the width of the wavefront we use the <code>ApertureFactory</code> class, specifying the the properties we want (ratio of primary to secondary mirror, number of struts etc), so it can pre-calculate the aperture and return the correct aperture class.</li> <li>We then want to apply the zernike aberrations using <code>AberrationFactory</code> to generate this class for us.</li> <li>To introduce our assymetry we add a <code>TransmissiveOptic</code> layer, feeding in the asymmetric array on ones and zeros we calcualted.</li> <li>We then normalise the flux to unitary power after the wavefront has passed through these two layers.</li> <li>Then we propagate our wavefront to a focal plane using the <code>AngularMFT</code> class, which defines pixel scale units in angular SI units, ie radians, specifying the number of pixels in the output detector.</li> </ul> In\u00a0[3]: Copied! <pre># Define Optical Configuration\noptical_layers = [\n    dl.CreateWavefront(wf_npix, diameter),\n    dl.ApertureFactory(wf_npix, nstruts=3, secondary_ratio=0.1, strut_ratio=0.01, name='Aperture'),\n    dl.AberrationFactory(wf_npix, zernikes=zernikes, coefficients=coeffs, name='Aberrations'),\n    dl.TransmissiveOptic(asymmetry),\n    dl.NormaliseWavefront(),\n    dl.AngularMFT(det_npix, det_pixsize)]\n</pre> # Define Optical Configuration optical_layers = [     dl.CreateWavefront(wf_npix, diameter),     dl.ApertureFactory(wf_npix, nstruts=3, secondary_ratio=0.1, strut_ratio=0.01, name='Aperture'),     dl.AberrationFactory(wf_npix, zernikes=zernikes, coefficients=coeffs, name='Aberrations'),     dl.TransmissiveOptic(asymmetry),     dl.NormaliseWavefront(),     dl.AngularMFT(det_npix, det_pixsize)] <p>Now we also need to create a source that we will be examining with this optical configuration. Here we use a simple point source, which is initialised on-axis, with a flux of one. We only need to define the wavelengths of this source, so lets have a look at the resulting object.</p> In\u00a0[4]: Copied! <pre># Create a point source\nwavels = np.linspace(450e-9, 550e-9, 5)\nsource = dl.PointSource(wavelengths=wavels)\n</pre> # Create a point source wavels = np.linspace(450e-9, 550e-9, 5) source = dl.PointSource(wavelengths=wavels) <p>Now we want to combine these two objects together into the convenient dLux.Instrument class, in order to model the optical system response to the point source.</p> <p>Note all dLux objects that contain 'layers' - such as the optical layers we define above - can be accessed like an attribute of the class. In this case we want to examine the input optical aberrations, so we will access the 'ApplyBasisOPD' layer using this method.</p> In\u00a0[5]: Copied! <pre># Construct the instrument with the source\ntelescope = dl.Instrument(optical_layers=optical_layers, sources=[source])\n\n# Get aperture &amp; aberrations\naper_in = telescope.Aperture.get_aperture()\naberr_in = telescope.Aberrations.get_opd()\n\n# Get mask, setting nan values for visualisation\nmask = 1.0*(aper_in*asymmetry &gt; 1e-5)\nmask = mask.at[mask==False].set(np.nan)\ncmap = colormaps['inferno']\ncmap.set_bad('k',1.)\n\n# Model the PSF using the .model() method\npsf = telescope.model()\n\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nplt.title(\"Aberrations\")\nplt.imshow(mask*aberr_in*1e9, cmap=cmap)\nplt.colorbar(label='nm')\n\nplt.subplot(1, 2, 2)\nplt.title(\"PSF\")\nplt.imshow(psf**0.5)\nplt.colorbar()\nplt.show()\n</pre> # Construct the instrument with the source telescope = dl.Instrument(optical_layers=optical_layers, sources=[source])  # Get aperture &amp; aberrations aper_in = telescope.Aperture.get_aperture() aberr_in = telescope.Aberrations.get_opd()  # Get mask, setting nan values for visualisation mask = 1.0*(aper_in*asymmetry &gt; 1e-5) mask = mask.at[mask==False].set(np.nan) cmap = colormaps['inferno'] cmap.set_bad('k',1.)  # Model the PSF using the .model() method psf = telescope.model()  plt.figure(figsize=(10, 4)) plt.subplot(1, 2, 1) plt.title(\"Aberrations\") plt.imshow(mask*aberr_in*1e9, cmap=cmap) plt.colorbar(label='nm')  plt.subplot(1, 2, 2) plt.title(\"PSF\") plt.imshow(psf**0.5) plt.colorbar() plt.show() <p>Excellent! Now we want to try and recover these aberrations. To do this we want to create a new optical system with a different set of zernike aberrations. We can do this using the <code>.set()</code> method and defining the path the optical aberration coefficients and assigning a newly-randomlised coefficient values. With this new optical system we will try and recover the original aberration coefficients using gradient descent methods.</p> In\u00a0[6]: Copied! <pre># Define path to the zernikes\nzernikes = 'Aberrations.coefficients'\n\n# Generate new random set of zernikes\ncoeffs_init = 2e-8*jr.normal(jr.PRNGKey(seed + 1), [len(coeffs)])\n\n# Generate a new model with updated zernike coefficients\nmodel = telescope.set(zernikes, coeffs_init)\n</pre> # Define path to the zernikes zernikes = 'Aberrations.coefficients'  # Generate new random set of zernikes coeffs_init = 2e-8*jr.normal(jr.PRNGKey(seed + 1), [len(coeffs)])  # Generate a new model with updated zernike coefficients model = telescope.set(zernikes, coeffs_init) <p>Now we need to define our loss function, and specify that we want to optimise the zernike coefficients. To do this we can pass in the string path to our zernikes that we just defined into the <code>zdx.filter_value_and_grad()</code> function. Note we also use the <code>zdx.filter_jit()</code> function in order to compile this function into XLA in order to run much faster!</p> In\u00a0[7]: Copied! <pre>@zdx.filter_jit\n@zdx.filter_value_and_grad(zernikes)\ndef loss_func(model, data):\n    out = model.model()\n    return -np.sum(jax.scipy.stats.poisson.logpmf(data, out))\n</pre> @zdx.filter_jit @zdx.filter_value_and_grad(zernikes) def loss_func(model, data):     out = model.model()     return -np.sum(jax.scipy.stats.poisson.logpmf(data, out)) <p>Now we compile the function and time its evaluation - even on CPU it is fast!</p> In\u00a0[8]: Copied! <pre>%%time\nloss, initial_grads = loss_func(model, psf) # Compile\nprint(\"Initial Loss: {}\".format(loss))\n</pre> %%time loss, initial_grads = loss_func(model, psf) # Compile print(\"Initial Loss: {}\".format(loss)) <pre>Initial Loss: 8.39254379272461\nCPU times: user 399 ms, sys: 18 ms, total: 417 ms\nWall time: 292 ms\n</pre> In\u00a0[9]: Copied! <pre>%%timeit\nloss = loss_func(model, psf)[0].block_until_ready()\n</pre> %%timeit loss = loss_func(model, psf)[0].block_until_ready() <pre>21.3 ms \u00b1 326 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</pre> <p>Now begin the optimization loop using <code>optax</code> with a low learning rate.</p> In\u00a0[10]: Copied! <pre>optim, opt_state = zdx.get_optimiser(model, [zernikes], [optax.adam(2e-9)])\n\nlosses, models_out = [], []\nwith tqdm(range(100), desc='Gradient Descent') as t:\n    for i in t: \n        # calculate the loss and gradient\n        loss, grads = loss_func(model, psf) \n        \n        # apply the update\n        updates, opt_state = optim.update(grads, opt_state)\n        model = zdx.apply_updates(model, updates)\n        \n        # save results\n        models_out.append(model) \n        losses.append(loss)\n        \n        t.set_description('Loss %.5f' % (loss)) # update the progress bar\nfinal_psf = model.model(source=source)\n</pre> optim, opt_state = zdx.get_optimiser(model, [zernikes], [optax.adam(2e-9)])  losses, models_out = [], [] with tqdm(range(100), desc='Gradient Descent') as t:     for i in t:          # calculate the loss and gradient         loss, grads = loss_func(model, psf)                   # apply the update         updates, opt_state = optim.update(grads, opt_state)         model = zdx.apply_updates(model, updates)                  # save results         models_out.append(model)          losses.append(loss)                  t.set_description('Loss %.5f' % (loss)) # update the progress bar final_psf = model.model(source=source) <pre>Gradient Descent:   0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> <p>Now we visualize this: we have great performance, recovering the input Zernike coefficients accurately and a beautiful PSF recovery.</p> In\u00a0[11]: Copied! <pre>coeffs_out = np.array([model_out.get(zernikes) for model_out in models_out])\n\nmosaic = \"\"\"\n    AABD\n    GGEF\n    \"\"\"\n\nfig = plt.figure(constrained_layout=True,figsize=(12, 8))\naxes = fig.subplot_mosaic(mosaic)\n\nfor ax in ['B','D','E','F']:\n    axes[ax].set_xticks([])\n    axes[ax].set_yticks([])\n\naxes['A'].plot(np.array(losses))\naxes['A'].set_title(\"Training History\")\naxes['A'].set_xlabel('Training Epoch')\naxes['A'].set_ylabel('Poisson Log-Likelihood')\n\naxes['B'].imshow(psf**0.5)\naxes['B'].set_title('True PSF')\n\naxes['G'].plot(coeffs*1e9,model.get(zernikes)*1e9,'.',markersize=12,color='C0',label='Recovered')\naxes['G'].plot(coeffs*1e9,coeffs_init*1e9,'.',markersize=12,color='C1',label='Initial')\n\naxes['G'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               np.array([np.min(coeffs),np.max(coeffs)])*1e9,\n               '-',color='C2',label='1:1')\naxes['G'].legend()\naxes['G'].set_title('Correlation Plot ')\naxes['G'].set_xlabel('True Zernike Coefficients (nm)')\naxes['G'].set_ylabel('Model Zernike Coefficients (nm)')\n\naxes['D'].imshow(final_psf**0.5)\naxes['D'].set_title('Recovered PSF')\n\naxes['E'].imshow(mask*aberr_in, cmap=cmap)\naxes['E'].set_title('Input Aberrations')\n\naxes['F'].imshow(mask*model.Aberrations.get_opd(), cmap=cmap)\naxes['F'].set_title('Recovered Aberrations')\nplt.show()\n</pre> coeffs_out = np.array([model_out.get(zernikes) for model_out in models_out])  mosaic = \"\"\"     AABD     GGEF     \"\"\"  fig = plt.figure(constrained_layout=True,figsize=(12, 8)) axes = fig.subplot_mosaic(mosaic)  for ax in ['B','D','E','F']:     axes[ax].set_xticks([])     axes[ax].set_yticks([])  axes['A'].plot(np.array(losses)) axes['A'].set_title(\"Training History\") axes['A'].set_xlabel('Training Epoch') axes['A'].set_ylabel('Poisson Log-Likelihood')  axes['B'].imshow(psf**0.5) axes['B'].set_title('True PSF')  axes['G'].plot(coeffs*1e9,model.get(zernikes)*1e9,'.',markersize=12,color='C0',label='Recovered') axes['G'].plot(coeffs*1e9,coeffs_init*1e9,'.',markersize=12,color='C1',label='Initial')  axes['G'].plot(np.array([np.min(coeffs),np.max(coeffs)])*1e9,                np.array([np.min(coeffs),np.max(coeffs)])*1e9,                '-',color='C2',label='1:1') axes['G'].legend() axes['G'].set_title('Correlation Plot ') axes['G'].set_xlabel('True Zernike Coefficients (nm)') axes['G'].set_ylabel('Model Zernike Coefficients (nm)')  axes['D'].imshow(final_psf**0.5) axes['D'].set_title('Recovered PSF')  axes['E'].imshow(mask*aberr_in, cmap=cmap) axes['E'].set_title('Input Aberrations')  axes['F'].imshow(mask*model.Aberrations.get_opd(), cmap=cmap) axes['F'].set_title('Recovered Aberrations') plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/phase_retrieval_demo/#phase-retrieval-in-dlux","title":"Phase Retrieval in dLux\u00b6","text":"<p>In this notebook, we will go through a simple example of phase retrieval in dLux, just recovering Zernike coefficients for an aberrated circular aperture by gradient descent.</p>"},{"location":"observations/abstract_observation/","title":"Abstract Observation","text":"<p>         Bases: <code>Base</code></p> <p>Abstract base class for observations. All observations should inherit from this class and must implement an <code>.observe()</code> method that only takes in a single instance of <code>dLux.Instrument</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p>"},{"location":"observations/abstract_observation/#dLux.observations.AbstractObservation.name","title":"<code>name = str(name)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"observations/abstract_observation/#dLux.observations.AbstractObservation.__init__","title":"<code>__init__(name='AbstractObservation')</code>","text":"<p>Constructor for the AbstractObservation class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> <code>'AbstractObservation'</code>"},{"location":"observations/abstract_observation/#dLux.observations.AbstractObservation.observe","title":"<code>observe(instrument)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for the observation function.</p>"},{"location":"observations/dither/","title":"Dither","text":"<p>         Bases: <code>AbstractObservation</code></p> <p>Observation class designed to apply a series of dithers to the insturment and return the corresponding psfs.</p> <p>Attributes:</p> Name Type Description <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p>"},{"location":"observations/dither/#dLux.observations.Dither.dithers","title":"<code>dithers = np.asarray(dithers, float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"observations/dither/#dLux.observations.Dither.__init__","title":"<code>__init__(dithers, name='Dither')</code>","text":"<p>Constructor for the Dither class.</p> <p>Parameters:</p> Name Type Description Default <code>dithers</code> <code>Array, radians</code> <p>The array of dithers to apply to the source positions. The shape of the array should be (ndithers, 2) where ndithers is the number of dithers and the second dimension is the (x, y) dither in radians.</p> required <code>name</code> <code>str</code> <p>The name of the observation that can be used to access the observation from the <code>Instrument</code> class.</p> <code>'Dither'</code>"},{"location":"observations/dither/#dLux.observations.Dither.dither_position","title":"<code>dither_position(instrument, dither)</code>","text":"<p>Dithers the position of the source objects by dither.</p> <p>Parameters:</p> Name Type Description Default <code>dither</code> <code>Array, radians</code> <p>The (x, y) dither to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>instrument</code> <code>Instrument</code> <p>The instrument with the sources dithered.</p>"},{"location":"observations/dither/#dLux.observations.Dither.observe","title":"<code>observe(instrument, *args, **kwargs)</code>","text":"<p>Applies a series of dithers to the instrument sources and calls the .model() method after applying each dither.</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>Instrument</code> <p>The array of dithers to apply to the source positions.</p> required <p>Returns:</p> Name Type Description <code>psfs</code> <code>Array</code> <p>The psfs generated after applying the dithers to the source positions.</p>"},{"location":"optics/add_opd/","title":"Add OPD","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Adds an Optical Path Difference (OPD) to the wavefront.</p> <p>Attributes:</p> Name Type Description <code>opd</code> <code>Array, meters</code> <p>Array of OPD values to be applied to the input wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/add_opd/#dLux.optics.AddOPD.opd","title":"<code>opd = np.asarray(opd, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/add_opd/#dLux.optics.AddOPD.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Apply the OPD array to the input wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the OPD added.</p>"},{"location":"optics/add_opd/#dLux.optics.AddOPD.__init__","title":"<code>__init__(opd, name='AddOPD')</code>","text":"<p>Constructor for the ApplyOPD class.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>float, meters</code> <p>The Array of OPDs to be applied to the input wavefront. This must a 0, 2 or 3 dimensional array with equal to that of the wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddOPD'</code>"},{"location":"optics/add_opd/#dLux.optics.AddOPD.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/add_phase/","title":"Add Phase","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of phase values to the wavefront.</p> <p>Attributes:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The Array of phase values to be applied to the input wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/add_phase/#dLux.optics.AddPhase.phase","title":"<code>phase = np.asarray(phase, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/add_phase/#dLux.optics.AddPhase.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Adds the phase to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the phase added.</p>"},{"location":"optics/add_phase/#dLux.optics.AddPhase.__init__","title":"<code>__init__(phase, name='AddPhase')</code>","text":"<p>Constructor for the AddPhase class.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>Array of phase values to be applied to the input wavefront. This must a 0, 2 or 3 dimensional array with equal to that of the  wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AddPhase'</code>"},{"location":"optics/add_phase/#dLux.optics.AddPhase.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/apply_basis_climb/","title":"Apply Basis CLIMB","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of binary phase values to the input wavefront from a set of continuous basis vectors. This uses the CLIMB algorithm in order to generate the binary values in a continous manner as described in the paper Wong et al. 2021. The basis vectors are taken as an Optical Path Difference (OPD), and applied to the phase of the wavefront. The ideal wavelength parameter described the wavelength that will have a perfect anti-phase relationship given by the Optical Path Difference.</p> <p>Note: Many of the methods in the class still need doccumentation. Note: This currently only outputs 256 pixel arrays and uses a 3x oversample, therefore requiring a 768 pixel basis array.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>Array</code> <p>Arrays holding the continous pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>ideal_wavelength</code> <code>Array</code> <p>The target wavelength at which a perfect anti-phase relationship is applied via the OPD.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.basis","title":"<code>basis = np.asarray(basis, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.coefficients","title":"<code>coefficients = np.array(coefficients).astype(float) if coefficients is not None else np.zeros(len(self.basis))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.ideal_wavelength","title":"<code>ideal_wavelength = np.asarray(ideal_wavelength, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.CLIMB","title":"<code>CLIMB(wf, ppsz=256)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Generates and applies the binary OPD array to the wavefront in a differentiable manner.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the binary OPD applied.</p>"},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.__init__","title":"<code>__init__(basis, ideal_wavelength, coefficients=None, name='ApplyBasisCLIMB')</code>","text":"<p>Constructor for the ApplyBasisCLIMB class.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array</code> <p>Arrays holding the continous pre-calculated basis vectors. This must be a 3d array of shape (nterms, npixels, npixels), with the final two dimensions matching that of the wavefront at time of application. This is currently required to be a nx768x768 shaped array.</p> required <code>ideal_wavelength</code> <code>Array</code> <p>The target wavelength at which a perfect anti-phase relationship is applied via the OPD.</p> required <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector. This must be a one dimensional array with leading dimension equal to the leading dimension of the basis vectors. Default is None which initialises an array of zeros.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyBasisCLIMB'</code>"},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.area","title":"<code>area(img, epsilon=1e-15)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.get_binary_phase","title":"<code>get_binary_phase()</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.get_opd","title":"<code>get_opd(basis, coefficients)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.get_total_opd","title":"<code>get_total_opd()</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.lsq","title":"<code>lsq(img)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.lsq_params","title":"<code>lsq_params(img)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.opd_to_phase","title":"<code>opd_to_phase(opd, wavel)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.phase_to_opd","title":"<code>phase_to_opd(phase, wavel)</code>","text":""},{"location":"optics/apply_basis_climb/#dLux.optics.ApplyBasisCLIMB.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/apply_basis_opd/","title":"Apply Basis OPD","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Adds an array of phase values to the input wavefront calculated from the Optical Path Difference (OPD). The OPDs are calculated from the basis arrays, and weighted by the coefficients, and converted to phases by the wavefront methods.</p> <p>Attributes:</p> Name Type Description <code>basis</code> <code>Array, meters</code> <p>Arrays holding the pre-calculated basis vectors.</p> <code>coefficients</code> <code>Array</code> <p>The Array of coefficients to be applied to each basis vector.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.basis","title":"<code>basis = np.asarray(basis, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.coefficients","title":"<code>coefficients = np.zeros(basis.shape[0]) if coefficients is None else np.asarray(coefficients, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Calculate and apply the appropriate phase shift to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the appropriate phase applied.</p>"},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.__init__","title":"<code>__init__(basis, coefficients=None, name='ApplyBasisOPD')</code>","text":"<p>Constructor for the ApplyBasisOPD class.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>Array, meters</code> <p>The Array of basis polynomials. This should be a 3 dimensional Array with the first dimension being the number of basis vectors, and the last two dimensions being equal to the wavefront shape at the time of application to the wavefront.</p> required <code>coefficients</code> <code>Array</code> <p>The coefficients by which to weight the basis vectors. This must have the same length as the first dimension of the basis Array. If None is supplied an Array of zeros is constructed.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'ApplyBasisOPD'</code>"},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.get_opd","title":"<code>get_opd()</code>","text":"<p>A function to calculate the total OPD from the basis vector and the coefficients.</p> <p>Returns:</p> Name Type Description <code>OPD</code> <code>Array, meters</code> <p>The total OPD calulated from the basis vectors and coefficients.</p>"},{"location":"optics/apply_basis_opd/#dLux.optics.ApplyBasisOPD.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/create_wavefront/","title":"Create Wavefront","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Initialises the relevant Wavefront class with the specified attributes. Also applies the tilt specified by the source object, defined in the parameters dictionary. All wavefronts are cosntructed in the Pupil plane.</p> <p>Attributes:</p> Name Type Description <code>npixels</code> <code>int</code> <p>The number of pixels used to represent the wavefront.</p> <code>diameter</code> <code>Array, meters</code> <p>The diameter of the wavefront in the Pupil plane.</p> <code>wavefront_type</code> <code>str</code> <p>Determines the type of wavefront class to create. Currently supports 'Cartesian', 'Angular', 'FarFieldFresnel'.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.diameter","title":"<code>diameter = np.asarray(diameter, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.npixels","title":"<code>npixels = int(npixels)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.wavefront_type","title":"<code>wavefront_type = str(wavefront_type)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.__call__","title":"<code>__call__(wavefront, parameters, returns_parameters=True)</code>","text":"<p>Constructs a wavefront obect based on the parameters of the class and the parameters within the parameters dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>None</code> <p>Any empty None type input to the class in order to maintain the input conventions determied by the apply method of OpticalLayers.</p> required <code>parameters</code> <code>dict</code> <p>A dictionary of parameters needed to construct the wavefront.</p> required <code>returns_parametrs</code> <p>Determines if the class returns the parameters dictionary.</p> required <p>Returns:</p> Type Description <code>wavefront, parameters</code> <p>Returns the constructed wavefront and the updated parameters dictionary. If returns_parameters is False, only the wavefront is returned.</p>"},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.__init__","title":"<code>__init__(npixels, diameter, wavefront_type='Cartesian', name='CreateWavefront')</code>","text":"<p>Constructor for the CreateWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The number of pixels used to represent the wavefront.</p> required <code>diameter</code> <code>Array</code> <p>The diameter of the wavefront in the Pupil plane.</p> required <code>wavefront_type</code> <code>str</code> <p>Determines the type of wavefront class to create. Currently supports 'Cartesian', 'Angular', 'FarFieldFresnel'.</p> <code>'Cartesian'</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary. Default is 'CreateWavefront'.</p> <code>'CreateWavefront'</code>"},{"location":"optics/create_wavefront/#dLux.optics.CreateWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/normalise_wavefront/","title":"Normalise Wavefront","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Normalises the input wavefront using the in-built wavefront normalisation method.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/normalise_wavefront/#dLux.optics.NormaliseWavefront.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Normalises the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the wavefront normalisation method applied.</p>"},{"location":"optics/normalise_wavefront/#dLux.optics.NormaliseWavefront.__init__","title":"<code>__init__(name='NormaliseWavefront')</code>","text":"<p>Constructor for the NormaliseWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'NormaliseWavefront'</code>"},{"location":"optics/normalise_wavefront/#dLux.optics.NormaliseWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/rotate/","title":"Rotate","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Applies a rotation to the wavefront using interpolation methods.</p> <p>Attributes:</p> Name Type Description <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in the clockwise direction.</p> <code>real_imaginary</code> <code>bool</code> <p>Should the rotation be performed on the amplitude and phase array or the real and imaginary arrays.</p> <code>fourier</code> <code>bool</code> <p>Should the rotation be done using fourier methods or interpolation.</p> <code>order</code> <code>int = 1</code> <p>The order of the interpolation to use. Only applies if fourier is False. Must be 0, 1, or 3.</p> <code>padding</code> <code>int</code> <p>The amount of padding to use if the fourier method is used.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/rotate/#dLux.optics.Rotate.angle","title":"<code>angle = np.asarray(angle, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/rotate/#dLux.optics.Rotate.fourier","title":"<code>fourier = bool(fourier)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/rotate/#dLux.optics.Rotate.order","title":"<code>order = int(order)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/rotate/#dLux.optics.Rotate.padding","title":"<code>padding = padding if padding is None else int(padding)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/rotate/#dLux.optics.Rotate.real_imaginary","title":"<code>real_imaginary = bool(real_imaginary)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/rotate/#dLux.optics.Rotate.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the rotation to a wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The rotated wavefront.</p>"},{"location":"optics/rotate/#dLux.optics.Rotate.__init__","title":"<code>__init__(angle, real_imaginary=False, fourier=False, order=1, padding=None, name='Rotate')</code>","text":"<p>Constructor for the Rotate class.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array</code> <p>The angle by which to rotate the wavefront in the clockwise  direction.</p> required <code>real_imaginary</code> <code>bool</code> <p>Should the rotation be performed on the amplitude and phase array or the real and imaginary arrays.</p> <code>False</code> <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>order</code> <code>int</code> <p>The order of the interpolation to use. Only applies if fourier is False. Must be 0, 1, or 3.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'Rotate'</code>"},{"location":"optics/rotate/#dLux.optics.Rotate.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/tilt_wavefront/","title":"Tilt Wavefront","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Tilts the wavefront by the input tilt_angles.</p> <p>Attributes:</p> Name Type Description <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/tilt_wavefront/#dLux.optics.TiltWavefront.tilt_angles","title":"<code>tilt_angles = np.asarray(tilt_angles, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/tilt_wavefront/#dLux.optics.TiltWavefront.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the tilt_angle to the phase of the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the optical layer applied.</p>"},{"location":"optics/tilt_wavefront/#dLux.optics.TiltWavefront.__init__","title":"<code>__init__(tilt_angles, name='TiltWavefront')</code>","text":"<p>Constructor for the TiltWavefront class.</p> <p>Parameters:</p> Name Type Description Default <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary. Default is 'TiltWavefront'.</p> <code>'TiltWavefront'</code>"},{"location":"optics/tilt_wavefront/#dLux.optics.TiltWavefront.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"optics/transmissive_optic/","title":"Transmissive Optic","text":"<p>         Bases: <code>OpticalLayer</code></p> <p>Represents an arbitrary transmissive optic.</p> <p>Note this class does not normalise the 'transmission' between 0 and 1, but simply multiplies the wavefront amplitude by the transmision array.</p> <p>Attributes:</p> Name Type Description <code>transmission</code> <code>Array</code> <p>An array representing the transmission of the optic.</p> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p>"},{"location":"optics/transmissive_optic/#dLux.optics.TransmissiveOptic.transmission","title":"<code>transmission = np.asarray(transmission, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"optics/transmissive_optic/#dLux.optics.TransmissiveOptic.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Applies the tranmission of the optical to the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to operate on.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the tranmission applied.</p>"},{"location":"optics/transmissive_optic/#dLux.optics.TransmissiveOptic.__init__","title":"<code>__init__(transmission, name='TransmissiveOptic')</code>","text":"<p>Constructor for the TransmissiveOptic class.</p> <p>Parameters:</p> Name Type Description Default <code>transmission</code> <code>Array</code> <p>The array representing the transmission of the aperture. This must a 0, 2 or 3 dimensional array with equal to that of the wavefront at time of aplication.</p> required <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'TransmissiveOptic'</code>"},{"location":"optics/transmissive_optic/#dLux.optics.TransmissiveOptic.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"propagators/abstract/angular_propagator/","title":"Angular propagator","text":"<p>         Bases: <code>Propagator</code>, <code>ABC</code></p> <p>A simple propagator class designed to be inhereited by propagators that operate on wavefronts defined in angular units in focal planes.</p> <p>Attributes:</p> Name Type Description <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/angular_propagator/#dLux.propagators.AngularPropagator.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for Angular propagators.</p>"},{"location":"propagators/abstract/cartesian_propagator/","title":"Cartesian propagator","text":"<p>         Bases: <code>Propagator</code>, <code>ABC</code></p> <p>A propagator class to store the focal_length parameter for cartesian propagations defined by a physical propagation distance defined as focal_length.</p> <p>Attributes:</p> Name Type Description <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/cartesian_propagator/#dLux.propagators.CartesianPropagator.focal_length","title":"<code>focal_length = np.asarray(focal_length, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/cartesian_propagator/#dLux.propagators.CartesianPropagator.__init__","title":"<code>__init__(focal_length, **kwargs)</code>","text":"<p>Constructor for Cartesian propagators.</p> <p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required"},{"location":"propagators/abstract/far_field_fresnel/","title":"Far field fresnel","text":"<p>         Bases: <code>Propagator</code>, <code>ABC</code></p> <p>A propagator class to store the propagation_shift parameter required for Far-Field fresnel propagations. These classes implement algorithms that use quadratic phase factors to better represent out-of-plane behaviour of wavefronts, close to the focal plane.</p> <p>Attributes:</p> Name Type Description <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/far_field_fresnel/#dLux.propagators.FarFieldFresnel.propagation_shift","title":"<code>propagation_shift = np.asarray(propagation_shift, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/far_field_fresnel/#dLux.propagators.FarFieldFresnel.__init__","title":"<code>__init__(propagation_shift, **kwargs)</code>","text":"<p>Constructor for FarFieldFresnel propagators.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> required"},{"location":"propagators/abstract/fixed_sampling_propagator/","title":"Fixed sampling propagator","text":"<p>         Bases: <code>Propagator</code>, <code>ABC</code></p> <p>A propagator that implements the Fast Fourier Transform algorithm. This algorith has a fixed sampling in the output plane, at one fringe per pixel. Note the size of the 'fringe' in this context is similar to an optical fringe in that its angular size is calcualted via wavelength/wavefront diameter.</p> <p>These propagators are implemented using the jax.numpy.fft package, with the appropriate normalisations and pixel sizes tracked for optical propagation.</p> <p>Attributes:</p> Name Type Description <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/fixed_sampling_propagator/#dLux.propagators.FixedSamplingPropagator.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Propagates the <code>Wavefront</code>.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the optical layer applied.</p>"},{"location":"propagators/abstract/fixed_sampling_propagator/#dLux.propagators.FixedSamplingPropagator.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for FixedSampling propagators.</p>"},{"location":"propagators/abstract/fixed_sampling_propagator/#dLux.propagators.FixedSamplingPropagator.get_pixel_scale_out","title":"<code>get_pixel_scale_out(wavefront)</code>  <code>abstractmethod</code>","text":"<p>Calculates the pixel scale in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is being propagated.</p> required <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters or radians per pixel for Cartesian or Angular Wavefront respectively.</p>"},{"location":"propagators/abstract/fixed_sampling_propagator/#dLux.propagators.FixedSamplingPropagator.propagate","title":"<code>propagate(wavefront)</code>","text":"<p>Propagates the wavefront by perfroming a Fast Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The normalised electric field phasor after the propagation.</p>"},{"location":"propagators/abstract/propagator/","title":"Propagator","text":"<p>         Bases: <code>dLux.optics.OpticalLayer</code>, <code>ABC</code></p> <p>An abstract class to store the various properties of the propagation of some wavefront.</p> <p>Attributes:</p> Name Type Description <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/propagator/#dLux.propagators.Propagator.inverse","title":"<code>inverse = bool(inverse)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/propagator/#dLux.propagators.Propagator.__init__","title":"<code>__init__(inverse=False, **kwargs)</code>","text":"<p>Constructor for the Propagator.</p> <p>Parameters:</p> Name Type Description Default <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code>"},{"location":"propagators/abstract/propagator/#dLux.propagators.Propagator.propagate","title":"<code>propagate(wavefront)</code>  <code>abstractmethod</code>","text":"<p>Performs the propagation as a directional wrapper to the fourier methods of the class.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The `Wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The normalised electric field of the wavefront after propagation.</p>"},{"location":"propagators/abstract/variable_sampling_propagator/","title":"Variable sampling propagator","text":"<p>         Bases: <code>Propagator</code>, <code>ABC</code></p> <p>A propagator that implements the Soummer et. al. 2007 MFT algorithm allowing variable sampling in the outuput plane rather than the fixed sampling enforced by Fast Fourier Transforms(FFTs).</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in meters or radians per pixel for Cartesian or Angular Wavefront respectively.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.npixels_out","title":"<code>npixels_out = int(npixels_out)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.pixel_scale_out","title":"<code>pixel_scale_out = np.asarray(pixel_scale_out, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.pixel_shift","title":"<code>pixel_shift = bool(pixel_shift)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.shift","title":"<code>shift = np.asarray(shift, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.__call__","title":"<code>__call__(wavefront)</code>","text":"<p>Propagates the <code>Wavefront</code>.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The wavefront with the optical layer applied.</p>"},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.__init__","title":"<code>__init__(pixel_scale_out, npixels_out, shift=np.array([0.0, 0.0]), pixel_shift=False, **kwargs)</code>","text":"<p>Constructor for VariableSampling propagators.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters or radians per pixel for Cartesian or Angular Wavefront respectively.</p> required <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians). = True interprets the shift value in pixel units.</p> <code>False</code>"},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.get_nfringes","title":"<code>get_nfringes(wavefront)</code>  <code>abstractmethod</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p>"},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.get_shift","title":"<code>get_shift()</code>","text":"<p>Accessor for the shift parameter. Converts to units of pixels if the pixel_shift parameter is True.</p> <p>Returns:</p> Name Type Description <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront throughout the propagation.</p>"},{"location":"propagators/abstract/variable_sampling_propagator/#dLux.propagators.VariableSamplingPropagator.propagate","title":"<code>propagate(wavefront)</code>","text":"<p>Propagates the wavefront from the input plane to the output plane using a Matrix Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The normalised electric field phasor after the propagation.</p>"},{"location":"propagators/concrete/angular_fft/","title":"Angular FFT","text":"<p>         Bases: <code>AngularPropagator</code>, <code>FixedSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane using a Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel in pupil planes and radians/pixel in focal planes.</p> <p>Attributes:</p> Name Type Description <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/concrete/angular_fft/#dLux.propagators.AngularFFT.__init__","title":"<code>__init__(inverse=False, name='AngularFFT')</code>","text":"<p>Constructor for the AngularFFT propagator.</p> <p>Parameters:</p> Name Type Description Default <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AngularFFT'</code>"},{"location":"propagators/concrete/angular_fft/#dLux.propagators.AngularFFT.get_pixel_scale_out","title":"<code>get_pixel_scale_out(wavefront)</code>","text":"<p>Calculate the pixel scale in the output plane in units of radians per pixel.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront that is being propagated.</p> required <p>Returns:</p> Name Type Description <code>pixel_scale_out</code> <code>Array, radians</code> <p>The pixel scale in the output plane.</p>"},{"location":"propagators/concrete/angular_fft/#dLux.propagators.AngularFFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"propagators/concrete/angular_mft/","title":"Angular MFT","text":"<p>         Bases: <code>AngularPropagator</code>, <code>VariableSamplingPropagator</code></p> <p>A Propagator class designed to propagate wavefronts, with pixel scale units defined in meters per pixel in pupil planes and radians/pixel in focal planes, with a variable output sampling in the output plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel or radians/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel in pupil plane and radians per pixel in focal planes.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/concrete/angular_mft/#dLux.propagators.AngularMFT.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='AngularMFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>Array, radians</code> <p>The pixel scale in the output plane, measured in meters per pixel in pupil planes and radians per pixel in focal planes.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'AngularMFT'</code>"},{"location":"propagators/concrete/angular_mft/#dLux.propagators.AngularMFT.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p>"},{"location":"propagators/concrete/angular_mft/#dLux.propagators.AngularMFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"propagators/concrete/cartesian_fft/","title":"Cartesian FFT","text":"<p>         Bases: <code>CartesianPropagator</code>, <code>FixedSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane using a Fast Fourier Transfrom, with the pixel scale units defined in meters/pixel.</p> <p>Attributes:</p> Name Type Description <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/concrete/cartesian_fft/#dLux.propagators.CartesianFFT.__init__","title":"<code>__init__(focal_length, inverse=False, name='CartesianFFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianFFT'</code>"},{"location":"propagators/concrete/cartesian_fft/#dLux.propagators.CartesianFFT.get_pixel_scale_out","title":"<code>get_pixel_scale_out(wavefront)</code>","text":"<p>The pixel scale in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The <code>Wavefront</code> that is being propagted.</p> required <p>Returns:</p> Name Type Description <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane.</p>"},{"location":"propagators/concrete/cartesian_fft/#dLux.propagators.CartesianFFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"propagators/concrete/cartesian_fresnel/","title":"Cartesian Fresnel","text":"<p>         Bases: <code>FarFieldFresnel</code>, <code>CartesianMFT</code></p> <p>A propagator class to for Far-Field fresnel propagations. This classes implements algorithms that use quadratic phase factors to better represent out-of-plane behaviour of wavefronts, close to the focal plane. This class is designed to work on Cartesian wavefronts, ie pixel units are in meters/pixel in the output plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, focal_length, propagation_shift, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='CartesianFresnel')</code>","text":"<p>Constructor for the CartesianFresnel propagator</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>propagation_shift</code> <code>Array, meters</code> <p>The shift in the propagation distance of the wavefront.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianFresnel'</code>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.propagate","title":"<code>propagate(wavefront)</code>","text":"<p>Propagates the wavefront from the input plane to the output plane using a Matrix Fourier Transform.</p> <p>TODO: Set plane type to intermediate</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The normalised electric field phasor after the propagation.</p>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.quadratic_phase","title":"<code>quadratic_phase(x_coordinates, y_coordinates, wavelength, distance)</code>","text":"<p>A convinience function for calculating quadratic phase factors.</p> <p>Parameters:</p> Name Type Description Default <code>x_coordinates</code> <code>Array</code> <p>The x coordinates of the pixels in meters. This will be different in the plane of propagation and the initial plane.</p> required <code>y_coordinates</code> <code>Array</code> <p>The y coordinates of the pixels in meters. This will be different in the plane of propagation and the initial plane.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength of the wavefront.</p> required <code>distance</code> <code>Array, meters</code> <p>The distance that is to be propagated in meters.</p> required <p>Returns:</p> Name Type Description <code>quadratic_phase</code> <code>Array</code> <p>A set of phase factors that are useful in optical calculations.</p>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"propagators/concrete/cartesian_fresnel/#dLux.propagators.CartesianFresnel.transfer_function","title":"<code>transfer_function(wavefront, distance)</code>","text":"<p>The Optical Transfer Function defining the phase evolution of the wavefront when propagating to a non-conjugate plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront to propagate.</p> required <code>distance</code> <code>Array, meters</code> <p>The distance that is being propagated in meters.</p> required <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The field that represents the optical transfer.</p>"},{"location":"propagators/concrete/cartesian_mft/","title":"Cartesian MFT","text":"<p>         Bases: <code>CartesianPropagator</code>, <code>VariableSamplingPropagator</code></p> <p>A Propagator class designed to propagate a wavefront to a plane that is defined in cartesian units (ie meters/pixel), with a variable output sampling in that plane.</p> <p>Attributes:</p> Name Type Description <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> <code>pixel_scale_out</code> <code>Array, meters/pixel</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixels, or in the physical units of the output plane (ie pixels or meters, radians). True interprets the shift value in pixel units.</p> <code>name</code> <code>str</code> <p>The name for this propagator.</p>"},{"location":"propagators/concrete/cartesian_mft/#dLux.propagators.CartesianMFT.__init__","title":"<code>__init__(npixels_out, pixel_scale_out, focal_length, inverse=False, shift=np.array([0.0, 0.0]), pixel_shift=False, name='CartesianMFT')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels in the output plane.</p> required <code>pixel_scale_out</code> <code>Array, meters</code> <p>The pixel scale in the output plane, measured in meters per pixel.</p> required <code>focal_length</code> <code>Array, meters</code> <p>The focal_length of the lens/mirror this propagator represents.</p> required <code>inverse</code> <code>bool</code> <p>Is this an 'inverse' propagation. Non-inverse propagations represents propagation from a pupil to a focal plane, and inverse represents propagation from a focal to a pupil plane.</p> <code>False</code> <code>shift</code> <code>Array</code> <p>The (x, y) shift to apply to the wavefront in the output plane.</p> <code>np.array([0.0, 0.0])</code> <code>pixel_shift</code> <code>bool</code> <p>Should the shift value be considered in units of pixel, or in the physical units of the output plane (ie pixels or meters, radians).</p> <code>False</code> <code>name</code> <code>str</code> <p>The name of the layer, which is used to index the layers dictionary.</p> <code>'CartesianMFT'</code>"},{"location":"propagators/concrete/cartesian_mft/#dLux.propagators.CartesianMFT.get_nfringes","title":"<code>get_nfringes(wavefront)</code>","text":"<p>The number of diffraction fringes in the output plane.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront</code> <code>Wavefront</code> <p>The wavefront being propagated.</p> required <p>Returns:</p> Name Type Description <code>fringes</code> <code>Array</code> <p>The number of diffraction fringes in the output plane.</p>"},{"location":"propagators/concrete/cartesian_mft/#dLux.propagators.CartesianMFT.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/array_distribution/","title":"Array Distribution","text":"<p>         Bases: <code>ResolvedSource</code></p> <p>A class for modelling resolved sources that parameterise their resolved component using an array of intensities.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/array_distribution/#dLux.sources.ArrayDistribution.distribution","title":"<code>distribution = distribution / distribution.sum()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"sources/array_distribution/#dLux.sources.ArrayDistribution.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), spectrum=None, wavelengths=None, name='ArrayDistribution', **kwargs)</code>","text":"<p>Constructor for the ArrayDistribution class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'ArrayDistribution'</code>"},{"location":"sources/array_distribution/#dLux.sources.ArrayDistribution.get_distribution","title":"<code>get_distribution()</code>","text":"<p>Getter method for the source distribution.</p> <p>Returns:</p> Name Type Description <code>distribution</code> <code>Array, intensity</code> <p>The distribution of the source intensity.</p>"},{"location":"sources/array_distribution/#dLux.sources.ArrayDistribution.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new source object with a normalised total spectrum and source distribution.</p> <p>Returns:</p> Name Type Description <code>source</code> <code>Source</code> <p>The source object with the normalised spectrum and distribution.</p>"},{"location":"sources/array_distribution/#dLux.sources.ArrayDistribution.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/binary_source/","title":"Binary Source","text":"<p>         Bases: <code>RelativePositionSource</code>, <code>RelativeFluxSource</code></p> <p>A parameterised binary source.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the sources.</p> <code>separation</code> <code>Array, radians</code> <p>The separation of the two sources in radians.</p> <code>position_angle</code> <code>Array, radians</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the two sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/binary_source/#dLux.sources.BinarySource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), separation=None, position_angle=np.pi / 2, contrast=np.array(1.0), spectrum=None, wavelengths=None, name='BinarySource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the sources.</p> <code>np.array(1.0)</code> <code>separation</code> <code>Array, radians</code> <p>The separation of the two sources in radians.</p> <code>None</code> <code>position_angle</code> <code>Array, radians</code> <p>The position angle between the two sources measured clockwise from the vertical axis.</p> <code>np.pi / 2</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the two sources.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>CombinedSpectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'BinarySource'</code>"},{"location":"sources/binary_source/#dLux.sources.BinarySource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source source modelled through the optics.</p>"},{"location":"sources/binary_source/#dLux.sources.BinarySource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/multi_point_source/","title":"Multiple Point Sources","text":"<p>         Bases: <code>Source</code></p> <p>Concrete Class for multiple unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky positions of these sources.</p> <code>flux</code> <code>Array, photons</code> <p>The fluxes of the sources.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/multi_point_source/#dLux.sources.MultiPointSource.flux","title":"<code>flux = np.ones(len(self.positions)) if flux is None else np.asarray(flux, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"sources/multi_point_source/#dLux.sources.MultiPointSource.position","title":"<code>position = np.asarray(position, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"sources/multi_point_source/#dLux.sources.MultiPointSource.__init__","title":"<code>__init__(position, flux=None, spectrum=None, wavelengths=None, name='MultiPointSource')</code>","text":"<p>Constructor for the MultiPointSource class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The ((x0, y0), (x1, y1), ...) on-sky positions of these sourcese.</p> required <code>flux</code> <code>Array, photons</code> <p>The fluxes of the sources.</p> <code>None</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object. Every source in this class will have an identical spectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'MultiPointSource'</code>"},{"location":"sources/multi_point_source/#dLux.sources.MultiPointSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the point source through the optics.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source source modelled through the optics.</p>"},{"location":"sources/multi_point_source/#dLux.sources.MultiPointSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/point_and_extended_source/","title":"Point And Extended Source","text":"<p>         Bases: <code>RelativeFluxSource</code>, <code>ArrayDistribution</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source, but with its own spectra. An example would be an unresolved quasar within a resolved galaxy. These two objects have independent spectra but have their fluxes defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array (ie this class inherits from ArrayDistribution).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolves source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/point_and_extended_source/#dLux.sources.PointAndExtendedSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), contrast=np.array(1.0), spectrum=None, wavelengths=None, name='PointAndExtendedSource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>CombinedSpectrum</code> <p>The spectrum of this object, represented by a CombinedSpectrum.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointAndExtendedSource'</code>"},{"location":"sources/point_and_extended_source/#dLux.sources.PointAndExtendedSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution, while also modelling the single point source psf. Applied a different spectrum to the point source and resolved source.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the source objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed. Default is None which is uniform throughput.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p>"},{"location":"sources/point_and_extended_source/#dLux.sources.PointAndExtendedSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/point_extended_source/","title":"Point Extended Source","text":"<p>         Bases: <code>RelativeFluxSource</code>, <code>ArrayDistribution</code></p> <p>A class for modelling a point source and a resolved source that is defined relative to the point source. An example would be an unresolved star with a resolved dust shell or debris disk. These two objects share the same spectra but have their fluxes defined by flux (the mean flux) and the flux ratio (contrast) between the point source and resolved distribution. The resolved component is defined by an array (ie this class inherits from ArrayDistribution).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolved source.</p> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/point_extended_source/#dLux.sources.PointExtendedSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), distribution=np.ones((3, 3)), contrast=np.array(1.0), spectrum=None, wavelengths=None, name='PointExtendedSource')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The mean flux of the point and resolved source.</p> <code>np.array(1.0)</code> <code>distribution</code> <code>Array</code> <p>The array of intensities respresenting the resolved source.</p> <code>np.ones((3, 3))</code> <code>contrast</code> <code>Array</code> <p>The contrast ratio between the point source and the resolved source.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointExtendedSource'</code>"},{"location":"sources/point_extended_source/#dLux.sources.PointExtendedSource.model","title":"<code>model(optics, detector=None, filter_in=None)</code>","text":"<p>Method to model the psf of the source through the optics. Implements a basic convolution with the psf and source distribution, while also modelling the single point source psf.</p> <p>Parameters:</p> Name Type Description Default <code>optics</code> <code>Optics</code> <p>The optics through which to model the soource objects.</p> required <code>detector</code> <code>Detector</code> <p>The detector object that is observing the psf.</p> <code>None</code> <code>filter_in</code> <code>Filter</code> <p>The filter through which the source is being observed. Default is  None which is uniform throughput.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The psf of the source modelled through the optics.</p>"},{"location":"sources/point_extended_source/#dLux.sources.PointExtendedSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"sources/point_source/","title":"Point Source","text":"<p>         Bases: <code>Source</code></p> <p>Concrete Class for unresolved point source objects.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>name</code> <code>str</code> <p>The name for this object.</p>"},{"location":"sources/point_source/#dLux.sources.PointSource.__init__","title":"<code>__init__(position=np.array([0.0, 0.0]), flux=np.array(1.0), spectrum=None, wavelengths=None, name='PointSource')</code>","text":"<p>Constructor for the PointSource class.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Array, radians</code> <p>The (x, y) on-sky position of this object.</p> <code>np.array([0.0, 0.0])</code> <code>flux</code> <code>Array, photons</code> <p>The flux of the object.</p> <code>np.array(1.0)</code> <code>spectrum</code> <code>Spectrum</code> <p>The spectrum of this object, represented by a Spectrum object.</p> <code>None</code> <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name for this object.</p> <code>'PointSource'</code>"},{"location":"sources/point_source/#dLux.sources.PointSource.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"spectrums/array_spectrum/","title":"Array Spectrum","text":"<p>         Bases: <code>Spectrum</code></p> <p>A Spectrum class that interally parametersises the spectrum via arrays (ie wavelengths and weights)</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p> <code>name</code> <code>str</code> <p>The name of the spectrum.</p>"},{"location":"spectrums/array_spectrum/#dLux.spectrums.ArraySpectrum.weights","title":"<code>weights = weights / np.sum(weights)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"spectrums/array_spectrum/#dLux.spectrums.ArraySpectrum.__init__","title":"<code>__init__(wavelengths, weights=None, name='ArraySpectrum')</code>","text":"<p>Constructor for the ArraySpectrum class.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength. Defaults to uniform spectrum. Weights are automatically normalised to a sum of 1.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> <code>'ArraySpectrum'</code>"},{"location":"spectrums/array_spectrum/#dLux.spectrums.ArraySpectrum.get_weights","title":"<code>get_weights()</code>","text":"<p>Getter method for the weights.</p> <p>Returns:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The relative weights of each wavelength.</p>"},{"location":"spectrums/array_spectrum/#dLux.spectrums.ArraySpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new spectrum object with a normalised total spectrum.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Specturm</code> <p>The spectrum object with the normalised spectrum.</p>"},{"location":"spectrums/array_spectrum/#dLux.spectrums.ArraySpectrum.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"spectrums/combined_spectrum/","title":"Combined Spectrum","text":"<p>         Bases: <code>ArraySpectrum</code></p> <p>Implements a combined spectrum, in order to have only a single spectrum object for parameterised sources such as binary stars.</p> <p>TODO: Expand to be arbitrary number of spectrums, store only a single wavelengths array and tile it on the get_wavelengths method. (ie make work for MultiPointSource)</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, meters</code> <p>The (nspectra, nwavels) array of wavelengths at which the spectrum is  defined. Input can also be a 1d</p> <code>weights</code> <code>Array</code> <p>The (nspectra, nwavels) relative weights of each wavelength. Defaults  to uniform throughput.</p> <code>name</code> <code>str</code> <p>The name of the spectrum.</p>"},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.name","title":"<code>name = str(name)</code>  <code>instance-attribute</code>","text":""},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.wavelengths","title":"<code>wavelengths = np.asarray(wavelengths, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.weights","title":"<code>weights = np.asarray(weights, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.__init__","title":"<code>__init__(wavelengths, weights=None, name='CombinedSpectrum')</code>","text":"<p>Constructor for the CombinedSpectrum class. Expects wavelengths and weights to have the same dimensionality, ie (nsources, nwavelengths).</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The (nspectra, nwavels) array of wavelengths at which the spectrum  is defined. Input can also be a 1d</p> required <code>weights</code> <code>Array(optional)</code> <p>The (nspectra, nwavels) relative weights of each wavelength.  Defaults to uniform throughput.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the spectrum.</p> <code>'CombinedSpectrum'</code>"},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.normalise","title":"<code>normalise()</code>","text":"<p>Method for returning a new spectrum object with a normalised total spectrum for each individual source.</p> <p>Returns:</p> Name Type Description <code>spectrum</code> <code>Specturm</code> <p>The spectrum object with the normalised spectrums.</p>"},{"location":"spectrums/combined_spectrum/#dLux.spectrums.CombinedSpectrum.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"spectrums/polynomial_spectrum/","title":"Polynomial Spectrum","text":"<p>         Bases: <code>Spectrum</code></p> <p>Implements a generic polynomial spectrum. This is likely not needed and will probably just be turned into LinearSpectrum in the future.</p> <p>This implements a polynomial as follows: f(x) = c0 + c1x + c2x^2 + ... + cn*x^n</p> <p>Attributes:</p> Name Type Description <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> <code>degree</code> <code>int</code> <p>The degree of the polynomial.</p> <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> <code>name</code> <code>str</code> <p>The name of the spectrum.</p>"},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.coefficients","title":"<code>coefficients = np.asarray(coefficients, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.degree","title":"<code>degree = int(len(coefficients) - 1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.__init__","title":"<code>__init__(wavelengths, coefficients, name='PolynomialSpectrum')</code>","text":"<p>Constructor for the PolynomialSpectrum class.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The array of wavelengths at which the spectrum is defined.</p> required <code>coefficients</code> <code>Array</code> <p>The array of polynomial coefficient values.</p> required <code>name</code> <code>str</code> <p>The name of the spectrum.</p> <code>'PolynomialSpectrum'</code>"},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.get_weights","title":"<code>get_weights()</code>","text":"<p>Gets the relative spectral weights by evalutating the polynomial function at the internal wavelengths. This automaically normalises the weights to have unitary amplitude.</p> <p>Returns:</p> Name Type Description <code>weights</code> <code>Array</code> <p>The normalised relative weights of each wavelength.</p>"},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.normalise","title":"<code>normalise()</code>","text":"<p>This method currently does nothing becuase solving for normalised polynomial coefficients is difficut and the get_weights() method already returns normalised weights.</p> <p>Returns: spectrum : Specturm     The unmodified spectrum object</p>"},{"location":"spectrums/polynomial_spectrum/#dLux.spectrums.PolynomialSpectrum.summary","title":"<code>summary(angular_units='radians', cartesian_units='meters', sigfigs=4)</code>","text":"<p>Returns a summary of the class.</p> <p>Parameters:</p> Name Type Description Default <code>angular_units</code> <code>str</code> <p>The angular units to use in the summary. Options are 'radians',  'degrees', 'arcseconds' and 'arcminutes'.</p> <code>'radians'</code> <code>cartesian_units</code> <code>str</code> <p>The cartesian units to use in the summary. Options are 'meters', 'millimeters' and 'microns'.</p> <code>'meters'</code> <code>sigfigs</code> <code>int</code> <p>The number of significant figures to use in the summary.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>str</code> <p>A summary of the class.</p>"},{"location":"utils/bayes/calculate_covariance/","title":"calculate covariance","text":"<p>Calcuates the covariance matrix under the Laplace approximation for the given likelihood function. The args and *kwargs are passed to the likelihood function.</p> <p>Parameters:</p> Name Type Description Default <code>likelihood_fn</code> <code>Callable</code> <p>The likelihood function to calculate the covaraince matrix with respect to.</p> required <p>Returns:</p> Name Type Description <code>covaraince</code> <code>Array</code> <p>The corresponding covariance matrix.</p>"},{"location":"utils/bayes/calculate_entropy/","title":"calculate entropy","text":"<p>Calcuates the entropy of the covaraince matrix under the Laplace approximation for the given likelihood function. The args and *kwargs are passed to through the calculate_covaraince function through to the likelihood function.</p> <p>Parameters:</p> Name Type Description Default <code>likelihood_fn</code> <code>Callable</code> <p>The likelihood function to calculate the entropy with respect to.</p> required <p>Returns:</p> Name Type Description <code>entropy</code> <code>Array</code> <p>The entropy of the covariance matrix for the given likelihood function.</p>"},{"location":"utils/bayes/chi2_likelihood/","title":"chi2 likelihood","text":"<p>Calculates the chi2 likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The chi2 likelihood of the updated model with respect to the data.</p>"},{"location":"utils/bayes/chi2_log_likelihood/","title":"chi2 log likelihood","text":"<p>Calculates the chi2 log likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The chi2 log likelihood of the updated model with respect to the data.</p>"},{"location":"utils/bayes/poisson_likelihood/","title":"poisson likelihood","text":"<p>Calculates the poissonion likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The poissonian likelihood of the updated model with respect to the data.</p>"},{"location":"utils/bayes/poisson_log_likelihood/","title":"poisson log likelihood","text":"<p>Calculates the poissonion log likelihood after updating the model using the update_fn. The extra args and *kwargs are passed to the model function.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Array</code> <p>The array of values to update the model with.</p> required <code>data</code> <code>Array</code> <p>The data to calulcate the prior with respect to.</p> required <code>model</code> <code>object</code> <p>The model used to model the data.</p> required <code>update_fn</code> <code>Callable</code> <p>The function used to update the model before modelling. This should take in the X array as the first argument and the model as the second.</p> required <code>model_fn</code> <code>str</code> <p>The name of the model function to use.</p> required <p>Returns:</p> Name Type Description <code>likelhood</code> <code>Array</code> <p>The poissonian log likelihood of the updated model with respect to the data.</p>"},{"location":"utils/coordinates/cartesian_to_polar/","title":"cartesian to polar","text":"<p>Converts the input (x, y) cartesian cordinates into (r, phi) polar coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (x, y) cartesian coordinates to be converted into polar cordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input cartesian coordinates converted into (r, phi) polar cordinates.</p>"},{"location":"utils/coordinates/compress/","title":"compress","text":"<p>Apply a compression to the coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>compression</code> <code>Array</code> <p>The (x, y) compression with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The compressed coordinates.</p>"},{"location":"utils/coordinates/get_pixel_positions/","title":"get pixel positions","text":"<p>Calculates the positions of the pixel centers for the given input. All  coordinates are output in units of meters. </p> <p>The indexing argument is the same as in numpy.meshgrid., ie:  Giving the string \u2018ij\u2019 returns a meshgrid with  matrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing. In  the 2-D case with inputs of length M and N, the outputs are of shape (N, M)  for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing. In the 3-D case with inputs  of length M, N and P, outputs are of shape (N, M, P) for \u2018xy\u2019 indexing and  (M, N, P) for \u2018ij\u2019 indexing. If the output is in polar coordainates,  indexing is set to 'xy' and the input must be 2d</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>Union[int, tuple]</code> <p>The number of pixels in each dimension.</p> required <code>pixel_scales</code> <code>Union[tuple, float, None]</code> <p>The pixel scales in each dimension. If a tuple, the length of the tuple must match the number of dimensions. If a float, the same scale is applied to all dimensions. If None, the scale is set to 1.</p> <code>None</code> <code>offsets</code> <code>Union[tuple, float, None]</code> <p>The offset of the pixel centers in each dimension. If a tuple, the  length of the tuple must match the number of dimensions. If a float,  the same offset is applied to all dimensions. If None, the offset is  set to 0.</p> <code>None</code> <code>polar</code> <code>bool</code> <p>If True, the output is in polar coordinates. If False, the output is in cartesian coordinates. Default is False.</p> <code>False</code> <code>indexing</code> <code>str</code> <p>The indexing of the output. Default is 'xy'. See numpy.meshgrid for more details.</p> <code>'xy'</code> <p>Returns:</p> Name Type Description <code>positions</code> <code>Array</code> <p>The positions of the pixel centers in the given dimensions.</p>"},{"location":"utils/coordinates/polar_to_cartesian/","title":"polar to cartesian","text":"<p>Converts the input (r, phi) polar coordinates into (x, y) cartesian cordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array</code> <p>The (r, phi) polar coordinates to be converted into cartesian cordinates.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The input polar coordinates converted into (x, y) cartesian cordinates.</p>"},{"location":"utils/coordinates/rotate/","title":"rotate","text":"<p>Rotate the coordinate system by a pre-specified amount.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>A <code>(2, npix, npix)</code> representation of the coordinate  system. The leading dimensions specifies the x and then  the y coordinates in that order.</p> required <code>rotation</code> <code>Array, radians</code> <p>The counter-clockwise rotation to apply.</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The rotated coordinate system.</p>"},{"location":"utils/coordinates/shear/","title":"shear","text":"<p>Apply a shear to the coordinate system. </p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>shear</code> <code>Array</code> <p>The (x, y) shear with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The sheared coordinate system.</p>"},{"location":"utils/coordinates/translate/","title":"translate","text":"<p>Move the center of the coordinate system by some  amount (centre). </p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>Array, meters</code> <p>The (x, y) coordinates with the dimensions  (2, npix, npix).</p> required <code>centre</code> <code>Array, meters</code> <p>The (x, y) coordinates of the new centre  with dimensions (2,)</p> required <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array, meters</code> <p>The translated coordinate system.</p>"},{"location":"utils/gradient_energy/get_GE/","title":"get GE","text":"<p>Calcuates the spatial gradient energy of the array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to calcuate the gradient energy for.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array of gradient energies.</p>"},{"location":"utils/gradient_energy/get_RGE/","title":"get RGE","text":"<p>Calcuates the spatial radial gradient energy of the array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to calcuate the radial gradient energy for.</p> required <code>epsilon</code> <code>float</code> <p>A small value added to the radial values to help with gradient stability.</p> <code>1e-08</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array of radial gradient energies.</p>"},{"location":"utils/gradient_energy/get_RWGE/","title":"get RWGE","text":"<p>Calcuates the spatial radially weighted gradient energy of the array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to calcuate the radially weighted gradient energy for.</p> required <code>epsilon</code> <code>float</code> <p>A small value added to the radially weighted values to help with gradient stability.</p> <code>1e-08</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array of radial radially weighted energies.</p>"},{"location":"utils/gradient_energy/get_radial_mask/","title":"get radial mask","text":"<p>Calcautes a binary radial mask, masking out radii below rmin, and above rmax.</p> <p>Parameters:</p> Name Type Description Default <code>npixels</code> <code>int</code> <p>The linear size of the array.</p> required <code>rmin</code> <code>Array</code> <p>The inner radius to mask out.</p> required <code>rmax</code> <code>Array</code> <p>The outer radius to mask out.</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>Array</code> <p>A mask with the the values below rmin and above rmax masked out.</p>"},{"location":"utils/helpers/list_to_dictionary/","title":"list to dictionary","text":"<p>Converts some input list of dLux layers and converts them into an OrderedDict with the correct structure, ensuring that all keys are unique.</p> <p>Parameters:</p> Name Type Description Default <code>list_in</code> <code>list</code> <p>The list of dLux OpticalLayers or DetectorLayers to be converted into a dictionary.</p> required <code>ordered</code> <code>bool</code> <p>Whether to return an ordered or regular dictionary.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dictionary</code> <code>dict</code> <p>The equivilent dictionary or ordered dictionary.</p>"},{"location":"utils/helpers/single_image_plot/","title":"Single image plot","text":"<p>Plots a  single image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The first array to plot.</p> required <code>figsize</code> <code>tuple</code> <p>The size of the figure to display.</p> <code>(5, 4)</code> <code>title</code> <code>str</code> <p>The title of the array.</p> <code>'Array'</code> <code>cmap</code> <code>str</code> <p>The colour map to use.</p> <code>'inferno'</code> <code>bound</code> <code>float</code> <p>The bound of the colour map.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>The resolution of the figure.</p> <code>120</code>"},{"location":"utils/helpers/spectrum_plot/","title":"Spectrum plot","text":"<p>Plots a spectrum based on wavelgths and weights.</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Array, meters</code> <p>The wavelengths of the spectrum.</p> required <code>weights</code> <code>Array</code> <p>The weights of the spectrum.</p> required <code>figsize</code> <code>tuple</code> <p>The size of the figure to display.</p> <code>(6, 3)</code> <code>labels</code> <code>tuple</code> <p>The labels of the spectra.</p> <code>None</code> <code>cartesian_units</code> <code>str</code> <p>The units of the wavelengths.</p> <code>'meters'</code> <code>dpi</code> <code>int</code> <p>The resolution of the figure.</p> <code>120</code>"},{"location":"utils/helpers/two_image_plot/","title":"two image plot","text":"<p>Plots two images side by side.</p> <p>Parameters:</p> Name Type Description Default <code>array1</code> <code>Array</code> <p>The first array to plot.</p> required <code>array2</code> <code>Array</code> <p>The second array to plot.</p> required <code>figsize</code> <code>tuple</code> <p>The size of the figure to display.</p> <code>(10, 4)</code> <code>titles</code> <code>tuple</code> <p>The titles of the arrays.</p> <code>('Array 1', 'Array 2')</code> <code>cmaps</code> <code>tuple</code> <p>The colour maps to use.</p> <code>('inferno', 'inferno')</code> <code>bounds</code> <code>tuple</code> <p>The bounds of the colour maps.</p> <code>(None, None)</code> <code>dpi</code> <code>int</code> <p>The resolution of the figure.</p> <code>120</code>"},{"location":"utils/interpolation/fourier_rotate/","title":"fourier_rotate","text":"<p>Rotates an array by the angle, using a fourier rotation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle to rotate the array by.</p> required <code>padding</code> <code>int</code> <p>The amount of fourier padding to use.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p>"},{"location":"utils/interpolation/generate_coordinates/","title":"generate coordinates","text":"<p>Generates a new set of paraxial coordinates which can be used for interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_in</code> <code>int</code> <p>The number of pixels in the original array.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>coordinates</code> <code>Array</code> <p>The output coordinates at which to interpolate onto.</p>"},{"location":"utils/interpolation/interpolate/","title":"interpolate","text":"<p>Paraxially interpolates an array based on the sampling ratio, and npixels_out.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The input array to interpolate.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The interpolated arrays.</p>"},{"location":"utils/interpolation/interpolate_field/","title":"interpolate field","text":"<p>Paraxially interpolates a wavefront field (either in ampltude and phase, or real and imaginiary) based on the sampling ratio, and npixels_out.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Array</code> <p>The input field to interpolate, either in amplitude and phase, or real and imaginary.</p> required <code>npixels_out</code> <code>int</code> <p>The number of pixel in the output array.</p> required <code>sampling_ratio</code> <code>Array</code> <p>The ratio of pixel sizes in the input and output array, ie pixel_scale_out/pixel_scale_in.</p> required <code>real_imaginary</code> <code>bool</code> <p>Is the input field given in amplitude and phase, or real and imagninary.</p> <code>False</code> <code>x_shift</code> <code>Array, pixles</code> <p>How much to shift the x_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <code>y_shift</code> <code>Array, pixles</code> <p>How much to shift the y_coordinates in the output array, in the pixel units of the output array.</p> <code>np.array(0.0)</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The interpolated output amplitude and phase arrays.</p>"},{"location":"utils/interpolation/rotate/","title":"rotate","text":"<p>Rotates an array by the angle, using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to rotate.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle to rotate the array by.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The rotated array.</p>"},{"location":"utils/interpolation/rotate_field/","title":"Rotate field","text":"<p>Paraxially rotates a wavefront field (either in ampltude and phase, or real and imaginiary) in the {}wise direction by angle. Two methods are available, interpolation and fourier rotation. Interpolation is much faster with large arrays, and fourier rotation is information preserving.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Array</code> <p>The input field to rotate, either in amplitude and phase, or real and imaginary.</p> required <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in a {}wise direction.</p> required <code>real_imaginary</code> <code>bool</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the the amplitude and phase representation.</p> <code>False</code> <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>order</code> <code>int</code> <p>The interpolation order to use. Must be 0, 1, or 3.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The rotated output amplitude and phase arrays.</p>"},{"location":"utils/interpolation/scale_array/","title":"scale array","text":"<p>Scales some input array to size_out using interolation.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>The array to scale.</p> required <code>size_out</code> <code>int</code> <p>The output size of the mask</p> required <code>order</code> <code>int</code> <p>The interpolation order. Supports 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>array</code> <code>Array</code> <p>The array scaled to size_out</p>"},{"location":"utils/math/factorial/","title":"factorial","text":"<p>Calculate n! in a jax friendly way. Note that n == 0 is not a  safe case.  </p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The value to calculate the factorial of.</p> required <p>Returns:</p> Type Description <code>n</code> <p>The factorial of the value.</p>"},{"location":"utils/models/simple_optical_system/","title":"simple optical system","text":"<p>Constucts a simple Fourier optical system.</p> <p>Parameters:</p> Name Type Description Default <code>aperture_diameter</code> <code>Array, meters</code> <p>The diameter of the optical system aperture.</p> required <code>wavefront_npixels</code> <code>int</code> <p>The number of pixel used to represent the wavefront.</p> required <code>detector_npixels</code> <code>int</code> <p>The number of pixel of the detector</p> required <code>detector_pixel_size</code> <code>Array, arcseconds</code> <p>The size of the detector pixels. Taken in units of arcseconds per pixel if anuglar == True, else units are taken in meters per pixel.</p> required <code>angular</code> <code>bool</code> <p>Whether to use angular (radians) or cartesian (meters) units.</p> <code>True</code> <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. This paramter is only used if angular == False.</p> <code>None</code> <code>secondary_mirror_diameter</code> <code>Array</code> <p>The diameter of the secondary mirror obscuration.</p> <code>None</code> <code>nzernike</code> <code>int</code> <p>The number of zernike terms to use. Ignore piston tip tilt.</p> <code>None</code> <code>zernike_coefficients</code> <code>Array</code> <p>The values of the zernike coefficients. Only used if nzerike == None.</p> <code>None</code> <code>extra_layers</code> <code>list</code> <p>The extra layers to add to the optical system.</p> <code>None</code> <code>return_layers</code> <code>bool</code> <p>Should the function return the layers, or an Optics class.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>optics</code> <code>OpticalSystem</code> <p>The optical system with the optical layers loaded.</p>"},{"location":"utils/models/toliman/","title":"toliman","text":"<p>Gets a simple Toliman optical system by calling the simple_optical_system function with pre-loaded values.</p> <p>Parameters:</p> Name Type Description Default <code>wavefront_npixels</code> <code>int</code> <p>The number of pixel used to represent the wavefront.</p> required <code>detector_npixels</code> <code>int</code> <p>The number of pixel of the detector</p> required <code>aperture_diameter</code> <code>Array, meters</code> <p>The diameter of the optical system aperture.</p> <code>0.13</code> <code>secondary_mirror_diameter</code> <code>Array</code> <p>The diameter of the secondary mirror obscuration.</p> <code>0.032</code> <code>detector_pixel_size</code> <code>Array, arcseconds</code> <p>The size of the detector pixels. Taken in units of arcseconds per pixel if anuglar == True, else units are taken in meters per pixel. The physical detector pixels are 2.4um</p> <code>0.375</code> <code>angular</code> <code>bool</code> <p>Whether to use angular (radians) or cartesian (meters) units.</p> <code>True</code> <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. This paramter is only used if angular == False. The EFL is 1.32m.</p> <code>None</code> <code>nzernike</code> <code>int</code> <p>The number of zernike terms to use. Ignore piston tip tilt.</p> <code>None</code> <code>zernike_coefficients</code> <code>Array</code> <p>The values of the zernike coefficients. Only used if nzerike == None.</p> <code>None</code> <code>extra_layers</code> <code>list</code> <p>The extra layers to add to the optical system.</p> <code>None</code> <code>return_layers</code> <code>bool</code> <p>Should the function return the layers, or an Optics class.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>optics</code> <code>OpticalSystem</code> <p>The optical system with the optical layers loaded.</p>"},{"location":"utils/optics/get_airy_pixel_scale/","title":"get airy pixel scale","text":"<p>Calcaultes the pixel_size needed in order to sample the diffraction fringes at the given sampling rate. Applies the 1.22 multiplier for Airy disk diffraction fringes given by a circular aperture.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or meters per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radans per pixel if no focal length is provided, else in units of meters per pixel.</p>"},{"location":"utils/optics/get_fringe_size/","title":"get fringe size","text":"<p>Calcualtes the angular size of the diffraction fringes.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <p>Returns:</p> Name Type Description <code>fringe_size</code> <code>Array, radians</code> <p>The angular fringe size in units of radians.</p>"},{"location":"utils/optics/get_pixel_scale/","title":"get pixel scale","text":"<p>Calcaultes the pixel_size needed in order to sample the diffraction fringes at the given sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>sampling_rate</code> <code>Array</code> <p>The rate at which to sample the diffraction fringes. A value of 2 will give nyquist sampled pixels.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The observation wavelength.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is given in units of radians per pixel, else it is given in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>pixel_scale</code> <code>Array, radians per pixel or meters per pixel</code> <p>The pixel_size needed to sample the diffraction fringes at the input sampling rate, in units of radans per pixel if no focal length is provided, else in units of meters per pixel.</p>"},{"location":"utils/optics/get_pixels_per_fringe/","title":"get pixels per fringe","text":"<p>Calculates the number of pixels per diffraction fringe, ie the fringe sampling rate.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the diffraction fringe for.</p> required <code>aperture</code> <code>Array, meters</code> <p>The size of the aperture.</p> required <code>pixel_scale</code> <code>Array, meters</code> <p>The size of each pixel. This is taken in units of radians per pixel if no focal length is provided, else it is taken in size of meters per pixel.</p> required <code>focal_length</code> <code>Array</code> <p>The focal length of the optical system. If none is provided, the pixel scale is taken in units of radians per pixel, else it is taken in meters per pixel.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sampling</code> <code>Array</code> <p>The sampling rate of the fringes in units of pixels.</p>"},{"location":"utils/optics/opd_to_phase/","title":"opd to phase","text":"<p>Converts the input Optical Path Difference (opd) in units of meters to phases in units of radians for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>opd</code> <code>Array, meters</code> <p>The Optical Path Difference (opd) to be converted into phase.</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>phase</code> <code>Array, radians</code> <p>The equivilent phase value for the given opd and wavelength.</p>"},{"location":"utils/optics/phase_to_opd/","title":"phase to opd","text":"<p>Converts the input phase in units of radians to the equivilent Optical Path Difference (opd) in meters for the given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phase to be converted into Optical Path Difference (opd)</p> required <code>wavelength</code> <code>Array, meters</code> <p>The wavelength at which to calculate the phase for.</p> required <p>Returns:</p> Name Type Description <code>opd</code> <code>Array, meters</code> <p>The equivilent opd value for the given phase and wavelength.</p>"},{"location":"utils/units/arcminutes_to_arcseconds/","title":"arcminutes to arcseconds","text":"<p>Converts the inputs values from arcminutes to arcseconds.</p> <p>Can also be imported as m2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p>"},{"location":"utils/units/arcminutes_to_degrees/","title":"arcminutes to degrees","text":"<p>Converts the inputs values from arcminutes to degrees.</p> <p>Can also be imported as m2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p>"},{"location":"utils/units/arcminutes_to_radians/","title":"arcminutes to radians","text":"<p>Converts the inputs values from arcminutes to radians.</p> <p>Can also be imported as m2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcminutes</code> <p>The input values in units of arcminutes to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p>"},{"location":"utils/units/arcseconds_to_arcminutes/","title":"arcseconds to arcminutes","text":"<p>Converts the inputs values from arcseconds to arcminutes.</p> <p>Can also be imported as s2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p>"},{"location":"utils/units/arcseconds_to_degrees/","title":"arcseconds to degrees","text":"<p>Converts the inputs values from arcseconds to degrees.</p> <p>Can also be imported as s2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p>"},{"location":"utils/units/arcseconds_to_radians/","title":"arcseconds to radians","text":"<p>Converts the inputs values from arcseconds to radians.</p> <p>Can also be imported as s2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, arcseconds</code> <p>The input values in units of arcseconds to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p>"},{"location":"utils/units/convert_angular/","title":"convert angular","text":"<p>Converts the input values from one unit to another.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array</code> <p>The input values to be converted.</p> required <code>input</code> <code>str</code> <p>The input units. Must be one of 'radians', 'degrees', 'arcseconds', or 'arcminutes'.</p> <code>'radians'</code> <code>output</code> <code>str</code> <p>The output units. Must be one of 'radians', 'degrees', 'arcseconds', or 'arcminutes'.</p> <code>'radians'</code> <p>Returns:</p> Name Type Description <code>values</code> <code>Array</code> <p>The input values converted into the output units.</p>"},{"location":"utils/units/convert_cartesian/","title":"convert cartesian","text":"<p>Converts the input values from one unit to another.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array</code> <p>The input values to be converted.</p> required <code>input</code> <code>str</code> <p>The input units. Must be one of 'meters', 'millimeters', or 'microns'.</p> <code>'meters'</code> <code>output</code> <code>str</code> <p>The output units. Must be one of 'meters', 'millimeters', or 'microns'.</p> <code>'meters'</code> <p>Returns:</p> Name Type Description <code>values</code> <code>Array</code> <p>The input values converted into the output units.</p>"},{"location":"utils/units/degrees_to_arcminutes/","title":"degrees to arcminutes","text":"<p>Converts the inputs values from degrees to arcminutes.</p> <p>Can also be imported as d2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p>"},{"location":"utils/units/degrees_to_arcseconds/","title":"degrees to arcseconds","text":"<p>Converts the inputs values from degrees to arcseconds.</p> <p>Can also be imported as d2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p>"},{"location":"utils/units/degrees_to_radians/","title":"degrees to radians","text":"<p>Converts the inputs values from degrees to radians.</p> <p>Can also be imported as d2r.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, degrees</code> <p>The input values in units of degrees to be converted into radians.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, radians</code> <p>The input values converted into radians.</p>"},{"location":"utils/units/radians_to_arcminutes/","title":"radians to arcminutes","text":"<p>Converts the inputs values from radians to arcminutes.</p> <p>Can also be imported as r2m.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcminutes.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcminutes</code> <p>The input values converted into arcminutes.</p>"},{"location":"utils/units/radians_to_arcseconds/","title":"radians to arcseconds","text":"<p>Converts the inputs values from radians to arcseconds.</p> <p>Can also be imported as r2s.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into arcseconds.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, arcseconds</code> <p>The input values converted into arcseconds.</p>"},{"location":"utils/units/radians_to_degrees/","title":"radians to degrees","text":"<p>Converts the inputs values from radians to degrees.</p> <p>Can also be imported as r2d.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array, radians</code> <p>The input values in units of radians to be converted into degrees.</p> required <p>Returns:</p> Name Type Description <code>values</code> <code>Array, degrees</code> <p>The input values converted into degrees.</p>"},{"location":"wavefronts/angular_wavefront/","title":"Angular Wavefront","text":"<p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. AngularWavefronts have pixel scales in units of meters per pixel in Pupil planes and radians per pixel in Focal planes.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel or radians/pixel</code> <p>The physical dimensions of the pixels representing the wavefront. This is in units of meters per pixel in pupil planes and radians per pixel in focal planes.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p>"},{"location":"wavefronts/angular_wavefront/#dLux.wavefronts.AngularWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for Angular wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel. Units are in meters per pixel in Pupil planes and radians per pixel in Focal planes.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required"},{"location":"wavefronts/cartesian_wavefront/","title":"Cartesian Wavefront","text":"<p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. CartesianWavefronts have pixel scales in units of meters per pixel in all planes.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel</code> <p>The physical dimensions of the pixels representing the wavefront.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p>"},{"location":"wavefronts/cartesian_wavefront/#dLux.wavefronts.CartesianWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for Cartesian wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required"},{"location":"wavefronts/far_field_fresnel_wavefront/","title":"Far Field Fresnel Wavefront","text":"<p>         Bases: <code>Wavefront</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type. FarFieldFresnelWavefronts are designed to work with FarFieldFresnel Propagators, and are better able to represent the behaviour of wavefronts outside of the focal planes, in the far-field approximation.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel</code> <p>The physical dimensions of the pixels representing the wavefront.</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p>"},{"location":"wavefronts/far_field_fresnel_wavefront/#dLux.wavefronts.FarFieldFresnelWavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for FarFieldFresnel wavefronts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each pixel. Units are in meters per pixel in Pupil planes and meters per pixel or radians per pixel in Focal planes depending on if Cartesian or Angular Propagators are used respectively.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required"},{"location":"wavefronts/wavefront/","title":"Wavefront","text":"<p>         Bases: <code>Base</code>, <code>ABC</code></p> <p>A class representing some wavefront, designed to track the various parameters such as wavelength, pixel_scale, amplitude and phase, as well as a helper parmeter, plane_type.</p> <p>All wavefronts currently only support square amplitude and phase arrays.</p> <p>Attributes:</p> Name Type Description <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> <code>pixel_scale</code> <code>float, meters/pixel or radians/pixel</code> <p>The physical dimensions of the pixels representing the wavefront. This can be in units of either meters per pixel or radians per pixel depending on both the plane type and the wavfront type (Cartesian or Angular).</p> <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane type of wavefront, can be Pupil, Focal or Intermediate.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.amplitude","title":"<code>amplitude = np.asarray(amplitude, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.diameter","title":"<code>diameter: Array</code>  <code>property</code>","text":"<p>Returns the current wavefront diameter calulated using the pixel scale and number of pixels.</p> <p>Returns:</p> Name Type Description <code>diameter</code> <code>Array, meters or radians</code> <p>The current diameter of the wavefront.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.imaginary","title":"<code>imaginary: Array</code>  <code>property</code>","text":"<p>Returns the imaginary component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The imaginary component of the <code>Wavefront</code> phasor.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.nfields","title":"<code>nfields: int</code>  <code>property</code>","text":"<p>Returns the number of polarisation fields currently representing the wavefront. Taken from the amplitude array first dimension.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of polarisation fields that represent the <code>Wavefront</code>.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.npixels","title":"<code>npixels: int</code>  <code>property</code>","text":"<p>Returns the side length of the arrays currently representing the wavefront. Taken from the amplitude array.</p> <p>Returns:</p> Name Type Description <code>pixels</code> <code>int</code> <p>The number of pixels that represent the <code>Wavefront</code>.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.phase","title":"<code>phase = np.asarray(phase, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.phasor","title":"<code>phasor: Array</code>  <code>property</code>","text":"<p>The electric field phasor described by this Wavefront in complex form.</p> <p>Returns:</p> Name Type Description <code>field</code> <code>Array</code> <p>The electric field phasor of the wavefront.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.pixel_coordinates","title":"<code>pixel_coordinates: Array</code>  <code>property</code>","text":"<p>Returns the physical positions of the wavefront pixels in meters.</p> <p>Returns:</p> Name Type Description <code>pixel_positions</code> <code>Array</code> <p>The coordinates of the centers of each pixel representing the wavefront.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.pixel_scale","title":"<code>pixel_scale = np.asarray(pixel_scale, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.plane_type","title":"<code>plane_type = plane_type</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.psf","title":"<code>psf: Array</code>  <code>property</code>","text":"<p>Calculates the Point Spread Function (PSF), ie the squared modulus of the complex wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.real","title":"<code>real: Array</code>  <code>property</code>","text":"<p>Returns the real component of the <code>Wavefront</code>.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Array</code> <p>The real component of the <code>Wavefront</code> phasor.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.wavelength","title":"<code>wavelength = np.asarray(wavelength, dtype=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.wavenumber","title":"<code>wavenumber: Array</code>  <code>property</code>","text":"<p>Returns the wavenumber of the wavefront (2 * pi / wavelength).</p> <p>Returns:</p> Name Type Description <code>wavenumber</code> <code>Array, 1</code> <p>The wavenumber of the wavefront.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.__init__","title":"<code>__init__(wavelength, pixel_scale, amplitude, phase, plane_type)</code>","text":"<p>Constructor for the wavefront.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float, meters</code> <p>The wavelength of the <code>Wavefront</code>.</p> required <code>pixel_scale</code> <code>float, meters</code> <p>The physical dimensions of each square pixel.</p> required <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <code>phase</code> <code>Array, radians</code> <p>The electric field phase of the <code>Wavefront</code>.</p> required <code>plane_type</code> <code>enum.IntEnum.PlaneType</code> <p>The current plane of wavefront, can be Pupil, Focal.</p> required"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.add_opd","title":"<code>add_opd(path_difference)</code>","text":"<p>Applies the wavelength-dependent phase based on the supplied optical path difference.</p> <p>Parameters:</p> Name Type Description Default <code>path_difference</code> <code>Array, meters</code> <p>The physical optical path difference of either the entire wavefront or each pixel individually.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phases updated according to the supplied path_difference</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.add_phase","title":"<code>add_phase(array_like)</code>","text":"<p>Add to the phase of the <code>Wavefront</code> by either a float or array.</p> <p>Parameters:</p> Name Type Description Default <code>array_like</code> <code>Array</code> <p>An array or float that has the same dimensions as phase that is added to the current phase.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated phase.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.crop_to","title":"<code>crop_to(npixels_out)</code>","text":"<p>Paraxially crops the <code>Wavefront</code> to the size determined by npixels_out. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to to odd dimension, ie 4 -&gt; 2 or 5 -&gt; 3.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The size of the array to crop to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> cropped to the size npixels_out.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.interpolate","title":"<code>interpolate(npixels_out, pixel_scale_out, real_imaginary=False)</code>","text":"<p>Performs a paraxial interpolation on the wavefront, determined by the the pixel_scale_out and npixels_out parameters. By default the interpolation is done on the amplitude and phase arrays, however by passing <code>real_imgainary=True</code> the interpolation is done on the real and imaginary components. This option allows for consistent interpolation behaviour when the phase array has a large amount of wrapping. Automatically conserves energy though the interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The number of pixels representing the wavefront after the interpolation.</p> required <code>pixel_scale_out</code> <code>Array</code> <p>The pixel scale of the array after the interpolation.</p> required <code>real_imaginary</code> <code>bool</code> <p>Whether to interpolate the real and imaginary representation of the wavefront as opposed to the the amplitude and phase representation.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront interpolated to the size and shape determined by npixels_out and pixel_scale_out, with the updated pixel_scale.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.invert_x","title":"<code>invert_x()</code>","text":"<p>Reflects the wavefront about the x axis.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the phase and amplitude arrays reversed along the x axis.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.invert_x_and_y","title":"<code>invert_x_and_y()</code>","text":"<p>Reflects the wavefront about both axes.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the phase and amplitude arrays reversed along both axes.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.invert_y","title":"<code>invert_y()</code>","text":"<p>Reflects the wavefront about the y axis.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the phase and amplitude arrays reversed along the y axis.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.multiply_amplitude","title":"<code>multiply_amplitude(array_like)</code>","text":"<p>Multiply the amplitude of the <code>Wavefront</code> by either a float or array.</p> <p>Parameters:</p> Name Type Description Default <code>array_like</code> <code>Array</code> <p>An array or float that has the same dimensions as amplitude that is multipled by the current ampltide.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated amplitude.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.normalise","title":"<code>normalise()</code>","text":"<p>Normalises the total power of the wavefront to 1.</p> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront with the normalised electric field amplitudes.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.pad_to","title":"<code>pad_to(npixels_out)</code>","text":"<p>Paraxially zero-pads the <code>Wavefront</code> to the size determined by npixels_out. Note this only supports padding arrays of even dimension to even dimension, and odd dimension to to odd dimension, ie 2 -&gt; 4 or 3 -&gt; 5.</p> <p>Parameters:</p> Name Type Description Default <code>npixels_out</code> <code>int</code> <p>The size of the array to pad to the wavefront to.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> zero-padded to the size npixels_out.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.rotate","title":"<code>rotate(angle, real_imaginary=False, fourier=False, order=1, padding=2)</code>","text":"<p>Performs a paraxial rotation on the wavefront, determined by the the angle parameter. By default the rotation is performed using a simple linear interpolation, but an information perserving rotation using fourier methods can be done by setting <code>fourier = True</code>. By default rotation is done on the amplitude and phase arrays, however by passing <code>real_imgainary=True</code> the rotation is done on the real and imaginary components.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Array, radians</code> <p>The angle by which to rotate the wavefront in a clockwise direction.</p> required <code>real_imaginary</code> <code>bool</code> <p>Whether to rotate the real and imaginary representation of the wavefront as opposed to the the amplitude and phase representation.</p> <code>False</code> <code>fourier</code> <code>bool</code> <p>Should the fourier rotation method be used (True), or regular interpolation method be used (False).</p> <code>False</code> <code>order</code> <code>int</code> <p>The interpolation order to use. Must be 0, 1, or 3.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The amount of fourier padding to use. Only applies if fourier is True.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new wavefront rotated by angle in the clockwise direction.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.set_amplitude","title":"<code>set_amplitude(amplitude)</code>","text":"<p>Mutator for the amplitude attribute.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>Array, power</code> <p>The electric field amplitude of the <code>Wavefront</code>.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated amplitude.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.set_phase","title":"<code>set_phase(phase)</code>","text":"<p>Mutator for the phase attribute.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Array, radians</code> <p>The phases of each pixel on the <code>Wavefront</code>.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the updated phase.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.set_phasor","title":"<code>set_phasor(amplitude, phase)</code>","text":"<p>Updates the phasor of the wavefront (ie both the amplitude and the phase).</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>Array, power</code> <p>The new electric field amplitude of the wavefront.</p> required <code>phase</code> <code>Array, radians</code> <p>The new electric field phase of the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with updated amplitude and phase.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.set_pixel_scale","title":"<code>set_pixel_scale(pixel_scale)</code>","text":"<p>Mutator for the pixel_scale attribute.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_scale</code> <code>Array</code> <p>The new pixel_scale associated with the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new Wavefront object with the updated pixel_scale.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.set_plane_type","title":"<code>set_plane_type(plane)</code>","text":"<p>Mutator for the PlaneType attribute.</p> <p>Parameters:</p> Name Type Description Default <code>plane</code> <code>PlaneType</code> <p>A PlaneType object describing the plane that the <code>Wavefront</code> is currently in.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the update plate_type information.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.tilt_wavefront","title":"<code>tilt_wavefront(tilt_angles)</code>","text":"<p>Tilts the wavefront by the tilt_angles.</p> <p>Parameters:</p> Name Type Description Default <code>tilt_angles</code> <code>Array, radians</code> <p>The (x, y) angles by which to tilt the wavefront.</p> required <p>Returns:</p> Name Type Description <code>wavefront</code> <code>Wavefront</code> <p>The new <code>Wavefront</code> with the (x, y) tilts applied.</p>"},{"location":"wavefronts/wavefront/#dLux.wavefronts.Wavefront.wavefront_to_psf","title":"<code>wavefront_to_psf(return_polarised=False)</code>","text":"<p>Calculates the Point Spread Function (PSF), ie the squared modulus of the complex wavefront.</p> <p>TODO: Take in the parameters dictionary and use the parameters in that to determine the way to output the wavefront.</p> <p>Returns:</p> Name Type Description <code>psf</code> <code>Array</code> <p>The PSF of the wavefront.</p>"}]}